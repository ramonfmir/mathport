{"second_of_chain_is_irreducible":
 "/-- The second element of a chain is irreducible. -/\ntheorem second_of_chain_is_irreducible {q : Associates M} {n : ℕ} (hn : n ≠ 0) {c : Fin (n + 1) → Associates M}\n    (h₁ : StrictMono c) (h₂ : ∀ {r}, r ≤ q ↔ ∃ i, r = c i) (hq : q ≠ 0) : Irreducible (c 1) :=\n  by\n  cases n; · contradiction\n  refine' (Associates.isAtom_iff (ne_zero_of_dvd_ne_zero hq (h₂.2 ⟨1, rfl⟩))).mp ⟨_, fun b hb => _⟩\n  · exact ne_bot_of_gt (h₁ (show (0 : Fin (n + 2)) < 1 from Fin.one_pos))\n  obtain ⟨⟨i, hi⟩, rfl⟩ := h₂.1 (hb.le.trans (h₂.2 ⟨1, rfl⟩))\n  cases i\n  · exact (Associates.isUnit_iff_eq_one _).mp (first_of_chain_is_unit h₁ @h₂)\n  · simpa [Fin.lt_iff_val_lt_val] using h₁.lt_iff_lt.mp hb\n#align second_of_chain_is_irreducible second_of_chain_is_irreducible\n\n",
 "pow_image_of_prime_by_factor_orderIso_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n#print pow_image_of_prime_by_factor_orderIso_dvd /-\ntheorem pow_image_of_prime_by_factor_orderIso_dvd [DecidableEq (Associates M)] {m p : Associates M} {n : Associates N}\n    (hn : n ≠ 0) (hp : p ∈ normalizedFactors m) (d : «expr ≃o » (Set.Iic m) (Set.Iic n)) {s : ℕ} (hs' : p ^ s ≤ m) :\n    (d ⟨p, dvd_of_mem_normalizedFactors hp⟩ : Associates N) ^ s ≤ n :=\n  by\n  by_cases hs : s = 0\n  · simp [hs]\n  suffices (d ⟨p, dvd_of_mem_normalized_factors hp⟩ : Associates N) ^ s = ↑(d ⟨p ^ s, hs'⟩)\n    by\n    rw [this]\n    apply Subtype.prop (d ⟨p ^ s, hs'⟩)\n  obtain ⟨c₁, rfl, hc₁', hc₁''⟩ := exists_chain_of_prime_pow hs (prime_of_normalized_factor p hp)\n  set c₂ : Fin (s + 1) → Associates N := fun t => d ⟨c₁ t, le_trans (hc₁''.2 ⟨t, by simp⟩) hs'⟩\n  have c₂.def : ∀ t, c₂ t = d ⟨c₁ t, _⟩ := fun t => rfl\n  refine' (congr_arg (· ^ s) (c₂.def 1).symm).trans _\n  refine' (eq_pow_second_of_chain_of_has_chain hs (fun t u h => _) (fun r => ⟨fun hr => _, _⟩) _).symm\n  · rw [c₂.def, c₂.def, Subtype.coe_lt_coe, d.lt_iff_lt, Subtype.mk_lt_mk, hc₁'.lt_iff_lt]\n    exact h\n  · have : r ≤ n := hr.trans (d ⟨c₁ 1 ^ s, _⟩).2\n    suffices d.symm ⟨r, this⟩ ≤ ⟨c₁ 1 ^ s, hs'⟩\n      by\n      obtain ⟨i, hi⟩ := hc₁''.1 this\n      use i\n      simp only [c₂.def, ← hi, d.apply_symm_apply, Subtype.coe_eta, Subtype.coe_mk]\n    conv_rhs => rw [← d.symm_apply_apply ⟨c₁ 1 ^ s, hs'⟩]\n    rw [d.symm.le_iff_le]\n    simpa only [← Subtype.coe_le_coe, Subtype.coe_mk] using hr\n  · rintro ⟨i, hr⟩\n    rw [hr, c₂.def, Subtype.coe_le_coe, d.le_iff_le]\n    simpa [Subtype.mk_le_mk] using hc₁''.2 ⟨i, rfl⟩\n  exact ne_zero_of_dvd_ne_zero hn (Subtype.prop (d ⟨c₁ 1 ^ s, _⟩))\n#align pow_image_of_prime_by_factor_order_iso_dvd pow_image_of_prime_by_factor_orderIso_dvd\n-/\n\n",
 "multiplicity_prime_le_multiplicity_image_by_factor_orderIso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n#print multiplicity_prime_le_multiplicity_image_by_factor_orderIso /-\ntheorem multiplicity_prime_le_multiplicity_image_by_factor_orderIso [DecidableEq (Associates M)] {m p : Associates M}\n    {n : Associates N} (hp : p ∈ normalizedFactors m) (d : «expr ≃o » (Set.Iic m) (Set.Iic n)) :\n    multiplicity p m ≤ multiplicity (↑(d ⟨p, dvd_of_mem_normalizedFactors hp⟩)) n :=\n  by\n  by_cases hn : n = 0\n  · simp [hn]\n  by_cases hm : m = 0\n  · simpa [hm] using hp\n  rw [← PartENat.natCast_get (finite_iff_dom.1 <| finite_prime_left (prime_of_normalized_factor p hp) hm), ←\n    pow_dvd_iff_le_multiplicity]\n  exact pow_image_of_prime_by_factor_orderIso_dvd hn hp d (pow_multiplicity_dvd _)\n#align multiplicity_prime_le_multiplicity_image_by_factor_order_iso multiplicity_prime_le_multiplicity_image_by_factor_orderIso\n-/\n\n",
 "multiplicity_prime_eq_multiplicity_image_by_factor_orderIso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n#print multiplicity_prime_eq_multiplicity_image_by_factor_orderIso /-\ntheorem multiplicity_prime_eq_multiplicity_image_by_factor_orderIso [DecidableEq (Associates M)] {m p : Associates M}\n    {n : Associates N} (hn : n ≠ 0) (hp : p ∈ normalizedFactors m) (d : «expr ≃o » (Set.Iic m) (Set.Iic n)) :\n    multiplicity p m = multiplicity (↑(d ⟨p, dvd_of_mem_normalizedFactors hp⟩)) n :=\n  by\n  refine' le_antisymm (multiplicity_prime_le_multiplicity_image_by_factor_orderIso hp d) _\n  suffices\n    multiplicity (↑(d ⟨p, dvd_of_mem_normalized_factors hp⟩)) n ≤\n      multiplicity (↑(d.symm (d ⟨p, dvd_of_mem_normalized_factors hp⟩))) m\n    by\n    rw [d.symm_apply_apply ⟨p, dvd_of_mem_normalized_factors hp⟩, Subtype.coe_mk] at this\n    exact this\n  letI := Classical.decEq (Associates N)\n  simpa only [Subtype.coe_eta] using\n    multiplicity_prime_le_multiplicity_image_by_factor_orderIso\n      (mem_normalizedFactors_factor_orderIso_of_mem_normalizedFactors hn hp d) d.symm\n#align multiplicity_prime_eq_multiplicity_image_by_factor_order_iso multiplicity_prime_eq_multiplicity_image_by_factor_orderIso\n-/\n\n",
 "multiplicity_factor_dvd_iso_eq_multiplicity_of_mem_normalizedFactors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print multiplicity_factor_dvd_iso_eq_multiplicity_of_mem_normalizedFactors /-\ntheorem multiplicity_factor_dvd_iso_eq_multiplicity_of_mem_normalizedFactors {m p : M} {n : N} (hm : m ≠ 0) (hn : n ≠ 0)\n    (hp : p ∈ normalizedFactors m) {d : «expr ≃ » { l : M // l ∣ m } { l : N // l ∣ n }}\n    (hd : ∀ l l', (d l : N) ∣ d l' ↔ (l : M) ∣ l') :\n    multiplicity (d ⟨p, dvd_of_mem_normalizedFactors hp⟩ : N) n = multiplicity p m :=\n  by\n  apply Eq.symm\n  suffices\n    multiplicity (Associates.mk p) (Associates.mk m) =\n      multiplicity\n        (Associates.mk\n          ↑(d\n              ⟨associatesEquivOfUniqueUnits (associates_equiv_of_unique_units.symm p), by\n                simp [dvd_of_mem_normalized_factors hp]⟩))\n        (Associates.mk n)\n    by\n    simpa only [multiplicity_mk_eq_multiplicity, associatesEquivOfUniqueUnits_symm_apply,\n      associatesEquivOfUniqueUnits_apply, out_mk, normalize_eq] using this\n  have :\n    Associates.mk\n        ↑(d\n            ⟨associatesEquivOfUniqueUnits (associates_equiv_of_unique_units.symm p), by\n              simp only [dvd_of_mem_normalized_factors hp, associatesEquivOfUniqueUnits_symm_apply,\n                associatesEquivOfUniqueUnits_apply, out_mk, normalize_eq]⟩) =\n      ↑(mkFactorOrderIsoOfFactorDvdEquiv hd\n          ⟨associates_equiv_of_unique_units.symm p, by\n            rw [associatesEquivOfUniqueUnits_symm_apply] <;>\n              exact mk_le_mk_of_dvd (dvd_of_mem_normalized_factors hp)⟩) :=\n    by\n    rw [mk_factor_order_iso_of_factor_dvd_equiv_apply_coe]\n    rfl\n  rw [this]\n  letI := Classical.decEq (Associates M)\n  refine'\n    multiplicity_prime_eq_multiplicity_image_by_factor_orderIso (mk_ne_zero.mpr hn) _\n      (mkFactorOrderIsoOfFactorDvdEquiv hd)\n  obtain ⟨q, hq, hq'⟩ :=\n    exists_mem_normalized_factors_of_dvd (mk_ne_zero.mpr hm)\n      ((prime_mk p).mpr (prime_of_normalized_factor p hp)).irreducible\n      (mk_le_mk_of_dvd (dvd_of_mem_normalized_factors hp))\n  rwa [associated_iff_eq.mp hq']\n#align multiplicity_factor_dvd_iso_eq_multiplicity_of_mem_normalized_factor multiplicity_factor_dvd_iso_eq_multiplicity_of_mem_normalizedFactors\n-/\n\n",
 "mem_normalizedFactors_factor_orderIso_of_mem_normalizedFactors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n#print mem_normalizedFactors_factor_orderIso_of_mem_normalizedFactors /-\ntheorem mem_normalizedFactors_factor_orderIso_of_mem_normalizedFactors [DecidableEq (Associates M)]\n    [DecidableEq (Associates N)] {m p : Associates M} {n : Associates N} (hn : n ≠ 0) (hp : p ∈ normalizedFactors m)\n    (d : «expr ≃o » (Set.Iic m) (Set.Iic n)) : ↑(d ⟨p, dvd_of_mem_normalizedFactors hp⟩) ∈ normalizedFactors n :=\n  by\n  obtain ⟨q, hq, hq'⟩ :=\n    exists_mem_normalized_factors_of_dvd hn (map_prime_of_factor_orderIso hn hp d).irreducible\n      (d ⟨p, dvd_of_mem_normalized_factors hp⟩).prop\n  rw [associated_iff_eq] at hq'\n  rwa [hq']\n#align mem_normalized_factors_factor_order_iso_of_mem_normalized_factors mem_normalizedFactors_factor_orderIso_of_mem_normalizedFactors\n-/\n\n",
 "mem_normalizedFactors_factor_dvd_iso_of_mem_normalizedFactors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print mem_normalizedFactors_factor_dvd_iso_of_mem_normalizedFactors /-\ntheorem mem_normalizedFactors_factor_dvd_iso_of_mem_normalizedFactors [DecidableEq N] {m p : M} {n : N} (hm : m ≠ 0)\n    (hn : n ≠ 0) (hp : p ∈ normalizedFactors m) {d : «expr ≃ » { l : M // l ∣ m } { l : N // l ∣ n }}\n    (hd : ∀ l l', (d l : N) ∣ d l' ↔ (l : M) ∣ (l' : M)) :\n    ↑(d ⟨p, dvd_of_mem_normalizedFactors hp⟩) ∈ normalizedFactors n :=\n  by\n  suffices\n    Prime\n      ↑(d\n          ⟨associatesEquivOfUniqueUnits (associates_equiv_of_unique_units.symm p), by\n            simp [dvd_of_mem_normalized_factors hp]⟩)\n    by\n    simp only [associatesEquivOfUniqueUnits_apply, out_mk, normalize_eq, associatesEquivOfUniqueUnits_symm_apply] at\n      this\n    obtain ⟨q, hq, hq'⟩ :=\n      exists_mem_normalized_factors_of_dvd hn this.irreducible\n        (d ⟨p, by apply dvd_of_mem_normalized_factors <;> convert hp⟩).prop\n    rwa [associated_iff_eq.mp hq']\n  have :\n    Associates.mk\n        ↑(d\n            ⟨associatesEquivOfUniqueUnits (associates_equiv_of_unique_units.symm p), by\n              simp only [dvd_of_mem_normalized_factors hp, associatesEquivOfUniqueUnits_apply, out_mk, normalize_eq,\n                associatesEquivOfUniqueUnits_symm_apply]⟩) =\n      ↑(mkFactorOrderIsoOfFactorDvdEquiv hd\n          ⟨associates_equiv_of_unique_units.symm p, by\n            simp only [associatesEquivOfUniqueUnits_symm_apply] <;>\n              exact mk_dvd_mk.mpr (dvd_of_mem_normalized_factors hp)⟩) :=\n    by\n    rw [mk_factor_order_iso_of_factor_dvd_equiv_apply_coe]\n    simp only [Subtype.coe_mk]\n  rw [← Associates.prime_mk, this]\n  letI := Classical.decEq (Associates M)\n  refine' map_prime_of_factor_orderIso (mk_ne_zero.mpr hn) _ _\n  obtain ⟨q, hq, hq'⟩ :=\n    exists_mem_normalized_factors_of_dvd (mk_ne_zero.mpr hm)\n      ((prime_mk p).mpr (prime_of_normalized_factor p (by convert hp))).irreducible\n      (mk_le_mk_of_dvd (dvd_of_mem_normalized_factors hp))\n  simpa only [associated_iff_eq.mp hq', associatesEquivOfUniqueUnits_symm_apply] using hq\n#align mem_normalized_factors_factor_dvd_iso_of_mem_normalized_factors mem_normalizedFactors_factor_dvd_iso_of_mem_normalizedFactors\n-/\n\n",
 "map_prime_of_factor_orderIso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n#print map_prime_of_factor_orderIso /-\ntheorem map_prime_of_factor_orderIso [DecidableEq (Associates M)] {m p : Associates M} {n : Associates N} (hn : n ≠ 0)\n    (hp : p ∈ normalizedFactors m) (d : «expr ≃o » (Set.Iic m) (Set.Iic n)) :\n    Prime (d ⟨p, dvd_of_mem_normalizedFactors hp⟩ : Associates N) :=\n  by\n  rw [← irreducible_iff_prime]\n  refine' (Associates.isAtom_iff <| ne_zero_of_dvd_ne_zero hn (d ⟨p, _⟩).prop).mp ⟨_, fun b hb => _⟩\n  · rw [ne.def, ← Associates.isUnit_iff_eq_bot, Associates.isUnit_iff_eq_one, coe_factor_orderIso_map_eq_one_iff _ d]\n    rintro rfl\n    exact (prime_of_normalized_factor 1 hp).not_unit isUnit_one\n  · obtain ⟨x, hx⟩ := d.surjective ⟨b, le_trans (le_of_lt hb) (d ⟨p, dvd_of_mem_normalized_factors hp⟩).prop⟩\n    rw [← Subtype.coe_mk b _, Subtype.coe_lt_coe, ← hx] at hb\n    letI : OrderBot { l : Associates M // l ≤ m } := Subtype.orderBot bot_le\n    letI : OrderBot { l : Associates N // l ≤ n } := Subtype.orderBot bot_le\n    suffices x = «expr⊥» by\n      rw [this, OrderIso.map_bot d] at hx\n      refine' (Subtype.mk_eq_bot_iff _ _).mp hx.symm\n      exact bot_le\n    obtain ⟨a, ha⟩ := x\n    rw [Subtype.mk_eq_bot_iff]\n    ·\n      exact\n        ((Associates.isAtom_iff <| Prime.ne_zero <| prime_of_normalized_factor p hp).mpr <|\n              irreducible_of_normalized_factor p hp).right\n          a (subtype.mk_lt_mk.mp <| d.lt_iff_lt.mp hb)\n    exact bot_le\n#align map_prime_of_factor_order_iso map_prime_of_factor_orderIso\n-/\n\n",
 "is_prime_pow_of_has_chain":
 "theorem is_prime_pow_of_has_chain {q : Associates M} {n : ℕ} (hn : n ≠ 0) {c : Fin (n + 1) → Associates M}\n    (h₁ : StrictMono c) (h₂ : ∀ {r : Associates M}, r ≤ q ↔ ∃ i, r = c i) (hq : q ≠ 0) : IsPrimePow q :=\n  ⟨c 1, n, irreducible_iff_prime.mp (second_of_chain_is_irreducible hn h₁ (@h₂) hq), zero_lt_iff.mpr hn,\n    (eq_pow_second_of_chain_of_has_chain hn h₁ (@h₂) hq).symm⟩\n#align is_prime_pow_of_has_chain is_prime_pow_of_has_chain\n\n",
 "isAtom_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Associates.isAtom_iff /-\n/-\nCopyright (c) 2021 Paul Lezeau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen, Paul Lezeau\n-/\ntheorem Associates.isAtom_iff {p : Associates M} (h₁ : p ≠ 0) : IsAtom p ↔ Irreducible p :=\n  ⟨fun hp =>\n    ⟨by simpa only [Associates.isUnit_iff_eq_one] using hp.1, fun a b h =>\n      (hp.le_iff.mp ⟨_, h⟩).cases_on (fun ha => or.inl (a.is_unit_iff_eq_one.mpr ha)) fun ha =>\n        or.inr\n          (show IsUnit b by\n            rw [ha] at h\n            apply isUnit_of_associated_mul (show Associated (p * b) p by conv_rhs => rw [h]) h₁)⟩,\n    fun hp =>\n    ⟨by simpa only [Associates.isUnit_iff_eq_one, Associates.bot_eq_one] using hp.1, fun b ⟨⟨a, hab⟩, hb⟩ =>\n      (hp.is_unit_or_is_unit hab).cases_on\n        (fun hb => show b = «expr⊥» by rwa [Associates.isUnit_iff_eq_one, ← Associates.bot_eq_one] at hb) fun ha =>\n        absurd\n          (show p ∣ b from\n            ⟨(ha.unit⁻¹ : Units _), by simp [hab] <;> rw [mul_assoc] <;> rw [IsUnit.mul_val_inv ha] <;> rw [mul_one]⟩)\n          hb⟩⟩\n#align associates.is_atom_iff Associates.isAtom_iff\n-/\n\n",
 "first_of_chain_is_unit":
 "theorem first_of_chain_is_unit {q : Associates M} {n : ℕ} {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c)\n    (h₂ : ∀ {r}, r ≤ q ↔ ∃ i, r = c i) : IsUnit (c 0) :=\n  by\n  obtain ⟨i, hr⟩ := h₂.mp Associates.one_le\n  rw [Associates.isUnit_iff_eq_one, ← Associates.le_one_iff, hr]\n  exact h₁.monotone (Fin.zero_le i)\n#align first_of_chain_is_unit first_of_chain_is_unit\n\n",
 "factor_orderIso_map_one_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n#print factor_orderIso_map_one_eq_bot /-\ntheorem factor_orderIso_map_one_eq_bot {m : Associates M} {n : Associates N}\n    (d : «expr ≃o » { l : Associates M // l ≤ m } { l : Associates N // l ≤ n }) :\n    (d ⟨1, one_dvd m⟩ : Associates N) = 1 :=\n  by\n  letI : OrderBot { l : Associates M // l ≤ m } := Subtype.orderBot bot_le\n  letI : OrderBot { l : Associates N // l ≤ n } := Subtype.orderBot bot_le\n  simp [← Associates.bot_eq_one]\n#align factor_order_iso_map_one_eq_bot factor_orderIso_map_one_eq_bot\n-/\n\n",
 "exists_chain_of_prime_pow":
 "theorem exists_chain_of_prime_pow {p : Associates M} {n : ℕ} (hn : n ≠ 0) (hp : Prime p) :\n    ∃ c : Fin (n + 1) → Associates M, c 1 = p ∧ StrictMono c ∧ ∀ {r : Associates M}, r ≤ p ^ n ↔ ∃ i, r = c i :=\n  by\n  refine' ⟨fun i => p ^ (i : ℕ), _, fun n m h => _, fun y => ⟨fun h => _, _⟩⟩\n  · rw [Fin.val_one', nat.mod_eq_of_lt, pow_one]\n    exact nat.lt_succ_of_le (nat.one_le_iff_ne_zero.mpr hn)\n  ·\n    exact\n      associates.dvd_not_unit_iff_lt.mp\n        ⟨pow_ne_zero n hp.ne_zero, p ^ (m - n : ℕ),\n          not_isUnit_of_not_isUnit_dvd hp.not_unit (dvd_pow dvd_rfl (nat.sub_pos_of_lt h).ne'),\n          (pow_mul_pow_sub p h.le).symm⟩\n  · obtain ⟨i, i_le, hi⟩ := (dvd_prime_pow hp n).1 h\n    rw [associated_iff_eq] at hi\n    exact ⟨⟨i, nat.lt_succ_of_le i_le⟩, hi⟩\n  · rintro ⟨i, rfl⟩\n    exact ⟨p ^ (n - i : ℕ), (pow_mul_pow_sub p (nat.succ_le_succ_iff.mp i.2)).symm⟩\n#align exists_chain_of_prime_pow exists_chain_of_prime_pow\n\n",
 "eq_second_of_chain_of_prime_dvd":
 "theorem eq_second_of_chain_of_prime_dvd {p q r : Associates M} {n : ℕ} (hn : n ≠ 0) {c : Fin (n + 1) → Associates M}\n    (h₁ : StrictMono c) (h₂ : ∀ {r : Associates M}, r ≤ q ↔ ∃ i, r = c i) (hp : Prime p) (hr : r ∣ q) (hp' : p ∣ r) :\n    p = c 1 := by\n  cases n\n  · contradiction\n  obtain ⟨i, rfl⟩ := h₂.1 (dvd_trans hp' hr)\n  refine' congr_arg c (eq_of_ge_of_not_gt _ fun hi => _)\n  · rw [Fin.le_iff_val_le_val, Fin.val_one, Nat.succ_le_iff, ← Fin.val_zero (n.succ + 1), ← Fin.lt_iff_val_lt_val,\n      Fin.pos_iff_ne_zero]\n    rintro rfl\n    exact hp.not_unit (first_of_chain_is_unit h₁ @h₂)\n  obtain rfl | ⟨j, rfl⟩ := i.eq_zero_or_eq_succ\n  · cases hi\n  refine'\n    not_irreducible_of_not_unit_dvdNotUnit\n      (DvdNotUnit.not_unit (Associates.dvdNotUnit_iff_lt.2 (h₁ (show (0 : Fin (n + 2)) < j from _)))) _ hp.irreducible\n  · simpa [Fin.succ_lt_succ_iff, Fin.lt_iff_val_lt_val] using hi\n  · refine' Associates.dvdNotUnit_iff_lt.2 (h₁ _)\n    simpa only [Fin.coe_eq_castSucc] using Fin.lt_succ\n#align eq_second_of_chain_of_prime_dvd eq_second_of_chain_of_prime_dvd\n\n",
 "eq_pow_second_of_chain_of_has_chain":
 "theorem eq_pow_second_of_chain_of_has_chain {q : Associates M} {n : ℕ} (hn : n ≠ 0) {c : Fin (n + 1) → Associates M}\n    (h₁ : StrictMono c) (h₂ : ∀ {r : Associates M}, r ≤ q ↔ ∃ i, r = c i) (hq : q ≠ 0) : q = c 1 ^ n := by\n  classical\n    obtain ⟨i, hi'⟩ := element_of_chain_eq_pow_second_of_chain hn h₁ (fun r => h₂) (dvd_refl q) hq\n    convert hi'\n    refine' (Nat.lt_succ_iff.1 i.prop).antisymm' (nat.le_of_succ_le_succ _)\n    calc\n      n + 1 = (Finset.univ : Finset (Fin (n + 1))).card := (Finset.card_fin _).symm\n      _ = (finset.univ.image c).card := (finset.card_image_iff.mpr (h₁.injective.inj_on _)).symm\n      _ ≤ (finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ℕ)).card := (Finset.card_le_of_subset _)\n      _ ≤ (Finset.univ : Finset (Fin (i + 1))).card := Finset.card_image_le\n      _ = i + 1 := Finset.card_fin _\n      \n    intro r hr\n    obtain ⟨j, -, rfl⟩ := Finset.mem_image.1 hr\n    have := h₂.2 ⟨j, rfl⟩\n    rw [hi'] at this\n    obtain ⟨u, hu, hu'⟩ := (dvd_prime_pow (show Prime (c 1) from _) i).1 this\n    refine' finset.mem_image.mpr ⟨u, Finset.mem_univ _, _⟩\n    · rw [associated_iff_eq] at hu'\n      rw [Fin.val_cast_of_lt (nat.lt_succ_of_le hu), hu']\n    · rw [← irreducible_iff_prime]\n      exact second_of_chain_is_irreducible hn h₁ (@h₂) hq\n#align eq_pow_second_of_chain_of_has_chain eq_pow_second_of_chain_of_has_chain\n\n",
 "element_of_chain_not_is_unit_of_index_ne_zero":
 "theorem element_of_chain_not_is_unit_of_index_ne_zero {n : ℕ} {i : Fin (n + 1)} (i_pos : i ≠ 0)\n    {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c) : ¬IsUnit (c i) :=\n  DvdNotUnit.not_unit\n    (Associates.dvdNotUnit_iff_lt.2 (h₁ <| show (0 : Fin (n + 1)) < i from i.pos_iff_ne_zero.mpr i_pos))\n#align element_of_chain_not_is_unit_of_index_ne_zero element_of_chain_not_is_unit_of_index_ne_zero\n\n",
 "element_of_chain_eq_pow_second_of_chain":
 "theorem element_of_chain_eq_pow_second_of_chain {q r : Associates M} {n : ℕ} (hn : n ≠ 0)\n    {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c) (h₂ : ∀ {r}, r ≤ q ↔ ∃ i, r = c i) (hr : r ∣ q) (hq : q ≠ 0) :\n    ∃ i : Fin (n + 1), r = c 1 ^ (i : ℕ) := by\n  classical\n    let i := (normalized_factors r).card\n    have hi : normalized_factors r = Multiset.replicate i (c 1) :=\n      by\n      apply Multiset.eq_replicate_of_mem\n      intro b hb\n      refine'\n        eq_second_of_chain_of_prime_dvd hn h₁ (fun r' => h₂) (prime_of_normalized_factor b hb) hr\n          (dvd_of_mem_normalized_factors hb)\n    have H : r = c 1 ^ i :=\n      by\n      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)\n      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this\n      rw [this]\n    refine' ⟨⟨i, _⟩, H⟩\n    have : (finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ℕ)).card = i + 1 :=\n      by\n      conv_rhs => rw [← Finset.card_fin (i + 1)]\n      cases n\n      · contradiction\n      rw [Finset.card_image_iff]\n      refine' Set.injOn_of_injective (fun m m' h => Fin.ext _) _\n      refine' pow_injective_of_not_unit (element_of_chain_not_is_unit_of_index_ne_zero (by simp) h₁) _ h\n      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h₁ (@h₂) hq)\n    suffices H' : ∀ r ∈ finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ℕ), r ≤ q\n    · simp only [← Nat.succ_le_iff, nat.succ_eq_add_one, ← this]\n      apply card_subset_divisors_le_length_of_chain (@h₂) H'\n    simp only [Finset.mem_image]\n    rintro r ⟨a, ha, rfl⟩\n    refine' dvd_trans _ hr\n    use c 1 ^ (i - a)\n    rw [pow_mul_pow_sub (c 1)]\n    · exact H\n    · exact nat.succ_le_succ_iff.mp a.2\n#align element_of_chain_eq_pow_second_of_chain element_of_chain_eq_pow_second_of_chain\n\n",
 "coe_factor_orderIso_map_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n#print coe_factor_orderIso_map_eq_one_iff /-\ntheorem coe_factor_orderIso_map_eq_one_iff {m u : Associates M} {n : Associates N} (hu' : u ≤ m)\n    (d : «expr ≃o » (Set.Iic m) (Set.Iic n)) : (d ⟨u, hu'⟩ : Associates N) = 1 ↔ u = 1 :=\n  ⟨fun hu =>\n    by\n    rw [show u = ↑(d.symm ⟨↑(d ⟨u, hu'⟩), (d ⟨u, hu'⟩).prop⟩) by\n        simp only [Subtype.coe_eta, OrderIso.symm_apply_apply, Subtype.coe_mk]]\n    convert factor_orderIso_map_one_eq_bot d.symm, fun hu =>\n    by\n    simp_rw [hu]\n    convert factor_orderIso_map_one_eq_bot d⟩\n#align coe_factor_order_iso_map_eq_one_iff coe_factor_orderIso_map_eq_one_iff\n-/\n\n",
 "card_subset_divisors_le_length_of_chain":
 "theorem card_subset_divisors_le_length_of_chain {q : Associates M} {n : ℕ} {c : Fin (n + 1) → Associates M}\n    (h₂ : ∀ {r}, r ≤ q ↔ ∃ i, r = c i) {m : Finset (Associates M)} (hm : ∀ r, r ∈ m → r ≤ q) : m.card ≤ n + 1 := by\n  classical\n    have mem_image : ∀ r : Associates M, r ≤ q → r ∈ finset.univ.image c :=\n      by\n      intro r hr\n      obtain ⟨i, hi⟩ := h₂.1 hr\n      exact Finset.mem_image.2 ⟨i, Finset.mem_univ _, hi.symm⟩\n    rw [← Finset.card_fin (n + 1)]\n    exact (Finset.card_le_of_subset fun x hx => mem_image x <| hm x hx).trans Finset.card_image_le\n#align card_subset_divisors_le_length_of_chain card_subset_divisors_le_length_of_chain\n\n"}