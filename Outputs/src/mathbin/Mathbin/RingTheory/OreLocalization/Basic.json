{"zero_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\nprotected theorem zero_mul (x : «expr [ ⁻¹]» R S) : 0 * x = 0 :=\n  by\n  induction' x using ore_localization.ind with r s\n  rw [ore_localization.zero_def, ore_div_mul_char 0 r 1 s r 1 (by simp)]; simp\n#align zero_mul zero_mul\n\n",
 "zero_div_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n@[simp]\ntheorem zero_div_eq_zero (s : S) : «expr /ₒ » 0 s = 0 :=\n  by\n  rw [ore_localization.zero_def, ore_div_eq_iff]\n  exact ⟨s, 1, by simp⟩\n#align zero_div_eq_zero zero_div_eq_zero\n\n",
 "zero_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\nprotected theorem zero_def : (0 : «expr [ ⁻¹]» R S) = «expr /ₒ » 0 1 :=\n  rfl\n#align zero_def zero_def\n\n",
 "zero_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n#print zero_add /-\nprotected theorem zero_add (x : «expr [ ⁻¹]» R S) : 0 + x = x :=\n  by\n  induction x using ore_localization.ind\n  rw [← zero_div_eq_zero, add_ore_div]; simp\n#align zero_add zero_add\n-/\n\n",
 "universal_mul_hom_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n/-- The universal morphism `universal_mul_hom` is unique. -/\ntheorem universal_mul_hom_unique (φ : «expr →* » («expr [ ⁻¹]» R S) T) (huniv : ∀ r : R, φ (numerator_hom r) = f r) :\n    φ = universal_mul_hom f fS hf := by\n  ext; induction' x using ore_localization.ind with r s\n  rw [universal_mul_hom_apply, ← huniv r, numerator_hom_apply, ← mul_one (φ («expr /ₒ » r s)), ← Units.val_one, ←\n    mul_right_inv (fS s), Units.val_mul, ← mul_assoc, ← hf, ← huniv, ← φ.map_mul, numerator_hom_apply,\n    ore_localization.mul_cancel]\n#align universal_mul_hom_unique universal_mul_hom_unique\n\n",
 "universal_mul_hom_commutes":
 "theorem universal_mul_hom_commutes {r : R} : universal_mul_hom f fS hf (numerator_hom r) = f r := by\n  simp [numerator_hom_apply, universal_mul_hom_apply]\n#align universal_mul_hom_commutes universal_mul_hom_commutes\n\n",
 "universal_mul_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\ntheorem universal_mul_hom_apply {r : R} {s : S} :\n    universal_mul_hom f fS hf («expr /ₒ » r s) = f r * ((fS s)⁻¹ : Units T) :=\n  rfl\n#align universal_mul_hom_apply universal_mul_hom_apply\n\n",
 "universal_hom_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\ntheorem universal_hom_unique (φ : «expr →+* » («expr [ ⁻¹]» R S) T) (huniv : ∀ r : R, φ (numerator_hom r) = f r) :\n    φ = universal_hom f fS hf :=\n  RingHom.coe_monoidHom_injective <| universal_mul_hom_unique (ring_hom.to_monoid_hom f) fS hf (↑φ) huniv\n#align universal_hom_unique universal_hom_unique\n\n",
 "universal_hom_commutes":
 "theorem universal_hom_commutes {r : R} : universal_hom f fS hf (numerator_hom r) = f r := by\n  simp [numerator_hom_apply, universal_hom_apply]\n#align universal_hom_commutes universal_hom_commutes\n\n",
 "universal_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\ntheorem universal_hom_apply {r : R} {s : S} : universal_hom f fS hf («expr /ₒ » r s) = f r * ((fS s)⁻¹ : Units T) :=\n  rfl\n#align universal_hom_apply universal_hom_apply\n\n",
 "right_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n#print right_distrib /-\ntheorem right_distrib (x y z : «expr [ ⁻¹]» R S) : (x + y) * z = x * z + y * z :=\n  by\n  induction' x using ore_localization.ind with r₁ s₁\n  induction' y using ore_localization.ind with r₂ s₂\n  induction' z using ore_localization.ind with r₃ s₃\n  rcases ore_div_add_char' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'; norm_cast  at ha\n  rw [ore_localization.expand' r₁ s₁ sa]\n  rw [ore_localization.expand r₂ s₂ ra (by rw [← ha] <;> apply SetLike.coe_mem)]\n  rw [← subtype.coe_eq_of_eq_mk ha]\n  repeat' rw [ore_div_mul_ore_div]; simp only [add_mul, add_ore_div]\n#align right_distrib right_distrib\n-/\n\n",
 "ore_div_mul_ore_div_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\ntheorem ore_div_mul_ore_div_comm {r₁ r₂ : R} {s₁ s₂ : S} :\n    «expr /ₒ » r₁ s₁ * «expr /ₒ » r₂ s₂ = «expr /ₒ » (r₁ * r₂) (s₁ * s₂) := by\n  rw [ore_div_mul_char r₁ r₂ s₁ s₂ r₂ s₁ (by simp [mul_comm]), mul_comm s₂]\n#align ore_div_mul_ore_div_comm ore_div_mul_ore_div_comm\n\n",
 "ore_div_mul_ore_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\ntheorem ore_div_mul_ore_div {r₁ r₂ : R} {s₁ s₂ : S} :\n    «expr /ₒ » r₁ s₁ * «expr /ₒ » r₂ s₂ = «expr /ₒ » (r₁ * oreNum r₂ s₁) (s₂ * oreDenom r₂ s₁) :=\n  rfl\n#align ore_div_mul_ore_div ore_div_mul_ore_div\n\n",
 "ore_div_mul_char":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/-- A characterization lemma for the multiplication on the Ore localization, allowing for a choice\nof Ore numerator and Ore denominator. -/\ntheorem ore_div_mul_char (r₁ r₂ : R) (s₁ s₂ : S) (r' : R) (s' : S) (huv : r₂ * (s' : R) = s₁ * r') :\n    «expr /ₒ » r₁ s₁ * «expr /ₒ » r₂ s₂ = «expr /ₒ » (r₁ * r') (s₂ * s') :=\n  mul'_char r₁ r₂ s₁ s₂ s' r' huv\n#align ore_div_mul_char ore_div_mul_char\n\n",
 "ore_div_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\ntheorem ore_div_eq_iff {r₁ r₂ : R} {s₁ s₂ : S} :\n    «expr /ₒ » r₁ s₁ = «expr /ₒ » r₂ s₂ ↔ ∃ (u : S)(v : R), r₂ * u = r₁ * v ∧ (s₂ : R) * u = s₁ * v :=\n  quotient.eq'\n#align ore_div_eq_iff ore_div_eq_iff\n\n",
 "ore_div_add_ore_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\ntheorem ore_div_add_ore_div {r r' : R} {s s' : S} :\n    «expr /ₒ » r s + «expr /ₒ » r' s' = «expr /ₒ » (r * oreDenom (s : R) s' + r' * oreNum s s') (s * oreDenom s s') :=\n  rfl\n#align ore_div_add_ore_div ore_div_add_ore_div\n\n",
 "ore_div_add_char":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/-- A characterization of the addition on the Ore localizaion, allowing for arbitrary Ore\nnumerator and Ore denominator. -/\ntheorem ore_div_add_char {r r' : R} (s s' : S) (rb : R) (sb : S) (h : (s : R) * sb = s' * rb) :\n    «expr /ₒ » r s + «expr /ₒ » r' s' = «expr /ₒ » (r * sb + r' * rb) (s * sb) :=\n  add''_char r s r' s' rb sb h\n#align ore_div_add_char ore_div_add_char\n\n",
 "one_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n#print one_mul /-\nprotected theorem one_mul (x : «expr [ ⁻¹]» R S) : 1 * x = x :=\n  by\n  induction' x using ore_localization.ind with r s\n  simp [ore_localization.one_def, ore_div_mul_char (1 : R) r (1 : S) s r 1 (by simp)]\n#align one_mul one_mul\n-/\n\n",
 "one_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\nprotected theorem one_def : (1 : «expr [ ⁻¹]» R S) = «expr /ₒ » 1 1 :=\n  rfl\n#align one_def one_def\n\n",
 "numerator_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\ntheorem numerator_is_unit (s : S) : is_unit (numerator_hom (s : R) : «expr [ ⁻¹]» R S) :=\n  ⟨numerator_unit s, rfl⟩\n#align numerator_is_unit numerator_is_unit\n\n",
 "numerator_hom_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\ntheorem numerator_hom_inj (hS : S ≤ non_zero_divisors R) : function.injective (numerator_hom : R → «expr [ ⁻¹]» R S) :=\n  fun r₁ r₂ h => by\n  rw [numerator_hom_apply, numerator_hom_apply, ore_div_eq_iff] at h\n  rcases h with ⟨u, v, h₁, h₂⟩\n  simp only [S.coe_one, one_mul] at h₂\n  rwa [← h₂, mul_cancel_right_mem_non_zero_divisor (hS (SetLike.coe_mem u)), eq_comm] at h₁\n#align numerator_hom_inj numerator_hom_inj\n\n",
 "numerator_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\ntheorem numerator_hom_apply {r : R} : numerator_hom r = «expr /ₒ » r (1 : S) :=\n  rfl\n#align numerator_hom_apply numerator_hom_apply\n\n",
 "nontrivial_of_non_zero_divisors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\ntheorem nontrivial_of_non_zero_divisors [nontrivial R] (hS : S ≤ non_zero_divisors R) : nontrivial («expr [ ⁻¹]» R S) :=\n  ⟨⟨0, 1, fun h => by\n      rw [ore_localization.one_def, ore_localization.zero_def] at h\n      apply non_zero_divisors.coe_ne_zero 1 (numerator_hom_inj hS h).symm⟩⟩\n#align nontrivial_of_non_zero_divisors nontrivial_of_non_zero_divisors\n\n",
 "neg_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n@[simp]\nprotected theorem neg_def (r : R) (s : S) : -«expr /ₒ » r s = «expr /ₒ » (-r) s :=\n  rfl\n#align neg_def neg_def\n\n",
 "mul_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\nprotected theorem mul_zero (x : «expr [ ⁻¹]» R S) : x * 0 = 0 :=\n  by\n  induction' x using ore_localization.ind with r s\n  rw [ore_localization.zero_def, ore_div_mul_char r 0 s 1 0 1 (by simp)]; simp\n#align mul_zero mul_zero\n\n",
 "mul_one_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n#print mul_one_div /-\n@[simp]\nprotected theorem mul_one_div {r : R} {s t : S} : «expr /ₒ » r s * «expr /ₒ » 1 t = «expr /ₒ » r (t * s) := by\n  simp [ore_div_mul_char r 1 s t 1 s (by simp)]\n#align mul_one_div mul_one_div\n-/\n\n",
 "mul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n#print mul_one /-\nprotected theorem mul_one (x : «expr [ ⁻¹]» R S) : x * 1 = x :=\n  by\n  induction' x using ore_localization.ind with r s\n  simp [ore_localization.one_def, ore_div_mul_char r 1 s 1 1 s (by simp)]\n#align mul_one mul_one\n-/\n\n",
 "mul_inv_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n#print mul_inv_cancel /-\nprotected theorem mul_inv_cancel (x : «expr [ ⁻¹]» R (non_zero_divisors R)) (h : x ≠ 0) : x * x⁻¹ = 1 :=\n  by\n  induction' x using ore_localization.ind with r s\n  rw [ore_localization.inv_def, ore_localization.one_def]\n  by_cases hr : r = 0\n  · exfalso\n    apply h\n    simp [hr]\n  · simp [hr]\n    apply ore_localization.div_eq_one'\n#align mul_inv_cancel mul_inv_cancel\n-/\n\n",
 "mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n#print mul_inv /-\nprotected theorem mul_inv (s s' : S) : «expr /ₒ » (s : R) s' * «expr /ₒ » s' s = 1 := by\n  simp [ore_div_mul_char (s : R) s' s' s 1 1 (by simp)]\n#align mul_inv mul_inv\n-/\n\n",
 "mul_cancel'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n@[simp]\nprotected theorem mul_cancel' {r₁ r₂ : R} {s t : S} :\n    «expr /ₒ » r₁ s * «expr /ₒ » (s * r₂) t = «expr /ₒ » (r₁ * r₂) t := by\n  simp [ore_div_mul_char r₁ (s * r₂) s t r₂ 1 (by simp)]\n#align mul_cancel' mul_cancel'\n\n",
 "mul_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n@[simp]\nprotected theorem mul_cancel {r : R} {s t : S} : «expr /ₒ » r s * «expr /ₒ » s t = «expr /ₒ » r t := by\n  simp [ore_div_mul_char r s s t 1 1 (by simp)]\n#align mul_cancel mul_cancel\n\n",
 "mul_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n#print mul_assoc /-\nprotected theorem mul_assoc (x y z : «expr [ ⁻¹]» R S) : x * y * z = x * (y * z) :=\n  by\n  induction' x using ore_localization.ind with r₁ s₁\n  induction' y using ore_localization.ind with r₂ s₂\n  induction' z using ore_localization.ind with r₃ s₃\n  rcases ore_div_mul_char' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'\n  rcases ore_div_mul_char' r₂ r₃ s₂ s₃ with ⟨rb, sb, hb, hb'⟩; rw [hb']; clear hb'\n  rcases ore_condition rb sa with ⟨rc, sc, hc⟩\n  rw [ore_div_mul_char (r₁ * ra) r₃ (s₂ * sa) s₃ rc (sb * sc)\n      (by\n        simp only [Submonoid.coe_mul]\n        assoc_rw [hb, hc])]\n  rw [mul_assoc, ← mul_assoc s₃]\n  symm; apply ore_div_mul_char\n  assoc_rw [hc, ← ha]; apply mul_assoc\n#align mul_assoc mul_assoc\n-/\n\n",
 "mul'_char":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\nprivate theorem mul'_char (r₁ r₂ : R) (s₁ s₂ : S) (u : S) (v : R) (huv : r₂ * (u : R) = s₁ * v) :\n    mul' r₁ s₁ r₂ s₂ = «expr /ₒ » (r₁ * v) (s₂ * u) :=\n  by\n  simp only [mul']\n  have h₀ := ore_eq r₂ s₁; set v₀ := ore_num r₂ s₁; set u₀ := ore_denom r₂ s₁\n  rcases ore_condition (u₀ : R) u with ⟨r₃, s₃, h₃⟩\n  have :=\n    calc\n      (s₁ : R) * (v * r₃) = r₂ * u * r₃ := by assoc_rw [← huv] <;> symm <;> apply mul_assoc\n      _ = r₂ * u₀ * s₃ := by assoc_rw [← h₃] <;> rfl\n      _ = s₁ * (v₀ * s₃) := by assoc_rw [h₀] <;> apply mul_assoc\n      \n  rcases ore_left_cancel _ _ _ this with ⟨s₄, hs₄⟩\n  symm; rw [ore_div_eq_iff]\n  use s₃ * s₄; use r₃ * s₄; simp only [Submonoid.coe_mul]; constructor\n  · assoc_rw [← hs₄]\n    simp only [mul_assoc]\n  · assoc_rw [h₃]\n    simp only [mul_assoc]\n#align mul'_char mul'_char\n\n",
 "lift₂_expand_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n@[simp]\ntheorem lift₂_expand_of {C : Sort _} {P : R → S → R → S → C}\n    {hP :\n      ∀ (r₁ t₁ : R) (s₁ : S) (ht₁ : (s₁ : R) * t₁ ∈ S) (r₂ t₂ : R) (s₂ : S) (ht₂ : (s₂ : R) * t₂ ∈ S),\n        P r₁ s₁ r₂ s₂ = P (r₁ * t₁) ⟨s₁ * t₁, ht₁⟩ (r₂ * t₂) ⟨s₂ * t₂, ht₂⟩}\n    (r₁ : R) (s₁ : S) (r₂ : R) (s₂ : S) : lift₂_expand P hP («expr /ₒ » r₁ s₁) («expr /ₒ » r₂ s₂) = P r₁ s₁ r₂ s₂ :=\n  rfl\n#align lift₂_expand_of lift₂_expand_of\n\n",
 "lift_expand_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n@[simp]\ntheorem lift_expand_of {C : Sort _} {P : R → S → C}\n    {hP : ∀ (r t : R) (s : S) (ht : (s : R) * t ∈ S), P r s = P (r * t) ⟨s * t, ht⟩} (r : R) (s : S) :\n    lift_expand P hP («expr /ₒ » r s) = P r s :=\n  rfl\n#align lift_expand_of lift_expand_of\n\n",
 "left_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n#print left_distrib /-\nprotected theorem left_distrib (x y z : «expr [ ⁻¹]» R S) : x * (y + z) = x * y + x * z :=\n  by\n  induction' x using ore_localization.ind with r₁ s₁\n  induction' y using ore_localization.ind with r₂ s₂\n  induction' z using ore_localization.ind with r₃ s₃\n  rcases ore_div_add_char' r₂ r₃ s₂ s₃ with ⟨ra, sa, ha, q⟩\n  rw [q]\n  clear q\n  rw [ore_localization.expand' r₂ s₂ sa]\n  rcases ore_div_mul_char' r₁ (r₂ * sa) s₁ (s₂ * sa) with ⟨rb, sb, hb, q⟩\n  rw [q]\n  clear q\n  have hs₃rasb : ↑s₃ * (ra * sb) ∈ S := by\n    rw [← mul_assoc, ← ha]\n    norm_cast\n    apply SetLike.coe_mem\n  rw [ore_localization.expand _ _ _ hs₃rasb]\n  have ha' : ↑(s₂ * sa * sb) = ↑s₃ * (ra * sb) := by simp [ha, ← mul_assoc]\n  rw [← subtype.coe_eq_of_eq_mk ha']\n  rcases ore_div_mul_char' r₁ (r₃ * (ra * sb)) s₁ (s₂ * sa * sb) with ⟨rc, sc, hc, hc'⟩\n  rw [hc']\n  rw [ore_div_add_char (s₂ * sa * sb) (s₂ * sa * sb * sc) 1 sc (by simp)]\n  rw [ore_localization.expand' (r₂ * ↑sa + r₃ * ra) (s₂ * sa) (sb * sc)]\n  conv_lhs =>\n    congr\n    skip\n    congr\n    rw [add_mul, S.coe_mul, ← mul_assoc, hb, ← mul_assoc, mul_assoc r₃, hc, mul_assoc, ← mul_add]\n  rw [ore_localization.mul_cancel']\n  simp only [mul_one, Submonoid.coe_mul, mul_add, ← mul_assoc]\n#align left_distrib left_distrib\n-/\n\n",
 "inv_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\nprotected theorem inv_zero : (0 : «expr [ ⁻¹]» R (non_zero_divisors R))⁻¹ = 0 :=\n  by\n  rw [ore_localization.zero_def, ore_localization.inv_def]\n  simp\n#align inv_zero inv_zero\n\n",
 "inv_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\nprotected theorem inv_def {r : R} {s : non_zero_divisors R} :\n    («expr /ₒ » r s)⁻¹ =\n      if hr : r = (0 : R) then (0 : «expr [ ⁻¹]» R (non_zero_divisors R))\n      else «expr /ₒ » s ⟨r, fun _ => eq_zero_of_ne_zero_of_mul_right_eq_zero hr⟩ :=\n  rfl\n#align inv_def inv_def\n\n",
 "ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/-\nCopyright (c) 2022 Jakob von Raumer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jakob von Raumer, Kevin Klinge\n-/\n@[elab_as_elim]\nprotected theorem ind {β : «expr [ ⁻¹]» R S → Prop} (c : ∀ (r : R) (s : S), β («expr /ₒ » r s)) : ∀ q, β q :=\n  by\n  apply quotient.ind\n  rintro ⟨r, s⟩\n  exact c r s\n#align ind ind\n\n",
 "expand'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/-- A fraction is equal to its expansion by an factor from s. -/\nprotected theorem expand' (r : R) (s s' : S) : «expr /ₒ » r s = «expr /ₒ » (r * s') (s * s') :=\n  ore_localization.expand r s s' (by norm_cast <;> apply SetLike.coe_mem)\n#align expand' expand'\n\n",
 "expand":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/-- A fraction `r /ₒ s` is equal to its expansion by an arbitrary factor `t` if `s * t ∈ S`. -/\nprotected theorem expand (r : R) (s : S) (t : R) (hst : (s : R) * t ∈ S) :\n    «expr /ₒ » r s = «expr /ₒ » (r * t) ⟨s * t, hst⟩ :=\n  by\n  apply quotient.sound\n  refine' ⟨s, t * s, _, _⟩ <;> dsimp <;> rw [mul_assoc] <;> rfl\n#align expand expand\n\n",
 "eq_of_num_factor_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/-- Fractions which differ by a factor of the numerator can be proven equal if\nthose factors expand to equal elements of `R`. -/\nprotected theorem eq_of_num_factor_eq {r r' r₁ r₂ : R} {s t : S} (h : r * t = r' * t) :\n    «expr /ₒ » (r₁ * r * r₂) s = «expr /ₒ » (r₁ * r' * r₂) s :=\n  by\n  rcases ore_condition r₂ t with ⟨r₂', t', hr₂⟩\n  calc\n    «expr /ₒ » (r₁ * r * r₂) s = «expr /ₒ » (r₁ * r * r₂ * t') (s * t') := ore_localization.expand _ _ t' _\n    _ = «expr /ₒ » (r₁ * r * (r₂ * t')) (s * t') := by simp [← mul_assoc]\n    _ = «expr /ₒ » (r₁ * r * (t * r₂')) (s * t') := by rw [hr₂]\n    _ = «expr /ₒ » (r₁ * (r * t) * r₂') (s * t') := by simp [← mul_assoc]\n    _ = «expr /ₒ » (r₁ * (r' * t) * r₂') (s * t') := by rw [h]\n    _ = «expr /ₒ » (r₁ * r' * (t * r₂')) (s * t') := by simp [← mul_assoc]\n    _ = «expr /ₒ » (r₁ * r' * (r₂ * t')) (s * t') := by rw [hr₂]\n    _ = «expr /ₒ » (r₁ * r' * r₂ * t') (s * t') := by simp [← mul_assoc]\n    _ = «expr /ₒ » (r₁ * r' * r₂) s := by symm <;> apply ore_localization.expand\n    \n#align eq_of_num_factor_eq eq_of_num_factor_eq\n\n",
 "div_one_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n@[simp]\ntheorem div_one_mul {p r : R} {s : S} : «expr /ₒ » r 1 * «expr /ₒ » p s = «expr /ₒ » (r * p) s :=\n  by--TODO use coercion r ↦ r /ₒ 1\n  simp [ore_div_mul_char r p 1 s p 1 (by simp)]\n#align div_one_mul div_one_mul\n\n",
 "div_eq_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n@[simp]\nprotected theorem div_eq_one' {r : R} (hr : r ∈ S) : «expr /ₒ » r ⟨r, hr⟩ = 1 :=\n  by\n  rw [ore_localization.one_def, ore_div_eq_iff]\n  exact ⟨⟨r, hr⟩, 1, by simp, by simp⟩\n#align div_eq_one' div_eq_one'\n\n",
 "div_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n#print div_eq_one /-\n@[simp]\nprotected theorem div_eq_one {s : S} : «expr /ₒ » (s : R) s = 1 := by cases s <;> apply ore_localization.div_eq_one'\n#align div_eq_one div_eq_one\n-/\n\n",
 "add_ore_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n@[simp]\ntheorem add_ore_div {r r' : R} {s : S} : «expr /ₒ » r s + «expr /ₒ » r' s = «expr /ₒ » (r + r') s := by\n  simp [ore_div_add_char s s 1 1 (by simp)]\n#align add_ore_div add_ore_div\n\n",
 "add_left_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n#print add_left_neg /-\nprotected theorem add_left_neg (x : «expr [ ⁻¹]» R S) : -x + x = 0 := by\n  induction' x using ore_localization.ind with r s <;> simp\n#align add_left_neg add_left_neg\n-/\n\n",
 "add_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n#print add_comm /-\nprotected theorem add_comm (x y : «expr [ ⁻¹]» R S) : x + y = y + x :=\n  by\n  induction x using ore_localization.ind\n  induction y using ore_localization.ind\n  change add' _ _ («expr /ₒ » _ _) = _; apply add'_comm\n#align add_comm add_comm\n-/\n\n",
 "add_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ⁻¹]» -/\n#print add_assoc /-\nprotected theorem add_assoc (x y z : «expr [ ⁻¹]» R S) : x + y + z = x + (y + z) :=\n  by\n  induction' x using ore_localization.ind with r₁ s₁\n  induction' y using ore_localization.ind with r₂ s₂\n  induction' z using ore_localization.ind with r₃ s₃\n  rcases ore_div_add_char' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'\n  rcases ore_div_add_char' r₂ r₃ s₂ s₃ with ⟨rb, sb, hb, hb'⟩; rw [hb']; clear hb'\n  rcases ore_div_add_char' (r₁ * sa + r₂ * ra) r₃ (s₁ * sa) s₃ with ⟨rc, sc, hc, q⟩; rw [q]; clear q\n  rcases ore_div_add_char' r₁ (r₂ * sb + r₃ * rb) s₁ (s₂ * sb) with ⟨rd, sd, hd, q⟩; rw [q]; clear q\n  noncomm_ring; rw [add_comm (r₂ * _)]\n  repeat' rw [← add_ore_div]\n  congr 1\n  · rcases ore_condition (sd : R) (sa * sc) with ⟨re, se, he⟩\n    · simp_rw [← Submonoid.coe_mul] at hb hc hd\n      assoc_rw [subtype.coe_eq_of_eq_mk hc]\n      rw [← ore_localization.expand, subtype.coe_eq_of_eq_mk hd, ← mul_assoc, ← ore_localization.expand,\n        subtype.coe_eq_of_eq_mk hb]\n      apply ore_localization.expand\n  congr 1\n  · rw [← ore_localization.expand', ← mul_assoc, ← mul_assoc, ← ore_localization.expand', ← ore_localization.expand']\n  · simp_rw [← Submonoid.coe_mul] at ha hd\n    rw [subtype.coe_eq_of_eq_mk hd, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← ore_localization.expand, ←\n      ore_localization.expand', subtype.coe_eq_of_eq_mk ha, ← ore_localization.expand]\n    apply ore_localization.expand'\n#align add_assoc add_assoc\n-/\n\n",
 "add'_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\n--plus tilde\n-- s*, r*\n--s~~, r~~\n-- s#, r#\nprivate theorem add'_comm (r₁ r₂ : R) (s₁ s₂ : S) : add' r₁ s₁ («expr /ₒ » r₂ s₂) = add' r₂ s₂ («expr /ₒ » r₁ s₁) :=\n  by\n  simp only [add', ore_div, add'', quotient.lift_mk, quotient.eq]\n  have hb := ore_eq (↑s₂) s₁\n  set rb := ore_num (↑s₂) s₁ with h\n  -- r~~\n  rw [← h]\n  clear h\n  set sb := ore_denom (↑s₂) s₁ with h\n  rw [← h]\n  clear h\n  -- s~~\n  have ha := ore_eq (↑s₁) s₂\n  set ra := ore_num (↑s₁) s₂ with h\n  -- r~\n  rw [← h]\n  clear h\n  set sa := ore_denom (↑s₁) s₂ with h\n  rw [← h]\n  clear h\n  -- s~\n  rcases ore_condition ra sb with ⟨rc, sc, hc⟩\n  -- r#, s#\n  have : (s₁ : R) * (rb * rc) = s₁ * (sa * sc) := by\n    rw [← mul_assoc, ← hb, mul_assoc, ← hc, ← mul_assoc, ← ha, mul_assoc]\n  rcases ore_left_cancel _ _ s₁ this with ⟨sd, hd⟩\n  -- s+\n  use sc * sd\n  use rc * sd\n  dsimp\n  constructor\n  · rw [add_mul, add_mul, add_comm]\n    assoc_rw [← hd, hc]\n    noncomm_ring\n  · rw [mul_assoc, ← mul_assoc ↑sa, ← hd, hb]\n    noncomm_ring\n#align add'_comm add'_comm\n\n",
 "add''_char":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₒ » -/\nprivate theorem add''_char (r₁ : R) (s₁ : S) (r₂ : R) (s₂ : S) (rb : R) (sb : S) (hb : (s₁ : R) * sb = (s₂ : R) * rb) :\n    add'' r₁ s₁ r₂ s₂ = «expr /ₒ » (r₁ * sb + r₂ * rb) (s₁ * sb) :=\n  by\n  simp only [add'']\n  have ha := ore_eq (s₁ : R) s₂\n  set! ra := ore_num (s₁ : R) s₂ with h\n  rw [← h] at *\n  clear h\n  -- r tilde\n  set! sa := ore_denom (s₁ : R) s₂ with h\n  rw [← h] at *\n  clear h\n  -- s tilde\n  rcases ore_condition (sa : R) sb with ⟨rc, sc, hc⟩\n  -- s*, r*\n  have : (s₂ : R) * (rb * rc) = s₂ * (ra * sc) := by\n    rw [← mul_assoc, ← hb, mul_assoc, ← hc, ← mul_assoc, ← mul_assoc, ha]\n  rcases ore_left_cancel _ _ s₂ this with ⟨sd, hd⟩\n  -- s#\n  symm\n  rw [ore_div_eq_iff]\n  use sc * sd\n  use rc * sd\n  constructor <;> simp only [Submonoid.coe_mul]\n  · noncomm_ring\n    assoc_rw [hd, hc]\n    noncomm_ring\n  · assoc_rw [hc]\n    noncomm_ring\n#align add''_char add''_char\n\n"}