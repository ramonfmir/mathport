{"radical_eq_jacobson":
 "theorem radical_eq_jacobson [H : is_jacobson R] (I : ideal R) : I.radical = I.jacobson :=\n  le_antisymm (le_infₛ fun J ⟨hJ, hJ_max⟩ => (is_prime.radical_le_iff hJ_max.is_prime).mpr hJ)\n    (H.out (radical_is_radical I) ▸ jacobson_mono le_radical)\n#align radical_eq_jacobson radical_eq_jacobson\n\n",
 "quotient_mk_comp_C_is_integral_of_jacobson'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Used to bootstrap the more general `quotient_mk_comp_C_is_integral_of_jacobson` -/\nprivate theorem quotient_mk_comp_C_is_integral_of_jacobson' [nontrivial R] (hR : is_jacobson R)\n    (hP' : ∀ x : R, C x ∈ P → x = 0) :\n    ((quotient.mk P).comp C : «expr →+* » R («expr ⧸ » (polynomial R) P)).is_integral :=\n  by\n  refine' (is_integral_quotient_map_iff _).mp _\n  let P' : ideal R := P.comap C\n  obtain ⟨pX, hpX, hp0⟩ :=\n    exists_nonzero_mem_of_ne_bot (ne_of_lt (bot_lt_of_maximal P polynomial_not_is_field)).symm hP'\n  let M : Submonoid («expr ⧸ » R P') := submonoid.powers (pX.map (Quotient.mk'' P')).leading_coeff\n  let φ : «expr →+* » («expr ⧸ » R P') («expr ⧸ » (polynomial R) P) := quotient_map P C le_rfl\n  haveI hp'_prime : P'.is_prime := comap_is_prime C P\n  have hM : (0 : «expr ⧸ » R P') ∉ M := fun ⟨n, hn⟩ => hp0 <| leading_coeff_eq_zero.mp (pow_eq_zero hn)\n  let M' : Submonoid («expr ⧸ » (polynomial R) P) := M.map (quotient_map P C le_rfl)\n  refine' (quotient_map P C le_rfl).is_integral_tower_bot_of_is_integral (algebra_map _ (localization M')) _ _\n  · refine'\n      is_localization.injective (localization M')\n        (show M' ≤ _ from le_non_zero_divisors_of_no_zero_divisors fun hM' => hM _)\n    exact\n      let ⟨z, zM, z0⟩ := hM'\n      quotient_map_injective (trans z0 φ.map_zero.symm) ▸ zM\n  · rw [← is_localization.map_comp M.le_comap_map]\n    refine'\n      ring_hom.is_integral_trans (algebra_map («expr ⧸ » R P') (localization M))\n        (is_localization.map (localization M') _ M.le_comap_map) _ _\n    ·\n      exact\n        (algebra_map («expr ⧸ » R P') (localization M)).is_integral_of_surjective\n          (is_field.localization_map_bijective hM\n              ((quotient.maximal_ideal_iff_is_field_quotient _).mp (is_maximal_comap_C_of_is_maximal P hP'))).2\n    ·-- `convert` here is faster than `exact`, and this proof is near the time limit.\n      convert is_integral_is_localization_polynomial_quotient P pX hpX\n#align quotient_mk_comp_C_is_integral_of_jacobson' quotient_mk_comp_C_is_integral_of_jacobson'\n\n",
 "quotient_mk_comp_C_is_integral_of_jacobson":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem quotient_mk_comp_C_is_integral_of_jacobson {R : Type _} [CommRing R] [is_jacobson R]\n    (P : ideal (mv_polynomial (fin n) R)) [P.is_maximal] :\n    ((quotient.mk P).comp mv_polynomial.C : «expr →+* » R («expr ⧸ » (mv_polynomial _ R) P)).is_integral :=\n  by\n  induction' n with n IH\n  · refine' ring_hom.is_integral_of_surjective _ (function.surjective.comp quotient.mk_surjective _)\n    exact C_surjective (fin 0)\n  · rw [← fin_succ_equiv_comp_C_eq_C, ← RingHom.comp_assoc, ← RingHom.comp_assoc, ← quotient_map_comp_mk le_rfl,\n      RingHom.comp_assoc polynomial.C, ← quotient_map_comp_mk le_rfl, RingHom.comp_assoc, RingHom.comp_assoc, ←\n      quotient_map_comp_mk le_rfl, ← RingHom.comp_assoc (Quotient.mk'' _)]\n    refine' ring_hom.is_integral_trans _ _ _ _\n    · refine' ring_hom.is_integral_trans _ _ (is_integral_of_surjective _ quotient.mk_surjective) _\n      refine' ring_hom.is_integral_trans _ _ _ _\n      · apply (is_integral_quotient_map_iff _).mpr (IH _)\n        apply polynomial.is_maximal_comap_C_of_is_jacobson _\n        · exact mv_polynomial.is_jacobson_mv_polynomial_fin n\n        · apply comap_is_maximal_of_surjective\n          exact (fin_succ_equiv R n).symm.surjective\n      · refine' (is_integral_quotient_map_iff _).mpr _\n        rw [← quotient_map_comp_mk le_rfl]\n        refine' ring_hom.is_integral_trans _ _ _ ((is_integral_quotient_map_iff _).mpr _)\n        · exact ring_hom.is_integral_of_surjective _ quotient.mk_surjective\n        · apply polynomial.quotient_mk_comp_C_is_integral_of_jacobson _\n          · exact mv_polynomial.is_jacobson_mv_polynomial_fin n\n          · exact comap_is_maximal_of_surjective _ (fin_succ_equiv R n).symm.surjective\n    · refine' (is_integral_quotient_map_iff _).mpr _\n      refine' ring_hom.is_integral_trans _ _ _ (is_integral_of_surjective _ quotient.mk_surjective)\n      exact ring_hom.is_integral_of_surjective _ (fin_succ_equiv R n).symm.surjective\n#align quotient_mk_comp_C_is_integral_of_jacobson quotient_mk_comp_C_is_integral_of_jacobson\n\n",
 "out":
 "theorem is_jacobson.out {R} [CommRing R] : is_jacobson R → ∀ {I : ideal R}, I.is_radical → I.jacobson = I :=\n  is_jacobson_iff.1\n#align is_jacobson.out is_jacobson.out\n\n",
 "jacobson_bot_of_integral_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If `f : R → S` descends to an integral map in the localization at `x`,\n  and `R` is a Jacobson ring, then the intersection of all maximal ideals in `S` is trivial -/\ntheorem jacobson_bot_of_integral_localization {R : Type _} [CommRing R] [IsDomain R] [is_jacobson R] (Rₘ Sₘ : Type _)\n    [CommRing Rₘ] [CommRing Sₘ] (φ : «expr →+* » R S) (hφ : function.injective φ) (x : R) (hx : x ≠ 0) [algebra R Rₘ]\n    [is_localization.away x Rₘ] [algebra S Sₘ] [is_localization ((submonoid.powers x).map φ : Submonoid S) Sₘ]\n    (hφ' : ring_hom.is_integral (is_localization.map Sₘ φ (submonoid.powers x).le_comap_map : «expr →+* » Rₘ Sₘ)) :\n    («expr⊥» : ideal S).jacobson = («expr⊥» : ideal S) :=\n  by\n  have hM : ((submonoid.powers x).map φ : Submonoid S) ≤ non_zero_divisors S :=\n    map_le_non_zero_divisors_of_injective φ hφ (powers_le_non_zero_divisors_of_no_zero_divisors hx)\n  letI : IsDomain Sₘ := is_localization.is_domain_of_le_non_zero_divisors _ hM\n  let φ' : «expr →+* » Rₘ Sₘ := is_localization.map _ φ (submonoid.powers x).le_comap_map\n  suffices ∀ I : ideal Sₘ, I.is_maximal → (I.comap (algebra_map S Sₘ)).is_maximal\n    by\n    have hϕ' : comap (algebra_map S Sₘ) («expr⊥» : ideal Sₘ) = («expr⊥» : ideal S) :=\n      by\n      rw [← ring_hom.ker_eq_comap_bot, ← ring_hom.injective_iff_ker_eq_bot]\n      exact is_localization.injective Sₘ hM\n    have hSₘ : is_jacobson Sₘ := is_jacobson_of_is_integral' φ' hφ' (is_jacobson_localization x)\n    refine' eq_bot_iff.mpr (le_trans _ (le_of_eq hϕ'))\n    rw [← hSₘ.out is_radical_bot_of_no_zero_divisors, comap_jacobson]\n    exact\n      infₛ_le_infₛ fun j hj =>\n        ⟨bot_le,\n          let ⟨J, hJ⟩ := hj\n          hJ.2 ▸ this J hJ.1.2⟩\n  intro I hI\n  -- Remainder of the proof is pulling and pushing ideals around the square and the quotient square\n  haveI : (I.comap (algebra_map S Sₘ)).is_prime := comap_is_prime _ I\n  haveI : (I.comap φ').is_prime := comap_is_prime φ' I\n  haveI : («expr⊥» : ideal («expr ⧸ » S (I.comap (algebra_map S Sₘ)))).is_prime := bot_prime\n  have hcomm : φ'.comp (algebra_map R Rₘ) = (algebra_map S Sₘ).comp φ := is_localization.map_comp _\n  let f := quotient_map (I.comap (algebra_map S Sₘ)) φ le_rfl\n  let g := quotient_map I (algebra_map S Sₘ) le_rfl\n  have := is_maximal_comap_of_is_integral_of_is_maximal' φ' hφ' I hI\n  have := ((is_maximal_iff_is_maximal_disjoint Rₘ x _).1 this).left\n  have : ((I.comap (algebra_map S Sₘ)).comap φ).is_maximal := by rwa [comap_comap, hcomm, ← comap_comap] at this\n  rw [← bot_quotient_is_maximal_iff] at this⊢\n  refine'\n    is_maximal_of_is_integral_of_is_maximal_comap' f _ («expr⊥»)\n      ((eq_bot_iff.2 (comap_bot_le_of_injective f quotient_map_injective)).symm ▸ this)\n  exact\n    f.is_integral_tower_bot_of_is_integral g quotient_map_injective\n      ((comp_quotient_map_eq_of_comp_eq hcomm I).symm ▸\n        ring_hom.is_integral_trans _ _\n          (ring_hom.is_integral_of_surjective _\n            (is_localization.surjective_quotient_map_of_maximal_of_localization (submonoid.powers x) Rₘ\n              (by rwa [comap_comap, hcomm, ← bot_quotient_is_maximal_iff])))\n          (ring_hom.is_integral_quotient_of_is_integral _ hφ'))\n#align jacobson_bot_of_integral_localization jacobson_bot_of_integral_localization\n\n",
 "is_maximal_of_is_maximal_disjoint":
 "/-- If `R` is a Jacobson ring, then maximal ideals in the localization at `y`\ncorrespond to maximal ideals in the original ring `R` that don't contain `y`.\nThis lemma gives the correspondence in the particular case of an ideal and its map.\nSee `le_rel_iso_of_maximal` for the more general statement, and the reverse of this implication -/\ntheorem is_maximal_of_is_maximal_disjoint [is_jacobson R] (I : ideal R) (hI : I.is_maximal) (hy : y ∉ I) :\n    (map (algebra_map R S) I).is_maximal :=\n  by\n  rw [is_maximal_iff_is_maximal_disjoint S y,\n    comap_map_of_is_prime_disjoint (powers y) S I (is_maximal.is_prime hI)\n      ((disjoint_powers_iff_not_mem y hI.is_prime.is_radical).2 hy)]\n  exact ⟨hI, hy⟩\n#align is_maximal_of_is_maximal_disjoint is_maximal_of_is_maximal_disjoint\n\n",
 "is_maximal_iff_is_maximal_disjoint":
 "/-- If `R` is a Jacobson ring, then maximal ideals in the localization at `y`\ncorrespond to maximal ideals in the original ring `R` that don't contain `y`.\nThis lemma gives the correspondence in the particular case of an ideal and its comap.\nSee `le_rel_iso_of_maximal` for the more general relation isomorphism -/\ntheorem is_maximal_iff_is_maximal_disjoint [H : is_jacobson R] (J : ideal S) :\n    J.is_maximal ↔ (comap (algebra_map R S) J).is_maximal ∧ y ∉ ideal.comap (algebra_map R S) J :=\n  by\n  constructor\n  · refine' fun h =>\n      ⟨_, fun hy => h.ne_top (ideal.eq_top_of_is_unit_mem _ hy (map_units _ ⟨y, submonoid.mem_powers _⟩))⟩\n    have hJ : J.is_prime := is_maximal.is_prime h\n    rw [is_prime_iff_is_prime_disjoint (submonoid.powers y)] at hJ\n    have : y ∉ (comap (algebra_map R S) J).1 := Set.disjoint_left.1 hJ.right (submonoid.mem_powers _)\n    erw [← H.out hJ.left.is_radical, mem_Inf] at this\n    push_neg  at this\n    rcases this with ⟨I, hI, hI'⟩\n    convert hI.right\n    by_cases hJ : J = map (algebra_map R S) I\n    · rw [hJ, comap_map_of_is_prime_disjoint (powers y) S I (is_maximal.is_prime hI.right)]\n      rwa [disjoint_powers_iff_not_mem y hI.right.is_prime.is_radical]\n    · have hI_p : (map (algebra_map R S) I).is_prime :=\n        by\n        refine' is_prime_of_is_prime_disjoint (powers y) _ I hI.right.is_prime _\n        rwa [disjoint_powers_iff_not_mem y hI.right.is_prime.is_radical]\n      have : J ≤ map (algebra_map R S) I := map_comap (submonoid.powers y) S J ▸ map_mono hI.left\n      exact absurd (h.1.2 _ (lt_of_le_of_ne this hJ)) hI_p.1\n  · refine' fun h => ⟨⟨fun hJ => h.1.ne_top (eq_top_iff.2 _), fun I hI => _⟩⟩\n    · rwa [eq_top_iff, ← (is_localization.order_embedding (powers y) S).le_iff_le] at hJ\n    · have := congr_arg (map (algebra_map R S)) (h.1.1.2 _ ⟨comap_mono (le_of_lt hI), _⟩)\n      rwa [map_comap (powers y) S I, map_top] at this\n      refine' fun hI' => hI.right _\n      rw [← map_comap (powers y) S I, ← map_comap (powers y) S J]\n      exact map_mono hI'\n#align is_maximal_iff_is_maximal_disjoint is_maximal_iff_is_maximal_disjoint\n\n",
 "is_maximal_comap_C_of_is_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_maximal_comap_C_of_is_maximal [nontrivial R] (hP' : ∀ x : R, C x ∈ P → x = 0) :\n    is_maximal (comap (C : «expr →+* » R (polynomial R)) P : ideal R) :=\n  by\n  haveI hp'_prime : (P.comap (C : «expr →+* » R (polynomial R)) : ideal R).is_prime := comap_is_prime C P\n  obtain ⟨m, hm⟩ := submodule.nonzero_mem_of_bot_lt (bot_lt_of_maximal P polynomial_not_is_field)\n  have : (m : polynomial R) ≠ 0\n  rwa [ne.def, submodule.coe_eq_zero]\n  let φ : «expr →+* » («expr ⧸ » R (P.comap (C : «expr →+* » R (polynomial R)))) («expr ⧸ » (polynomial R) P) :=\n    quotient_map P (C : «expr →+* » R (polynomial R)) le_rfl\n  let M : Submonoid («expr ⧸ » R (P.comap C)) :=\n    submonoid.powers\n      ((m : polynomial R).map (Quotient.mk'' (P.comap (C : «expr →+* » R (polynomial R)) : ideal R))).leading_coeff\n  rw [← bot_quotient_is_maximal_iff]\n  have hp0 :\n    ((m : polynomial R).map (Quotient.mk'' (P.comap (C : «expr →+* » R (polynomial R)) : ideal R))).leading_coeff ≠ 0 :=\n    fun hp0' =>\n    this <|\n      map_injective (Quotient.mk'' (P.comap (C : «expr →+* » R (polynomial R)) : ideal R))\n        ((injective_iff_map_eq_zero (Quotient.mk'' (P.comap (C : «expr →+* » R (polynomial R)) : ideal R))).2\n          fun x hx => by rwa [quotient.eq_zero_iff_mem, (by rwa [eq_bot_iff] : (P.comap C : ideal R) = «expr⊥»)] at hx)\n        (by simpa only [leading_coeff_eq_zero, polynomial.map_zero] using hp0')\n  have hM : (0 : «expr ⧸ » R (P.comap C)) ∉ M := fun ⟨n, hn⟩ => hp0 (pow_eq_zero hn)\n  suffices («expr⊥» : ideal (localization M)).is_maximal\n    by\n    rw [←\n      is_localization.comap_map_of_is_prime_disjoint M (localization M) («expr⊥») bot_prime\n        (disjoint_iff_inf_le.mpr fun x hx => hM (hx.2 ▸ hx.1))]\n    refine' ((is_maximal_iff_is_maximal_disjoint (localization M) _ _).mp (by rwa [map_bot])).1\n    swap\n    exact localization.is_localization\n  let M' : Submonoid («expr ⧸ » (polynomial R) P) := M.map φ\n  have hM' : (0 : «expr ⧸ » (polynomial R) P) ∉ M' := fun ⟨z, hz⟩ =>\n    hM (quotient_map_injective (trans hz.2 φ.map_zero.symm) ▸ hz.1)\n  haveI : IsDomain (localization M') :=\n    is_localization.is_domain_localization (le_non_zero_divisors_of_no_zero_divisors hM')\n  suffices («expr⊥» : ideal (localization M')).is_maximal\n    by\n    rw [le_antisymm bot_le\n        (comap_bot_le_of_injective _\n          (is_localization.map_injective_of_injective M (localization M) (localization M') quotient_map_injective))]\n    refine' is_maximal_comap_of_is_integral_of_is_maximal' _ _ («expr⊥») this\n    apply is_integral_is_localization_polynomial_quotient P _ (submodule.coe_mem m)\n  rw [(map_bot.symm :\n      («expr⊥» : ideal (localization M')) = map (algebra_map («expr ⧸ » (polynomial R) P) (localization M')) («expr⊥»))]\n  let bot_maximal := (bot_quotient_is_maximal_iff _).mpr hP\n  refine' map.is_maximal (algebra_map _ _) (is_field.localization_map_bijective hM' _) bot_maximal\n  rwa [← quotient.maximal_ideal_iff_is_field_quotient, ← bot_quotient_is_maximal_iff]\n#align is_maximal_comap_C_of_is_maximal is_maximal_comap_C_of_is_maximal\n\n",
 "is_maximal_comap_C_of_is_jacobson":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_maximal_comap_C_of_is_jacobson : (P.comap (C : «expr →+* » R (polynomial R))).is_maximal :=\n  by\n  rw [← @mk_ker _ _ P, ring_hom.ker_eq_comap_bot, comap_comap]\n  exact\n    is_maximal_comap_of_is_integral_of_is_maximal' _ (quotient_mk_comp_C_is_integral_of_jacobson P) («expr⊥»)\n      ((bot_quotient_is_maximal_iff _).mpr hP)\n#align is_maximal_comap_C_of_is_jacobson is_maximal_comap_C_of_is_jacobson\n\n",
 "is_jacobson_polynomial_of_is_jacobson":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_jacobson_polynomial_of_is_jacobson (hR : is_jacobson R) : is_jacobson (polynomial R) :=\n  by\n  refine' is_jacobson_iff_prime_eq.mpr fun I => _\n  intro hI\n  let R' : subring («expr ⧸ » (polynomial R) I) := ((Quotient.mk'' I).comp C).range\n  let i : «expr →+* » R R' := ((Quotient.mk'' I).comp C).range_restrict\n  have hi : function.surjective (i : R → R') := ((Quotient.mk'' I).comp C).range_restrict_surjective\n  have hi' : (polynomial.map_ring_hom i : «expr →+* » (polynomial R) (polynomial R')).ker ≤ I :=\n    by\n    refine' fun f hf => polynomial_mem_ideal_of_coeff_mem_ideal I f fun n => _\n    replace hf := congr_arg (fun g : polynomial ((Quotient.mk'' I).comp C).range => g.coeff n) hf\n    change (polynomial.map ((Quotient.mk'' I).comp C).range_restrict f).coeff n = 0 at hf\n    rw [coeff_map, subtype.ext_iff] at hf\n    rwa [mem_comap, ← quotient.eq_zero_iff_mem, ← RingHom.comp_apply]\n  haveI := map_is_prime_of_surjective (show function.surjective (map_ring_hom i) from map_surjective i hi) hi'\n  suffices (I.map (polynomial.map_ring_hom i)).jacobson = I.map (polynomial.map_ring_hom i)\n    by\n    replace this := congr_arg (comap (polynomial.map_ring_hom i)) this\n    rw [← map_jacobson_of_surjective _ hi', comap_map_of_surjective _ _, comap_map_of_surjective _ _] at this\n    refine' le_antisymm (le_trans (le_sup_of_le_left le_rfl) (le_trans (le_of_eq this) (sup_le le_rfl hi'))) le_jacobson\n    all_goals exact polynomial.map_surjective i hi\n  exact\n    @is_jacobson_polynomial_of_domain R' _ _ (is_jacobson_of_surjective ⟨i, hi⟩) (map (map_ring_hom i) I) _\n      (eq_zero_of_polynomial_mem_map_range I)\n#align is_jacobson_polynomial_of_is_jacobson is_jacobson_polynomial_of_is_jacobson\n\n",
 "is_jacobson_polynomial_of_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Used to bootstrap the proof of `is_jacobson_polynomial_iff_is_jacobson`.\n  That theorem is more general and should be used instead of this one. -/\nprivate theorem is_jacobson_polynomial_of_domain (R : Type _) [CommRing R] [IsDomain R] [hR : is_jacobson R]\n    (P : ideal (polynomial R)) [is_prime P] (hP : ∀ x : R, C x ∈ P → x = 0) : P.jacobson = P :=\n  by\n  by_cases Pb : P = «expr⊥»\n  · exact Pb.symm ▸ jacobson_bot_polynomial_of_jacobson_bot (hR.out is_radical_bot_of_no_zero_divisors)\n  · rw [jacobson_eq_iff_jacobson_quotient_eq_bot]\n    haveI : (P.comap (C : «expr →+* » R (polynomial R))).is_prime := comap_is_prime C P\n    obtain ⟨p, pP, p0⟩ := exists_nonzero_mem_of_ne_bot Pb hP\n    let x := (polynomial.map (Quotient.mk'' (comap (C : «expr →+* » R _) P)) p).leading_coeff\n    have hx : x ≠ 0 := by rwa [ne.def, leading_coeff_eq_zero]\n    refine'\n      jacobson_bot_of_integral_localization (localization.away x)\n        (localization ((submonoid.powers x).map (P.quotient_map C le_rfl) : Submonoid («expr ⧸ » (polynomial R) P)))\n        (quotient_map P C le_rfl) quotient_map_injective x hx _\n    -- `convert` is noticeably faster than `exact` here:\n    convert is_integral_is_localization_polynomial_quotient P p pP\n#align is_jacobson_polynomial_of_domain is_jacobson_polynomial_of_domain\n\n",
 "is_jacobson_polynomial_iff_is_jacobson":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_jacobson_polynomial_iff_is_jacobson : is_jacobson (polynomial R) ↔ is_jacobson R :=\n  by\n  refine' ⟨_, is_jacobson_polynomial_of_is_jacobson⟩\n  intro H\n  exact\n    is_jacobson_of_surjective\n      ⟨eval₂_ring_hom (RingHom.id _) 1, fun x => ⟨C x, by simp only [coe_eval₂_ring_hom, RingHom.id_apply, eval₂_C]⟩⟩\n#align is_jacobson_polynomial_iff_is_jacobson is_jacobson_polynomial_iff_is_jacobson\n\n",
 "is_jacobson_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_jacobson_of_surjective [H : is_jacobson R] :\n    (∃ f : «expr →+* » R S, function.surjective f) → is_jacobson S :=\n  by\n  rintro ⟨f, hf⟩\n  rw [is_jacobson_iff_Inf_maximal]\n  intro p hp\n  use «expr '' » (map f) { J : ideal R | comap f p ≤ J ∧ J.is_maximal }\n  use fun j ⟨J, hJ, hmap⟩ => hmap ▸ (map_eq_top_or_is_maximal_of_surjective f hf hJ.right).symm\n  have : p = map f (comap f p).jacobson :=\n    (is_jacobson.out' _ <| hp.is_radical.comap f).symm ▸ (map_comap_of_surjective f hf p).symm\n  exact this.trans (map_Inf hf fun J ⟨hJ, _⟩ => le_trans (ideal.ker_le_comap f) hJ)\n#align is_jacobson_of_surjective is_jacobson_of_surjective\n\n",
 "is_jacobson_of_is_integral'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_jacobson_of_is_integral' (f : «expr →+* » R S) (hf : f.is_integral) (hR : is_jacobson R) : is_jacobson S :=\n  @is_jacobson_of_is_integral _ _ _ _ f.to_algebra hf hR\n#align is_jacobson_of_is_integral' is_jacobson_of_is_integral'\n\n",
 "is_jacobson_of_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem is_jacobson_of_is_integral [algebra R S] (hRS : algebra.is_integral R S) (hR : is_jacobson R) : is_jacobson S :=\n  by\n  rw [is_jacobson_iff_prime_eq]\n  intro P hP\n  by_cases hP_top : comap (algebra_map R S) P = «expr⊤»\n  · simp [comap_eq_top_iff.1 hP_top]\n  · haveI : nontrivial («expr ⧸ » R (comap (algebra_map R S) P)) := quotient.nontrivial hP_top\n    rw [jacobson_eq_iff_jacobson_quotient_eq_bot]\n    refine' eq_bot_of_comap_eq_bot (is_integral_quotient_of_is_integral hRS) _\n    rw [eq_bot_iff, ←\n      jacobson_eq_iff_jacobson_quotient_eq_bot.1\n        ((is_jacobson_iff_prime_eq.1 hR) (comap (algebra_map R S) P) (comap_is_prime _ _)),\n      comap_jacobson]\n    refine' infₛ_le_infₛ fun J hJ => _\n    simp only [true_and_iff, Set.mem_image, bot_le, Set.mem_setOf_eq]\n    have : J.is_maximal := by simpa using hJ\n    exact\n      exists_ideal_over_maximal_of_is_integral (is_integral_quotient_of_is_integral hRS) J\n        (comap_bot_le_of_injective _ algebra_map_quotient_injective)\n#align is_jacobson_of_is_integral is_jacobson_of_is_integral\n\n",
 "is_jacobson_mv_polynomial_fin":
 "theorem is_jacobson_mv_polynomial_fin {R : Type _} [CommRing R] [H : is_jacobson R] :\n    ∀ n : ℕ, is_jacobson (mv_polynomial (fin n) R)\n  | 0 =>\n    (is_jacobson_iso\n          ((rename_equiv R (Equiv.equivPEmpty (fin 0))).to_ring_equiv.trans (is_empty_ring_equiv R PEmpty))).mpr\n      H\n  | n + 1 =>\n    (is_jacobson_iso (fin_succ_equiv R n).to_ring_equiv).2\n      (polynomial.is_jacobson_polynomial_iff_is_jacobson.2 (is_jacobson_mv_polynomial_fin n))\n#align is_jacobson_mv_polynomial_fin is_jacobson_mv_polynomial_fin\n\n",
 "is_jacobson_localization":
 "/-- If `S` is the localization of the Jacobson ring `R` at the submonoid generated by `y : R`, then\n`S` is Jacobson. -/\ntheorem is_jacobson_localization [H : is_jacobson R] : is_jacobson S :=\n  by\n  rw [is_jacobson_iff_prime_eq]\n  refine' fun P' hP' => le_antisymm _ le_jacobson\n  obtain ⟨hP', hPM⟩ := (is_localization.is_prime_iff_is_prime_disjoint (powers y) S P').mp hP'\n  have hP := H.out hP'.is_radical\n  refine'\n    (is_localization.map_comap (powers y) S P'.jacobson).ge.trans\n      ((map_mono _).trans (is_localization.map_comap (powers y) S P').le)\n  have : Inf { I : ideal R | comap (algebra_map R S) P' ≤ I ∧ I.is_maximal ∧ y ∉ I } ≤ comap (algebra_map R S) P' :=\n    by\n    intro x hx\n    have hxy : x * y ∈ (comap (algebra_map R S) P').jacobson :=\n      by\n      rw [ideal.jacobson, mem_Inf]\n      intro J hJ\n      by_cases y ∈ J\n      · exact J.mul_mem_left x h\n      · exact J.mul_mem_right y ((mem_Inf.1 hx) ⟨hJ.left, ⟨hJ.right, h⟩⟩)\n    rw [hP] at hxy\n    cases' hP'.mem_or_mem hxy with hxy hxy\n    · exact hxy\n    · exact (hPM.le_bot ⟨submonoid.mem_powers _, hxy⟩).elim\n  refine' le_trans _ this\n  rw [ideal.jacobson, comap_Inf', infₛ_eq_infᵢ]\n  refine' infᵢ_le_infᵢ_of_subset fun I hI => ⟨map (algebra_map R S) I, ⟨_, _⟩⟩\n  ·\n    exact\n      ⟨le_trans (le_of_eq (is_localization.map_comap (powers y) S P').symm) (map_mono hI.1),\n        is_maximal_of_is_maximal_disjoint y _ hI.2.1 hI.2.2⟩\n  ·\n    exact\n      is_localization.comap_map_of_is_prime_disjoint _ S I (is_maximal.is_prime hI.2.1)\n        ((disjoint_powers_iff_not_mem y hI.2.1.is_prime.is_radical).2 hI.2.2)\n#align is_jacobson_localization is_jacobson_localization\n\n",
 "is_jacobson_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\ntheorem is_jacobson_iso (e : «expr ≃+* » R S) : is_jacobson R ↔ is_jacobson S :=\n  ⟨fun h => @is_jacobson_of_surjective _ _ _ _ h ⟨(e : «expr →+* » R S), e.surjective⟩, fun h =>\n    @is_jacobson_of_surjective _ _ _ _ h ⟨(e.symm : «expr →+* » S R), e.symm.surjective⟩⟩\n#align is_jacobson_iso is_jacobson_iso\n\n",
 "is_jacobson_iff_prime_eq":
 "/-- A ring is a Jacobson ring if and only if for all prime ideals `P`,\n the Jacobson radical of `P` is equal to `P`. -/\ntheorem is_jacobson_iff_prime_eq : is_jacobson R ↔ ∀ P : ideal R, is_prime P → P.jacobson = P :=\n  by\n  refine' is_jacobson_iff.trans ⟨fun h I hI => h I hI.is_radical, _⟩\n  refine' fun h I hI => le_antisymm (fun x hx => _) fun x hx => mem_Inf.mpr fun _ hJ => hJ.left hx\n  rw [← hI.radical, radical_eq_Inf I, mem_Inf]\n  intro P hP\n  rw [Set.mem_setOf_eq] at hP\n  erw [mem_Inf] at hx\n  erw [← h P hP.right, mem_Inf]\n  exact fun J hJ => hx ⟨le_trans hP.left hJ.left, hJ.right⟩\n#align is_jacobson_iff_prime_eq is_jacobson_iff_prime_eq\n\n",
 "is_jacobson_iff_Inf_maximal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_jacobson_iff_Inf_maximal' :\n    is_jacobson R ↔\n      ∀ {I : ideal R}, I.is_prime → ∃ M : set (ideal R), (∀ J ∈ M, ∀ (K : ideal R), J < K → K = «expr⊤») ∧ I = infₛ M :=\n  ⟨fun H I h => eq_jacobson_iff_Inf_maximal'.1 (H.out h.is_radical), fun H =>\n    is_jacobson_iff_prime_eq.2 fun P hP => eq_jacobson_iff_Inf_maximal'.2 (H hP)⟩\n#align is_jacobson_iff_Inf_maximal' is_jacobson_iff_Inf_maximal'\n\n",
 "is_jacobson_iff_Inf_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A ring `R` is Jacobson if and only if for every prime ideal `I`,\n `I` can be written as the infimum of some collection of maximal ideals.\n Allowing ⊤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. -/\ntheorem is_jacobson_iff_Inf_maximal :\n    is_jacobson R ↔\n      ∀ {I : ideal R}, I.is_prime → ∃ M : set (ideal R), (∀ J ∈ M, is_maximal J ∨ J = «expr⊤») ∧ I = infₛ M :=\n  ⟨fun H I h => eq_jacobson_iff_Inf_maximal.1 (H.out h.is_radical), fun H =>\n    is_jacobson_iff_prime_eq.2 fun P hP => eq_jacobson_iff_Inf_maximal.2 (H hP)⟩\n#align is_jacobson_iff_Inf_maximal is_jacobson_iff_Inf_maximal\n\n",
 "is_jacobson_iff":
 "/-\nCopyright (c) 2020 Devon Tuma. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Devon Tuma\n-/\ntheorem is_jacobson_iff {R} [CommRing R] : is_jacobson R ↔ ∀ I : ideal R, I.is_radical → I.jacobson = I :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align is_jacobson_iff is_jacobson_iff\n\n",
 "is_integral_is_localization_polynomial_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `I` is a prime ideal of `R[X]` and `pX ∈ I` is a non-constant polynomial,\n  then the map `R →+* R[x]/I` descends to an integral map when localizing at `pX.leading_coeff`.\n  In particular `X` is integral because it satisfies `pX`, and constants are trivially integral,\n  so integrality of the entire extension follows by closure under addition and multiplication. -/\ntheorem is_integral_is_localization_polynomial_quotient (P : ideal (polynomial R)) (pX : polynomial R) (hpX : pX ∈ P)\n    [algebra («expr ⧸ » R (P.comap (C : «expr →+* » R _))) Rₘ]\n    [is_localization.away (pX.map (quotient.mk (P.comap (C : «expr →+* » R (polynomial R))))).leading_coeff Rₘ]\n    [algebra («expr ⧸ » (polynomial R) P) Sₘ]\n    [is_localization\n        ((submonoid.powers (pX.map (quotient.mk (P.comap (C : «expr →+* » R (polynomial R))))).leading_coeff).map\n            (quotient_map P C le_rfl) :\n          Submonoid («expr ⧸ » (polynomial R) P))\n        Sₘ] :\n    (is_localization.map Sₘ (quotient_map P C le_rfl)\n          (submonoid.powers\n              (pX.map (quotient.mk (P.comap (C : «expr →+* » R (polynomial R))))).leading_coeff).le_comap_map :\n        «expr →+* » Rₘ _).is_integral :=\n  by\n  let P' : ideal R := P.comap C\n  let M : Submonoid («expr ⧸ » R P') :=\n    submonoid.powers (pX.map (Quotient.mk'' (P.comap (C : «expr →+* » R (polynomial R))))).leading_coeff\n  let M' : Submonoid («expr ⧸ » (polynomial R) P) :=\n    (submonoid.powers (pX.map (Quotient.mk'' (P.comap (C : «expr →+* » R (polynomial R))))).leading_coeff).map\n      (quotient_map P C le_rfl)\n  let φ : «expr →+* » («expr ⧸ » R P') («expr ⧸ » (polynomial R) P) := quotient_map P C le_rfl\n  let φ' : «expr →+* » Rₘ Sₘ := is_localization.map Sₘ φ M.le_comap_map\n  have hφ' : φ.comp (Quotient.mk'' P') = (Quotient.mk'' P).comp C := rfl\n  intro p\n  obtain ⟨⟨p', ⟨q, hq⟩⟩, hp⟩ := is_localization.surj M' p\n  suffices φ'.is_integral_elem (algebra_map _ _ p')\n    by\n    obtain ⟨q', hq', rfl⟩ := hq\n    obtain ⟨q'', hq''⟩ := isUnit_iff_exists_inv'.1 (is_localization.map_units Rₘ (⟨q', hq'⟩ : M))\n    refine' φ'.is_integral_of_is_integral_mul_unit p (algebra_map _ _ (φ q')) q'' _ (hp.symm ▸ this)\n    convert trans (trans (φ'.map_mul _ _).symm (congr_arg φ' hq'')) φ'.map_one using 2\n    rw [← φ'.comp_apply, is_localization.map_comp, RingHom.comp_apply, subtype.coe_mk]\n  refine'\n    is_integral_of_mem_closure''\n      («expr '' » ((algebra_map _ Sₘ).comp (Quotient.mk'' P)) (insert X { p | p.degree ≤ 0 })) _ _ _\n  · rintro x ⟨p, hp, rfl⟩\n    refine' hp.rec_on (fun hy => _) fun hy => _\n    · refine'\n        hy.symm ▸\n          φ.is_integral_elem_localization_at_leading_coeff ((Quotient.mk'' P) X) (pX.map (Quotient.mk'' P')) _ M\n            ⟨1, pow_one _⟩\n      rwa [eval₂_map, hφ', ← hom_eval₂, quotient.eq_zero_iff_mem, eval₂_C_X]\n    · rw [Set.mem_setOf_eq, degree_le_zero_iff] at hy\n      refine' hy.symm ▸ ⟨X - C (algebra_map _ _ ((Quotient.mk'' P') (p.coeff 0))), monic_X_sub_C _, _⟩\n      simp only [eval₂_sub, eval₂_C, eval₂_X]\n      rw [sub_eq_zero, ← φ'.comp_apply, is_localization.map_comp]\n      rfl\n  · obtain ⟨p, rfl⟩ := quotient.mk_surjective p'\n    refine'\n      polynomial.induction_on p (fun r => subring.subset_closure <| Set.mem_image_of_mem _ (or.inr degree_C_le))\n        (fun _ _ h1 h2 => _) fun n _ hr => _\n    · convert subring.add_mem _ h1 h2\n      rw [RingHom.map_add, RingHom.map_add]\n    · rw [pow_succ X n, mul_comm X, ← mul_assoc, RingHom.map_mul, RingHom.map_mul]\n      exact subring.mul_mem _ hr (subring.subset_closure (Set.mem_image_of_mem _ (or.inl rfl)))\n#align is_integral_is_localization_polynomial_quotient is_integral_is_localization_polynomial_quotient\n\n",
 "disjoint_powers_iff_not_mem":
 "theorem disjoint_powers_iff_not_mem (hI : I.is_radical) : Disjoint (submonoid.powers y : set R) ↑I ↔ y ∉ I.1 :=\n  by\n  refine' ⟨fun h => Set.disjoint_left.1 h (mem_powers _), fun h => disjoint_iff.mpr (eq_bot_iff.mpr _)⟩\n  rintro x ⟨⟨n, rfl⟩, hx'⟩\n  exact h (hI <| mem_radical_of_pow_mem <| le_radical hx')\n#align disjoint_powers_iff_not_mem disjoint_powers_iff_not_mem\n\n",
 "comp_C_integral_of_surjective_of_jacobson":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comp_C_integral_of_surjective_of_jacobson {R : Type _} [CommRing R] [is_jacobson R] {σ : Type _} [Finite σ]\n    {S : Type _} [Field S] (f : «expr →+* » (mv_polynomial σ R) S) (hf : function.surjective f) :\n    (f.comp C).is_integral := by\n  cases nonempty_fintype σ\n  have e := (fintype.equiv_fin σ).symm\n  let f' : «expr →+* » (mv_polynomial (fin _) R) S := f.comp (rename_equiv R e).to_ring_equiv.to_ring_hom\n  have hf' : function.surjective f' := function.surjective.comp hf (rename_equiv R e).surjective\n  have : (f'.comp C).is_integral :=\n    by\n    haveI : f'.ker.is_maximal := ker_is_maximal_of_surjective f' hf'\n    let g : «expr →+* » («expr ⧸ » (mv_polynomial _ R) f'.ker) S := ideal.quotient.lift f'.ker f' fun _ h => h\n    have hfg : g.comp (Quotient.mk'' f'.ker) = f' := ring_hom_ext (fun r => rfl) fun i => rfl\n    rw [← hfg, RingHom.comp_assoc]\n    refine'\n      ring_hom.is_integral_trans _ g (quotient_mk_comp_C_is_integral_of_jacobson f'.ker) (g.is_integral_of_surjective _)\n    rw [← hfg] at hf'\n    exact function.surjective.of_comp hf'\n  rw [RingHom.comp_assoc] at this\n  convert this\n  refine' RingHom.ext fun x => _\n  exact ((rename_equiv R e).commutes' x).symm\n#align comp_C_integral_of_surjective_of_jacobson comp_C_integral_of_surjective_of_jacobson\n\n"}