{"smul_repr_mk":
 "#print Basis.smul_repr_mk /-\ntheorem Basis.smul_repr_mk {ι : Type v₁} {ι' : Type w₁} (b : Basis ι R S) (c : Basis ι' S A) (x i j) :\n    (b.smul c).repr x (i, j) = b.repr (c.repr x j) i :=\n  b.smul_repr c x (i, j)\n#align basis.smul_repr_mk Basis.smul_repr_mk\n-/\n\n",
 "smul_repr":
 "#print Basis.smul_repr /-\n@[simp]\ntheorem Basis.smul_repr {ι : Type v₁} {ι' : Type w₁} (b : Basis ι R S) (c : Basis ι' S A) (x ij) :\n    (b.smul c).repr x ij = b.repr (c.repr x ij.2) ij.1 := by simp [Basis.smul]\n#align basis.smul_repr Basis.smul_repr\n-/\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.smul_apply /-\n@[simp]\ntheorem Basis.smul_apply {ι : Type v₁} {ι' : Type w₁} (b : Basis ι R S) (c : Basis ι' S A) (ij) :\n    (b.smul c) ij = «expr • » (b ij.1) (c ij.2) :=\n  by\n  obtain ⟨i, j⟩ := ij\n  rw [Basis.apply_eq_iff]\n  ext ⟨i', j'⟩\n  rw [Basis.smul_repr, LinearEquiv.map_smul, Basis.repr_self, Finsupp.smul_apply, Finsupp.single_apply]\n  dsimp only\n  split_ifs with hi\n  · simp [hi, Finsupp.single_apply]\n  · simp [hi]\n#align basis.smul_apply Basis.smul_apply\n-/\n\n",
 "linearIndependent_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print linearIndependent_smul /-\ntheorem linearIndependent_smul {ι : Type v₁} {b : ι → S} {ι' : Type w₁} {c : ι' → A} (hb : LinearIndependent R b)\n    (hc : LinearIndependent S c) : LinearIndependent R fun p : ι × ι' => «expr • » (b p.1) (c p.2) :=\n  by\n  rw [linearIndependent_iff'] at hb hc; rw [linearIndependent_iff'']; rintro s g hg hsg ⟨i, k⟩\n  by_cases hik : (i, k) ∈ s\n  · have h1 :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (finset.product (s.image Prod.fst) (s.image Prod.snd)) («expr • » (g i) («expr • » (b i.1) (c i.2))) =\n        0 :=\n      by\n      rw [← hsg]\n      exact\n        (Finset.sum_subset Finset.subset_product fun p _ hp =>\n            show «expr • » (g p) («expr • » (b p.1) (c p.2)) = 0 by rw [hg p hp, zero_smul]).symm\n    rw [Finset.sum_product_right] at h1\n    simp_rw [← smul_assoc, ← Finset.sum_smul] at h1\n    exact hb _ _ (hc _ _ h1 k (Finset.mem_image_of_mem _ hik)) i (Finset.mem_image_of_mem _ hik)\n  exact hg _ hik\n#align linear_independent_smul linearIndependent_smul\n-/\n\n",
 "coe_algebraMapCoeffs":
 "#print Basis.coe_algebraMapCoeffs /-\n@[simp]\ntheorem Basis.coe_algebraMapCoeffs : (b.algebra_map_coeffs A h : ι → M) = b :=\n  b.coe_map_coeffs _ _\n#align basis.coe_algebra_map_coeffs Basis.coe_algebraMapCoeffs\n-/\n\n",
 "algebraMap_injective":
 "#print Basis.algebraMap_injective /-\ntheorem Basis.algebraMap_injective {ι : Type _} [NoZeroDivisors R] [Nontrivial S] (b : Basis ι R S) :\n    function.injective (algebraMap R S) :=\n  have : NoZeroSMulDivisors R S := b.no_zero_smul_divisors\n  NoZeroSMulDivisors.algebraMap_injective R S\n#align basis.algebra_map_injective Basis.algebraMap_injective\n-/\n\n",
 "algebraMapCoeffs_apply":
 "#print Basis.algebraMapCoeffs_apply /-\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem Basis.algebraMapCoeffs_apply (i : ι) : b.algebra_map_coeffs A h i = b i :=\n  b.map_coeffs_apply _ _ _\n#align basis.algebra_map_coeffs_apply Basis.algebraMapCoeffs_apply\n-/\n\n"}