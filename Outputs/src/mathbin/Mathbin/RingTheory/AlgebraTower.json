{"smul_repr_mk":
 "theorem basis.smul_repr_mk {ι : Type v₁} {ι' : Type w₁} (b : basis ι R S) (c : basis ι' S A) (x i j) :\n    (b.smul c).repr x (i, j) = b.repr (c.repr x j) i :=\n  b.smul_repr c x (i, j)\n#align basis.smul_repr_mk basis.smul_repr_mk\n\n",
 "smul_repr":
 "@[simp]\ntheorem basis.smul_repr {ι : Type v₁} {ι' : Type w₁} (b : basis ι R S) (c : basis ι' S A) (x ij) :\n    (b.smul c).repr x ij = b.repr (c.repr x ij.2) ij.1 := by simp [basis.smul]\n#align basis.smul_repr basis.smul_repr\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem basis.smul_apply {ι : Type v₁} {ι' : Type w₁} (b : basis ι R S) (c : basis ι' S A) (ij) :\n    (b.smul c) ij = «expr • » (b ij.1) (c ij.2) :=\n  by\n  obtain ⟨i, j⟩ := ij\n  rw [basis.apply_eq_iff]\n  ext ⟨i', j'⟩\n  rw [basis.smul_repr, linear_equiv.map_smul, basis.repr_self, finsupp.smul_apply, finsupp.single_apply]\n  dsimp only\n  split_ifs with hi\n  · simp [hi, finsupp.single_apply]\n  · simp [hi]\n#align basis.smul_apply basis.smul_apply\n\n",
 "linear_independent_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem linear_independent_smul {ι : Type v₁} {b : ι → S} {ι' : Type w₁} {c : ι' → A} (hb : linear_independent R b)\n    (hc : linear_independent S c) : linear_independent R fun p : ι × ι' => «expr • » (b p.1) (c p.2) :=\n  by\n  rw [linear_independent_iff'] at hb hc; rw [linear_independent_iff'']; rintro s g hg hsg ⟨i, k⟩\n  by_cases hik : (i, k) ∈ s\n  · have h1 :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (finset.product (s.image prod.fst) (s.image prod.snd)) («expr • » (g i) («expr • » (b i.1) (c i.2))) =\n        0 :=\n      by\n      rw [← hsg]\n      exact\n        (finset.sum_subset finset.subset_product fun p _ hp =>\n            show «expr • » (g p) («expr • » (b p.1) (c p.2)) = 0 by rw [hg p hp, zero_smul]).symm\n    rw [finset.sum_product_right] at h1\n    simp_rw [← smul_assoc, ← finset.sum_smul] at h1\n    exact hb _ _ (hc _ _ h1 k (Finset.mem_image_of_mem _ hik)) i (Finset.mem_image_of_mem _ hik)\n  exact hg _ hik\n#align linear_independent_smul linear_independent_smul\n\n",
 "coe_algebra_map_coeffs":
 "@[simp]\ntheorem basis.coe_algebra_map_coeffs : (b.algebra_map_coeffs A h : ι → M) = b :=\n  b.coe_map_coeffs _ _\n#align basis.coe_algebra_map_coeffs basis.coe_algebra_map_coeffs\n\n",
 "algebra_map_injective":
 "theorem basis.algebra_map_injective {ι : Type _} [no_zero_divisors R] [nontrivial S] (b : basis ι R S) :\n    function.injective (algebra_map R S) :=\n  have : NoZeroSMulDivisors R S := b.no_zero_smul_divisors\n  no_zero_smul_divisors.algebra_map_injective R S\n#align basis.algebra_map_injective basis.algebra_map_injective\n\n",
 "algebra_map_coeffs_apply":
 "/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem basis.algebra_map_coeffs_apply (i : ι) : b.algebra_map_coeffs A h i = b i :=\n  b.map_coeffs_apply _ _ _\n#align basis.algebra_map_coeffs_apply basis.algebra_map_coeffs_apply\n\n"}