{"pow":
 "theorem transcendental.pow {r : A} (ht : transcendental R r) {n : ℕ} (hn : 0 < n) : transcendental R (r ^ n) :=\n  fun ht' => ht <| is_algebraic_of_pow hn ht'\n#align transcendental.pow transcendental.pow\n\n",
 "polynomial_smul_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem polynomial_smul_apply' [CommSemiring R'] [Semiring S'] [algebra R' S'] [SMul S' T'] (p : polynomial R')\n    (f : S' → T') (x : S') : («expr • » p f) x = «expr • » (aeval x p) (f x) :=\n  rfl\n#align polynomial_smul_apply' polynomial_smul_apply'\n\n",
 "polynomial_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem polynomial_smul_apply [Semiring R'] [SMul R' S'] (p : polynomial R') (f : R' → S') (x : R') :\n    («expr • » p f) x = «expr • » (eval x p) (f x) :=\n  rfl\n#align polynomial_smul_apply polynomial_smul_apply\n\n",
 "is_transcendental_of_subsingleton":
 "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem is_transcendental_of_subsingleton [subsingleton R] (x : A) : transcendental R x := fun ⟨p, h, _⟩ =>\n  h <| subsingleton.elim p 0\n#align is_transcendental_of_subsingleton is_transcendental_of_subsingleton\n\n",
 "is_integral_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A field extension is integral if it is finite. -/\ntheorem is_integral_of_finite [finite_dimensional K L] : algebra.is_integral K L := fun x =>\n  is_integral_of_submodule_noetherian («expr⊤») (is_noetherian.iff_fg.2 infer_instance) x algebra.mem_top\n#align is_integral_of_finite is_integral_of_finite\n\n",
 "is_field_of_algebraic":
 "/-- In an algebraic extension L/K, an intermediate subalgebra is a field. -/\ntheorem subalgebra.is_field_of_algebraic (hKL : algebra.is_algebraic K L) : IsField A :=\n  { show nontrivial A by infer_instance, subalgebra.to_comm_ring A with\n    mul_inv_cancel := fun a ha =>\n      ⟨⟨a⁻¹, A.inv_mem_of_algebraic (hKL a)⟩, subtype.ext (mul_inv_cancel (mt (subalgebra.coe_eq_zero _).mp ha))⟩ }\n#align subalgebra.is_field_of_algebraic subalgebra.is_field_of_algebraic\n\n",
 "is_algebraic_zero":
 "theorem is_algebraic_zero [nontrivial R] : is_algebraic R (0 : A) :=\n  ⟨_, X_ne_zero, aeval_X 0⟩\n#align is_algebraic_zero is_algebraic_zero\n\n",
 "is_algebraic_trans":
 "/-- If L is an algebraic field extension of K and A is an algebraic algebra over L,\nthen A is algebraic over K. -/\ntheorem is_algebraic_trans (L_alg : is_algebraic K L) (A_alg : is_algebraic L A) : is_algebraic K A :=\n  by\n  simp only [is_algebraic, is_algebraic_iff_is_integral] at L_alg A_alg⊢\n  exact is_integral_trans L_alg A_alg\n#align is_algebraic_trans is_algebraic_trans\n\n",
 "is_algebraic_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem is_algebraic_rat (R : Type u) {A : Type v} [DivisionRing A] [Field R] [algebra R A] (n : exprℚ) :\n    is_algebraic R (n : A) := by\n  rw [← map_ratCast (algebra_map R A)]\n  exact is_algebraic_algebra_map n\n#align is_algebraic_rat is_algebraic_rat\n\n",
 "is_algebraic_one":
 "theorem is_algebraic_one [nontrivial R] : is_algebraic R (1 : A) :=\n  by\n  rw [← _root_.map_one _]\n  exact is_algebraic_algebra_map 1\n#align is_algebraic_one is_algebraic_one\n\n",
 "is_algebraic_of_pow":
 "theorem is_algebraic_of_pow {r : A} {n : ℕ} (hn : 0 < n) (ht : is_algebraic R (r ^ n)) : is_algebraic R r :=\n  by\n  obtain ⟨p, p_nonzero, hp⟩ := ht\n  refine' ⟨polynomial.expand _ n p, _, _⟩\n  · rwa [polynomial.expand_ne_zero hn]\n  · rwa [polynomial.expand_aeval n p r]\n#align is_algebraic_of_pow is_algebraic_of_pow\n\n",
 "is_algebraic_of_mem_root_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_algebraic_of_mem_root_set {R : Type u} {A : Type v} [Field R] [Field A] [algebra R A] {p : polynomial R}\n    {x : A} (hx : x ∈ p.root_set A) : is_algebraic R x :=\n  ⟨p, ne_zero_of_mem_root_set hx, aeval_eq_zero_of_mem_root_set hx⟩\n#align is_algebraic_of_mem_root_set is_algebraic_of_mem_root_set\n\n",
 "is_algebraic_of_larger_base_of_injective":
 "/-- If A is an algebraic algebra over R, then A is algebraic over S when S is an extension of R,\n  and the map from `R` to `S` is injective. -/\ntheorem is_algebraic_of_larger_base_of_injective (hinj : function.injective (algebra_map R S))\n    (A_alg : is_algebraic R A) : is_algebraic S A := fun x => is_algebraic_of_larger_base_of_injective hinj (A_alg x)\n#align is_algebraic_of_larger_base_of_injective is_algebraic_of_larger_base_of_injective\n\n",
 "is_algebraic_of_larger_base":
 "/-- If A is an algebraic algebra over K, then A is algebraic over L when L is an extension of K -/\ntheorem is_algebraic_of_larger_base (A_alg : is_algebraic K A) : is_algebraic L A :=\n  is_algebraic_of_larger_base_of_injective (algebra_map K L).injective A_alg\n#align is_algebraic_of_larger_base is_algebraic_of_larger_base\n\n",
 "is_algebraic_of_finite":
 "/-- A field extension is algebraic if it is finite. -/\ntheorem is_algebraic_of_finite [finite : finite_dimensional K L] : is_algebraic K L :=\n  algebra.is_algebraic_iff_is_integral.mpr (is_integral_of_finite K L)\n#align is_algebraic_of_finite is_algebraic_of_finite\n\n",
 "is_algebraic_nat":
 "theorem is_algebraic_nat [nontrivial R] (n : ℕ) : is_algebraic R (n : A) :=\n  by\n  rw [← map_nat_cast _]\n  exact is_algebraic_algebra_map n\n#align is_algebraic_nat is_algebraic_nat\n\n",
 "is_algebraic_int":
 "theorem is_algebraic_int [nontrivial R] (n : ℤ) : is_algebraic R (n : A) :=\n  by\n  rw [← _root_.map_int_cast (algebra_map R A)]\n  exact is_algebraic_algebra_map n\n#align is_algebraic_int is_algebraic_int\n\n",
 "is_algebraic_iff_not_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_algebraic_iff_not_injective {x : A} :\n    is_algebraic R x ↔ ¬function.injective (polynomial.aeval x : «expr →ₐ[ ] » (polynomial R) R A) := by\n  simp only [is_algebraic, injective_iff_map_eq_zero, not_forall, and_comm, exists_prop]\n#align is_algebraic_iff_not_injective is_algebraic_iff_not_injective\n\n",
 "is_algebraic_iff_is_integral":
 "protected theorem algebra.is_algebraic_iff_is_integral : algebra.is_algebraic K A ↔ algebra.is_integral K A :=\n  ⟨fun h x => is_algebraic_iff_is_integral.mp (h x), fun h x => is_algebraic_iff_is_integral.mpr (h x)⟩\n#align algebra.is_algebraic_iff_is_integral algebra.is_algebraic_iff_is_integral\n\n",
 "is_algebraic_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem _root_.alg_equiv.is_algebraic_iff {B} [Ring B] [algebra R B] (e : «expr ≃ₐ[ ] » A R B) :\n    algebra.is_algebraic R A ↔ algebra.is_algebraic R B :=\n  ⟨e.is_algebraic, e.symm.is_algebraic⟩\n#align alg_equiv.is_algebraic_iff alg_equiv.is_algebraic_iff\n\n",
 "is_algebraic_algebra_map_of_is_algebraic":
 "theorem is_algebraic_algebra_map_of_is_algebraic {a : S} : is_algebraic R a → is_algebraic R (algebra_map S A a) :=\n  fun ⟨f, hf₁, hf₂⟩ => ⟨f, hf₁, by rw [aeval_algebra_map_apply, hf₂, map_zero]⟩\n#align is_algebraic_algebra_map_of_is_algebraic is_algebraic_algebra_map_of_is_algebraic\n\n",
 "is_algebraic_algebra_map_iff":
 "theorem is_algebraic_algebra_map_iff {a : S} (h : function.injective (algebra_map S A)) :\n    is_algebraic R (algebra_map S A a) ↔ is_algebraic R a :=\n  ⟨fun ⟨p, hp0, hp⟩ => ⟨p, hp0, h (by rwa [map_zero, ← aeval_algebra_map_apply])⟩,\n    is_algebraic_algebra_map_of_is_algebraic⟩\n#align is_algebraic_algebra_map_iff is_algebraic_algebra_map_iff\n\n",
 "is_algebraic_algebra_map":
 "/-- An element of `R` is algebraic, when viewed as an element of the `R`-algebra `A`. -/\ntheorem is_algebraic_algebra_map [nontrivial R] (x : R) : is_algebraic R (algebra_map R A x) :=\n  ⟨_, X_sub_C_ne_zero x, by rw [_root_.map_sub, aeval_X, aeval_C, sub_self]⟩\n#align is_algebraic_algebra_map is_algebraic_algebra_map\n\n",
 "is_algebraic_alg_hom_of_is_algebraic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- This is slightly more general than `is_algebraic_algebra_map_of_is_algebraic` in that it\n  allows noncommutative intermediate rings `A`. -/\ntheorem is_algebraic_alg_hom_of_is_algebraic {B} [Ring B] [algebra R B] (f : «expr →ₐ[ ] » A R B) {a : A}\n    (h : is_algebraic R a) : is_algebraic R (f a) :=\n  let ⟨p, hp, ha⟩ := h\n  ⟨p, hp, by rw [aeval_alg_hom, f.comp_apply, ha, map_zero]⟩\n#align is_algebraic_alg_hom_of_is_algebraic is_algebraic_alg_hom_of_is_algebraic\n\n",
 "is_algebraic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/-- Transfer `algebra.is_algebraic` across an `alg_equiv`. -/\ntheorem _root_.alg_equiv.is_algebraic {B} [Ring B] [algebra R B] (e : «expr ≃ₐ[ ] » A R B)\n    (h : algebra.is_algebraic R A) : algebra.is_algebraic R B := fun b => by\n  convert ← is_algebraic_alg_hom_of_is_algebraic e.to_alg_hom (h _) <;> apply e.apply_symm_apply\n#align alg_equiv.is_algebraic alg_equiv.is_algebraic\n\n",
 "inv_mem_of_root_of_coeff_zero_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem subalgebra.inv_mem_of_root_of_coeff_zero_ne_zero {x : A} {p : polynomial K} (aeval_eq : aeval x p = 0)\n    (coeff_zero_ne : p.coeff 0 ≠ 0) : (x⁻¹ : L) ∈ A :=\n  by\n  suffices (x⁻¹ : L) = «expr • » (-p.coeff 0)⁻¹ (aeval x (div_X p))\n    by\n    rw [this]\n    exact A.smul_mem (aeval x _).2 _\n  have : aeval (x : L) p = 0 := by rw [subalgebra.aeval_coe, aeval_eq, subalgebra.coe_zero]\n  rw [inv_eq_of_root_of_coeff_zero_ne_zero this coeff_zero_ne, div_eq_inv_mul, algebra.smul_def, map_inv₀, map_neg,\n    inv_neg, neg_mul, subalgebra.aeval_coe]\n#align subalgebra.inv_mem_of_root_of_coeff_zero_ne_zero subalgebra.inv_mem_of_root_of_coeff_zero_ne_zero\n\n",
 "inv_mem_of_algebraic":
 "theorem subalgebra.inv_mem_of_algebraic {x : A} (hx : is_algebraic K (x : L)) : (x⁻¹ : L) ∈ A :=\n  by\n  obtain ⟨p, ne_zero, aeval_eq⟩ := hx\n  rw [subalgebra.aeval_coe, subalgebra.coe_eq_zero] at aeval_eq\n  revert ne_zero aeval_eq\n  refine' p.rec_on_horner _ _ _\n  · intro h\n    contradiction\n  · intro p a hp ha ih ne_zero aeval_eq\n    refine' A.inv_mem_of_root_of_coeff_zero_ne_zero aeval_eq _\n    rwa [coeff_add, hp, zero_add, coeff_C, if_pos rfl]\n  · intro p hp ih ne_zero aeval_eq\n    rw [alg_hom.map_mul, aeval_X, mul_eq_zero] at aeval_eq\n    cases' aeval_eq with aeval_eq x_eq\n    · exact ih hp aeval_eq\n    · rw [x_eq, subalgebra.coe_zero, inv_zero]\n      exact A.zero_mem\n#align subalgebra.inv_mem_of_algebraic subalgebra.inv_mem_of_algebraic\n\n",
 "inv_eq_of_root_of_coeff_zero_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem inv_eq_of_root_of_coeff_zero_ne_zero {x : L} {p : polynomial K} (aeval_eq : aeval x p = 0)\n    (coeff_zero_ne : p.coeff 0 ≠ 0) : x⁻¹ = -(aeval x (div_X p) / algebra_map _ _ (p.coeff 0)) :=\n  by\n  convert inv_eq_of_aeval_div_X_ne_zero (mt (fun h => (algebra_map K L).injective _) coeff_zero_ne)\n  · rw [aeval_eq, zero_sub, div_neg]\n  rw [RingHom.map_zero]\n  convert aeval_eq\n  conv_rhs => rw [← div_X_mul_X_add p]\n  rw [alg_hom.map_add, alg_hom.map_mul, h, zero_mul, zero_add, aeval_C]\n#align inv_eq_of_root_of_coeff_zero_ne_zero inv_eq_of_root_of_coeff_zero_ne_zero\n\n",
 "inv_eq_of_aeval_div_X_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem inv_eq_of_aeval_div_X_ne_zero {x : L} {p : polynomial K} (aeval_ne : aeval x (div_X p) ≠ 0) :\n    x⁻¹ = aeval x (div_X p) / (aeval x p - algebra_map _ _ (p.coeff 0)) :=\n  by\n  rw [inv_eq_iff_inv_eq, inv_div, div_eq_iff, sub_eq_iff_eq_add, mul_comm]\n  conv_lhs => rw [← div_X_mul_X_add p]\n  rw [alg_hom.map_add, alg_hom.map_mul, aeval_X, aeval_C]\n  exact aeval_ne\n#align inv_eq_of_aeval_div_X_ne_zero inv_eq_of_aeval_div_X_ne_zero\n\n",
 "exists_smul_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (d «expr ≠ » (0 : R)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A fraction `(a : S) / (b : S)` can be reduced to `(c : S) / (d : R)`,\nif `S` is the integral closure of `R` in an algebraic extension `L` of `R`. -/\ntheorem is_integral_closure.exists_smul_eq_mul {L : Type _} [Field L] [algebra R S] [algebra S L] [algebra R L]\n    [IsScalarTower R S L] [is_integral_closure S R L] (h : algebra.is_algebraic R L)\n    (inj : function.injective (algebra_map R L)) (a : S) {b : S} (hb : b ≠ 0) :\n    ∃ (c : S)(d : _)(_ : d ≠ (0 : R)), «expr • » d a = b * c :=\n  by\n  obtain ⟨c, d, d_ne, hx⟩ :=\n    exists_integral_multiple (h (algebra_map _ L a / algebra_map _ L b)) ((injective_iff_map_eq_zero _).mp inj)\n  refine' ⟨is_integral_closure.mk' S (c : L) c.2, d, d_ne, is_integral_closure.algebra_map_injective S R L _⟩\n  simp only [algebra.smul_def, RingHom.map_mul, is_integral_closure.algebra_map_mk', ← hx, ←\n    is_scalar_tower.algebra_map_apply]\n  rw [← mul_assoc _ (_ / _), mul_div_cancel' (algebra_map S L a), mul_comm]\n  exact mt ((injective_iff_map_eq_zero _).mp (is_integral_closure.algebra_map_injective S R L) _) hb\n#align is_integral_closure.exists_smul_eq_mul is_integral_closure.exists_smul_eq_mul\n\n",
 "exists_integral_multiple":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y «expr ≠ » (0 : R)) -/\ntheorem exists_integral_multiple [algebra R S] {z : S} (hz : is_algebraic R z)\n    (inj : ∀ x, algebra_map R S x = 0 → x = 0) :\n    ∃ (x : integral_closure R S)(y : _)(_ : y ≠ (0 : R)), z * algebra_map R S y = x :=\n  by\n  rcases hz with ⟨p, p_ne_zero, px⟩\n  set a := p.leading_coeff with a_def\n  have a_ne_zero : a ≠ 0 := mt polynomial.leading_coeff_eq_zero.mp p_ne_zero\n  have y_integral : is_integral R (algebra_map R S a) := is_integral_algebra_map\n  have x_integral : is_integral R (z * algebra_map R S a) :=\n    ⟨p.integral_normalization, monic_integral_normalization p_ne_zero, integral_normalization_aeval_eq_zero px inj⟩\n  exact ⟨⟨_, x_integral⟩, a, a_ne_zero, rfl⟩\n#align exists_integral_multiple exists_integral_multiple\n\n",
 "bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem _root_.alg_hom.bijective [finite_dimensional K L] (ϕ : «expr →ₐ[ ] » L K L) : function.bijective ϕ :=\n  (algebra.is_algebraic_of_finite K L).alg_hom_bijective ϕ\n#align alg_hom.bijective alg_hom.bijective\n\n",
 "algebra_map_pi_self_eq_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem polynomial.algebra_map_pi_self_eq_eval :\n    (algebra_map (polynomial R') (R' → R') : polynomial R' → R' → R') = fun p z => eval z p :=\n  rfl\n#align polynomial.algebra_map_pi_self_eq_eval polynomial.algebra_map_pi_self_eq_eval\n\n",
 "algebra_map_pi_eq_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem polynomial.algebra_map_pi_eq_aeval :\n    (algebra_map (polynomial R') (S' → T') : polynomial R' → S' → T') = fun p z => algebra_map _ _ (aeval z p) :=\n  rfl\n#align polynomial.algebra_map_pi_eq_aeval polynomial.algebra_map_pi_eq_aeval\n\n",
 "alg_hom_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem is_algebraic.alg_hom_bijective (ha : algebra.is_algebraic K L) (f : «expr →ₐ[ ] » L K L) :\n    function.bijective f := by\n  refine' ⟨f.to_ring_hom.injective, fun b => _⟩\n  obtain ⟨p, hp, he⟩ := ha b\n  let f' : p.root_set L → p.root_set L := (root_set_maps_to' id f).restrict f _ _\n  have : function.surjective f' :=\n    finite.injective_iff_surjective.1 fun _ _ h => subtype.eq <| f.to_ring_hom.injective <| subtype.ext_iff.1 h\n  obtain ⟨a, ha⟩ := this ⟨b, mem_root_set.2 ⟨hp, he⟩⟩\n  exact ⟨a, subtype.ext_iff.1 ha⟩\n#align is_algebraic.alg_hom_bijective is_algebraic.alg_hom_bijective\n\n"}