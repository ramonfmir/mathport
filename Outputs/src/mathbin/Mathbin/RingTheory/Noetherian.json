{"well_founded_submodule_gt":
 "theorem well_founded_submodule_gt (R M) [Semiring R] [add_comm_monoid M] [Module R M] :\n    ∀ [is_noetherian R M], well_founded ((· > ·) : submodule R M → submodule R M → Prop) :=\n  is_noetherian_iff_well_founded.mp\n#align well_founded_submodule_gt well_founded_submodule_gt\n\n",
 "set_has_maximal_iff_noetherian":
 "/-- A module is Noetherian iff every nonempty set of submodules has a maximal submodule among them.\n-/\ntheorem set_has_maximal_iff_noetherian :\n    (∀ a : set <| submodule R M, a.nonempty → ∃ M' ∈ a, ∀ I ∈ a, M' ≤ I → I = M') ↔ is_noetherian R M := by\n  rw [is_noetherian_iff_well_founded, WellFounded.wellFounded_iff_has_max']\n#align set_has_maximal_iff_noetherian set_has_maximal_iff_noetherian\n\n",
 "of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- see Note [lower instance priority]\ntheorem finite.of_injective [is_noetherian R N] (f : «expr →ₗ[ ] » M R N) (hf : function.injective f) : finite R M :=\n  ⟨fg_of_injective f hf⟩\n#align finite.of_injective finite.of_injective\n\n",
 "monotone_stabilizes_iff_noetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n/-- A module is Noetherian iff every increasing chain of submodules stabilizes. -/\ntheorem monotone_stabilizes_iff_noetherian :\n    (∀ f : «expr →o » ℕ (submodule R M), ∃ n, ∀ m, n ≤ m → f n = f m) ↔ is_noetherian R M := by\n  rw [is_noetherian_iff_well_founded, well_founded.monotone_chain_condition]\n#align monotone_stabilizes_iff_noetherian monotone_stabilizes_iff_noetherian\n\n",
 "is_noetherian_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_noetherian_top_iff : is_noetherian R («expr⊤» : submodule R M) ↔ is_noetherian R M :=\n  by\n  constructor <;> intro h\n  · exact is_noetherian_of_linear_equiv (linear_equiv.of_top («expr⊤» : submodule R M) rfl)\n  · exact is_noetherian_of_linear_equiv (linear_equiv.of_top («expr⊤» : submodule R M) rfl).symm\n#align is_noetherian_top_iff is_noetherian_top_iff\n\n",
 "is_noetherian_submodule_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_noetherian_submodule_right {N : submodule R M} :\n    is_noetherian R N ↔ ∀ s : submodule R M, («expr ⊓ » s N).fg :=\n  is_noetherian_submodule.trans ⟨fun H s => H _ inf_le_right, fun H s hs => inf_of_le_left hs ▸ H _⟩\n#align is_noetherian_submodule_right is_noetherian_submodule_right\n\n",
 "is_noetherian_submodule_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_noetherian_submodule_left {N : submodule R M} :\n    is_noetherian R N ↔ ∀ s : submodule R M, («expr ⊓ » N s).fg :=\n  is_noetherian_submodule.trans ⟨fun H s => H _ inf_le_left, fun H s hs => inf_of_le_right hs ▸ H _⟩\n#align is_noetherian_submodule_left is_noetherian_submodule_left\n\n",
 "is_noetherian_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_noetherian_submodule {N : submodule R M} : is_noetherian R N ↔ ∀ s : submodule R M, s ≤ N → s.fg :=\n  by\n  refine'\n    ⟨fun ⟨hn⟩ => fun s hs =>\n      have : s ≤ N.subtype.range := N.range_subtype.symm ▸ hs\n      submodule.map_comap_eq_self this ▸ (hn _).map _,\n      fun h => ⟨fun s => _⟩⟩\n  have f := (submodule.equiv_map_of_injective N.subtype subtype.val_injective s).symm\n  have h₁ := h (s.map N.subtype) (submodule.map_subtype_le N s)\n  have h₂ : («expr⊤» : submodule R (s.map N.subtype)).map f = «expr⊤» := by simp\n  have h₃ := ((submodule.fg_top _).2 h₁).map (↑f : «expr →ₗ[ ] » _ R s)\n  exact (submodule.fg_top _).1 (h₂ ▸ h₃)\n#align is_noetherian_submodule is_noetherian_submodule\n\n",
 "is_noetherian_span_of_finite":
 "/-- In a module over a noetherian ring, the submodule generated by finitely many vectors is\nnoetherian. -/\ntheorem is_noetherian_span_of_finite (R) {M} [Ring R] [add_comm_group M] [Module R M] [is_noetherian_ring R] {A : set M}\n    (hA : A.finite) : is_noetherian R (submodule.span R A) :=\n  is_noetherian_of_fg_of_noetherian _ (submodule.fg_def.mpr ⟨A, hA, rfl⟩)\n#align is_noetherian_span_of_finite is_noetherian_span_of_finite\n\n",
 "is_noetherian_ring_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_noetherian_ring_of_surjective (R) [Ring R] (S) [Ring S] (f : «expr →+* » R S) (hf : function.surjective f)\n    [H : is_noetherian_ring R] : is_noetherian_ring S :=\n  by\n  rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at H⊢\n  exact OrderEmbedding.wellFounded (ideal.order_embedding_of_surjective f hf).dual H\n#align is_noetherian_ring_of_surjective is_noetherian_ring_of_surjective\n\n",
 "is_noetherian_ring_of_ring_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\ntheorem is_noetherian_ring_of_ring_equiv (R) [Ring R] {S} [Ring S] (f : «expr ≃+* » R S) [is_noetherian_ring R] :\n    is_noetherian_ring S :=\n  is_noetherian_ring_of_surjective R S f.to_ring_hom f.to_equiv.surjective\n#align is_noetherian_ring_of_ring_equiv is_noetherian_ring_of_ring_equiv\n\n",
 "is_noetherian_ring_iff_ideal_fg":
 "/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem is_noetherian_ring_iff_ideal_fg (R : Type _) [Semiring R] : is_noetherian_ring R ↔ ∀ I : ideal R, I.fg :=\n  is_noetherian_ring_iff.trans is_noetherian_def\n#align is_noetherian_ring_iff_ideal_fg is_noetherian_ring_iff_ideal_fg\n\n",
 "is_noetherian_ring_iff":
 "theorem is_noetherian_ring_iff {R} [Semiring R] : is_noetherian_ring R ↔ is_noetherian R R :=\n  iff.rfl\n#align is_noetherian_ring_iff is_noetherian_ring_iff\n\n",
 "is_noetherian_of_tower":
 "/-- If `M / S / R` is a scalar tower, and `M / R` is Noetherian, then `M / S` is\nalso noetherian. -/\ntheorem is_noetherian_of_tower (R) {S M} [Semiring R] [Semiring S] [add_comm_monoid M] [SMul R S] [Module S M]\n    [Module R M] [IsScalarTower R S M] (h : is_noetherian R M) : is_noetherian S M :=\n  by\n  rw [is_noetherian_iff_well_founded] at h⊢\n  refine' (submodule.restrict_scalars_embedding R S M).dual.well_founded h\n#align is_noetherian_of_tower is_noetherian_of_tower\n\n",
 "is_noetherian_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_noetherian_of_surjective (f : «expr →ₗ[ ] » M R P) (hf : f.range = «expr⊤») [is_noetherian R M] :\n    is_noetherian R P :=\n  ⟨fun s =>\n    have : (s.comap f).map f = s := submodule.map_comap_eq_self <| hf.symm ▸ le_top\n    this ▸ (noetherian _).map _⟩\n#align is_noetherian_of_surjective is_noetherian_of_surjective\n\n",
 "is_noetherian_of_submodule_of_noetherian":
 "-- see Note [lower instance priority]\n-- see Note [lower instance priority]\ntheorem is_noetherian_of_submodule_of_noetherian (R M) [Semiring R] [add_comm_monoid M] [Module R M] (N : submodule R M)\n    (h : is_noetherian R M) : is_noetherian R N :=\n  by\n  rw [is_noetherian_iff_well_founded] at h⊢\n  exact OrderEmbedding.wellFounded (submodule.map_subtype.order_embedding N).dual h\n#align is_noetherian_of_submodule_of_noetherian is_noetherian_of_submodule_of_noetherian\n\n",
 "is_noetherian_of_range_eq_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If the first and final modules in a short exact sequence are noetherian,\n  then the middle module is also noetherian. -/\ntheorem is_noetherian_of_range_eq_ker [is_noetherian R M] [is_noetherian R P] (f : «expr →ₗ[ ] » M R N)\n    (g : «expr →ₗ[ ] » N R P) (hf : function.injective f) (hg : function.surjective g) (h : f.range = g.ker) :\n    is_noetherian R N :=\n  is_noetherian_iff_well_founded.2 <|\n    wellFounded_gt_exact_sequence (well_founded_submodule_gt R M) (well_founded_submodule_gt R P) f.range\n      (submodule.map f) (submodule.comap f) (submodule.comap g) (submodule.map g) (submodule.gci_map_comap hf)\n      (submodule.gi_map_comap hg) (by simp [submodule.map_comap_eq, inf_comm]) (by simp [submodule.comap_map_eq, h])\n#align is_noetherian_of_range_eq_ker is_noetherian_of_range_eq_ker\n\n",
 "is_noetherian_of_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem is_noetherian_of_linear_equiv (f : «expr ≃ₗ[ ] » M R P) [is_noetherian R M] : is_noetherian R P :=\n  is_noetherian_of_surjective _ f.to_linear_map f.range\n#align is_noetherian_of_linear_equiv is_noetherian_of_linear_equiv\n\n",
 "is_noetherian_of_le":
 "theorem is_noetherian_of_le {s t : submodule R M} [ht : is_noetherian R t] (h : s ≤ t) : is_noetherian R s :=\n  is_noetherian_submodule.mpr fun s' hs' => is_noetherian_submodule.mp ht _ (le_trans hs' h)\n#align is_noetherian_of_le is_noetherian_of_le\n\n",
 "is_noetherian_of_ker_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_noetherian_of_ker_bot [is_noetherian R P] (f : «expr →ₗ[ ] » M R P) (hf : f.ker = «expr⊥») :\n    is_noetherian R M :=\n  is_noetherian_of_linear_equiv (linear_equiv.of_injective f <| linear_map.ker_eq_bot.mp hf).symm\n#align is_noetherian_of_ker_bot is_noetherian_of_ker_bot\n\n",
 "is_noetherian_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_noetherian_of_injective [is_noetherian R P] (f : «expr →ₗ[ ] » M R P) (hf : function.injective f) :\n    is_noetherian R M :=\n  is_noetherian_of_linear_equiv (linear_equiv.of_injective f hf).symm\n#align is_noetherian_of_injective is_noetherian_of_injective\n\n",
 "is_noetherian_of_fg_of_noetherian'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_noetherian_of_fg_of_noetherian' {R M} [Ring R] [add_comm_group M] [Module R M] [is_noetherian_ring R]\n    (h : («expr⊤» : submodule R M).fg) : is_noetherian R M :=\n  have : is_noetherian R («expr⊤» : submodule R M) := is_noetherian_of_fg_of_noetherian _ h\n  is_noetherian_of_linear_equiv (linear_equiv.of_top («expr⊤» : submodule R M) rfl)\n#align is_noetherian_of_fg_of_noetherian' is_noetherian_of_fg_of_noetherian'\n\n",
 "is_noetherian_of_fg_of_noetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_noetherian_of_fg_of_noetherian {R M} [Ring R] [add_comm_group M] [Module R M] (N : submodule R M)\n    [is_noetherian_ring R] (hN : N.fg) : is_noetherian R N :=\n  by\n  let ⟨s, hs⟩ := hN\n  haveI := classical.dec_eq M\n  haveI := classical.dec_eq R\n  letI : is_noetherian R R := by infer_instance\n  have : ∀ x ∈ s, x ∈ N := fun x hx => hs ▸ submodule.subset_span hx\n  refine' @is_noetherian_of_surjective ((↑s : set M) → R) _ _ _ (Pi.module _ _ _) _ _ _ is_noetherian_pi\n  · fapply linear_map.mk\n    ·\n      exact fun f =>\n        ⟨finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n            («expr • » (f i) i.1),\n          N.sum_mem fun c _ => N.smul_mem _ <| this _ c.2⟩\n    · intro f g\n      apply subtype.eq\n      change\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n            («expr • » (f i + g i) _) =\n          _\n      simp only [add_smul, finset.sum_add_distrib]\n      rfl\n    · intro c f\n      apply subtype.eq\n      change\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n            («expr • » («expr • » c (f i)) _) =\n          _\n      simp only [smul_eq_mul, mul_smul]\n      exact finset.smul_sum.symm\n  rw [linear_map.range_eq_top]\n  rintro ⟨n, hn⟩\n  change n ∈ N at hn\n  rw [← hs, ← Set.image_id ↑s, finsupp.mem_span_image_iff_total] at hn\n  rcases hn with ⟨l, hl1, hl2⟩\n  refine' ⟨fun x => l x, subtype.ext _⟩\n  change\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n        («expr • » (l i) (i : M)) =\n      n\n  rw [@finset.sum_attach M M s _ fun i => «expr • » (l i) i, ← hl2, finsupp.total_apply, finsupp.sum, eq_comm]\n  refine' finset.sum_subset hl1 fun x _ hx => _\n  rw [finsupp.not_mem_support_iff.1 hx, zero_smul]\n#align is_noetherian_of_fg_of_noetherian is_noetherian_of_fg_of_noetherian\n\n",
 "is_noetherian_iff_well_founded":
 "theorem is_noetherian_iff_well_founded :\n    is_noetherian R M ↔ well_founded ((· > ·) : submodule R M → submodule R M → Prop) :=\n  by\n  rw [(complete_lattice.well_founded_characterisations <| submodule R M).out 0 3]\n  exact ⟨fun ⟨h⟩ => fun k => (fg_iff_compact k).mp (h k), fun h => ⟨fun k => (fg_iff_compact k).mpr (h k)⟩⟩\n#align is_noetherian_iff_well_founded is_noetherian_iff_well_founded\n\n",
 "is_noetherian_iff_fg_well_founded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem is_noetherian_iff_fg_well_founded :\n    is_noetherian R M ↔ well_founded ((· > ·) : { N : submodule R M // N.fg } → { N : submodule R M // N.fg } → Prop) :=\n  by\n  let α := { N : submodule R M // N.fg }\n  constructor\n  · intro H\n    let f : «expr ↪o » α (submodule R M) := OrderEmbedding.subtype _\n    exact OrderEmbedding.wellFounded f.dual (is_noetherian_iff_well_founded.mp H)\n  · intro H\n    constructor\n    intro N\n    obtain ⟨⟨N₀, h₁⟩, e : N₀ ≤ N, h₂⟩ :=\n      well_founded.well_founded_iff_has_max'.mp H { N' : α | N'.1 ≤ N } ⟨⟨«expr⊥», submodule.fg_bot⟩, bot_le⟩\n    convert h₁\n    refine' (e.antisymm _).symm\n    by_contra h₃\n    obtain ⟨x, hx₁ : x ∈ N, hx₂ : x ∉ N₀⟩ := set.not_subset.mp h₃\n    apply hx₂\n    have := h₂ ⟨«expr ⊔ » («expr ∙ » R x) N₀, _⟩ _ _\n    · injection this with eq\n      rw [← eq]\n      exact (le_sup_left : «expr ∙ » R x ≤ «expr ⊔ » («expr ∙ » R x) N₀) (submodule.mem_span_singleton_self _)\n    · exact submodule.fg.sup ⟨{x}, by rw [Finset.coe_singleton]⟩ h₁\n    · exact sup_le ((submodule.span_singleton_le_iff_mem _ _).mpr hx₁) e\n    · show N₀ ≤ «expr ⊔ » («expr ∙ » R x) N₀\n      exact le_sup_right\n#align is_noetherian_iff_fg_well_founded is_noetherian_iff_fg_well_founded\n\n",
 "is_noetherian_def":
 "/-\nCopyright (c) 2018 Mario Carneiro, Kevin Buzzard. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Kevin Buzzard\n-/\n/-- An R-module is Noetherian iff all its submodules are finitely-generated. -/\ntheorem is_noetherian_def : is_noetherian R M ↔ ∀ s : submodule R M, s.fg :=\n  ⟨fun h => h.noetherian, is_noetherian.mk⟩\n#align is_noetherian_def is_noetherian_def\n\n",
 "is_nilpotent_nilradical":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_noetherian_ring.is_nilpotent_nilradical (R : Type _) [CommRing R] [is_noetherian_ring R] :\n    is_nilpotent (nilradical R) :=\n  by\n  obtain ⟨n, hn⟩ := ideal.exists_radical_pow_le_of_fg («expr⊥» : ideal R) (is_noetherian.noetherian _)\n  exact ⟨n, eq_bot_iff.mpr hn⟩\n#align is_noetherian_ring.is_nilpotent_nilradical is_noetherian_ring.is_nilpotent_nilradical\n\n",
 "injective_of_surjective_endomorphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem is_noetherian.injective_of_surjective_endomorphism [is_noetherian R M] (f : «expr →ₗ[ ] » M R M)\n    (s : surjective f) : injective f :=\n  by\n  obtain ⟨n, ne, w⟩ := is_noetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot f\n  rw [linear_map.range_eq_top.mpr (linear_map.iterate_surjective s n), inf_top_eq, linear_map.ker_eq_bot] at w\n  exact linear_map.injective_of_iterate_injective ne w\n#align is_noetherian.injective_of_surjective_endomorphism is_noetherian.injective_of_surjective_endomorphism\n\n",
 "induction":
 "/-- If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. -/\ntheorem is_noetherian.induction [is_noetherian R M] {P : submodule R M → Prop} (hgt : ∀ I, (∀ J > I, P J) → P I)\n    (I : submodule R M) : P I :=\n  well_founded.recursion (well_founded_submodule_gt R M) I hgt\n#align is_noetherian.induction is_noetherian.induction\n\n",
 "finite_of_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem finite_of_linear_independent [nontrivial R] [is_noetherian R M] {s : set M}\n    (hs : linear_independent R (coe : s → M)) : s.finite :=\n  by\n  refine'\n    by_contradiction fun hf =>\n      (rel_embedding.well_founded_iff_no_descending_seq.1 (well_founded_submodule_gt R M)).elim' _\n  have f : «expr ↪ » ℕ s := set.infinite.nat_embedding s hf\n  have : ∀ n, «expr '' » (coe ∘ f) { m | m ≤ n } ⊆ s :=\n    by\n    rintro n x ⟨y, hy₁, rfl⟩\n    exact (f y).2\n  have : ∀ a b : ℕ, a ≤ b ↔ span R («expr '' » (coe ∘ f) { m | m ≤ a }) ≤ span R («expr '' » (coe ∘ f) { m | m ≤ b }) :=\n    by\n    intro a b\n    rw [span_le_span_iff hs (this a) (this b), Set.image_subset_image_iff (subtype.coe_injective.comp f.injective),\n      Set.subset_def]\n    exact ⟨fun hab x (hxa : x ≤ a) => le_trans hxa hab, fun hx => hx a (le_refl a)⟩\n  exact\n    ⟨⟨fun n => span R («expr '' » (coe ∘ f) { m | m ≤ n }), fun x y => by\n        simp (config := { contextual := true }) [le_antisymm_iff, (this _ _).symm]⟩,\n      by dsimp [GT.gt] <;> simp only [lt_iff_le_not_le, (this _ _).symm] <;> tauto⟩\n#align finite_of_linear_independent finite_of_linear_independent\n\n",
 "fg_of_ker_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem fg_of_ker_bot [is_noetherian R P] {N : submodule R M} (f : «expr →ₗ[ ] » M R P) (hf : f.ker = «expr⊥») : N.fg :=\n  @is_noetherian.noetherian _ _ _ (is_noetherian_of_ker_bot f hf) N\n#align fg_of_ker_bot fg_of_ker_bot\n\n",
 "fg_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem fg_of_injective [is_noetherian R P] {N : submodule R M} (f : «expr →ₗ[ ] » M R P) (hf : function.injective f) :\n    N.fg :=\n  @is_noetherian.noetherian _ _ _ (is_noetherian_of_injective f hf) N\n#align fg_of_injective fg_of_injective\n\n",
 "exists_endomorphism_iterate_ker_inf_range_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- For any endomorphism of a Noetherian module, there is some nontrivial iterate\nwith disjoint kernel and range.\n-/\ntheorem is_noetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot [I : is_noetherian R M]\n    (f : «expr →ₗ[ ] » M R M) : ∃ n : ℕ, n ≠ 0 ∧ «expr ⊓ » (f ^ n).ker (f ^ n).range = «expr⊥» :=\n  by\n  obtain ⟨n, w⟩ :=\n    monotone_stabilizes_iff_noetherian.mpr I (f.iterate_ker.comp ⟨fun n => n + 1, fun n m w => by linarith⟩)\n  specialize w (2 * n + 1) (by linarith only)\n  dsimp at w\n  refine' ⟨n + 1, nat.succ_ne_zero _, _⟩\n  rw [eq_bot_iff]\n  rintro - ⟨h, ⟨y, rfl⟩⟩\n  rw [mem_bot, ← linear_map.mem_ker, w]\n  erw [linear_map.mem_ker] at h⊢\n  change (f ^ (n + 1) * f ^ (n + 1)) y = 0 at h\n  rw [← pow_add] at h\n  convert h using 3\n  ring\n#align\n  is_noetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot is_noetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot\n\n",
 "disjoint_partial_sups_eventually_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A sequence `f` of submodules of a noetherian module,\nwith `f (n+1)` disjoint from the supremum of `f 0`, ..., `f n`,\nis eventually zero.\n-/\ntheorem is_noetherian.disjoint_partial_sups_eventually_bot [I : is_noetherian R M] (f : ℕ → submodule R M)\n    (h : ∀ n, Disjoint (partial_sups f n) (f (n + 1))) : ∃ n : ℕ, ∀ m, n ≤ m → f m = «expr⊥» :=\n  by\n  -- A little off-by-one cleanup first:\n  suffices t : ∃ n : ℕ, ∀ m, n ≤ m → f (m + 1) = «expr⊥»\n  · obtain ⟨n, w⟩ := t\n    use n + 1\n    rintro (_ | m) p\n    · cases p\n    · apply w\n      exact nat.succ_le_succ_iff.mp p\n  obtain ⟨n, w⟩ := monotone_stabilizes_iff_noetherian.mpr I (partial_sups f)\n  exact ⟨n, fun m p => (h m).eq_bot_of_ge <| sup_eq_left.1 <| (w (m + 1) <| le_add_right p).symm.trans <| w m p⟩\n#align is_noetherian.disjoint_partial_sups_eventually_bot is_noetherian.disjoint_partial_sups_eventually_bot\n\n",
 "bijective_of_surjective_endomorphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem is_noetherian.bijective_of_surjective_endomorphism [is_noetherian R M] (f : «expr →ₗ[ ] » M R M)\n    (s : surjective f) : bijective f :=\n  ⟨is_noetherian.injective_of_surjective_endomorphism f s, s⟩\n#align is_noetherian.bijective_of_surjective_endomorphism is_noetherian.bijective_of_surjective_endomorphism\n\n"}