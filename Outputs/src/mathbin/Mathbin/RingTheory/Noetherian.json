{"wellFounded_submodule_gt":
 "#print wellFounded_submodule_gt /-\ntheorem wellFounded_submodule_gt (R M) [Semiring R] [AddCommMonoid M] [Module R M] :\n    ∀ [IsNoetherian R M], well_founded ((· > ·) : Submodule R M → Submodule R M → Prop) :=\n  isNoetherian_iff_wellFounded.mp\n#align well_founded_submodule_gt wellFounded_submodule_gt\n-/\n\n",
 "set_has_maximal_iff_noetherian":
 "#print set_has_maximal_iff_noetherian /-\n/-- A module is Noetherian iff every nonempty set of submodules has a maximal submodule among them.\n-/\ntheorem set_has_maximal_iff_noetherian :\n    (∀ a : Set <| Submodule R M, a.nonempty → ∃ M' ∈ a, ∀ I ∈ a, ¬M' < I) ↔ IsNoetherian R M := by\n  rw [isNoetherian_iff_wellFounded, WellFounded.wellFounded_iff_has_min]\n#align set_has_maximal_iff_noetherian set_has_maximal_iff_noetherian\n-/\n\n",
 "of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Finite.of_injective /-\n-- see Note [lower instance priority]\ntheorem Finite.of_injective [IsNoetherian R N] (f : «expr →ₗ[ ] » M R N) (hf : function.injective f) : Finite R M :=\n  ⟨fg_of_injective f hf⟩\n#align finite.of_injective Finite.of_injective\n-/\n\n",
 "monotone_stabilizes_iff_noetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n#print monotone_stabilizes_iff_noetherian /-\n/-- A module is Noetherian iff every increasing chain of submodules stabilizes. -/\ntheorem monotone_stabilizes_iff_noetherian :\n    (∀ f : «expr →o » ℕ (Submodule R M), ∃ n, ∀ m, n ≤ m → f n = f m) ↔ IsNoetherian R M := by\n  rw [isNoetherian_iff_wellFounded, WellFounded.monotone_chain_condition]\n#align monotone_stabilizes_iff_noetherian monotone_stabilizes_iff_noetherian\n-/\n\n",
 "isNoetherian_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print isNoetherian_top_iff /-\ntheorem isNoetherian_top_iff : IsNoetherian R («expr⊤» : Submodule R M) ↔ IsNoetherian R M :=\n  by\n  constructor <;> intro h\n  · exact isNoetherian_of_linearEquiv (LinearEquiv.ofTop («expr⊤» : Submodule R M) rfl)\n  · exact isNoetherian_of_linearEquiv (LinearEquiv.ofTop («expr⊤» : Submodule R M) rfl).symm\n#align is_noetherian_top_iff isNoetherian_top_iff\n-/\n\n",
 "isNoetherian_submodule_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print isNoetherian_submodule_right /-\ntheorem isNoetherian_submodule_right {N : Submodule R M} : IsNoetherian R N ↔ ∀ s : Submodule R M, («expr ⊓ » s N).fg :=\n  isNoetherian_submodule.trans ⟨fun H s => H _ inf_le_right, fun H s hs => inf_of_le_left hs ▸ H _⟩\n#align is_noetherian_submodule_right isNoetherian_submodule_right\n-/\n\n",
 "isNoetherian_submodule_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print isNoetherian_submodule_left /-\ntheorem isNoetherian_submodule_left {N : Submodule R M} : IsNoetherian R N ↔ ∀ s : Submodule R M, («expr ⊓ » N s).fg :=\n  isNoetherian_submodule.trans ⟨fun H s => H _ inf_le_left, fun H s hs => inf_of_le_right hs ▸ H _⟩\n#align is_noetherian_submodule_left isNoetherian_submodule_left\n-/\n\n",
 "isNoetherian_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print isNoetherian_submodule /-\ntheorem isNoetherian_submodule {N : Submodule R M} : IsNoetherian R N ↔ ∀ s : Submodule R M, s ≤ N → s.fg :=\n  by\n  refine'\n    ⟨fun ⟨hn⟩ => fun s hs =>\n      have : s ≤ N.subtype.range := N.range_subtype.symm ▸ hs\n      Submodule.map_comap_eq_self this ▸ (hn _).map _,\n      fun h => ⟨fun s => _⟩⟩\n  have f := (Submodule.equivMapOfInjective N.subtype Subtype.val_injective s).symm\n  have h₁ := h (s.map N.subtype) (Submodule.map_subtype_le N s)\n  have h₂ : («expr⊤» : Submodule R (s.map N.subtype)).map f = «expr⊤» := by simp\n  have h₃ := ((Submodule.fg_top _).2 h₁).map (↑f : «expr →ₗ[ ] » _ R s)\n  exact (Submodule.fg_top _).1 (h₂ ▸ h₃)\n#align is_noetherian_submodule isNoetherian_submodule\n-/\n\n",
 "isNoetherian_span_of_finite":
 "#print isNoetherian_span_of_finite /-\n/-- In a module over a noetherian ring, the submodule generated by finitely many vectors is\nnoetherian. -/\ntheorem isNoetherian_span_of_finite (R) {M} [Ring R] [AddCommGroup M] [Module R M] [IsNoetherianRing R] {A : Set M}\n    (hA : A.finite) : IsNoetherian R (Submodule.span R A) :=\n  isNoetherian_of_fg_of_noetherian _ (Submodule.fg_def.mpr ⟨A, hA, rfl⟩)\n#align is_noetherian_span_of_finite isNoetherian_span_of_finite\n-/\n\n",
 "isNoetherian_of_tower":
 "#print isNoetherian_of_tower /-\n/-- If `M / S / R` is a scalar tower, and `M / R` is Noetherian, then `M / S` is\nalso noetherian. -/\ntheorem isNoetherian_of_tower (R) {S M} [Semiring R] [Semiring S] [AddCommMonoid M] [SMul R S] [Module S M] [Module R M]\n    [IsScalarTower R S M] (h : IsNoetherian R M) : IsNoetherian S M :=\n  by\n  rw [isNoetherian_iff_wellFounded] at h⊢\n  refine' (Submodule.restrictScalarsEmbedding R S M).dual.well_founded h\n#align is_noetherian_of_tower isNoetherian_of_tower\n-/\n\n",
 "isNoetherian_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print isNoetherian_of_surjective /-\ntheorem isNoetherian_of_surjective (f : «expr →ₗ[ ] » M R P) (hf : f.range = «expr⊤») [IsNoetherian R M] :\n    IsNoetherian R P :=\n  ⟨fun s =>\n    have : (s.comap f).map f = s := Submodule.map_comap_eq_self <| hf.symm ▸ le_top\n    this ▸ (noetherian _).map _⟩\n#align is_noetherian_of_surjective isNoetherian_of_surjective\n-/\n\n",
 "isNoetherian_of_submodule_of_noetherian":
 "#print isNoetherian_of_submodule_of_noetherian /-\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\ntheorem isNoetherian_of_submodule_of_noetherian (R M) [Semiring R] [AddCommMonoid M] [Module R M] (N : Submodule R M)\n    (h : IsNoetherian R M) : IsNoetherian R N :=\n  by\n  rw [isNoetherian_iff_wellFounded] at h⊢\n  exact OrderEmbedding.wellFounded (Submodule.MapSubtype.orderEmbedding N).dual h\n#align is_noetherian_of_submodule_of_noetherian isNoetherian_of_submodule_of_noetherian\n-/\n\n",
 "isNoetherian_of_range_eq_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print isNoetherian_of_range_eq_ker /-\n/-- If the first and final modules in a short exact sequence are noetherian,\n  then the middle module is also noetherian. -/\ntheorem isNoetherian_of_range_eq_ker [IsNoetherian R M] [IsNoetherian R P] (f : «expr →ₗ[ ] » M R N)\n    (g : «expr →ₗ[ ] » N R P) (hf : function.injective f) (hg : function.surjective g) (h : f.range = g.ker) :\n    IsNoetherian R N :=\n  isNoetherian_iff_wellFounded.2 <|\n    wellFounded_gt_exact_sequence (wellFounded_submodule_gt R M) (wellFounded_submodule_gt R P) f.range\n      (Submodule.map f) (Submodule.comap f) (Submodule.comap g) (Submodule.map g) (Submodule.gciMapComap hf)\n      (Submodule.giMapComap hg) (by simp [Submodule.map_comap_eq, inf_comm]) (by simp [Submodule.comap_map_eq, h])\n#align is_noetherian_of_range_eq_ker isNoetherian_of_range_eq_ker\n-/\n\n",
 "isNoetherian_of_linearEquiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print isNoetherian_of_linearEquiv /-\ntheorem isNoetherian_of_linearEquiv (f : «expr ≃ₗ[ ] » M R P) [IsNoetherian R M] : IsNoetherian R P :=\n  isNoetherian_of_surjective _ f.to_linear_map f.range\n#align is_noetherian_of_linear_equiv isNoetherian_of_linearEquiv\n-/\n\n",
 "isNoetherian_of_le":
 "#print isNoetherian_of_le /-\ntheorem isNoetherian_of_le {s t : Submodule R M} [ht : IsNoetherian R t] (h : s ≤ t) : IsNoetherian R s :=\n  isNoetherian_submodule.mpr fun s' hs' => isNoetherian_submodule.mp ht _ (le_trans hs' h)\n#align is_noetherian_of_le isNoetherian_of_le\n-/\n\n",
 "isNoetherian_of_ker_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isNoetherian_of_ker_bot /-\ntheorem isNoetherian_of_ker_bot [IsNoetherian R P] (f : «expr →ₗ[ ] » M R P) (hf : f.ker = «expr⊥») :\n    IsNoetherian R M :=\n  isNoetherian_of_linearEquiv (LinearEquiv.ofInjective f <| LinearMap.ker_eq_bot.mp hf).symm\n#align is_noetherian_of_ker_bot isNoetherian_of_ker_bot\n-/\n\n",
 "isNoetherian_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print isNoetherian_of_injective /-\ntheorem isNoetherian_of_injective [IsNoetherian R P] (f : «expr →ₗ[ ] » M R P) (hf : function.injective f) :\n    IsNoetherian R M :=\n  isNoetherian_of_linearEquiv (LinearEquiv.ofInjective f hf).symm\n#align is_noetherian_of_injective isNoetherian_of_injective\n-/\n\n",
 "isNoetherian_of_fg_of_noetherian'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print isNoetherian_of_fg_of_noetherian' /-\ntheorem isNoetherian_of_fg_of_noetherian' {R M} [Ring R] [AddCommGroup M] [Module R M] [IsNoetherianRing R]\n    (h : («expr⊤» : Submodule R M).fg) : IsNoetherian R M :=\n  have : IsNoetherian R («expr⊤» : Submodule R M) := isNoetherian_of_fg_of_noetherian _ h\n  isNoetherian_of_linearEquiv (LinearEquiv.ofTop («expr⊤» : Submodule R M) rfl)\n#align is_noetherian_of_fg_of_noetherian' isNoetherian_of_fg_of_noetherian'\n-/\n\n",
 "isNoetherian_of_fg_of_noetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print isNoetherian_of_fg_of_noetherian /-\ntheorem isNoetherian_of_fg_of_noetherian {R M} [Ring R] [AddCommGroup M] [Module R M] (N : Submodule R M)\n    [IsNoetherianRing R] (hN : N.fg) : IsNoetherian R N :=\n  by\n  let ⟨s, hs⟩ := hN\n  haveI := Classical.decEq M\n  haveI := Classical.decEq R\n  letI : IsNoetherian R R := by infer_instance\n  have : ∀ x ∈ s, x ∈ N := fun x hx => hs ▸ Submodule.subset_span hx\n  refine' @isNoetherian_of_surjective ((↑s : Set M) → R) _ _ _ (Pi.module _ _ _) _ _ _ isNoetherian_pi\n  · fapply linear_map.mk\n    ·\n      exact fun f =>\n        ⟨finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n            («expr • » (f i) i.1),\n          N.sum_mem fun c _ => N.smul_mem _ <| this _ c.2⟩\n    · intro f g\n      apply Subtype.eq\n      change\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n            («expr • » (f i + g i) _) =\n          _\n      simp only [add_smul, Finset.sum_add_distrib]\n      rfl\n    · intro c f\n      apply Subtype.eq\n      change\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n            («expr • » («expr • » c (f i)) _) =\n          _\n      simp only [smul_eq_mul, mul_smul]\n      exact finset.smul_sum.symm\n  rw [LinearMap.range_eq_top]\n  rintro ⟨n, hn⟩\n  change n ∈ N at hn\n  rw [← hs, ← Set.image_id ↑s, Finsupp.mem_span_image_iff_total] at hn\n  rcases hn with ⟨l, hl1, hl2⟩\n  refine' ⟨fun x => l x, Subtype.ext _⟩\n  change\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n        («expr • » (l i) (i : M)) =\n      n\n  rw [@Finset.sum_attach M M s _ fun i => «expr • » (l i) i, ← hl2, Finsupp.total_apply, Finsupp.sum, eq_comm]\n  refine' Finset.sum_subset hl1 fun x _ hx => _\n  rw [Finsupp.not_mem_support_iff.1 hx, zero_smul]\n#align is_noetherian_of_fg_of_noetherian isNoetherian_of_fg_of_noetherian\n-/\n\n",
 "isNoetherian_iff_wellFounded":
 "#print isNoetherian_iff_wellFounded /-\ntheorem isNoetherian_iff_wellFounded :\n    IsNoetherian R M ↔ well_founded ((· > ·) : Submodule R M → Submodule R M → Prop) :=\n  by\n  rw [(CompleteLattice.wellFounded_characterisations <| Submodule R M).out 0 3]\n  exact ⟨fun ⟨h⟩ => fun k => (fg_iff_compact k).mp (h k), fun h => ⟨fun k => (fg_iff_compact k).mpr (h k)⟩⟩\n#align is_noetherian_iff_well_founded isNoetherian_iff_wellFounded\n-/\n\n",
 "isNoetherian_iff_fg_wellFounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n#print isNoetherian_iff_fg_wellFounded /-\ntheorem isNoetherian_iff_fg_wellFounded :\n    IsNoetherian R M ↔ well_founded ((· > ·) : { N : Submodule R M // N.fg } → { N : Submodule R M // N.fg } → Prop) :=\n  by\n  let α := { N : Submodule R M // N.fg }\n  constructor\n  · intro H\n    let f : «expr ↪o » α (Submodule R M) := OrderEmbedding.subtype _\n    exact OrderEmbedding.wellFounded f.dual (is_noetherian_iff_well_founded.mp H)\n  · intro H\n    constructor\n    intro N\n    obtain ⟨⟨N₀, h₁⟩, e : N₀ ≤ N, h₂⟩ :=\n      WellFounded.has_min H { N' : α | N'.1 ≤ N } ⟨⟨«expr⊥», Submodule.fg_bot⟩, bot_le⟩\n    convert h₁\n    refine' (e.antisymm _).symm\n    by_contra h₃\n    obtain ⟨x, hx₁ : x ∈ N, hx₂ : x ∉ N₀⟩ := set.not_subset.mp h₃\n    apply hx₂\n    have := eq_of_le_of_not_lt _ (h₂ ⟨«expr ⊔ » («expr ∙ » R x) N₀, _⟩ _)\n    · injection this with eq\n      rw [Eq]\n      exact (le_sup_left : «expr ∙ » R x ≤ «expr ⊔ » («expr ∙ » R x) N₀) (Submodule.mem_span_singleton_self _)\n    · exact Submodule.Fg.sup ⟨{x}, by rw [Finset.coe_singleton]⟩ h₁\n    · show N₀ ≤ «expr ⊔ » («expr ∙ » R x) N₀\n      exact le_sup_right\n    · exact sup_le ((Submodule.span_singleton_le_iff_mem _ _).mpr hx₁) e\n#align is_noetherian_iff_fg_well_founded isNoetherian_iff_fg_wellFounded\n-/\n\n",
 "isNoetherian_def":
 "#print isNoetherian_def /-\n/-\nCopyright (c) 2018 Mario Carneiro, Kevin Buzzard. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Kevin Buzzard\n-/\n/-- An R-module is Noetherian iff all its submodules are finitely-generated. -/\ntheorem isNoetherian_def : IsNoetherian R M ↔ ∀ s : Submodule R M, s.fg :=\n  ⟨fun h => h.noetherian, is_noetherian.mk⟩\n#align is_noetherian_def isNoetherian_def\n-/\n\n",
 "isNoetherianRing_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print isNoetherianRing_of_surjective /-\ntheorem isNoetherianRing_of_surjective (R) [Ring R] (S) [Ring S] (f : «expr →+* » R S) (hf : function.surjective f)\n    [H : IsNoetherianRing R] : IsNoetherianRing S :=\n  by\n  rw [isNoetherianRing_iff, isNoetherian_iff_wellFounded] at H⊢\n  exact OrderEmbedding.wellFounded (Ideal.orderEmbeddingOfSurjective f hf).dual H\n#align is_noetherian_ring_of_surjective isNoetherianRing_of_surjective\n-/\n\n",
 "isNoetherianRing_of_ringEquiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n#print isNoetherianRing_of_ringEquiv /-\ntheorem isNoetherianRing_of_ringEquiv (R) [Ring R] {S} [Ring S] (f : «expr ≃+* » R S) [IsNoetherianRing R] :\n    IsNoetherianRing S :=\n  isNoetherianRing_of_surjective R S f.to_ring_hom f.to_equiv.surjective\n#align is_noetherian_ring_of_ring_equiv isNoetherianRing_of_ringEquiv\n-/\n\n",
 "isNoetherianRing_iff_ideal_fg":
 "#print isNoetherianRing_iff_ideal_fg /-\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem isNoetherianRing_iff_ideal_fg (R : Type _) [Semiring R] : IsNoetherianRing R ↔ ∀ I : Ideal R, I.fg :=\n  isNoetherianRing_iff.trans isNoetherian_def\n#align is_noetherian_ring_iff_ideal_fg isNoetherianRing_iff_ideal_fg\n-/\n\n",
 "isNoetherianRing_iff":
 "#print isNoetherianRing_iff /-\ntheorem isNoetherianRing_iff {R} [Semiring R] : IsNoetherianRing R ↔ IsNoetherian R R :=\n  iff.rfl\n#align is_noetherian_ring_iff isNoetherianRing_iff\n-/\n\n",
 "isNilpotent_nilradical":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print IsNoetherianRing.isNilpotent_nilradical /-\ntheorem IsNoetherianRing.isNilpotent_nilradical (R : Type _) [CommRing R] [IsNoetherianRing R] :\n    IsNilpotent (nilradical R) :=\n  by\n  obtain ⟨n, hn⟩ := Ideal.exists_radical_pow_le_of_fg («expr⊥» : Ideal R) (is_noetherian.noetherian _)\n  exact ⟨n, eq_bot_iff.mpr hn⟩\n#align is_noetherian_ring.is_nilpotent_nilradical IsNoetherianRing.isNilpotent_nilradical\n-/\n\n",
 "injective_of_surjective_endomorphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print IsNoetherian.injective_of_surjective_endomorphism /-\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem IsNoetherian.injective_of_surjective_endomorphism [IsNoetherian R M] (f : «expr →ₗ[ ] » M R M)\n    (s : surjective f) : injective f :=\n  by\n  obtain ⟨n, ne, w⟩ := IsNoetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot f\n  rw [linear_map.range_eq_top.mpr (LinearMap.iterate_surjective s n), inf_top_eq, LinearMap.ker_eq_bot] at w\n  exact LinearMap.injective_of_iterate_injective ne w\n#align is_noetherian.injective_of_surjective_endomorphism IsNoetherian.injective_of_surjective_endomorphism\n-/\n\n",
 "induction":
 "#print IsNoetherian.induction /-\n/-- If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. -/\ntheorem IsNoetherian.induction [IsNoetherian R M] {P : Submodule R M → Prop} (hgt : ∀ I, (∀ J > I, P J) → P I)\n    (I : Submodule R M) : P I :=\n  well_founded.recursion (wellFounded_submodule_gt R M) I hgt\n#align is_noetherian.induction IsNoetherian.induction\n-/\n\n",
 "finite_of_linearIndependent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print finite_of_linearIndependent /-\ntheorem finite_of_linearIndependent [Nontrivial R] [IsNoetherian R M] {s : Set M}\n    (hs : LinearIndependent R (coe : s → M)) : s.finite :=\n  by\n  refine'\n    by_contradiction fun hf => (RelEmbedding.wellFounded_iff_no_descending_seq.1 (wellFounded_submodule_gt R M)).elim' _\n  have f : «expr ↪ » ℕ s := Set.Infinite.natEmbedding s hf\n  have : ∀ n, «expr '' » (coe ∘ f) { m | m ≤ n } ⊆ s :=\n    by\n    rintro n x ⟨y, hy₁, rfl⟩\n    exact (f y).2\n  have : ∀ a b : ℕ, a ≤ b ↔ span R («expr '' » (coe ∘ f) { m | m ≤ a }) ≤ span R («expr '' » (coe ∘ f) { m | m ≤ b }) :=\n    by\n    intro a b\n    rw [span_le_span_iff hs (this a) (this b), Set.image_subset_image_iff (subtype.coe_injective.comp f.injective),\n      Set.subset_def]\n    exact ⟨fun hab x (hxa : x ≤ a) => le_trans hxa hab, fun hx => hx a (le_refl a)⟩\n  exact\n    ⟨⟨fun n => span R («expr '' » (coe ∘ f) { m | m ≤ n }), fun x y => by\n        simp (config := { contextual := true }) [le_antisymm_iff, (this _ _).symm]⟩,\n      by dsimp [GT.gt] <;> simp only [lt_iff_le_not_le, (this _ _).symm] <;> tauto⟩\n#align finite_of_linear_independent finite_of_linearIndependent\n-/\n\n",
 "fg_of_ker_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print fg_of_ker_bot /-\ntheorem fg_of_ker_bot [IsNoetherian R P] {N : Submodule R M} (f : «expr →ₗ[ ] » M R P) (hf : f.ker = «expr⊥») : N.fg :=\n  @is_noetherian.noetherian _ _ _ (isNoetherian_of_ker_bot f hf) N\n#align fg_of_ker_bot fg_of_ker_bot\n-/\n\n",
 "fg_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print fg_of_injective /-\ntheorem fg_of_injective [IsNoetherian R P] {N : Submodule R M} (f : «expr →ₗ[ ] » M R P) (hf : function.injective f) :\n    N.fg :=\n  @is_noetherian.noetherian _ _ _ (isNoetherian_of_injective f hf) N\n#align fg_of_injective fg_of_injective\n-/\n\n",
 "exists_endomorphism_iterate_ker_inf_range_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print IsNoetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot /-\n/-- For any endomorphism of a Noetherian module, there is some nontrivial iterate\nwith disjoint kernel and range.\n-/\ntheorem IsNoetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot [I : IsNoetherian R M] (f : «expr →ₗ[ ] » M R M) :\n    ∃ n : ℕ, n ≠ 0 ∧ «expr ⊓ » (f ^ n).ker (f ^ n).range = «expr⊥» :=\n  by\n  obtain ⟨n, w⟩ :=\n    monotone_stabilizes_iff_noetherian.mpr I (f.iterate_ker.comp ⟨fun n => n + 1, fun n m w => by linarith⟩)\n  specialize w (2 * n + 1) (by linarith only)\n  dsimp at w\n  refine' ⟨n + 1, nat.succ_ne_zero _, _⟩\n  rw [eq_bot_iff]\n  rintro - ⟨h, ⟨y, rfl⟩⟩\n  rw [mem_bot, ← LinearMap.mem_ker, w]\n  erw [LinearMap.mem_ker] at h⊢\n  change (f ^ (n + 1) * f ^ (n + 1)) y = 0 at h\n  rw [← pow_add] at h\n  convert h using 3\n  ring\n#align is_noetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot IsNoetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot\n-/\n\n",
 "disjoint_partialSups_eventually_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print IsNoetherian.disjoint_partialSups_eventually_bot /-\n/-- A sequence `f` of submodules of a noetherian module,\nwith `f (n+1)` disjoint from the supremum of `f 0`, ..., `f n`,\nis eventually zero.\n-/\ntheorem IsNoetherian.disjoint_partialSups_eventually_bot [I : IsNoetherian R M] (f : ℕ → Submodule R M)\n    (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) : ∃ n : ℕ, ∀ m, n ≤ m → f m = «expr⊥» :=\n  by\n  -- A little off-by-one cleanup first:\n  suffices t : ∃ n : ℕ, ∀ m, n ≤ m → f (m + 1) = «expr⊥»\n  · obtain ⟨n, w⟩ := t\n    use n + 1\n    rintro (_ | m) p\n    · cases p\n    · apply w\n      exact nat.succ_le_succ_iff.mp p\n  obtain ⟨n, w⟩ := monotone_stabilizes_iff_noetherian.mpr I (partialSups f)\n  exact ⟨n, fun m p => (h m).eq_bot_of_ge <| sup_eq_left.1 <| (w (m + 1) <| le_add_right p).symm.trans <| w m p⟩\n#align is_noetherian.disjoint_partial_sups_eventually_bot IsNoetherian.disjoint_partialSups_eventually_bot\n-/\n\n",
 "bijective_of_surjective_endomorphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print IsNoetherian.bijective_of_surjective_endomorphism /-\n/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem IsNoetherian.bijective_of_surjective_endomorphism [IsNoetherian R M] (f : «expr →ₗ[ ] » M R M)\n    (s : surjective f) : bijective f :=\n  ⟨IsNoetherian.injective_of_surjective_endomorphism f s, s⟩\n#align is_noetherian.bijective_of_surjective_endomorphism IsNoetherian.bijective_of_surjective_endomorphism\n-/\n\n"}