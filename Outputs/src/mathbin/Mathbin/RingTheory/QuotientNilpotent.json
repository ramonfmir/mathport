{"isUnit_quotient_mk_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print IsNilpotent.isUnit_quotient_mk_iff /-\ntheorem IsNilpotent.isUnit_quotient_mk_iff {R : Type _} [CommRing R] {I : Ideal R} (hI : IsNilpotent I) {x : R} :\n    IsUnit (Ideal.Quotient.mk I x) ↔ IsUnit x :=\n  by\n  refine' ⟨_, fun h => h.map I.quotient.mk⟩\n  revert x\n  apply Ideal.IsNilpotent.induction_on I hI <;> clear hI I\n  swap\n  · introv e h₁ h₂ h₃\n    apply h₁\n    apply h₂\n    exact\n      h₃.map ((DoubleQuot.quotQuotEquivQuotSup I J).trans (Ideal.quotEquivOfEq (sup_eq_right.mpr e))).symm.to_ring_hom\n  · introv e H\n    skip\n    obtain ⟨y, hy⟩ := Ideal.Quotient.mk_surjective (↑H.unit⁻¹ : «expr ⧸ » S I)\n    have : Ideal.Quotient.mk I (x * y) = Ideal.Quotient.mk I 1 := by\n      rw [map_one, _root_.map_mul, hy, IsUnit.mul_val_inv]\n    rw [Ideal.Quotient.eq] at this\n    have : (x * y - 1) ^ 2 = 0 := by\n      rw [← Ideal.mem_bot, ← e]\n      exact Ideal.pow_mem_pow this _\n    have : x * (y * (2 - x * y)) = 1 := by\n      rw [eq_comm, ← sub_eq_zero, ← this]\n      ring\n    exact isUnit_of_mul_eq_one _ _ this\n#align is_nilpotent.is_unit_quotient_mk_iff IsNilpotent.isUnit_quotient_mk_iff\n-/\n\n",
 "isRadical_iff_quotient_reduced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print Ideal.isRadical_iff_quotient_reduced /-\n/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem Ideal.isRadical_iff_quotient_reduced {R : Type _} [CommRing R] (I : Ideal R) :\n    I.is_radical ↔ IsReduced («expr ⧸ » R I) :=\n  by\n  conv_lhs => rw [← @Ideal.mk_ker R _ I]\n  exact RingHom.ker_isRadical_iff_reduced_of_surjective (@Ideal.Quotient.mk_surjective R _ I)\n#align ideal.is_radical_iff_quotient_reduced Ideal.isRadical_iff_quotient_reduced\n-/\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Ideal.IsNilpotent.induction_on /-\n/-- Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n  `P I → P (J ⧸ I) → P J`, then `P` holds for all nilpotent ideals. -/\ntheorem Ideal.IsNilpotent.induction_on (hI : IsNilpotent I) {P : ∀ ⦃S : Type _⦄ [CommRing S], ∀ I : Ideal S, Prop}\n    (h₁ : ∀ ⦃S : Type _⦄ [CommRing S], ∀ I : Ideal S, I ^ 2 = «expr⊥» → P I)\n    (h₂ : ∀ ⦃S : Type _⦄ [CommRing S], ∀ I J : Ideal S, I ≤ J → P I → P (J.map (Ideal.Quotient.mk I)) → P J) : P I :=\n  by\n  obtain ⟨n, hI : I ^ n = «expr⊥»⟩ := hI\n  revert S\n  apply nat.strong_induction_on n\n  clear n\n  intro n H S _ I hI\n  by_cases hI' : I = «expr⊥»\n  · subst hI'\n    apply h₁\n    rw [← Ideal.zero_eq_bot, zero_pow]\n    exact zero_lt_two\n  cases n\n  · rw [pow_zero, Ideal.one_eq_top] at hI\n    haveI := subsingleton_of_bot_eq_top hI.symm\n    exact (hI' (subsingleton.elim _ _)).elim\n  cases n\n  · rw [pow_one] at hI\n    exact (hI' hI).elim\n  apply h₂ (I ^ 2) _ (Ideal.pow_le_self two_ne_zero)\n  · apply H n.succ _ (I ^ 2)\n    · rw [← pow_mul, eq_bot_iff, ← hI, nat.succ_eq_add_one, nat.succ_eq_add_one]\n      exact Ideal.pow_le_pow (by linarith)\n    · exact le_refl n.succ.succ\n  · apply h₁\n    rw [← Ideal.map_pow, Ideal.map_quotient_self]\n#align ideal.is_nilpotent.induction_on Ideal.IsNilpotent.induction_on\n-/\n\n"}