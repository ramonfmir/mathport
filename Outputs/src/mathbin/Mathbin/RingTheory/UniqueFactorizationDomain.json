{"zero_not_mem_normalized_factors":
 "theorem zero_not_mem_normalized_factors (x : α) : (0 : α) ∉ normalized_factors x := fun h =>\n  Prime.ne_zero (prime_of_normalized_factor _ h) rfl\n#align zero_not_mem_normalized_factors zero_not_mem_normalized_factors\n\n",
 "well_founded_associates":
 "theorem well_founded_associates : well_founded ((· < ·) : Associates α → Associates α → Prop) :=\n  subrelation.wf (fun x y => dvdNotUnit_of_lt) well_founded_dvd_not_unit\n#align well_founded_associates well_founded_associates\n\n",
 "unique_factorization_monoid_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\ntheorem mul_equiv.unique_factorization_monoid_iff (e : «expr ≃* » α β) :\n    unique_factorization_monoid α ↔ unique_factorization_monoid β :=\n  ⟨e.unique_factorization_monoid, e.symm.unique_factorization_monoid⟩\n#align mul_equiv.unique_factorization_monoid_iff mul_equiv.unique_factorization_monoid_iff\n\n",
 "unique_factorization_monoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\ntheorem mul_equiv.unique_factorization_monoid (e : «expr ≃* » α β) (hα : unique_factorization_monoid α) :\n    unique_factorization_monoid β :=\n  by\n  rw [unique_factorization_monoid.iff_exists_prime_factors] at hα⊢; intro a ha\n  obtain ⟨w, hp, u, h⟩ :=\n    hα (e.symm a) fun h =>\n      ha <| by\n        convert ← map_zero e\n        simp [← h]\n  exact\n    ⟨w.map e, fun b hb =>\n      let ⟨c, hc, he⟩ := Multiset.mem_map.1 hb\n      he ▸ e.prime_iff.1 (hp c hc),\n      Units.map e.to_monoid_hom u, by\n      erw [Multiset.prod_hom, ← e.map_mul, h]\n      simp⟩\n#align mul_equiv.unique_factorization_monoid mul_equiv.unique_factorization_monoid\n\n",
 "unique'":
 "theorem unique' {p q : Multiset (Associates α)} :\n    (∀ a ∈ p, Irreducible a) → (∀ a ∈ q, Irreducible a) → p.prod = q.prod → p = q :=\n  by\n  apply Multiset.induction_on_multiset_quot p\n  apply Multiset.induction_on_multiset_quot q\n  intro s t hs ht eq\n  refine' Multiset.map_mk_eq_map_mk_of_rel (unique_factorization_monoid.factors_unique _ _ _)\n  · exact fun a ha => (irreducible_mk _).1 <| hs _ <| Multiset.mem_map_of_mem _ ha\n  · exact fun a ha => (irreducible_mk _).1 <| ht _ <| Multiset.mem_map_of_mem _ ha\n  simpa [quot_mk_eq_mk, prod_mk, mk_eq_mk_iff_associated] using eq\n#align unique' unique'\n\n",
 "unique":
 "theorem factor_set.unique [nontrivial α] {p q : factor_set α} (h : p.prod = q.prod) : p = q :=\n  by\n  induction p using WithTop.recTopCoe <;> induction q using WithTop.recTopCoe\n  · rfl\n  · rw [eq_comm, ← factor_set.prod_eq_zero_iff, ← h, associates.prod_top]\n  · rw [← factor_set.prod_eq_zero_iff, h, associates.prod_top]\n  · congr 1\n    rw [← Multiset.map_eq_map subtype.coe_injective]\n    apply unique' _ _ h <;>\n      · intro a ha\n        obtain ⟨⟨a', irred⟩, -, rfl⟩ := multiset.mem_map.mp ha\n        rwa [subtype.coe_mk]\n#align factor_set.unique factor_set.unique\n\n",
 "ufm_of_gcd_of_wf_dvd_monoid":
 "-- see Note [default priority]\n/-- Can't be an instance because it would cause a loop `ufm → wf_dvd_monoid → ufm → ...`. -/\n@[reducible]\ntheorem ufm_of_gcd_of_wf_dvd_monoid [cancel_comm_monoid_with_zero α] [wf_dvd_monoid α] [GCDMonoid α] :\n    unique_factorization_monoid α :=\n  { ‹wf_dvd_monoid α› with irreducible_iff_prime := fun _ => GCDMonoid.irreducible_iff_prime }\n#align ufm_of_gcd_of_wf_dvd_monoid ufm_of_gcd_of_wf_dvd_monoid\n\n",
 "support_factorization":
 "/-- The support of `factorization n` is exactly the finset of normalized factors -/\n@[simp]\ntheorem support_factorization {n : α} : (factorization n).support = (normalized_factors n).to_finset := by\n  simp [factorization, multiset.to_finsupp_support]\n#align support_factorization support_factorization\n\n",
 "sup_mul_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem sup_mul_inf (a b : Associates α) : «expr ⊔ » a b * «expr ⊓ » a b = a * b :=\n  show («expr ⊔ » a.factors b.factors).prod * («expr ⊓ » a.factors b.factors).prod = a * b\n    by\n    nontriviality α\n    refine' eq_of_factors_eq_factors _\n    rw [← prod_add, prod_factors, factors_mul, factor_set.sup_add_inf_eq_add]\n#align sup_mul_inf sup_mul_inf\n\n",
 "sup_add_inf_eq_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem factor_set.sup_add_inf_eq_add [decidable_eq (Associates α)] :\n    ∀ a b : factor_set α, «expr ⊔ » a b + «expr ⊓ » a b = a + b\n  | none, b => show «expr ⊔ » («expr⊤») b + «expr ⊓ » («expr⊤») b = «expr⊤» + b by simp\n  | a, none => show «expr ⊔ » a («expr⊤») + «expr ⊓ » a («expr⊤») = a + «expr⊤» by simp\n  | some a, some b =>\n    show «expr ⊔ » (a : factor_set α) b + «expr ⊓ » a b = a + b\n      by\n      rw [← WithTop.coe_sup, ← WithTop.coe_inf, ← WithTop.coe_add, ← WithTop.coe_add, WithTop.coe_eq_coe]\n      exact Multiset.union_add_inter _ _\n#align factor_set.sup_add_inf_eq_add factor_set.sup_add_inf_eq_add\n\n",
 "reducible_not_mem_factor_set":
 "theorem reducible_not_mem_factor_set {p : Associates α} (hp : ¬Irreducible p) (s : factor_set α) : ¬p ∈ s :=\n  fun h : if hp : Irreducible p then bfactor_set_mem ⟨p, hp⟩ s else false => by rwa [dif_neg hp] at h\n#align reducible_not_mem_factor_set reducible_not_mem_factor_set\n\n",
 "quot_out":
 "theorem associates.quot_out {α : Type _} [comm_monoid α] (a : Associates α) : Associates.mk (quot.out a) = a := by\n  rw [← quot_mk_eq_mk, quot.out_eq]\n#align associates.quot_out associates.quot_out\n\n",
 "prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem prod_top : («expr⊤» : factor_set α).prod = 0 :=\n  rfl\n#align prod_top prod_top\n\n",
 "prod_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem prod_mono : ∀ {a b : factor_set α}, a ≤ b → a.prod ≤ b.prod\n  | none, b, h => by\n    have : b = «expr⊤» := top_unique h\n    rw [this, prod_top] <;> exact le_rfl\n  | a, none, h => show a.prod ≤ («expr⊤» : factor_set α).prod by simp <;> exact le_top\n  | some a, some b, h => prod_le_prod <| Multiset.map_le_map <| WithTop.coe_le_coe.1 <| h\n#align prod_mono prod_mono\n\n",
 "prod_le_prod_iff_le":
 "theorem prod_le_prod_iff_le [nontrivial α] {p q : Multiset (Associates α)} (hp : ∀ a ∈ p, Irreducible a)\n    (hq : ∀ a ∈ q, Irreducible a) : p.prod ≤ q.prod ↔ p ≤ q :=\n  iff.intro\n    (by\n      classical\n        rintro ⟨c, eqc⟩\n        refine' Multiset.le_iff_exists_add.2 ⟨factors c, unique' hq (fun x hx => _) _⟩\n        · obtain h | h := Multiset.mem_add.1 hx\n          · exact hp x h\n          · exact irreducible_of_factor _ h\n        · rw [eqc, Multiset.prod_add]\n          congr\n          refine' associated_iff_eq.mp (factors_prod fun hc => _).symm\n          refine' not_irreducible_zero (hq _ _)\n          rw [← prod_eq_zero_iff, eqc, hc, mul_zero])\n    prod_le_prod\n#align prod_le_prod_iff_le prod_le_prod_iff_le\n\n",
 "prod_le":
 "theorem prod_le [nontrivial α] {a b : factor_set α} : a.prod ≤ b.prod ↔ a ≤ b := by\n  classical exact\n      iff.intro\n        (fun h => by\n          have : a.prod.factors ≤ b.prod.factors := factors_mono h\n          rwa [prod_factors, prod_factors] at this)\n        prod_mono\n#align prod_le prod_le\n\n",
 "prod_factors":
 "theorem prod_factors [nontrivial α] (s : factor_set α) : s.prod.factors = s :=\n  factor_set.unique <| factors_prod _\n#align prod_factors prod_factors\n\n",
 "prod_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem factor_set.prod_eq_zero_iff [nontrivial α] (p : factor_set α) : p.prod = 0 ↔ p = «expr⊤» :=\n  by\n  induction p using WithTop.recTopCoe\n  · simp only [iff_self_iff, eq_self_iff_true, associates.prod_top]\n  simp only [prod_coe, WithTop.coe_ne_top, iff_false_iff, prod_eq_zero_iff, Multiset.mem_map]\n  rintro ⟨⟨a, ha⟩, -, eq⟩\n  rw [subtype.coe_mk] at eq\n  exact ha.ne_zero eq\n#align factor_set.prod_eq_zero_iff factor_set.prod_eq_zero_iff\n\n",
 "prod_coe":
 "@[simp]\ntheorem prod_coe {s : Multiset { a : Associates α // Irreducible a }} : (s : factor_set α).prod = (s.map coe).prod :=\n  rfl\n#align prod_coe prod_coe\n\n",
 "prod_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem prod_add : ∀ a b : factor_set α, (a + b).prod = a.prod * b.prod\n  | none, b => show («expr⊤» + b).prod = («expr⊤» : factor_set α).prod * b.prod by simp\n  | a, none => show (a + «expr⊤»).prod = a.prod * («expr⊤» : factor_set α).prod by simp\n  | some a, some b =>\n    show (↑a + ↑b : factor_set α).prod = (↑a : factor_set α).prod * (↑b : factor_set α).prod by\n      rw [← factor_set.coe_add, prod_coe, prod_coe, prod_coe, Multiset.map_add, Multiset.prod_add]\n#align prod_add prod_add\n\n",
 "prime_pow_dvd_iff_le":
 "theorem prime_pow_dvd_iff_le [nontrivial α] {m p : Associates α} (h₁ : m ≠ 0) (h₂ : Irreducible p) {k : ℕ} :\n    p ^ k ≤ m ↔ k ≤ count p m.factors :=\n  by\n  obtain ⟨a, nz, rfl⟩ := Associates.exists_non_zero_rep h₁\n  rw [factors_mk _ nz, ← WithTop.some_eq_coe, count_some, Multiset.le_count_iff_replicate_le, ← factors_le,\n    factors_prime_pow h₂, factors_mk _ nz]\n  exact WithTop.coe_le_coe\n#align prime_pow_dvd_iff_le prime_pow_dvd_iff_le\n\n",
 "prime_pow_coprime_prod_of_coprime_insert":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (q q' «expr ∈ » insert[has_insert.insert] p s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prime_pow_coprime_prod_of_coprime_insert [decidable_eq α] {s : Finset α} (i : α → ℕ) (p : α) (hps : p ∉ s)\n    (is_prime : ∀ q ∈ insert p s, Prime q)\n    (is_coprime : ∀ (q) (_ : q ∈ insert p s) (q') (_ : q' ∈ insert p s), q ∣ q' → q = q') :\n    ∀ q : α,\n      q ∣ p ^ i p →\n        q ∣\n            finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n              (p' ^ i p') →\n          is_unit q :=\n  by\n  have hp := is_prime _ (Finset.mem_insert_self _ _)\n  refine' fun _ => no_factors_of_no_prime_factors (pow_ne_zero _ hp.ne_zero) _\n  intro d hdp hdprod hd\n  apply hps\n  replace hdp := hd.dvd_of_dvd_pow hdp\n  obtain ⟨q, q_mem', hdq⟩ := hd.exists_mem_multiset_dvd hdprod\n  obtain ⟨q, q_mem, rfl⟩ := multiset.mem_map.mp q_mem'\n  replace hdq := hd.dvd_of_dvd_pow hdq\n  have : p ∣ q := dvd_trans (hd.irreducible.dvd_symm hp.irreducible hdp) hdq\n  convert q_mem\n  exact IsCoprime _ (Finset.mem_insert_self p s) _ (Finset.mem_insert_of_mem q_mem) this\n#align prime_pow_coprime_prod_of_coprime_insert prime_pow_coprime_prod_of_coprime_insert\n\n",
 "prime_of_normalized_factor":
 "theorem prime_of_normalized_factor {a : α} : ∀ x : α, x ∈ normalized_factors a → Prime x :=\n  by\n  rw [normalized_factors, factors]\n  split_ifs with ane0; · simp\n  intro x hx; rcases Multiset.mem_map.1 hx with ⟨y, ⟨hy, rfl⟩⟩\n  rw [(normalize_associated _).prime_iff]\n  exact (Classical.choose_spec (unique_factorization_monoid.exists_prime_factors a ane0)).1 y hy\n#align prime_of_normalized_factor prime_of_normalized_factor\n\n",
 "prime_of_factor":
 "theorem prime_of_factor {a : α} (x : α) (hx : x ∈ factors a) : Prime x :=\n  by\n  have ane0 := ne_zero_of_mem_factors hx\n  rw [factors, dif_neg ane0] at hx\n  exact (Classical.choose_spec (unique_factorization_monoid.exists_prime_factors a ane0)).1 x hx\n#align prime_of_factor prime_of_factor\n\n",
 "prime_factors_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem prime_factors_unique [cancel_comm_monoid_with_zero α] :\n    ∀ {f g : Multiset α},\n      (∀ x ∈ f, Prime x) → (∀ x ∈ g, Prime x) → «expr ~ᵤ » f.prod g.prod → Multiset.Rel Associated f g :=\n  haveI := classical.dec_eq α\n  fun f =>\n  Multiset.induction_on f\n    (fun g _ hg h =>\n      Multiset.rel_zero_left.2 <|\n        Multiset.eq_zero_of_forall_not_mem fun x hx =>\n          have : is_unit g.prod := by simpa [associated_one_iff_isUnit] using h.symm\n          (hg x hx).not_unit <| isUnit_iff_dvd_one.2 <| (Multiset.dvd_prod hx).trans (isUnit_iff_dvd_one.1 this))\n    fun p f ih g hf hg hfg =>\n    by\n    let ⟨b, hbg, hb⟩ :=\n      (exists_associated_mem_of_dvd_prod (hf p (by simp)) fun q hq => hg _ hq) <|\n        hfg.dvd_iff_dvd_right.1 (show p ∣ («expr ::ₘ » p f).prod by simp)\n    rw [← Multiset.cons_erase hbg]\n    exact\n      multiset.rel.cons hb\n        (ih (fun q hq => hf _ (by simp [hq])) (fun q (hq : q ∈ g.erase b) => hg q (Multiset.mem_of_mem_erase hq))\n          (Associated.of_mul_left (by rwa [← Multiset.prod_cons, ← Multiset.prod_cons, Multiset.cons_erase hbg]) hb\n            (hf p (by simp)).ne_zero))\n#align prime_factors_unique prime_factors_unique\n\n",
 "prime_factors_irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/-- If an irreducible has a prime factorization,\n  then it is an associate of one of its prime factors. -/\ntheorem prime_factors_irreducible [cancel_comm_monoid_with_zero α] {a : α} {f : Multiset α} (ha : Irreducible a)\n    (pfa : (∀ b ∈ f, Prime b) ∧ «expr ~ᵤ » f.prod a) : ∃ p, «expr ~ᵤ » a p ∧ f = {p} :=\n  by\n  haveI := classical.dec_eq α\n  refine'\n    Multiset.induction_on f (fun h => (ha.not_unit (associated_one_iff_isUnit.1 (Associated.symm h))).elim) _ pfa.2\n      pfa.1\n  rintro p s _ ⟨u, hu⟩ hs\n  use p\n  have hs0 : s = 0 := by\n    by_contra hs0\n    obtain ⟨q, hq⟩ := Multiset.exists_mem_of_ne_zero hs0\n    apply (hs q (by simp [hq])).2.1\n    refine' (ha.is_unit_or_is_unit (_ : _ = p * ↑u * (s.erase q).prod * _)).resolve_left _\n    · rw [mul_right_comm _ _ q, mul_assoc, ← Multiset.prod_cons, Multiset.cons_erase hq, ← hu, mul_comm, mul_comm p _,\n        mul_assoc]\n      simp\n    apply mt isUnit_of_mul_isUnit_left (mt isUnit_of_mul_isUnit_left _)\n    apply (hs p (Multiset.mem_cons_self _ _)).2.1\n  simp only [mul_one, Multiset.prod_cons, Multiset.prod_zero, hs0] at *\n  exact ⟨Associated.symm ⟨u, hu⟩, rfl⟩\n#align prime_factors_irreducible prime_factors_irreducible\n\n",
 "pow_right_injective":
 "theorem pow_right_injective {a : R} (ha0 : a ≠ 0) (ha1 : ¬is_unit a) : function.injective ((· ^ ·) a : ℕ → R) :=\n  by\n  letI := classical.dec_eq R\n  intro i j hij\n  letI : nontrivial R := ⟨⟨a, 0, ha0⟩⟩\n  letI : NormalizationMonoid R := unique_factorization_monoid.normalization_monoid\n  obtain ⟨p', hp', dvd'⟩ := wf_dvd_monoid.exists_irreducible_factor ha1 ha0\n  obtain ⟨p, mem, _⟩ := exists_mem_normalized_factors_of_dvd ha0 hp' dvd'\n  have := congr_arg (fun x => Multiset.count p (normalized_factors x)) hij\n  simp only [normalized_factors_pow, Multiset.count_nsmul] at this\n  exact mul_right_cancel₀ (multiset.count_ne_zero.mpr mem) this\n#align pow_right_injective pow_right_injective\n\n",
 "pow_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem pow_factors [nontrivial α] {a : Associates α} {k : ℕ} : (a ^ k).factors = «expr • » k a.factors :=\n  by\n  induction' k with n h\n  · rw [zero_nsmul, pow_zero]\n    exact factors_one\n  · rw [pow_succ, succ_nsmul, factors_mul, h]\n#align pow_factors pow_factors\n\n",
 "pow_eq_pow_iff":
 "theorem pow_eq_pow_iff {a : R} (ha0 : a ≠ 0) (ha1 : ¬is_unit a) {i j : ℕ} : a ^ i = a ^ j ↔ i = j :=\n  (pow_right_injective ha0 ha1).eq_iff\n#align pow_eq_pow_iff pow_eq_pow_iff\n\n",
 "of_wf_dvd_monoid_associates":
 "/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Jens Wagemaker, Aaron Anderson\n-/\n-- see Note [lower instance priority]\ntheorem of_wf_dvd_monoid_associates (h : wf_dvd_monoid (Associates α)) : wf_dvd_monoid α :=\n  ⟨by\n    haveI := h\n    refine' (Surjective.wellFounded_iff mk_surjective _).2 well_founded_dvd_not_unit\n    intros ; rw [mk_dvd_not_unit_mk_iff]⟩\n#align of_wf_dvd_monoid_associates of_wf_dvd_monoid_associates\n\n",
 "of_well_founded_associates":
 "theorem wf_dvd_monoid.of_well_founded_associates [cancel_comm_monoid_with_zero α]\n    (h : well_founded ((· < ·) : Associates α → Associates α → Prop)) : wf_dvd_monoid α :=\n  wf_dvd_monoid.of_wf_dvd_monoid_associates\n    ⟨by\n      convert h\n      ext\n      exact Associates.dvdNotUnit_iff_lt⟩\n#align wf_dvd_monoid.of_well_founded_associates wf_dvd_monoid.of_well_founded_associates\n\n",
 "of_exists_unique_irreducible_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem unique_factorization_monoid.of_exists_unique_irreducible_factors [cancel_comm_monoid_with_zero α]\n    (eif : ∀ a : α, a ≠ 0 → ∃ f : Multiset α, (∀ b ∈ f, Irreducible b) ∧ «expr ~ᵤ » f.prod a)\n    (uif :\n      ∀ f g : Multiset α,\n        (∀ x ∈ f, Irreducible x) → (∀ x ∈ g, Irreducible x) → «expr ~ᵤ » f.prod g.prod → Multiset.Rel Associated f g) :\n    unique_factorization_monoid α :=\n  unique_factorization_monoid.of_exists_prime_factors\n    (by\n      convert eif\n      simp_rw [irreducible_iff_prime_of_exists_unique_irreducible_factors eif uif])\n#align\n  unique_factorization_monoid.of_exists_unique_irreducible_factors unique_factorization_monoid.of_exists_unique_irreducible_factors\n\n",
 "of_exists_prime_factors":
 "theorem unique_factorization_monoid.of_exists_prime_factors : unique_factorization_monoid α :=\n  { wf_dvd_monoid.of_exists_prime_factors pf with\n    irreducible_iff_prime := fun _ => irreducible_iff_prime_of_exists_prime_factors pf }\n#align unique_factorization_monoid.of_exists_prime_factors unique_factorization_monoid.of_exists_prime_factors\n\n",
 "not_unit_iff_exists_factors_eq":
 "theorem not_unit_iff_exists_factors_eq (a : α) (hn0 : a ≠ 0) :\n    ¬is_unit a ↔ ∃ f : Multiset α, (∀ b ∈ f, Irreducible b) ∧ f.prod = a ∧ f ≠ ∅ :=\n  ⟨fun hnu => by\n    obtain ⟨f, hi, u, rfl⟩ := exists_factors a hn0\n    obtain ⟨b, h⟩ := Multiset.exists_mem_of_ne_zero fun h : f = 0 => hnu <| by simp [h]\n    classical\n      refine' ⟨(f.erase b).cons (b * u), fun a ha => _, _, Multiset.cons_ne_zero⟩\n      · obtain rfl | ha := Multiset.mem_cons.1 ha\n        exacts[Associated.irreducible ⟨u, rfl⟩ (hi b h), hi a (Multiset.mem_of_mem_erase ha)]\n      · rw [Multiset.prod_cons, mul_comm b, mul_assoc, Multiset.prod_erase h, mul_comm],\n    fun ⟨f, hi, he, hne⟩ =>\n    let ⟨b, h⟩ := Multiset.exists_mem_of_ne_zero hne\n    not_isUnit_of_not_isUnit_dvd (hi b h).not_unit <| he ▸ Multiset.dvd_prod h⟩\n#align not_unit_iff_exists_factors_eq not_unit_iff_exists_factors_eq\n\n",
 "normalized_factors_zero":
 "@[simp]\ntheorem normalized_factors_zero : normalized_factors (0 : α) = 0 := by simp [normalized_factors, factors]\n#align normalized_factors_zero normalized_factors_zero\n\n",
 "normalized_factors_prod_of_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem normalized_factors_prod_of_prime [nontrivial α] [unique («expr ˣ» α)] {m : Multiset α} (h : ∀ p ∈ m, Prime p) :\n    normalized_factors m.prod = m := by\n  simpa only [← Multiset.rel_eq, ← associated_eq_eq] using\n    prime_factors_unique prime_of_normalized_factor h (normalized_factors_prod (m.prod_ne_zero_of_prime h))\n#align normalized_factors_prod_of_prime normalized_factors_prod_of_prime\n\n",
 "normalized_factors_prod_eq":
 "theorem normalized_factors_prod_eq (s : Multiset α) (hs : ∀ a ∈ s, Irreducible a) :\n    normalized_factors s.prod = s.map normalize :=\n  by\n  induction' s using Multiset.induction with a s ih\n  · rw [Multiset.prod_zero, normalized_factors_one, Multiset.map_zero]\n  · have ia := hs a (Multiset.mem_cons_self a _)\n    have ib := fun b h => hs b (Multiset.mem_cons_of_mem h)\n    obtain rfl | ⟨b, hb⟩ := s.empty_or_exists_mem\n    · rw [Multiset.cons_zero, Multiset.prod_singleton, Multiset.map_singleton, normalized_factors_irreducible ia]\n    haveI := nontrivial_of_ne b 0 (ib b hb).ne_zero\n    rw [Multiset.prod_cons, Multiset.map_cons, normalized_factors_mul ia.ne_zero, normalized_factors_irreducible ia, ih]\n    exacts[rfl, ib, Multiset.prod_ne_zero fun h => (ib 0 h).ne_zero rfl]\n#align normalized_factors_prod_eq normalized_factors_prod_eq\n\n",
 "normalized_factors_prod":
 "theorem normalized_factors_prod {a : α} (ane0 : a ≠ 0) : Associated (normalized_factors a).prod a :=\n  by\n  rw [normalized_factors, factors, dif_neg ane0]\n  refine' Associated.trans _ (Classical.choose_spec (exists_prime_factors a ane0)).2\n  rw [← Associates.mk_eq_mk_iff_associated, ← associates.prod_mk, ← associates.prod_mk, Multiset.map_map]\n  congr 2\n  ext\n  rw [function.comp_apply, Associates.mk_normalize]\n#align normalized_factors_prod normalized_factors_prod\n\n",
 "normalized_factors_pow":
 "theorem _root_.irreducible.normalized_factors_pow {p : α} (hp : Irreducible p) (k : ℕ) :\n    normalized_factors (p ^ k) = multiset.replicate k (normalize p) := by\n  rw [normalized_factors_pow, normalized_factors_irreducible hp, Multiset.nsmul_singleton]\n#align irreducible.normalized_factors_pow irreducible.normalized_factors_pow\n\n",
 "normalized_factors_pos":
 "@[simp]\ntheorem normalized_factors_pos (x : α) (hx : x ≠ 0) : 0 < normalized_factors x ↔ ¬is_unit x :=\n  by\n  constructor\n  · intro h hx\n    obtain ⟨p, hp⟩ := Multiset.exists_mem_of_ne_zero h.ne'\n    exact (prime_of_normalized_factor _ hp).not_unit (isUnit_of_dvd_unit (dvd_of_mem_normalized_factors hp) hx)\n  · intro h\n    obtain ⟨p, hp⟩ := exists_mem_normalized_factors hx h\n    exact bot_lt_iff_ne_bot.mpr (mt multiset.eq_zero_iff_forall_not_mem.mp (not_forall.mpr ⟨p, not_not.mpr hp⟩))\n#align normalized_factors_pos normalized_factors_pos\n\n",
 "normalized_factors_one":
 "@[simp]\ntheorem normalized_factors_one : normalized_factors (1 : α) = 0 :=\n  by\n  nontriviality α using normalized_factors, factors\n  rw [← Multiset.rel_zero_right]\n  apply factors_unique irreducible_of_normalized_factor\n  · intro x hx\n    exfalso\n    apply Multiset.not_mem_zero x hx\n  · simp [normalized_factors_prod one_ne_zero]\n  infer_instance\n#align normalized_factors_one normalized_factors_one\n\n",
 "normalized_factors_of_irreducible_pow":
 "theorem normalized_factors_of_irreducible_pow {p : α} (hp : Irreducible p) (k : ℕ) :\n    normalized_factors (p ^ k) = multiset.replicate k (normalize p) := by\n  rw [normalized_factors_pow, normalized_factors_irreducible hp, Multiset.nsmul_singleton]\n#align normalized_factors_of_irreducible_pow normalized_factors_of_irreducible_pow\n\n",
 "normalized_factors_mul":
 "@[simp]\ntheorem normalized_factors_mul {x y : α} (hx : x ≠ 0) (hy : y ≠ 0) :\n    normalized_factors (x * y) = normalized_factors x + normalized_factors y :=\n  by\n  have h : (normalize : α → α) = Associates.out ∘ Associates.mk :=\n    by\n    ext\n    rw [function.comp_apply, Associates.out_mk]\n  rw [← Multiset.map_id' (normalized_factors (x * y)), ← Multiset.map_id' (normalized_factors x), ←\n    Multiset.map_id' (normalized_factors y), ← Multiset.map_congr rfl normalize_normalized_factor, ←\n    Multiset.map_congr rfl normalize_normalized_factor, ← Multiset.map_congr rfl normalize_normalized_factor, ←\n    Multiset.map_add, h, ← Multiset.map_map Associates.out, eq_comm, ← Multiset.map_map Associates.out]\n  refine' congr rfl _\n  apply Multiset.map_mk_eq_map_mk_of_rel\n  apply factors_unique\n  · intro x hx\n    rcases Multiset.mem_add.1 hx with (hx | hx) <;> exact irreducible_of_normalized_factor x hx\n  · exact irreducible_of_normalized_factor\n  · rw [Multiset.prod_add]\n    exact\n      ((normalized_factors_prod hx).mul_mul (normalized_factors_prod hy)).trans\n        (normalized_factors_prod (mul_ne_zero hx hy)).symm\n#align normalized_factors_mul normalized_factors_mul\n\n",
 "normalized_factors_irreducible":
 "theorem normalized_factors_irreducible {a : α} (ha : Irreducible a) : normalized_factors a = {normalize a} :=\n  by\n  obtain ⟨p, a_assoc, hp⟩ :=\n    prime_factors_irreducible ha ⟨prime_of_normalized_factor, normalized_factors_prod ha.ne_zero⟩\n  have p_mem : p ∈ normalized_factors a := by\n    rw [hp]\n    exact Multiset.mem_singleton_self _\n  convert hp\n  rwa [← normalize_normalized_factor p p_mem, normalize_eq_normalize_iff, dvd_dvd_iff_associated]\n#align normalized_factors_irreducible normalized_factors_irreducible\n\n",
 "normalized_factors_eq_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (p q «expr ∈ » normalized_factors[unique_factorization_monoid.normalized_factors] a) -/\ntheorem normalized_factors_eq_of_dvd (a : α) :\n    ∀ (p) (_ : p ∈ normalized_factors a) (q) (_ : q ∈ normalized_factors a), p ∣ q → p = q :=\n  by\n  intro p hp q hq hdvd\n  convert\n        normalize_eq_normalize hdvd\n          ((prime_of_normalized_factor _ hp).irreducible.dvd_symm (prime_of_normalized_factor _ hq).irreducible\n            hdvd) <;>\n      apply (normalize_normalized_factor _ _).symm <;>\n    assumption\n#align normalized_factors_eq_of_dvd normalized_factors_eq_of_dvd\n\n",
 "normalize_normalized_factor":
 "theorem normalize_normalized_factor {a : α} : ∀ x : α, x ∈ normalized_factors a → normalize x = x :=\n  by\n  rw [normalized_factors, factors]\n  split_ifs with h; · simp\n  intro x hx\n  obtain ⟨y, hy, rfl⟩ := Multiset.mem_map.1 hx\n  apply normalize_idem\n#align normalize_normalized_factor normalize_normalized_factor\n\n",
 "no_factors_of_no_prime_factors":
 "theorem no_factors_of_no_prime_factors {a b : R} (ha : a ≠ 0) (h : ∀ {d}, d ∣ a → d ∣ b → ¬Prime d) :\n    ∀ {d}, d ∣ a → d ∣ b → is_unit d := fun d =>\n  induction_on_prime d\n    (by\n      simp only [zero_dvd_iff]\n      intros\n      contradiction)\n    (fun x hx _ _ => hx) fun d q hp hq ih dvd_a dvd_b =>\n    absurd hq (h (dvd_of_mul_right_dvd dvd_a) (dvd_of_mul_right_dvd dvd_b))\n#align no_factors_of_no_prime_factors no_factors_of_no_prime_factors\n\n",
 "ne_zero_of_mem_factors":
 "theorem ne_zero_of_mem_factors {p a : α} (h : p ∈ factors a) : a ≠ 0 :=\n  by\n  intro ha\n  rw [factors, dif_pos ha] at h\n  exact Multiset.not_mem_zero _ h\n#align ne_zero_of_mem_factors ne_zero_of_mem_factors\n\n",
 "multiplicity_eq_count_normalized_factors":
 "/-- The multiplicity of an irreducible factor of a nonzero element is exactly the number of times\nthe normalized factor occurs in the `normalized_factors`.\n\nSee also `count_normalized_factors_eq` which expands the definition of `multiplicity`\nto produce a specification for `count (normalized_factors _) _`..\n-/\ntheorem multiplicity_eq_count_normalized_factors {a b : R} (ha : Irreducible a) (hb : b ≠ 0) :\n    multiplicity a b = (normalized_factors b).count (normalize a) :=\n  by\n  apply le_antisymm\n  · apply part_enat.le_of_lt_add_one\n    rw [← Nat.cast_one, ← Nat.cast_add, lt_iff_not_ge, ge_iff_le,\n      le_multiplicity_iff_replicate_le_normalized_factors ha hb, ← le_count_iff_replicate_le]\n    simp\n  rw [le_multiplicity_iff_replicate_le_normalized_factors ha hb, ← le_count_iff_replicate_le]\n#align multiplicity_eq_count_normalized_factors multiplicity_eq_count_normalized_factors\n\n",
 "multiplicative_prime_power":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (p q «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (p q «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If `f` maps `p ^ i` to `(f p) ^ i` for primes `p`, and `f`\nis multiplicative on coprime elements, then `f` is multiplicative on all products of primes. -/\n@[elab_as_elim]\ntheorem multiplicative_prime_power {f : α → β} (s : Finset α) (i j : α → ℕ) (is_prime : ∀ p ∈ s, Prime p)\n    (is_coprime : ∀ (p) (_ : p ∈ s) (q) (_ : q ∈ s), p ∣ q → p = q) (h1 : ∀ {x y}, is_unit y → f (x * y) = f x * f y)\n    (hpr : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i)\n    (hcp : ∀ {x y}, (∀ p, p ∣ x → p ∣ y → is_unit p) → f (x * y) = f x * f y) :\n    f\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (p ^ (i p + j p))) =\n      f\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (p ^ i p)) *\n        f\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (p ^ j p)) :=\n  by\n  letI := classical.dec_eq α\n  induction' s using Finset.induction_on with p s hps ih\n  · simpa using h1 isUnit_one\n  have hpr_p := is_prime _ (Finset.mem_insert_self _ _)\n  have hpr_s : ∀ p ∈ s, Prime p := fun p hp => is_prime _ (Finset.mem_insert_of_mem hp)\n  have hcp_p := fun i => prime_pow_coprime_prod_of_coprime_insert i p hps is_prime IsCoprime\n  have hcp_s : ∀ (p) (_ : p ∈ s) (q) (_ : q ∈ s), p ∣ q → p = q := fun p hp q hq =>\n    IsCoprime p (Finset.mem_insert_of_mem hp) q (Finset.mem_insert_of_mem hq)\n  rw [finset.prod_insert hps, finset.prod_insert hps, finset.prod_insert hps, hcp (hcp_p _), hpr _ hpr_p, hcp (hcp_p _),\n    hpr _ hpr_p, hcp (hcp_p _), hpr _ hpr_p, ih hpr_s hcp_s, pow_add, mul_assoc, mul_left_comm (f p ^ j p), mul_assoc]\n#align multiplicative_prime_power multiplicative_prime_power\n\n",
 "multiplicative_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If `f` maps `p ^ i` to `(f p) ^ i` for primes `p`, and `f`\nis multiplicative on coprime elements, then `f` is multiplicative everywhere. -/\ntheorem multiplicative_of_coprime (f : α → β) (a b : α) (h0 : f 0 = 0) (h1 : ∀ {x y}, is_unit y → f (x * y) = f x * f y)\n    (hpr : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i)\n    (hcp : ∀ {x y}, (∀ p, p ∣ x → p ∣ y → is_unit p) → f (x * y) = f x * f y) : f (a * b) = f a * f b :=\n  by\n  letI := classical.dec_eq α\n  by_cases ha0 : a = 0\n  · rw [ha0, zero_mul, h0, zero_mul]\n  by_cases hb0 : b = 0\n  · rw [hb0, mul_zero, h0, mul_zero]\n  by_cases hf1 : f 1 = 0\n  ·\n    calc\n      f (a * b) = f (a * b * 1) := by rw [mul_one]\n      _ = 0 := by simp only [h1 isUnit_one, hf1, mul_zero]\n      _ = f a * f (b * 1) := by simp only [h1 isUnit_one, hf1, mul_zero]\n      _ = f a * f b := by rw [mul_one]\n      \n  have h1' : f 1 = 1 := (mul_left_inj' hf1).mp (by rw [← h1 isUnit_one, one_mul, one_mul])\n  haveI : nontrivial α := ⟨⟨_, _, ha0⟩⟩\n  letI : NormalizationMonoid α := unique_factorization_monoid.normalization_monoid\n  suffices\n    f\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          ((normalized_factors a).to_finset ∪ (normalized_factors b).to_finset)\n          (p ^ ((normalized_factors a).count p + (normalized_factors b).count p))) =\n      f\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            ((normalized_factors a).to_finset ∪ (normalized_factors b).to_finset)\n            (p ^ (normalized_factors a).count p)) *\n        f\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            ((normalized_factors a).to_finset ∪ (normalized_factors b).to_finset) (p ^ (normalized_factors b).count p))\n    by\n    obtain ⟨ua, a_eq⟩ := normalized_factors_prod ha0\n    obtain ⟨ub, b_eq⟩ := normalized_factors_prod hb0\n    rw [← a_eq, ← b_eq, mul_right_comm _ ↑ua, h1 ua.is_unit, h1 ub.is_unit, h1 ua.is_unit, ← mul_assoc, h1 ub.is_unit,\n      mul_right_comm _ (f ua), ← mul_assoc]\n    congr\n    rw [← (normalized_factors a).map_id, ← (normalized_factors b).map_id, finset.prod_multiset_map_count,\n      finset.prod_multiset_map_count, finset.prod_subset (Finset.subset_union_left _ (normalized_factors b).to_finset),\n      finset.prod_subset (Finset.subset_union_right _ (normalized_factors b).to_finset), ← finset.prod_mul_distrib]\n    simp_rw [id.def, ← pow_add, this]\n    all_goals simp only [Multiset.mem_toFinset]\n    · intro p hpab hpb\n      simp [hpb]\n    · intro p hpab hpa\n      simp [hpa]\n  refine' multiplicative_prime_power _ _ _ _ _ @h1 @hpr @hcp\n  all_goals simp only [Multiset.mem_toFinset, Finset.mem_union]\n  · rintro p (hpa | hpb) <;> apply prime_of_normalized_factor <;> assumption\n  ·\n    rintro p (hp | hp) q (hq | hq) hdvd <;>\n        rw [← normalize_normalized_factor _ hp, ← normalize_normalized_factor _ hq] <;>\n      exact\n        normalize_eq_normalize hdvd\n          ((prime_of_normalized_factor _ hp).irreducible.dvd_symm (prime_of_normalized_factor _ hq).irreducible hdvd)\n#align multiplicative_of_coprime multiplicative_of_coprime\n\n",
 "mem_normalized_factors_eq_of_associated":
 "theorem mem_normalized_factors_eq_of_associated {a b c : α} (ha : a ∈ normalized_factors c)\n    (hb : b ∈ normalized_factors c) (h : Associated a b) : a = b :=\n  by\n  rw [← normalize_normalized_factor a ha, ← normalize_normalized_factor b hb, normalize_eq_normalize_iff]\n  apply Associated.dvd_dvd h\n#align mem_normalized_factors_eq_of_associated mem_normalized_factors_eq_of_associated\n\n",
 "mem_factors_of_dvd":
 "theorem mem_factors_of_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) (hd : p ∣ a) :\n    Associates.mk p ∈ factors (Associates.mk a) := by rw [factors_mk _ ha0];\n  exact mem_factor_set_some.mpr (mem_factors'_of_dvd ha0 hp hd)\n#align mem_factors_of_dvd mem_factors_of_dvd\n\n",
 "mem_factors_iff_dvd":
 "theorem mem_factors_iff_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) :\n    Associates.mk p ∈ factors (Associates.mk a) ↔ p ∣ a :=\n  by\n  constructor\n  · rw [← mk_dvd_mk]\n    apply dvd_of_mem_factors\n    exact (irreducible_mk p).mpr hp\n  · apply mem_factors_of_dvd ha0 hp\n#align mem_factors_iff_dvd mem_factors_iff_dvd\n\n",
 "mem_factors'_of_dvd":
 "theorem mem_factors'_of_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) (hd : p ∣ a) :\n    subtype.mk (Associates.mk p) ((irreducible_mk _).2 hp) ∈ factors' a :=\n  by\n  obtain ⟨q, hq, hpq⟩ := exists_mem_factors_of_dvd ha0 hp hd\n  apply multiset.mem_pmap.mpr; use q; use hq\n  exact subtype.eq (eq.symm (mk_eq_mk_iff_associated.mpr hpq))\n#align mem_factors'_of_dvd mem_factors'_of_dvd\n\n",
 "mem_factors'_iff_dvd":
 "theorem mem_factors'_iff_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) :\n    subtype.mk (Associates.mk p) ((irreducible_mk _).2 hp) ∈ factors' a ↔ p ∣ a :=\n  by\n  constructor\n  · rw [← mk_dvd_mk]\n    apply dvd_of_mem_factors'\n    apply ha0\n  · apply mem_factors'_of_dvd ha0\n#align mem_factors'_iff_dvd mem_factors'_iff_dvd\n\n",
 "mem_factor_set_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem mem_factor_set_top {p : Associates α} {hp : Irreducible p} : p ∈ («expr⊤» : factor_set α) := by\n  dsimp only [has_mem.mem]; dsimp only [factor_set_mem]; split_ifs; exact trivial\n#align mem_factor_set_top mem_factor_set_top\n\n",
 "mem_factor_set_some":
 "theorem mem_factor_set_some {p : Associates α} {hp : Irreducible p}\n    {l : Multiset { a : Associates α // Irreducible a }} : p ∈ (l : factor_set α) ↔ subtype.mk p hp ∈ l := by\n  dsimp only [has_mem.mem]; dsimp only [factor_set_mem]; split_ifs; rfl\n#align mem_factor_set_some mem_factor_set_some\n\n",
 "map_subtype_coe_factors'":
 "@[simp]\ntheorem map_subtype_coe_factors' {a : α} : (factors' a).map coe = (factors a).map Associates.mk := by\n  simp [factors', Multiset.map_pmap, Multiset.pmap_eq_map]\n#align map_subtype_coe_factors' map_subtype_coe_factors'\n\n",
 "le_of_count_ne_zero":
 "theorem le_of_count_ne_zero {m p : Associates α} (h0 : m ≠ 0) (hp : Irreducible p) : count p m.factors ≠ 0 → p ≤ m :=\n  by\n  nontriviality α\n  rw [← pos_iff_ne_zero]\n  intro h\n  rw [← pow_one p]\n  apply (prime_pow_dvd_iff_le h0 hp).2\n  simpa only\n#align le_of_count_ne_zero le_of_count_ne_zero\n\n",
 "le_multiplicity_iff_replicate_le_normalized_factors":
 "theorem le_multiplicity_iff_replicate_le_normalized_factors {a b : R} {n : ℕ} (ha : Irreducible a) (hb : b ≠ 0) :\n    ↑n ≤ multiplicity a b ↔ replicate n (normalize a) ≤ normalized_factors b :=\n  by\n  rw [← pow_dvd_iff_le_multiplicity]\n  revert b\n  induction' n with n ih; · simp\n  intro b hb\n  constructor\n  · rintro ⟨c, rfl⟩\n    rw [ne.def, pow_succ, mul_assoc, mul_eq_zero, decidable.not_or_iff_and_not] at hb\n    rw [pow_succ, mul_assoc, normalized_factors_mul hb.1 hb.2, replicate_succ, normalized_factors_irreducible ha,\n      singleton_add, cons_le_cons_iff, ← ih hb.2]\n    apply Dvd.intro _ rfl\n  · rw [Multiset.le_iff_exists_add]\n    rintro ⟨u, hu⟩\n    rw [← (normalized_factors_prod hb).dvd_iff_dvd_right, hu, prod_add, prod_replicate]\n    exact (Associated.pow_pow <| associated_normalize a).dvd.trans (Dvd.intro u.prod rfl)\n#align le_multiplicity_iff_replicate_le_normalized_factors le_multiplicity_iff_replicate_le_normalized_factors\n\n",
 "is_pow_of_dvd_count":
 "theorem is_pow_of_dvd_count [nontrivial α] {a : Associates α} (ha : a ≠ 0) {k : ℕ}\n    (hk : ∀ (p : Associates α) (hp : Irreducible p), k ∣ count p a.factors) : ∃ b : Associates α, a = b ^ k :=\n  by\n  obtain ⟨a0, hz, rfl⟩ := exists_non_zero_rep ha\n  rw [factors_mk a0 hz] at hk\n  have hk' : ∀ p, p ∈ factors' a0 → k ∣ (factors' a0).count p :=\n    by\n    rintro p -\n    have pp : p = ⟨p.val, p.2⟩ := by simp only [subtype.coe_eta, subtype.val_eq_coe]\n    rw [pp, ← count_some p.2]\n    exact hk p.val p.2\n  obtain ⟨u, hu⟩ := multiset.exists_smul_of_dvd_count _ hk'\n  use (u : factor_set α).prod\n  apply eq_of_factors_eq_factors\n  rw [pow_factors, prod_factors, factors_mk a0 hz, ← WithTop.some_eq_coe, hu]\n  exact WithBot.coe_nsmul u k\n#align is_pow_of_dvd_count is_pow_of_dvd_count\n\n",
 "irreducible_of_normalized_factor":
 "theorem irreducible_of_normalized_factor {a : α} : ∀ x : α, x ∈ normalized_factors a → Irreducible x := fun x h =>\n  (prime_of_normalized_factor x h).irreducible\n#align irreducible_of_normalized_factor irreducible_of_normalized_factor\n\n",
 "irreducible_of_factor":
 "theorem irreducible_of_factor {a : α} : ∀ x : α, x ∈ factors a → Irreducible x := fun x h =>\n  (prime_of_factor x h).irreducible\n#align irreducible_of_factor irreducible_of_factor\n\n",
 "irreducible_iff_prime_of_exists_unique_irreducible_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem irreducible_iff_prime_of_exists_unique_irreducible_factors [cancel_comm_monoid_with_zero α]\n    (eif : ∀ a : α, a ≠ 0 → ∃ f : Multiset α, (∀ b ∈ f, Irreducible b) ∧ «expr ~ᵤ » f.prod a)\n    (uif :\n      ∀ f g : Multiset α,\n        (∀ x ∈ f, Irreducible x) → (∀ x ∈ g, Irreducible x) → «expr ~ᵤ » f.prod g.prod → Multiset.Rel Associated f g)\n    (p : α) : Irreducible p ↔ Prime p :=\n  ⟨letI := classical.dec_eq α\n    fun hpi =>\n    ⟨hpi.ne_zero, hpi.1, fun a b ⟨x, hx⟩ =>\n      if hab0 : a * b = 0 then\n        (eq_zero_or_eq_zero_of_mul_eq_zero hab0).elim (fun ha0 => by simp [ha0]) fun hb0 => by simp [hb0]\n      else by\n        have hx0 : x ≠ 0 := fun hx0 => by simp_all\n        have ha0 : a ≠ 0 := left_ne_zero_of_mul hab0\n        have hb0 : b ≠ 0 := right_ne_zero_of_mul hab0\n        cases' eif x hx0 with fx hfx\n        cases' eif a ha0 with fa hfa\n        cases' eif b hb0 with fb hfb\n        have h : Multiset.Rel Associated («expr ::ₘ » p fx) (fa + fb) :=\n          by\n          apply uif\n          · exact fun i hi => (Multiset.mem_cons.1 hi).elim (fun hip => hip.symm ▸ hpi) (hfx.1 _)\n          · exact fun i hi => (Multiset.mem_add.1 hi).elim (hfa.1 _) (hfb.1 _)\n          calc\n            «expr ~ᵤ » (Multiset.prod («expr ::ₘ » p fx)) (a * b) := by\n              rw [hx, Multiset.prod_cons] <;> exact hfx.2.mul_left _\n            «expr ~ᵤ » _ (fa.prod * fb.prod) := hfa.2.symm.mul_mul hfb.2.symm\n            _ = _ := by rw [Multiset.prod_add]\n            \n        exact\n          let ⟨q, hqf, hq⟩ := Multiset.exists_mem_of_rel_of_mem h (Multiset.mem_cons_self p _)\n          (Multiset.mem_add.1 hqf).elim\n            (fun hqa => or.inl <| hq.dvd_iff_dvd_left.2 <| hfa.2.dvd_iff_dvd_right.1 (Multiset.dvd_prod hqa)) fun hqb =>\n            or.inr <| hq.dvd_iff_dvd_left.2 <| hfb.2.dvd_iff_dvd_right.1 (Multiset.dvd_prod hqb)⟩,\n    Prime.irreducible⟩\n#align\n  irreducible_iff_prime_of_exists_unique_irreducible_factors irreducible_iff_prime_of_exists_unique_irreducible_factors\n\n",
 "irreducible_iff_prime_of_exists_prime_factors":
 "theorem irreducible_iff_prime_of_exists_prime_factors {p : α} : Irreducible p ↔ Prime p :=\n  by\n  by_cases hp0 : p = 0\n  · simp [hp0]\n  refine' ⟨fun h => _, Prime.irreducible⟩\n  obtain ⟨f, hf⟩ := pf p hp0\n  obtain ⟨q, hq, rfl⟩ := prime_factors_irreducible h hf\n  rw [hq.prime_iff]\n  exact hf.1 q (Multiset.mem_singleton_self _)\n#align irreducible_iff_prime_of_exists_prime_factors irreducible_iff_prime_of_exists_prime_factors\n\n",
 "induction_on_prime_power":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (p q «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If `P` holds for units and powers of primes,\nand `P x ∧ P y` for coprime `x, y` implies `P (x * y)`,\nthen `P` holds on a product of powers of distinct primes. -/\n@[elab_as_elim]\ntheorem induction_on_prime_power {P : α → Prop} (s : Finset α) (i : α → ℕ) (is_prime : ∀ p ∈ s, Prime p)\n    (is_coprime : ∀ (p) (_ : p ∈ s) (q) (_ : q ∈ s), p ∣ q → p = q) (h1 : ∀ {x}, is_unit x → P x)\n    (hpr : ∀ {p} (i : ℕ), Prime p → P (p ^ i))\n    (hcp : ∀ {x y}, (∀ p, p ∣ x → p ∣ y → is_unit p) → P x → P y → P (x * y)) :\n    P (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (p ^ i p)) :=\n  by\n  letI := classical.dec_eq α\n  induction' s using Finset.induction_on with p f' hpf' ih\n  · simpa using h1 isUnit_one\n  rw [finset.prod_insert hpf']\n  exact\n    hcp (prime_pow_coprime_prod_of_coprime_insert i p hpf' is_prime IsCoprime)\n      (hpr (i p) (is_prime _ (Finset.mem_insert_self _ _)))\n      (ih (fun q hq => is_prime _ (Finset.mem_insert_of_mem hq)) fun q hq q' hq' =>\n        IsCoprime _ (Finset.mem_insert_of_mem hq) _ (Finset.mem_insert_of_mem hq'))\n#align induction_on_prime_power induction_on_prime_power\n\n",
 "induction_on_prime":
 "@[elab_as_elim]\ntheorem induction_on_prime {P : α → Prop} (a : α) (h₁ : P 0) (h₂ : ∀ x : α, is_unit x → P x)\n    (h₃ : ∀ a p : α, a ≠ 0 → Prime p → P a → P (p * a)) : P a :=\n  by\n  simp_rw [← unique_factorization_monoid.irreducible_iff_prime] at h₃\n  exact wf_dvd_monoid.induction_on_irreducible a h₁ h₂ h₃\n#align induction_on_prime induction_on_prime\n\n",
 "induction_on_irreducible":
 "@[elab_as_elim]\ntheorem induction_on_irreducible {P : α → Prop} (a : α) (h0 : P 0) (hu : ∀ u : α, is_unit u → P u)\n    (hi : ∀ a i : α, a ≠ 0 → Irreducible i → P a → P (i * a)) : P a :=\n  haveI := classical.dec\n  well_founded_dvd_not_unit.fix\n    (fun a ih =>\n      if ha0 : a = 0 then ha0.substr h0\n      else\n        if hau : is_unit a then hu a hau\n        else\n          let ⟨i, hii, b, hb⟩ := exists_irreducible_factor hau ha0\n          let hb0 : b ≠ 0 := ne_zero_of_dvd_ne_zero ha0 ⟨i, mul_comm i b ▸ hb⟩\n          hb.symm ▸ hi b i hb0 hii <| ih b ⟨hb0, i, hii.1, mul_comm i b ▸ hb⟩)\n    a\n#align induction_on_irreducible induction_on_irreducible\n\n",
 "induction_on_coprime":
 "/-- If `P` holds for `0`, units and powers of primes,\nand `P x ∧ P y` for coprime `x, y` implies `P (x * y)`,\nthen `P` holds on all `a : α`. -/\n@[elab_as_elim]\ntheorem induction_on_coprime {P : α → Prop} (a : α) (h0 : P 0) (h1 : ∀ {x}, is_unit x → P x)\n    (hpr : ∀ {p} (i : ℕ), Prime p → P (p ^ i))\n    (hcp : ∀ {x y}, (∀ p, p ∣ x → p ∣ y → is_unit p) → P x → P y → P (x * y)) : P a :=\n  by\n  letI := classical.dec_eq α\n  have P_of_associated : ∀ {x y}, Associated x y → P x → P y :=\n    by\n    rintro x y ⟨u, rfl⟩ hx\n    exact hcp (fun p _ hpx => isUnit_of_dvd_unit hpx u.is_unit) hx (h1 u.is_unit)\n  by_cases ha0 : a = 0\n  · rwa [ha0]\n  haveI : nontrivial α := ⟨⟨_, _, ha0⟩⟩\n  letI : NormalizationMonoid α := unique_factorization_monoid.normalization_monoid\n  refine' P_of_associated (normalized_factors_prod ha0) _\n  rw [← (normalized_factors a).map_id, finset.prod_multiset_map_count]\n  refine' induction_on_prime_power _ _ _ _ @h1 @hpr @hcp <;> simp only [Multiset.mem_toFinset]\n  · apply prime_of_normalized_factor\n  · apply normalized_factors_eq_of_dvd\n#align induction_on_coprime induction_on_coprime\n\n",
 "iff_well_founded_associates":
 "theorem wf_dvd_monoid.iff_well_founded_associates [cancel_comm_monoid_with_zero α] :\n    wf_dvd_monoid α ↔ well_founded ((· < ·) : Associates α → Associates α → Prop) :=\n  ⟨by apply wf_dvd_monoid.well_founded_associates, wf_dvd_monoid.of_well_founded_associates⟩\n#align wf_dvd_monoid.iff_well_founded_associates wf_dvd_monoid.iff_well_founded_associates\n\n",
 "iff_exists_prime_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem unique_factorization_monoid.iff_exists_prime_factors [cancel_comm_monoid_with_zero α] :\n    unique_factorization_monoid α ↔ ∀ a : α, a ≠ 0 → ∃ f : Multiset α, (∀ b ∈ f, Prime b) ∧ «expr ~ᵤ » f.prod a :=\n  ⟨fun h => @unique_factorization_monoid.exists_prime_factors _ _ h,\n    unique_factorization_monoid.of_exists_prime_factors⟩\n#align unique_factorization_monoid.iff_exists_prime_factors unique_factorization_monoid.iff_exists_prime_factors\n\n",
 "factors_zero":
 "@[simp]\ntheorem factors_zero : factors (0 : α) = 0 := by simp [factors]\n#align factors_zero factors_zero\n\n",
 "factors_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem factors_unique {f g : Multiset α} (hf : ∀ x ∈ f, Irreducible x) (hg : ∀ x ∈ g, Irreducible x)\n    (h : «expr ~ᵤ » f.prod g.prod) : Multiset.Rel Associated f g :=\n  prime_factors_unique (fun x hx => irreducible_iff_prime.mp (hf x hx)) (fun x hx => irreducible_iff_prime.mp (hg x hx))\n    h\n#align factors_unique factors_unique\n\n",
 "factors_subsingleton":
 "@[nontriviality]\ntheorem factors_subsingleton [subsingleton α] {a : Associates α} : a.factors = option.none := by\n  convert factors_0 <;> infer_instance\n#align factors_subsingleton factors_subsingleton\n\n",
 "factors_self":
 "theorem factors_self [nontrivial α] {p : Associates α} (hp : Irreducible p) : p.factors = some {⟨p, hp⟩} :=\n  eq_of_prod_eq_prod (by rw [factors_prod, factor_set.prod, map_singleton, prod_singleton, subtype.coe_mk])\n#align factors_self factors_self\n\n",
 "factors_prod":
 "@[simp]\ntheorem factors_prod (a : Associates α) : a.factors.prod = a :=\n  Quotient.inductionOn a fun a =>\n    decidable.by_cases (fun this : Associates.mk a = 0 => by simp [quotient_mk_eq_mk, this])\n      fun this : Associates.mk a ≠ 0 => by\n      have : a ≠ 0 := by simp_all\n      simp [this, quotient_mk_eq_mk, prod_mk, mk_eq_mk_iff_associated.2 (factors_prod this)]\n#align factors_prod factors_prod\n\n",
 "factors_prime_pow":
 "theorem factors_prime_pow [nontrivial α] {p : Associates α} (hp : Irreducible p) (k : ℕ) :\n    factors (p ^ k) = some (multiset.replicate k ⟨p, hp⟩) :=\n  eq_of_prod_eq_prod\n    (by rw [associates.factors_prod, factor_set.prod, Multiset.map_replicate, Multiset.prod_replicate, subtype.coe_mk])\n#align factors_prime_pow factors_prime_pow\n\n",
 "factors_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem factors_pow {x : α} (n : ℕ) : Multiset.Rel Associated (factors (x ^ n)) («expr • » n (factors x)) :=\n  by\n  induction' n with n ih\n  · simp\n  by_cases h0 : x = 0\n  · simp [h0, zero_pow n.succ_pos, smul_zero]\n  rw [pow_succ, succ_nsmul]\n  refine' Multiset.Rel.trans _ (factors_mul h0 (pow_ne_zero n h0)) _\n  refine' Multiset.Rel.add _ ih\n  exact Multiset.rel_refl_of_refl_on fun y hy => Associated.refl _\n#align factors_pow factors_pow\n\n",
 "factors_pos":
 "@[simp]\ntheorem factors_pos (x : α) (hx : x ≠ 0) : 0 < factors x ↔ ¬is_unit x :=\n  by\n  constructor\n  · intro h hx\n    obtain ⟨p, hp⟩ := Multiset.exists_mem_of_ne_zero h.ne'\n    exact (prime_of_factor _ hp).not_unit (isUnit_of_dvd_unit (dvd_of_mem_factors hp) hx)\n  · intro h\n    obtain ⟨p, hp⟩ := exists_mem_factors hx h\n    exact bot_lt_iff_ne_bot.mpr (mt multiset.eq_zero_iff_forall_not_mem.mp (not_forall.mpr ⟨p, not_not.mpr hp⟩))\n#align factors_pos factors_pos\n\n",
 "factors_one":
 "@[simp]\ntheorem factors_one [nontrivial α] : factors (1 : Associates α) = 0 :=\n  by\n  apply eq_of_prod_eq_prod\n  rw [associates.factors_prod]\n  exact Multiset.prod_zero\n#align factors_one factors_one\n\n",
 "factors_mul":
 "@[simp]\ntheorem factors_mul (a b : Associates α) : (a * b).factors = a.factors + b.factors :=\n  by\n  cases subsingleton_or_nontrivial α\n  · simp [subsingleton.elim a 0]\n  refine' eq_of_prod_eq_prod (eq_of_factors_eq_factors _)\n  rw [prod_add, factors_prod, factors_prod, factors_prod]\n#align factors_mul factors_mul\n\n",
 "factors_mono":
 "theorem factors_mono : ∀ {a b : Associates α}, a ≤ b → a.factors ≤ b.factors\n  | s, t, ⟨d, rfl⟩ => by rw [factors_mul] <;> exact le_add_of_nonneg_right bot_le\n#align factors_mono factors_mono\n\n",
 "factors_mk":
 "@[simp]\ntheorem factors_mk (a : α) (h : a ≠ 0) : (Associates.mk a).factors = factors' a := by\n  classical\n    apply dif_neg\n    apply mt mk_eq_zero.1 h\n#align factors_mk factors_mk\n\n",
 "factors_le":
 "theorem factors_le {a b : Associates α} : a.factors ≤ b.factors ↔ a ≤ b :=\n  iff.intro\n    (fun h => by\n      have : a.factors.prod ≤ b.factors.prod := prod_mono h\n      rwa [factors_prod, factors_prod] at this)\n    factors_mono\n#align factors_le factors_le\n\n",
 "factors_eq_some_iff_ne_zero":
 "theorem factors_eq_some_iff_ne_zero {a : Associates α} :\n    (∃ s : Multiset { p : Associates α // Irreducible p }, a.factors = some s) ↔ a ≠ 0 := by\n  rw [← Option.isSome_iff_exists, ← Option.ne_none_iff_isSome, ne.def, ne.def, factors_eq_none_iff_zero]\n#align factors_eq_some_iff_ne_zero factors_eq_some_iff_ne_zero\n\n",
 "factors_eq_normalized_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- An arbitrary choice of factors of `x : M` is exactly the (unique) normalized set of factors,\nif `M` has a trivial group of units. -/\n@[simp]\ntheorem factors_eq_normalized_factors {M : Type _} [cancel_comm_monoid_with_zero M] [decidable_eq M]\n    [unique_factorization_monoid M] [unique («expr ˣ» M)] (x : M) : factors x = normalized_factors x :=\n  by\n  unfold normalized_factors\n  convert (Multiset.map_id (factors x)).symm\n  ext p\n  exact normalize_eq p\n#align factors_eq_normalized_factors factors_eq_normalized_factors\n\n",
 "factors_eq_none_iff_zero":
 "theorem factors_eq_none_iff_zero {a : Associates α} : a.factors = option.none ↔ a = 0 :=\n  by\n  nontriviality α\n  exact ⟨fun h => by rwa [← factors_prod a, factor_set.prod_eq_zero_iff], fun h => h.symm ▸ factors_0⟩\n#align factors_eq_none_iff_zero factors_eq_none_iff_zero\n\n",
 "factors_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem factors_0 : (0 : Associates α).factors = «expr⊤» :=\n  dif_pos rfl\n#align factors_0 factors_0\n\n",
 "factors'_cong":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem factors'_cong {a b : α} (h : «expr ~ᵤ » a b) : factors' a = factors' b :=\n  by\n  obtain rfl | hb := eq_or_ne b 0\n  · rw [associated_zero_iff_eq_zero] at h\n    rw [h]\n  have ha : a ≠ 0 := by\n    contrapose! hb with ha\n    rw [← associated_zero_iff_eq_zero, ← ha]\n    exact h.symm\n  rw [← Multiset.map_eq_map subtype.coe_injective, map_subtype_coe_factors', map_subtype_coe_factors', ←\n    rel_associated_iff_map_eq_map]\n  exact\n    factors_unique irreducible_of_factor irreducible_of_factor\n      ((factors_prod ha).trans <| h.trans <| (factors_prod hb).symm)\n#align factors'_cong factors'_cong\n\n",
 "factorization_zero":
 "@[simp]\ntheorem factorization_zero : factorization (0 : α) = 0 := by simp [factorization]\n#align factorization_zero factorization_zero\n\n",
 "factorization_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- For any `p`, the power of `p` in `x^n` is `n` times the power in `x` -/\ntheorem factorization_pow {x : α} {n : ℕ} : factorization (x ^ n) = «expr • » n (factorization x) :=\n  by\n  ext\n  simp [factorization]\n#align factorization_pow factorization_pow\n\n",
 "factorization_one":
 "@[simp]\ntheorem factorization_one : factorization (1 : α) = 0 := by simp [factorization]\n#align factorization_one factorization_one\n\n",
 "factorization_mul":
 "/-- For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` -/\n@[simp]\ntheorem factorization_mul {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) :\n    factorization (a * b) = factorization a + factorization b := by simp [factorization, normalized_factors_mul ha hb]\n#align factorization_mul factorization_mul\n\n",
 "factorization_eq_count":
 "-- We'll show `λ (u : Mˣ) (f ⊆ factors y) → u * Π f` is injective\n-- and has image exactly the divisors of `y`.\ntheorem factorization_eq_count {n p : α} : factorization n p = Multiset.count p (normalized_factors n) := by\n  simp [factorization]\n#align factorization_eq_count factorization_eq_count\n\n",
 "factor_set_mem_eq_mem":
 "@[simp]\ntheorem factor_set_mem_eq_mem (p : Associates α) (s : factor_set α) : factor_set_mem p s = (p ∈ s) :=\n  rfl\n#align factor_set_mem_eq_mem factor_set_mem_eq_mem\n\n",
 "exists_reduced_factors'":
 "theorem exists_reduced_factors' (a b : R) (hb : b ≠ 0) :\n    ∃ a' b' c', (∀ {d}, d ∣ a' → d ∣ b' → is_unit d) ∧ c' * a' = a ∧ c' * b' = b :=\n  let ⟨b', a', c', no_factor, hb, ha⟩ := exists_reduced_factors b hb a\n  ⟨a', b', c', fun _ hpb hpa => no_factor hpa hpb, ha, hb⟩\n#align exists_reduced_factors' exists_reduced_factors'\n\n",
 "exists_reduced_factors":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (a «expr ≠ » (0 : R)) -/\n/-- If `a ≠ 0, b` are elements of a unique factorization domain, then dividing\nout their common factor `c'` gives `a'` and `b'` with no factors in common. -/\ntheorem exists_reduced_factors :\n    ∀ (a) (_ : a ≠ (0 : R)) (b), ∃ a' b' c', (∀ {d}, d ∣ a' → d ∣ b' → is_unit d) ∧ c' * a' = a ∧ c' * b' = b :=\n  by\n  haveI := classical.prop_decidable\n  intro a\n  refine' induction_on_prime a _ _ _\n  · intros\n    contradiction\n  · intro a a_unit a_ne_zero b\n    use a, b, 1\n    constructor\n    · intro p p_dvd_a _\n      exact isUnit_of_dvd_unit p_dvd_a a_unit\n    · simp\n  · intro a p a_ne_zero p_prime ih_a pa_ne_zero b\n    by_cases p ∣ b\n    · rcases h with ⟨b, rfl⟩\n      obtain ⟨a', b', c', no_factor, ha', hb'⟩ := ih_a a_ne_zero b\n      refine' ⟨a', b', p * c', @no_factor, _, _⟩\n      · rw [mul_assoc, ha']\n      · rw [mul_assoc, hb']\n    · obtain ⟨a', b', c', coprime, rfl, rfl⟩ := ih_a a_ne_zero b\n      refine' ⟨p * a', b', c', _, mul_left_comm _ _ _, rfl⟩\n      intro q q_dvd_pa' q_dvd_b'\n      cases' p_prime.left_dvd_or_dvd_right_of_dvd_mul q_dvd_pa' with p_dvd_q q_dvd_a'\n      · have : p ∣ c' * b' := dvd_mul_of_dvd_right (p_dvd_q.trans q_dvd_b') _\n        contradiction\n      exact coprime q_dvd_a' q_dvd_b'\n#align exists_reduced_factors exists_reduced_factors\n\n",
 "exists_prime_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem exists_prime_factors (a : α) : a ≠ 0 → ∃ f : Multiset α, (∀ b ∈ f, Prime b) ∧ «expr ~ᵤ » f.prod a :=\n  by\n  simp_rw [← unique_factorization_monoid.irreducible_iff_prime]\n  apply wf_dvd_monoid.exists_factors a\n#align exists_prime_factors exists_prime_factors\n\n",
 "exists_prime_dvd_of_not_inf_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem exists_prime_dvd_of_not_inf_one {a b : α} (ha : a ≠ 0) (hb : b ≠ 0)\n    (h : «expr ⊓ » (Associates.mk a) (Associates.mk b) ≠ 1) : ∃ p : α, Prime p ∧ p ∣ a ∧ p ∣ b :=\n  by\n  have hz : «expr ⊓ » (factors (Associates.mk a)) (factors (Associates.mk b)) ≠ 0 :=\n    by\n    contrapose! h with hf\n    change («expr ⊓ » (factors (Associates.mk a)) (factors (Associates.mk b))).prod = 1\n    rw [hf]\n    exact Multiset.prod_zero\n  rw [factors_mk a ha, factors_mk b hb, ← WithTop.coe_inf] at hz\n  obtain ⟨⟨p0, p0_irr⟩, p0_mem⟩ := Multiset.exists_mem_of_ne_zero ((mt with_top.coe_eq_coe.mpr) hz)\n  rw [Multiset.inf_eq_inter] at p0_mem\n  obtain ⟨p, rfl⟩ : ∃ p, Associates.mk p = p0 := quot.exists_rep p0\n  refine' ⟨p, _, _, _⟩\n  · rw [← irreducible_iff_prime, ← irreducible_mk]\n    exact p0_irr\n  · apply dvd_of_mk_le_mk\n    apply dvd_of_mem_factors' (multiset.mem_inter.mp p0_mem).left\n    apply ha\n  · apply dvd_of_mk_le_mk\n    apply dvd_of_mem_factors' (multiset.mem_inter.mp p0_mem).right\n    apply hb\n#align exists_prime_dvd_of_not_inf_one exists_prime_dvd_of_not_inf_one\n\n",
 "exists_mem_normalized_factors_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem exists_mem_normalized_factors_of_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) :\n    p ∣ a → ∃ q ∈ normalized_factors a, «expr ~ᵤ » p q := fun ⟨b, hb⟩ =>\n  have hb0 : b ≠ 0 := fun hb0 => by simp_all\n  have : Multiset.Rel Associated («expr ::ₘ » p (normalized_factors b)) (normalized_factors a) :=\n    factors_unique\n      (fun x hx => (Multiset.mem_cons.1 hx).elim (fun h => h.symm ▸ hp) (irreducible_of_normalized_factor _))\n      irreducible_of_normalized_factor\n      (Associated.symm <|\n        calc\n          «expr ~ᵤ » (Multiset.prod (normalized_factors a)) a := normalized_factors_prod ha0\n          _ = p * b := hb\n          «expr ~ᵤ » _ (Multiset.prod («expr ::ₘ » p (normalized_factors b))) := by\n            rw [Multiset.prod_cons] <;> exact (normalized_factors_prod hb0).symm.mul_left _\n          )\n  Multiset.exists_mem_of_rel_of_mem this (by simp)\n#align exists_mem_normalized_factors_of_dvd exists_mem_normalized_factors_of_dvd\n\n",
 "exists_mem_normalized_factors":
 "theorem exists_mem_normalized_factors {x : α} (hx : x ≠ 0) (h : ¬is_unit x) : ∃ p, p ∈ normalized_factors x :=\n  by\n  obtain ⟨p', hp', hp'x⟩ := wf_dvd_monoid.exists_irreducible_factor h hx\n  obtain ⟨p, hp, hpx⟩ := exists_mem_normalized_factors_of_dvd hx hp' hp'x\n  exact ⟨p, hp⟩\n#align exists_mem_normalized_factors exists_mem_normalized_factors\n\n",
 "exists_mem_factors_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem exists_mem_factors_of_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) :\n    p ∣ a → ∃ q ∈ factors a, «expr ~ᵤ » p q := fun ⟨b, hb⟩ =>\n  have hb0 : b ≠ 0 := fun hb0 => by simp_all\n  have : Multiset.Rel Associated («expr ::ₘ » p (factors b)) (factors a) :=\n    factors_unique (fun x hx => (Multiset.mem_cons.1 hx).elim (fun h => h.symm ▸ hp) (irreducible_of_factor _))\n      irreducible_of_factor\n      (Associated.symm <|\n        calc\n          «expr ~ᵤ » (Multiset.prod (factors a)) a := factors_prod ha0\n          _ = p * b := hb\n          «expr ~ᵤ » _ (Multiset.prod («expr ::ₘ » p (factors b))) := by\n            rw [Multiset.prod_cons] <;> exact (factors_prod hb0).symm.mul_left _\n          )\n  Multiset.exists_mem_of_rel_of_mem this (by simp)\n#align exists_mem_factors_of_dvd exists_mem_factors_of_dvd\n\n",
 "exists_mem_factors":
 "theorem exists_mem_factors {x : α} (hx : x ≠ 0) (h : ¬is_unit x) : ∃ p, p ∈ factors x :=\n  by\n  obtain ⟨p', hp', hp'x⟩ := wf_dvd_monoid.exists_irreducible_factor h hx\n  obtain ⟨p, hp, hpx⟩ := exists_mem_factors_of_dvd hx hp' hp'x\n  exact ⟨p, hp⟩\n#align exists_mem_factors exists_mem_factors\n\n",
 "exists_irreducible_factor":
 "theorem exists_irreducible_factor {a : α} (ha : ¬is_unit a) (ha0 : a ≠ 0) : ∃ i, Irreducible i ∧ i ∣ a :=\n  let ⟨b, hs, hr⟩ := well_founded_dvd_not_unit.has_min { b | b ∣ a ∧ ¬is_unit b } ⟨a, dvd_rfl, ha⟩\n  ⟨b,\n    ⟨hs.2, fun c d he =>\n      let h := dvd_trans ⟨d, he⟩ hs.1\n      or_iff_not_imp_left.2 fun hc => of_not_not fun hd => hr c ⟨h, hc⟩ ⟨ne_zero_of_dvd_ne_zero ha0 h, d, hd, he⟩⟩,\n    hs.1⟩\n#align exists_irreducible_factor exists_irreducible_factor\n\n",
 "exists_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem exists_factors (a : α) : a ≠ 0 → ∃ f : Multiset α, (∀ b ∈ f, Irreducible b) ∧ Associated f.prod a :=\n  induction_on_irreducible a (fun h => (h rfl).elim) (fun u hu _ => ⟨0, fun _ h => h.elim, hu.unit, one_mul _⟩)\n    fun a i ha0 hi ih _ =>\n    let ⟨s, hs⟩ := ih ha0\n    ⟨«expr ::ₘ » i s, fun b H => (Multiset.mem_cons.1 H).elim (fun h => h.symm ▸ hi) (hs.1 b),\n      by\n      rw [s.prod_cons i]\n      exact hs.2.mul_left i⟩\n#align exists_factors exists_factors\n\n",
 "exists_associated_prime_pow_of_unique_normalized_factor":
 "theorem exists_associated_prime_pow_of_unique_normalized_factor {p r : α} (h : ∀ {m}, m ∈ normalized_factors r → m = p)\n    (hr : r ≠ 0) : ∃ i : ℕ, Associated (p ^ i) r :=\n  by\n  use (normalized_factors r).card\n  have := unique_factorization_monoid.normalized_factors_prod hr\n  rwa [Multiset.eq_replicate_of_mem fun b => h, Multiset.prod_replicate] at this\n#align exists_associated_prime_pow_of_unique_normalized_factor exists_associated_prime_pow_of_unique_normalized_factor\n\n",
 "eq_pow_of_mul_eq_pow":
 "theorem eq_pow_of_mul_eq_pow [nontrivial α] {a b c : Associates α} (ha : a ≠ 0) (hb : b ≠ 0)\n    (hab : ∀ d, d ∣ a → d ∣ b → ¬Prime d) {k : ℕ} (h : a * b = c ^ k) : ∃ d : Associates α, a = d ^ k := by\n  classical\n    by_cases hk0 : k = 0\n    · use 1\n      rw [hk0, pow_zero] at h⊢\n      apply (mul_eq_one_iff.1 h).1\n    · refine' is_pow_of_dvd_count ha _\n      intro p hp\n      apply dvd_count_of_dvd_count_mul hb hp hab\n      rw [h]\n      apply dvd_count_pow _ hp\n      rintro rfl\n      rw [zero_pow' _ hk0] at h\n      cases mul_eq_zero.mp h <;> contradiction\n#align eq_pow_of_mul_eq_pow eq_pow_of_mul_eq_pow\n\n",
 "eq_pow_find_of_dvd_irreducible_pow":
 "/-- The only divisors of prime powers are prime powers. -/\ntheorem eq_pow_find_of_dvd_irreducible_pow {a p : Associates α} (hp : Irreducible p) [∀ n : ℕ, decidable (a ∣ p ^ n)]\n    {n : ℕ} (h : a ∣ p ^ n) : a = p ^ nat.find ⟨n, h⟩ := by\n  classical rw [count_factors_eq_find_of_dvd_pow hp, ← eq_pow_count_factors_of_dvd_pow hp h]\n#align eq_pow_find_of_dvd_irreducible_pow eq_pow_find_of_dvd_irreducible_pow\n\n",
 "eq_pow_count_factors_of_dvd_pow":
 "/-- The only divisors of prime powers are prime powers. See `eq_pow_find_of_dvd_irreducible_pow`\nfor an explicit expression as a p-power (without using `count`). -/\ntheorem eq_pow_count_factors_of_dvd_pow {p a : Associates α} (hp : Irreducible p) {n : ℕ} (h : a ∣ p ^ n) :\n    a = p ^ p.count a.factors := by\n  nontriviality α\n  have hph := pow_ne_zero n hp.ne_zero\n  have ha := ne_zero_of_dvd_ne_zero hph h\n  apply eq_of_eq_counts ha (pow_ne_zero _ hp.ne_zero)\n  have eq_zero_of_ne : ∀ q : Associates α, Irreducible q → q ≠ p → _ = 0 := fun q hq h' =>\n    nat.eq_zero_of_le_zero <| by\n      convert count_le_count_of_le hph hq h\n      symm\n      rw [count_pow hp.ne_zero hq, count_eq_zero_of_ne hq hp h', mul_zero]\n  intro q hq\n  rw [count_pow hp.ne_zero hq]\n  by_cases h : q = p\n  · rw [h, count_self hp, mul_one]\n  · rw [count_eq_zero_of_ne hq hp h, mul_zero, eq_zero_of_ne q hq h]\n#align eq_pow_count_factors_of_dvd_pow eq_pow_count_factors_of_dvd_pow\n\n",
 "eq_of_prod_eq_prod":
 "theorem eq_of_prod_eq_prod [nontrivial α] {a b : factor_set α} (h : a.prod = b.prod) : a = b := by\n  classical\n    have : a.prod.factors = b.prod.factors := by rw [h]\n    rwa [prod_factors, prod_factors] at this\n#align eq_of_prod_eq_prod eq_of_prod_eq_prod\n\n",
 "eq_of_factors_eq_factors":
 "theorem eq_of_factors_eq_factors {a b : Associates α} (h : a.factors = b.factors) : a = b :=\n  by\n  have : a.factors.prod = b.factors.prod := by rw [h]\n  rwa [factors_prod, factors_prod] at this\n#align eq_of_factors_eq_factors eq_of_factors_eq_factors\n\n",
 "eq_of_eq_counts":
 "theorem eq_of_eq_counts {a b : Associates α} (ha : a ≠ 0) (hb : b ≠ 0)\n    (h : ∀ p : Associates α, Irreducible p → p.count a.factors = p.count b.factors) : a = b :=\n  eq_of_factors_eq_factors (eq_factors_of_eq_counts ha hb h)\n#align eq_of_eq_counts eq_of_eq_counts\n\n",
 "eq_factors_of_eq_counts":
 "theorem eq_factors_of_eq_counts {a b : Associates α} (ha : a ≠ 0) (hb : b ≠ 0)\n    (h : ∀ (p : Associates α) (hp : Irreducible p), p.count a.factors = p.count b.factors) : a.factors = b.factors :=\n  by\n  obtain ⟨sa, h_sa⟩ := factors_eq_some_iff_ne_zero.mpr ha\n  obtain ⟨sb, h_sb⟩ := factors_eq_some_iff_ne_zero.mpr hb\n  rw [h_sa, h_sb] at h⊢\n  rw [option.some_inj]\n  have h_count : ∀ (p : Associates α) (hp : Irreducible p), sa.count ⟨p, hp⟩ = sb.count ⟨p, hp⟩ :=\n    by\n    intro p hp\n    rw [← count_some, ← count_some, h p hp]\n  apply multiset.to_finsupp.injective\n  ext ⟨p, hp⟩\n  rw [multiset.to_finsupp_apply, multiset.to_finsupp_apply, h_count p hp]\n#align eq_factors_of_eq_counts eq_factors_of_eq_counts\n\n",
 "dvd_of_mem_normalized_factors":
 "theorem dvd_of_mem_normalized_factors {a p : α} (H : p ∈ normalized_factors a) : p ∣ a :=\n  by\n  by_cases hcases : a = 0\n  · rw [hcases]\n    exact dvd_zero p\n  · exact dvd_trans (Multiset.dvd_prod H) (Associated.dvd (normalized_factors_prod hcases))\n#align dvd_of_mem_normalized_factors dvd_of_mem_normalized_factors\n\n",
 "dvd_of_mem_factors'":
 "theorem dvd_of_mem_factors' {a : α} {p : Associates α} {hp : Irreducible p} {hz : a ≠ 0}\n    (h_mem : subtype.mk p hp ∈ factors' a) : p ∣ Associates.mk a :=\n  by\n  haveI := classical.dec_eq (Associates α)\n  apply @dvd_of_mem_factors _ _ _ _ _ _ _ _ hp\n  rw [factors_mk _ hz]\n  apply mem_factor_set_some.2 h_mem\n#align dvd_of_mem_factors' dvd_of_mem_factors'\n\n",
 "dvd_of_mem_factors":
 "theorem dvd_of_mem_factors {a p : Associates α} {hp : Irreducible p} (hm : p ∈ factors a) : p ∣ a :=\n  by\n  by_cases ha0 : a = 0;\n  · rw [ha0]\n    exact dvd_zero p\n  obtain ⟨a0, nza, ha'⟩ := exists_non_zero_rep ha0\n  rw [← associates.factors_prod a]\n  rw [← ha', factors_mk a0 nza] at hm⊢\n  erw [prod_coe]\n  apply Multiset.dvd_prod; apply multiset.mem_map.mpr\n  exact ⟨⟨p, hp⟩, mem_factor_set_some.mp hm, rfl⟩\n#align dvd_of_mem_factors dvd_of_mem_factors\n\n",
 "dvd_of_dvd_mul_right_of_no_prime_factors":
 "/-- Euclid's lemma: if `a ∣ b * c` and `a` and `b` have no common prime factors, `a ∣ c`.\nCompare `is_coprime.dvd_of_dvd_mul_right`. -/\ntheorem dvd_of_dvd_mul_right_of_no_prime_factors {a b c : R} (ha : a ≠ 0)\n    (no_factors : ∀ {d}, d ∣ a → d ∣ b → ¬Prime d) : a ∣ b * c → a ∣ c := by\n  simpa [mul_comm b c] using dvd_of_dvd_mul_left_of_no_prime_factors ha @no_factors\n#align dvd_of_dvd_mul_right_of_no_prime_factors dvd_of_dvd_mul_right_of_no_prime_factors\n\n",
 "dvd_of_dvd_mul_left_of_no_prime_factors":
 "/-- Euclid's lemma: if `a ∣ b * c` and `a` and `c` have no common prime factors, `a ∣ b`.\nCompare `is_coprime.dvd_of_dvd_mul_left`. -/\ntheorem dvd_of_dvd_mul_left_of_no_prime_factors {a b c : R} (ha : a ≠ 0) :\n    (∀ {d}, d ∣ a → d ∣ c → ¬Prime d) → a ∣ b * c → a ∣ b :=\n  by\n  refine' induction_on_prime c _ _ _\n  · intro no_factors\n    simp only [dvd_zero, mul_zero, forall_prop_of_true]\n    haveI := classical.prop_decidable\n    exact is_unit_iff_forall_dvd.mp (no_factors_of_no_prime_factors ha (@no_factors) (dvd_refl a) (dvd_zero a)) _\n  · rintro _ ⟨x, rfl⟩ _ a_dvd_bx\n    apply units.dvd_mul_right.mp a_dvd_bx\n  · intro c p hc hp ih no_factors a_dvd_bpc\n    apply ih fun q dvd_a dvd_c hq => no_factors dvd_a (dvd_c.mul_left _) hq\n    rw [mul_left_comm] at a_dvd_bpc\n    refine' or.resolve_left (hp.left_dvd_or_dvd_right_of_dvd_mul a_dvd_bpc) fun h => _\n    exact no_factors h (dvd_mul_right p c) hp\n#align dvd_of_dvd_mul_left_of_no_prime_factors dvd_of_dvd_mul_left_of_no_prime_factors\n\n",
 "dvd_not_unit_iff_normalized_factors_lt_normalized_factors":
 "theorem dvd_not_unit_iff_normalized_factors_lt_normalized_factors {x y : α} (hx : x ≠ 0) (hy : y ≠ 0) :\n    DvdNotUnit x y ↔ normalized_factors x < normalized_factors y :=\n  by\n  constructor\n  · rintro ⟨_, c, hc, rfl⟩\n    simp only [hx, right_ne_zero_of_mul hy, normalized_factors_mul, ne.def, not_false_iff, lt_add_iff_pos_right,\n      normalized_factors_pos, hc]\n  · intro h\n    exact\n      dvdNotUnit_of_dvd_of_not_dvd ((dvd_iff_normalized_factors_le_normalized_factors hx hy).mpr h.le)\n        (mt (dvd_iff_normalized_factors_le_normalized_factors hy hx).mp h.not_le)\n#align\n  dvd_not_unit_iff_normalized_factors_lt_normalized_factors dvd_not_unit_iff_normalized_factors_lt_normalized_factors\n\n",
 "dvd_iff_normalized_factors_le_normalized_factors":
 "theorem dvd_iff_normalized_factors_le_normalized_factors {x y : α} (hx : x ≠ 0) (hy : y ≠ 0) :\n    x ∣ y ↔ normalized_factors x ≤ normalized_factors y :=\n  by\n  constructor\n  · rintro ⟨c, rfl⟩\n    simp [hx, right_ne_zero_of_mul hy]\n  · rw [← (normalized_factors_prod hx).dvd_iff_dvd_left, ← (normalized_factors_prod hy).dvd_iff_dvd_right]\n    apply Multiset.prod_dvd_prod_of_le\n#align dvd_iff_normalized_factors_le_normalized_factors dvd_iff_normalized_factors_le_normalized_factors\n\n",
 "dvd_count_pow":
 "theorem dvd_count_pow [nontrivial α] {a : Associates α} (ha : a ≠ 0) {p : Associates α} (hp : Irreducible p) (k : ℕ) :\n    k ∣ count p (a ^ k).factors := by\n  rw [count_pow ha hp]\n  apply dvd_mul_right\n#align dvd_count_pow dvd_count_pow\n\n",
 "dvd_count_of_dvd_count_mul":
 "theorem dvd_count_of_dvd_count_mul {a b : Associates α} (hb : b ≠ 0) {p : Associates α} (hp : Irreducible p)\n    (hab : ∀ d, d ∣ a → d ∣ b → ¬Prime d) {k : ℕ} (habk : k ∣ count p (a * b).factors) : k ∣ count p a.factors :=\n  by\n  by_cases ha : a = 0; · simpa [*] using habk\n  cases' count_of_coprime ha hb hab hp with hz h\n  · rw [hz]\n    exact dvd_zero k\n  · rw [count_mul ha hb hp, h] at habk\n    exact habk\n#align dvd_count_of_dvd_count_mul dvd_count_of_dvd_count_mul\n\n",
 "count_zero":
 "@[simp]\ntheorem count_zero [decidable_eq (Associates α)] {p : Associates α} (hp : Irreducible p) :\n    count p (0 : factor_set α) = 0 := by\n  dsimp only [count]\n  split_ifs\n  rfl\n#align count_zero count_zero\n\n",
 "count_some":
 "@[simp]\ntheorem count_some [decidable_eq (Associates α)] {p : Associates α} (hp : Irreducible p) (s : Multiset _) :\n    count p (some s) = s.count ⟨p, hp⟩ := by\n  dsimp only [count]\n  split_ifs\n  rfl\n#align count_some count_some\n\n",
 "count_self":
 "theorem count_self [nontrivial α] {p : Associates α} (hp : Irreducible p) : p.count p.factors = 1 := by\n  simp [factors_self hp, associates.count_some hp]\n#align count_self count_self\n\n",
 "count_reducible":
 "theorem count_reducible [decidable_eq (Associates α)] {p : Associates α} (hp : ¬Irreducible p) : count p = 0 :=\n  dif_neg hp\n#align count_reducible count_reducible\n\n",
 "count_pow":
 "theorem count_pow [nontrivial α] {a : Associates α} (ha : a ≠ 0) {p : Associates α} (hp : Irreducible p) (k : ℕ) :\n    count p (a ^ k).factors = k * count p a.factors :=\n  by\n  induction' k with n h\n  · rw [pow_zero, factors_one, zero_mul, count_zero hp]\n  · rw [pow_succ, count_mul ha (pow_ne_zero _ ha) hp, h, nat.succ_eq_add_one]\n    ring\n#align count_pow count_pow\n\n",
 "count_of_coprime":
 "theorem count_of_coprime {a : Associates α} (ha : a ≠ 0) {b : Associates α} (hb : b ≠ 0)\n    (hab : ∀ d, d ∣ a → d ∣ b → ¬Prime d) {p : Associates α} (hp : Irreducible p) :\n    count p a.factors = 0 ∨ count p b.factors = 0 :=\n  by\n  rw [or_iff_not_imp_left, ← ne.def]\n  intro hca\n  contrapose! hab with hcb\n  exact ⟨p, le_of_count_ne_zero ha hp hca, le_of_count_ne_zero hb hp hcb, irreducible_iff_prime.mp hp⟩\n#align count_of_coprime count_of_coprime\n\n",
 "count_normalized_factors_eq'":
 "/-- The number of times an irreducible factor `p` appears in `normalized_factors x` is defined by\nthe number of times it divides `x`. This is a slightly more general version of\n`unique_factorization_monoid.count_normalized_factors_eq` that allows `p = 0`.\n\nSee also `multiplicity_eq_count_normalized_factors` if `n` is given by `multiplicity p x`.\n-/\ntheorem count_normalized_factors_eq' {p x : R} (hp : p = 0 ∨ Irreducible p) (hnorm : normalize p = p) {n : ℕ}\n    (hle : p ^ n ∣ x) (hlt : ¬p ^ (n + 1) ∣ x) : (normalized_factors x).count p = n :=\n  by\n  rcases hp with (rfl | hp)\n  · cases n\n    · exact count_eq_zero.2 (zero_not_mem_normalized_factors _)\n    · rw [zero_pow (nat.succ_pos _)] at hle hlt\n      exact absurd hle hlt\n  · exact count_normalized_factors_eq hp hnorm hle hlt\n#align count_normalized_factors_eq' count_normalized_factors_eq'\n\n",
 "count_normalized_factors_eq":
 "/-- The number of times an irreducible factor `p` appears in `normalized_factors x` is defined by\nthe number of times it divides `x`.\n\nSee also `multiplicity_eq_count_normalized_factors` if `n` is given by `multiplicity p x`.\n-/\ntheorem count_normalized_factors_eq {p x : R} (hp : Irreducible p) (hnorm : normalize p = p) {n : ℕ} (hle : p ^ n ∣ x)\n    (hlt : ¬p ^ (n + 1) ∣ x) : (normalized_factors x).count p = n :=\n  by\n  letI : decidable_rel ((· ∣ ·) : R → R → Prop) := fun _ _ => classical.prop_decidable _\n  by_cases hx0 : x = 0\n  · simp [hx0] at hlt\n    contradiction\n  rw [← part_enat.coe_inj]\n  convert (multiplicity_eq_count_normalized_factors hp hx0).symm\n  · exact hnorm.symm\n  exact (multiplicity.eq_coe_iff.mpr ⟨hle, hlt⟩).symm\n#align count_normalized_factors_eq count_normalized_factors_eq\n\n",
 "count_ne_zero_iff_dvd":
 "theorem count_ne_zero_iff_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) :\n    (Associates.mk p).count (Associates.mk a).factors ≠ 0 ↔ p ∣ a :=\n  by\n  nontriviality α\n  rw [← Associates.mk_le_mk_iff_dvd_iff]\n  refine'\n    ⟨fun h => associates.le_of_count_ne_zero (associates.mk_ne_zero.mpr ha0) ((Associates.irreducible_mk p).mpr hp) h,\n      fun h => _⟩\n  · rw [← pow_one (Associates.mk p),\n      associates.prime_pow_dvd_iff_le (associates.mk_ne_zero.mpr ha0) ((Associates.irreducible_mk p).mpr hp)] at h\n    exact (zero_lt_one.trans_le h).ne'\n#align count_ne_zero_iff_dvd count_ne_zero_iff_dvd\n\n",
 "count_mul_of_coprime'":
 "theorem count_mul_of_coprime' {a b : Associates α} {p : Associates α} (hp : Irreducible p)\n    (hab : ∀ d, d ∣ a → d ∣ b → ¬Prime d) :\n    count p (a * b).factors = count p a.factors ∨ count p (a * b).factors = count p b.factors :=\n  by\n  by_cases ha : a = 0; · simp [ha]\n  by_cases hb : b = 0; · simp [hb]\n  rw [count_mul ha hb hp]\n  cases' count_of_coprime ha hb hab hp with ha0 hb0\n  · apply Or.intro_right\n    rw [ha0, zero_add]\n  · apply or.intro_left\n    rw [hb0, add_zero]\n#align count_mul_of_coprime' count_mul_of_coprime'\n\n",
 "count_mul_of_coprime":
 "theorem count_mul_of_coprime {a : Associates α} {b : Associates α} (hb : b ≠ 0) {p : Associates α} (hp : Irreducible p)\n    (hab : ∀ d, d ∣ a → d ∣ b → ¬Prime d) : count p a.factors = 0 ∨ count p a.factors = count p (a * b).factors :=\n  by\n  by_cases ha : a = 0\n  · simp [ha]\n  cases' count_of_coprime ha hb hab hp with hz hb0; · tauto\n  apply Or.intro_right\n  rw [count_mul ha hb hp, hb0, add_zero]\n#align count_mul_of_coprime count_mul_of_coprime\n\n",
 "count_mul":
 "theorem count_mul {a : Associates α} (ha : a ≠ 0) {b : Associates α} (hb : b ≠ 0) {p : Associates α}\n    (hp : Irreducible p) : count p (factors (a * b)) = count p a.factors + count p b.factors :=\n  by\n  obtain ⟨a0, nza, ha'⟩ := exists_non_zero_rep ha\n  obtain ⟨b0, nzb, hb'⟩ := exists_non_zero_rep hb\n  rw [factors_mul, ← ha', ← hb', factors_mk a0 nza, factors_mk b0 nzb, ← factor_set.coe_add, ← WithTop.some_eq_coe, ←\n    WithTop.some_eq_coe, ← WithTop.some_eq_coe, count_some hp, Multiset.count_add, count_some hp, count_some hp]\n#align count_mul count_mul\n\n",
 "count_le_count_of_le":
 "theorem count_le_count_of_le {a b p : Associates α} (hb : b ≠ 0) (hp : Irreducible p) (h : a ≤ b) :\n    p.count a.factors ≤ p.count b.factors :=\n  count_le_count_of_factors_le hb hp <| factors_mono h\n#align count_le_count_of_le count_le_count_of_le\n\n",
 "count_le_count_of_factors_le":
 "theorem count_le_count_of_factors_le {a b p : Associates α} (hb : b ≠ 0) (hp : Irreducible p)\n    (h : a.factors ≤ b.factors) : p.count a.factors ≤ p.count b.factors :=\n  by\n  by_cases ha : a = 0\n  · simp_all\n  obtain ⟨sa, h_sa⟩ := factors_eq_some_iff_ne_zero.mpr ha\n  obtain ⟨sb, h_sb⟩ := factors_eq_some_iff_ne_zero.mpr hb\n  rw [h_sa, h_sb] at h⊢\n  rw [count_some hp, count_some hp]; rw [WithTop.some_le_some] at h\n  exact Multiset.count_le_of_le _ h\n#align count_le_count_of_factors_le count_le_count_of_factors_le\n\n",
 "count_factors_eq_find_of_dvd_pow":
 "theorem count_factors_eq_find_of_dvd_pow {a p : Associates α} (hp : Irreducible p) [∀ n : ℕ, decidable (a ∣ p ^ n)]\n    {n : ℕ} (h : a ∣ p ^ n) : nat.find ⟨n, h⟩ = p.count a.factors :=\n  by\n  apply le_antisymm\n  · refine' Nat.find_le ⟨1, _⟩\n    rw [mul_one]\n    symm\n    exact eq_pow_count_factors_of_dvd_pow hp h\n  · have hph := pow_ne_zero (nat.find ⟨n, h⟩) hp.ne_zero\n    cases' subsingleton_or_nontrivial α with hα hα\n    · simpa using hph\n    convert count_le_count_of_le hph hp (nat.find_spec ⟨n, h⟩)\n    rw [count_pow hp.ne_zero hp, count_self hp, mul_one]\n#align count_factors_eq_find_of_dvd_pow count_factors_eq_find_of_dvd_pow\n\n",
 "count_eq_zero_of_ne":
 "theorem count_eq_zero_of_ne {p q : Associates α} (hp : Irreducible p) (hq : Irreducible q) (h : p ≠ q) :\n    p.count q.factors = 0 :=\n  not_ne_iff.mp fun h' =>\n    h <|\n      associated_iff_eq.mp <|\n        hp.associated_of_dvd hq <| by\n          nontriviality α\n          exact le_of_count_ne_zero hq.ne_zero hp h'\n#align count_eq_zero_of_ne count_eq_zero_of_ne\n\n",
 "coprime_iff_inf_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem coprime_iff_inf_one {a b : α} (ha0 : a ≠ 0) (hb0 : b ≠ 0) :\n    «expr ⊓ » (Associates.mk a) (Associates.mk b) = 1 ↔ ∀ {d : α}, d ∣ a → d ∣ b → ¬Prime d :=\n  by\n  constructor\n  · intro hg p ha hb hp\n    refine' ((Associates.prime_mk _).mpr hp).not_unit (isUnit_of_dvd_one _ _)\n    rw [← hg]\n    exact le_inf (mk_le_mk_of_dvd ha) (mk_le_mk_of_dvd hb)\n  · contrapose\n    intro hg hc\n    obtain ⟨p, hp, hpa, hpb⟩ := exists_prime_dvd_of_not_inf_one ha0 hb0 hg\n    exact hc hpa hpb hp\n#align coprime_iff_inf_one coprime_iff_inf_one\n\n",
 "coe_add":
 "theorem factor_set.coe_add {a b : Multiset { a : Associates α // Irreducible a }} : (↑(a + b) : factor_set α) = a + b :=\n  by norm_cast\n#align factor_set.coe_add factor_set.coe_add\n\n",
 "associated_of_factorization_eq":
 "theorem associated_of_factorization_eq (a b : α) (ha : a ≠ 0) (hb : b ≠ 0) (h : factorization a = factorization b) :\n    Associated a b := by\n  simp_rw [factorization, AddEquiv.apply_eq_iff_eq] at h\n  rwa [associated_iff_normalized_factors_eq_normalized_factors ha hb]\n#align associated_of_factorization_eq associated_of_factorization_eq\n\n",
 "associated_iff_normalized_factors_eq_normalized_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem associated_iff_normalized_factors_eq_normalized_factors {x y : α} (hx : x ≠ 0) (hy : y ≠ 0) :\n    «expr ~ᵤ » x y ↔ normalized_factors x = normalized_factors y :=\n  by\n  refine'\n    ⟨fun h => _, fun h => (normalized_factors_prod hx).symm.trans (trans (by rw [h]) (normalized_factors_prod hy))⟩\n  apply le_antisymm <;> rw [← dvd_iff_normalized_factors_le_normalized_factors]\n  all_goals simp [*, h.dvd, h.symm.dvd]\n#align associated_iff_normalized_factors_eq_normalized_factors associated_iff_normalized_factors_eq_normalized_factors\n\n"}