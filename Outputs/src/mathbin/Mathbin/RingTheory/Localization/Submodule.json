{"mem_span_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_span_map {x : S} {a : Set R} :\n    x ∈ Ideal.span («expr '' » (algebraMap R S) a) ↔ ∃ y ∈ Ideal.span a, ∃ z : M, x = mk' S y z :=\n  by\n  refine' (mem_span_iff M).trans _\n  constructor\n  · rw [← coe_submodule_span]\n    rintro ⟨_, ⟨y, hy, rfl⟩, z, hz⟩\n    refine' ⟨y, hy, z, _⟩\n    rw [hz, Algebra.linearMap_apply, smul_eq_mul, mul_comm, mul_mk'_eq_mk'_of_mul, mul_one]\n  · rintro ⟨y, hy, z, hz⟩\n    refine' ⟨algebraMap R S y, Submodule.map_mem_span_algebraMap_image _ _ hy, z, _⟩\n    rw [hz, smul_eq_mul, mul_comm, mul_mk'_eq_mk'_of_mul, mul_one]\n#align mem_span_map mem_span_map\n\n",
 "mem_span_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_span_iff {N : Type _} [AddCommGroup N] [Module R N] [Module S N] [IsScalarTower R S N] {x : N} {a : Set N} :\n    x ∈ Submodule.span S a ↔ ∃ y ∈ Submodule.span R a, ∃ z : M, x = «expr • » (mk' S 1 z) y :=\n  by\n  constructor; intro h\n  · refine' Submodule.span_induction h _ _ _ _\n    · rintro x hx\n      exact ⟨x, Submodule.subset_span hx, 1, by rw [mk'_one, _root_.map_one, one_smul]⟩\n    · exact ⟨0, Submodule.zero_mem _, 1, by rw [mk'_one, _root_.map_one, one_smul]⟩\n    · rintro _ _ ⟨y, hy, z, rfl⟩ ⟨y', hy', z', rfl⟩\n      refine'\n        ⟨«expr • » (z' : R) y + «expr • » (z : R) y',\n          Submodule.add_mem _ (Submodule.smul_mem _ _ hy) (Submodule.smul_mem _ _ hy'), z * z', _⟩\n      rw [smul_add, ← IsScalarTower.algebraMap_smul S (z : R), ← IsScalarTower.algebraMap_smul S (z' : R), smul_smul,\n        smul_smul]\n      congr 1\n      · rw [← mul_one (1 : R), mk'_mul, mul_assoc, mk'_spec, _root_.map_one, mul_one, mul_one]\n      · rw [← mul_one (1 : R), mk'_mul, mul_right_comm, mk'_spec, _root_.map_one, mul_one, one_mul]\n      all_goals infer_instance\n    · rintro a _ ⟨y, hy, z, rfl⟩\n      obtain ⟨y', z', rfl⟩ := mk'_surjective M a\n      refine' ⟨«expr • » y' y, Submodule.smul_mem _ _ hy, z' * z, _⟩\n      rw [← IsScalarTower.algebraMap_smul S y', smul_smul, ← mk'_mul, smul_smul, mul_comm (mk' S _ _),\n        mul_mk'_eq_mk'_of_mul]\n      all_goals infer_instance\n  · rintro ⟨y, hy, z, rfl⟩\n    exact Submodule.smul_mem _ _ (Submodule.span_subset_span R S _ hy)\n#align mem_span_iff mem_span_iff\n\n",
 "mem_coe_submodule":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\n-- This was previously a `has_coe` instance, but if `S = R` then this will loop.\n-- It could be a `has_coe_t` instance, but we keep it explicit here to avoid slowing down\n-- the rest of the library.\ntheorem mem_coe_submodule (I : Ideal R) {x : S} : x ∈ coeSubmodule S I ↔ ∃ y : R, y ∈ I ∧ algebraMap R S y = x :=\n  iff.rfl\n#align mem_coe_submodule mem_coe_submodule\n\n",
 "coe_submodule_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_submodule_top : coeSubmodule S («expr⊤» : Ideal R) = 1 := by\n  rw [coe_submodule, Submodule.map_top, Submodule.one_eq_range]\n#align coe_submodule_top coe_submodule_top\n\n",
 "coe_submodule_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem coe_submodule_sup (I J : Ideal R) :\n    coeSubmodule S («expr ⊔ » I J) = «expr ⊔ » (coeSubmodule S I) (coeSubmodule S J) :=\n  Submodule.map_sup _ _ _\n#align coe_submodule_sup coe_submodule_sup\n\n",
 "coe_submodule_strict_mono":
 "@[mono]\ntheorem coe_submodule_strict_mono : StrictMono (coeSubmodule K : Ideal R → Submodule R K) :=\n  strictMono_of_le_iff_le fun _ _ => coeSubmodule_le_coeSubmodule.symm\n#align coe_submodule_strict_mono coe_submodule_strict_mono\n\n",
 "coe_submodule_span_singleton":
 "@[simp]\ntheorem coe_submodule_span_singleton (x : R) :\n    coeSubmodule S (Ideal.span {x}) = Submodule.span R {(algebraMap R S) x} := by\n  rw [coe_submodule_span, Set.image_singleton]\n#align coe_submodule_span_singleton coe_submodule_span_singleton\n\n",
 "coe_submodule_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem coe_submodule_span (s : Set R) :\n    coeSubmodule S (Ideal.span s) = Submodule.span R («expr '' » (algebraMap R S) s) :=\n  by\n  rw [IsLocalization.coeSubmodule, Ideal.span, Submodule.map_span]\n  rfl\n#align coe_submodule_span coe_submodule_span\n\n",
 "coe_submodule_mul":
 "@[simp]\ntheorem coe_submodule_mul (I J : Ideal R) : coeSubmodule S (I * J) = coeSubmodule S I * coeSubmodule S J :=\n  Submodule.map_mul _ _ (Algebra.ofId R S)\n#align coe_submodule_mul coe_submodule_mul\n\n",
 "coe_submodule_mono":
 "theorem coe_submodule_mono {I J : Ideal R} (h : I ≤ J) : coeSubmodule S I ≤ coeSubmodule S J :=\n  Submodule.map_mono h\n#align coe_submodule_mono coe_submodule_mono\n\n",
 "coe_submodule_le_coe_submodule":
 "@[simp, mono]\ntheorem coe_submodule_le_coe_submodule {I J : Ideal R} : coeSubmodule K I ≤ coeSubmodule K J ↔ I ≤ J :=\n  IsLocalization.coeSubmodule_le_coeSubmodule le_rfl\n#align coe_submodule_le_coe_submodule coe_submodule_le_coe_submodule\n\n",
 "coe_submodule_is_principal":
 "@[simp]\ntheorem coe_submodule_is_principal {I : Ideal R} : (coeSubmodule K I).is_principal ↔ I.is_principal :=\n  IsLocalization.coeSubmodule_isPrincipal _ le_rfl\n#align coe_submodule_is_principal coe_submodule_is_principal\n\n",
 "coe_submodule_injective":
 "theorem coe_submodule_injective : function.injective (coeSubmodule K : Ideal R → Submodule R K) :=\n  injective_of_le_imp_le _ fun _ _ => coeSubmodule_le_coeSubmodule.mp\n#align coe_submodule_injective coe_submodule_injective\n\n",
 "coe_submodule_fg":
 "theorem coe_submodule_fg (hS : function.injective (algebraMap R S)) (I : Ideal R) :\n    Submodule.Fg (coeSubmodule S I) ↔ Submodule.Fg I :=\n  ⟨Submodule.fg_of_fg_map _ (LinearMap.ker_eq_bot.mpr hS), Submodule.Fg.map _⟩\n#align coe_submodule_fg coe_submodule_fg\n\n",
 "coe_submodule_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_submodule_bot : coeSubmodule S («expr⊥» : Ideal R) = «expr⊥» := by rw [coe_submodule, Submodule.map_bot]\n#align coe_submodule_bot coe_submodule_bot\n\n",
 "IsNoetherianRing":
 "#print IsNoetherianRing /-\ntheorem IsNoetherianRing (h : IsNoetherianRing R) : IsNoetherianRing S :=\n  by\n  rw [isNoetherianRing_iff, isNoetherian_iff_wellFounded] at h⊢\n  exact OrderEmbedding.wellFounded (IsLocalization.orderEmbedding M S).dual h\n#align is_noetherian_ring IsNoetherianRing\n-/\n\n"}