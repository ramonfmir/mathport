{"mem_span_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_span_map {x : S} {a : set R} :\n    x ∈ ideal.span («expr '' » (algebra_map R S) a) ↔ ∃ y ∈ ideal.span a, ∃ z : M, x = mk' S y z :=\n  by\n  refine' (mem_span_iff M).trans _\n  constructor\n  · rw [← coe_submodule_span]\n    rintro ⟨_, ⟨y, hy, rfl⟩, z, hz⟩\n    refine' ⟨y, hy, z, _⟩\n    rw [hz, algebra.linear_map_apply, smul_eq_mul, mul_comm, mul_mk'_eq_mk'_of_mul, mul_one]\n  · rintro ⟨y, hy, z, hz⟩\n    refine' ⟨algebra_map R S y, submodule.map_mem_span_algebra_map_image _ _ hy, z, _⟩\n    rw [hz, smul_eq_mul, mul_comm, mul_mk'_eq_mk'_of_mul, mul_one]\n#align mem_span_map mem_span_map\n\n",
 "mem_span_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_span_iff {N : Type _} [add_comm_group N] [Module R N] [Module S N] [IsScalarTower R S N] {x : N}\n    {a : set N} : x ∈ submodule.span S a ↔ ∃ y ∈ submodule.span R a, ∃ z : M, x = «expr • » (mk' S 1 z) y :=\n  by\n  constructor; intro h\n  · refine' submodule.span_induction h _ _ _ _\n    · rintro x hx\n      exact ⟨x, submodule.subset_span hx, 1, by rw [mk'_one, _root_.map_one, one_smul]⟩\n    · exact ⟨0, submodule.zero_mem _, 1, by rw [mk'_one, _root_.map_one, one_smul]⟩\n    · rintro _ _ ⟨y, hy, z, rfl⟩ ⟨y', hy', z', rfl⟩\n      refine'\n        ⟨«expr • » (z' : R) y + «expr • » (z : R) y',\n          submodule.add_mem _ (submodule.smul_mem _ _ hy) (submodule.smul_mem _ _ hy'), z * z', _⟩\n      rw [smul_add, ← is_scalar_tower.algebra_map_smul S (z : R), ← is_scalar_tower.algebra_map_smul S (z' : R),\n        smul_smul, smul_smul]\n      congr 1\n      · rw [← mul_one (1 : R), mk'_mul, mul_assoc, mk'_spec, _root_.map_one, mul_one, mul_one]\n      · rw [← mul_one (1 : R), mk'_mul, mul_right_comm, mk'_spec, _root_.map_one, mul_one, one_mul]\n      all_goals infer_instance\n    · rintro a _ ⟨y, hy, z, rfl⟩\n      obtain ⟨y', z', rfl⟩ := mk'_surjective M a\n      refine' ⟨«expr • » y' y, submodule.smul_mem _ _ hy, z' * z, _⟩\n      rw [← is_scalar_tower.algebra_map_smul S y', smul_smul, ← mk'_mul, smul_smul, mul_comm (mk' S _ _),\n        mul_mk'_eq_mk'_of_mul]\n      all_goals infer_instance\n  · rintro ⟨y, hy, z, rfl⟩\n    exact submodule.smul_mem _ _ (submodule.span_subset_span R S _ hy)\n#align mem_span_iff mem_span_iff\n\n",
 "mem_coe_submodule":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\n-- This was previously a `has_coe` instance, but if `S = R` then this will loop.\n-- It could be a `has_coe_t` instance, but we keep it explicit here to avoid slowing down\n-- the rest of the library.\ntheorem mem_coe_submodule (I : ideal R) {x : S} : x ∈ coe_submodule S I ↔ ∃ y : R, y ∈ I ∧ algebra_map R S y = x :=\n  iff.rfl\n#align mem_coe_submodule mem_coe_submodule\n\n",
 "is_noetherian_ring":
 "theorem is_noetherian_ring (h : is_noetherian_ring R) : is_noetherian_ring S :=\n  by\n  rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at h⊢\n  exact OrderEmbedding.wellFounded (is_localization.order_embedding M S).dual h\n#align is_noetherian_ring is_noetherian_ring\n\n",
 "coe_submodule_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_submodule_top : coe_submodule S («expr⊤» : ideal R) = 1 := by\n  rw [coe_submodule, submodule.map_top, submodule.one_eq_range]\n#align coe_submodule_top coe_submodule_top\n\n",
 "coe_submodule_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem coe_submodule_sup (I J : ideal R) :\n    coe_submodule S («expr ⊔ » I J) = «expr ⊔ » (coe_submodule S I) (coe_submodule S J) :=\n  submodule.map_sup _ _ _\n#align coe_submodule_sup coe_submodule_sup\n\n",
 "coe_submodule_strict_mono":
 "@[mono]\ntheorem coe_submodule_strict_mono : strict_mono (coe_submodule K : ideal R → submodule R K) :=\n  strictMono_of_le_iff_le fun _ _ => coe_submodule_le_coe_submodule.symm\n#align coe_submodule_strict_mono coe_submodule_strict_mono\n\n",
 "coe_submodule_span_singleton":
 "@[simp]\ntheorem coe_submodule_span_singleton (x : R) :\n    coe_submodule S (ideal.span {x}) = submodule.span R {(algebra_map R S) x} := by\n  rw [coe_submodule_span, Set.image_singleton]\n#align coe_submodule_span_singleton coe_submodule_span_singleton\n\n",
 "coe_submodule_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem coe_submodule_span (s : set R) :\n    coe_submodule S (ideal.span s) = submodule.span R («expr '' » (algebra_map R S) s) :=\n  by\n  rw [is_localization.coe_submodule, ideal.span, submodule.map_span]\n  rfl\n#align coe_submodule_span coe_submodule_span\n\n",
 "coe_submodule_mul":
 "@[simp]\ntheorem coe_submodule_mul (I J : ideal R) : coe_submodule S (I * J) = coe_submodule S I * coe_submodule S J :=\n  submodule.map_mul _ _ (algebra.of_id R S)\n#align coe_submodule_mul coe_submodule_mul\n\n",
 "coe_submodule_mono":
 "theorem coe_submodule_mono {I J : ideal R} (h : I ≤ J) : coe_submodule S I ≤ coe_submodule S J :=\n  submodule.map_mono h\n#align coe_submodule_mono coe_submodule_mono\n\n",
 "coe_submodule_le_coe_submodule":
 "@[simp, mono]\ntheorem coe_submodule_le_coe_submodule {I J : ideal R} : coe_submodule K I ≤ coe_submodule K J ↔ I ≤ J :=\n  is_localization.coe_submodule_le_coe_submodule le_rfl\n#align coe_submodule_le_coe_submodule coe_submodule_le_coe_submodule\n\n",
 "coe_submodule_is_principal":
 "@[simp]\ntheorem coe_submodule_is_principal {I : ideal R} : (coe_submodule K I).is_principal ↔ I.is_principal :=\n  is_localization.coe_submodule_is_principal _ le_rfl\n#align coe_submodule_is_principal coe_submodule_is_principal\n\n",
 "coe_submodule_injective":
 "theorem coe_submodule_injective : function.injective (coe_submodule K : ideal R → submodule R K) :=\n  injective_of_le_imp_le _ fun _ _ => coe_submodule_le_coe_submodule.mp\n#align coe_submodule_injective coe_submodule_injective\n\n",
 "coe_submodule_fg":
 "theorem coe_submodule_fg (hS : function.injective (algebra_map R S)) (I : ideal R) :\n    submodule.fg (coe_submodule S I) ↔ submodule.fg I :=\n  ⟨submodule.fg_of_fg_map _ (linear_map.ker_eq_bot.mpr hS), submodule.fg.map _⟩\n#align coe_submodule_fg coe_submodule_fg\n\n",
 "coe_submodule_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_submodule_bot : coe_submodule S («expr⊥» : ideal R) = «expr⊥» := by rw [coe_submodule, submodule.map_bot]\n#align coe_submodule_bot coe_submodule_bot\n\n"}