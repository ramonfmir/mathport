{"surjective_quotient_map_of_maximal_of_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- `quotient_map` applied to maximal ideals of a localization is `surjective`.\n  The quotient by a maximal ideal is a field, so inverses to elements already exist,\n  and the localization necessarily maps the equivalence class of the inverse in the localization -/\ntheorem surjective_quotient_map_of_maximal_of_localization {I : ideal S} [I.is_prime] {J : ideal R}\n    {H : J ≤ I.comap (algebra_map R S)} (hI : (I.comap (algebra_map R S)).is_maximal) :\n    function.surjective (I.quotient_map (algebra_map R S) H) :=\n  by\n  intro s\n  obtain ⟨s, rfl⟩ := ideal.quotient.mk_surjective s\n  obtain ⟨r, ⟨m, hm⟩, rfl⟩ := mk'_surjective M s\n  by_cases hM : (ideal.quotient.mk (I.comap (algebra_map R S))) m = 0\n  · have : I = «expr⊤» := by\n      rw [ideal.eq_top_iff_one]\n      rw [ideal.quotient.eq_zero_iff_mem, ideal.mem_comap] at hM\n      convert I.mul_mem_right (mk' S (1 : R) ⟨m, hm⟩) hM\n      rw [← mk'_eq_mul_mk'_one, mk'_self]\n    exact ⟨0, eq_comm.1 (by simp [ideal.quotient.eq_zero_iff_mem, this])⟩\n  · rw [ideal.quotient.maximal_ideal_iff_is_field_quotient] at hI\n    obtain ⟨n, hn⟩ := hI.3 hM\n    obtain ⟨rn, rfl⟩ := ideal.quotient.mk_surjective n\n    refine' ⟨(ideal.quotient.mk J) (r * rn), _⟩\n    -- The rest of the proof is essentially just algebraic manipulations to prove the equality\n    rw [← RingHom.map_mul] at hn\n    replace hn := congr_arg (ideal.quotient_map I (algebra_map R S) le_rfl) hn\n    simp only [RingHom.map_one, ideal.quotient_map_mk, RingHom.map_mul] at hn\n    rw [ideal.quotient_map_mk, ← sub_eq_zero, ← RingHom.map_sub, ideal.quotient.eq_zero_iff_mem, ←\n      ideal.quotient.eq_zero_iff_mem, RingHom.map_sub, sub_eq_zero, mk'_eq_mul_mk'_one]\n    simp only [mul_eq_mul_left_iff, RingHom.map_mul]\n    exact\n      or.inl\n        (mul_left_cancel₀\n          (fun hn => hM (ideal.quotient.eq_zero_iff_mem.2 (ideal.mem_comap.2 (ideal.quotient.eq_zero_iff_mem.1 hn))))\n          (trans hn (by rw [← RingHom.map_mul, ← mk'_eq_mul_mk'_one, mk'_self, RingHom.map_one])))\n#align surjective_quotient_map_of_maximal_of_localization surjective_quotient_map_of_maximal_of_localization\n\n",
 "mem_map_algebra_map_iff":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\ntheorem mem_map_algebra_map_iff {I : ideal R} {z} :\n    z ∈ ideal.map (algebra_map R S) I ↔ ∃ x : I × M, z * algebra_map R S x.2 = algebra_map R S x.1 :=\n  by\n  constructor\n  · change _ → z ∈ map_ideal M S I\n    refine' fun h => ideal.mem_Inf.1 h fun z hz => _\n    obtain ⟨y, hy⟩ := hz\n    use ⟨⟨⟨y, hy.left⟩, 1⟩, by simp [hy.right]⟩\n  · rintro ⟨⟨a, s⟩, h⟩\n    rw [← ideal.unit_mul_mem_iff_mem _ (map_units S s), mul_comm]\n    exact h.symm ▸ ideal.mem_map_of_mem _ a.2\n#align mem_map_algebra_map_iff mem_map_algebra_map_iff\n\n",
 "map_comap":
 "theorem map_comap (J : ideal S) : ideal.map (algebra_map R S) (ideal.comap (algebra_map R S) J) = J :=\n  le_antisymm (ideal.map_le_iff_le_comap.2 le_rfl) fun x hJ =>\n    by\n    obtain ⟨r, s, hx⟩ := mk'_surjective M x\n    rw [← hx] at hJ⊢\n    exact\n      ideal.mul_mem_right _ _\n        (ideal.mem_map_of_mem _\n          (show (algebra_map R S) r ∈ J from mk'_spec S r s ▸ J.mul_mem_right ((algebra_map R S) s) hJ))\n#align map_comap map_comap\n\n",
 "is_prime_of_is_prime_disjoint":
 "/-- If `R` is a ring, then prime ideals in the localization at `M`\ncorrespond to prime ideals in the original ring `R` that are disjoint from `M`.\nThis lemma gives the particular case for an ideal and its map,\nsee `le_rel_iso_of_prime` for the more general relation isomorphism, and the reverse implication -/\ntheorem is_prime_of_is_prime_disjoint (I : ideal R) (hp : I.is_prime) (hd : Disjoint (M : set R) ↑I) :\n    (ideal.map (algebra_map R S) I).is_prime :=\n  by\n  rw [is_prime_iff_is_prime_disjoint M S, comap_map_of_is_prime_disjoint M S I hp hd]\n  exact ⟨hp, hd⟩\n#align is_prime_of_is_prime_disjoint is_prime_of_is_prime_disjoint\n\n",
 "is_prime_iff_is_prime_disjoint":
 "/-- If `R` is a ring, then prime ideals in the localization at `M`\ncorrespond to prime ideals in the original ring `R` that are disjoint from `M`.\nThis lemma gives the particular case for an ideal and its comap,\nsee `le_rel_iso_of_prime` for the more general relation isomorphism -/\ntheorem is_prime_iff_is_prime_disjoint (J : ideal S) :\n    J.is_prime ↔ (ideal.comap (algebra_map R S) J).is_prime ∧ Disjoint (M : set R) ↑(ideal.comap (algebra_map R S) J) :=\n  by\n  constructor\n  · refine' fun h =>\n      ⟨⟨_, _⟩,\n        set.disjoint_left.mpr fun m hm1 hm2 => h.ne_top (ideal.eq_top_of_is_unit_mem _ hm2 (map_units S ⟨m, hm1⟩))⟩\n    · refine' fun hJ => h.ne_top _\n      rw [eq_top_iff, ← (OrderEmbedding M S).le_iff_le]\n      exact le_of_eq hJ.symm\n    · intro x y hxy\n      rw [ideal.mem_comap, RingHom.map_mul] at hxy\n      exact h.mem_or_mem hxy\n  · refine' fun h => ⟨fun hJ => h.left.ne_top (eq_top_iff.2 _), _⟩\n    · rwa [eq_top_iff, ← (OrderEmbedding M S).le_iff_le] at hJ\n    · intro x y hxy\n      obtain ⟨a, s, ha⟩ := mk'_surjective M x\n      obtain ⟨b, t, hb⟩ := mk'_surjective M y\n      have : mk' S (a * b) (s * t) ∈ J := by rwa [mk'_mul, ha, hb]\n      rw [mk'_mem_iff, ← ideal.mem_comap] at this\n      replace this := h.left.mem_or_mem this\n      rw [ideal.mem_comap, ideal.mem_comap] at this\n      rwa [← ha, ← hb, mk'_mem_iff, mk'_mem_iff]\n#align is_prime_iff_is_prime_disjoint is_prime_iff_is_prime_disjoint\n\n",
 "comap_map_of_is_prime_disjoint":
 "theorem comap_map_of_is_prime_disjoint (I : ideal R) (hI : I.is_prime) (hM : Disjoint (M : set R) I) :\n    ideal.comap (algebra_map R S) (ideal.map (algebra_map R S) I) = I :=\n  by\n  refine' le_antisymm (fun a ha => _) ideal.le_comap_map\n  obtain ⟨⟨b, s⟩, h⟩ := (mem_map_algebra_map_iff M S).1 (ideal.mem_comap.1 ha)\n  replace h : algebra_map R S (a * s) = algebra_map R S b := by simpa only [← map_mul] using h\n  obtain ⟨c, hc⟩ := (eq_iff_exists M S).1 h\n  have : a * (s * c) ∈ I := by\n    rw [← mul_assoc, hc]\n    exact I.mul_mem_right c b.2\n  exact (hI.mem_or_mem this).resolve_right fun hsc => hM.le_bot ⟨(s * c).2, hsc⟩\n#align comap_map_of_is_prime_disjoint comap_map_of_is_prime_disjoint\n\n"}