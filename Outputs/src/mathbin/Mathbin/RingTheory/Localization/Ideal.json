{"surjective_quotient_map_of_maximal_of_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- `quotient_map` applied to maximal ideals of a localization is `surjective`.\n  The quotient by a maximal ideal is a field, so inverses to elements already exist,\n  and the localization necessarily maps the equivalence class of the inverse in the localization -/\ntheorem surjective_quotient_map_of_maximal_of_localization {I : Ideal S} [I.is_prime] {J : Ideal R}\n    {H : J ≤ I.comap (algebraMap R S)} (hI : (I.comap (algebraMap R S)).is_maximal) :\n    function.surjective (I.quotient_map (algebraMap R S) H) :=\n  by\n  intro s\n  obtain ⟨s, rfl⟩ := Ideal.Quotient.mk_surjective s\n  obtain ⟨r, ⟨m, hm⟩, rfl⟩ := mk'_surjective M s\n  by_cases hM : (Ideal.Quotient.mk (I.comap (algebraMap R S))) m = 0\n  · have : I = «expr⊤» := by\n      rw [Ideal.eq_top_iff_one]\n      rw [Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_comap] at hM\n      convert I.mul_mem_right (mk' S (1 : R) ⟨m, hm⟩) hM\n      rw [← mk'_eq_mul_mk'_one, mk'_self]\n    exact ⟨0, eq_comm.1 (by simp [Ideal.Quotient.eq_zero_iff_mem, this])⟩\n  · rw [Ideal.Quotient.maximal_ideal_iff_isField_quotient] at hI\n    obtain ⟨n, hn⟩ := hI.3 hM\n    obtain ⟨rn, rfl⟩ := Ideal.Quotient.mk_surjective n\n    refine' ⟨(Ideal.Quotient.mk J) (r * rn), _⟩\n    -- The rest of the proof is essentially just algebraic manipulations to prove the equality\n    rw [← RingHom.map_mul] at hn\n    replace hn := congr_arg (Ideal.quotientMap I (algebraMap R S) le_rfl) hn\n    simp only [RingHom.map_one, Ideal.quotientMap_mk, RingHom.map_mul] at hn\n    rw [Ideal.quotientMap_mk, ← sub_eq_zero, ← RingHom.map_sub, Ideal.Quotient.eq_zero_iff_mem, ←\n      Ideal.Quotient.eq_zero_iff_mem, RingHom.map_sub, sub_eq_zero, mk'_eq_mul_mk'_one]\n    simp only [mul_eq_mul_left_iff, RingHom.map_mul]\n    exact\n      or.inl\n        (mul_left_cancel₀\n          (fun hn => hM (Ideal.Quotient.eq_zero_iff_mem.2 (Ideal.mem_comap.2 (Ideal.Quotient.eq_zero_iff_mem.1 hn))))\n          (trans hn (by rw [← RingHom.map_mul, ← mk'_eq_mul_mk'_one, mk'_self, RingHom.map_one])))\n#align surjective_quotient_map_of_maximal_of_localization surjective_quotient_map_of_maximal_of_localization\n\n",
 "mem_map_algebra_map_iff":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\ntheorem mem_map_algebra_map_iff {I : Ideal R} {z} :\n    z ∈ Ideal.map (algebraMap R S) I ↔ ∃ x : I × M, z * algebraMap R S x.2 = algebraMap R S x.1 :=\n  by\n  constructor\n  · change _ → z ∈ map_ideal M S I\n    refine' fun h => Ideal.mem_infₛ.1 h fun z hz => _\n    obtain ⟨y, hy⟩ := hz\n    use ⟨⟨⟨y, hy.left⟩, 1⟩, by simp [hy.right]⟩\n  · rintro ⟨⟨a, s⟩, h⟩\n    rw [← Ideal.unit_mul_mem_iff_mem _ (map_units S s), mul_comm]\n    exact h.symm ▸ Ideal.mem_map_of_mem _ a.2\n#align mem_map_algebra_map_iff mem_map_algebra_map_iff\n\n",
 "map_comap":
 "theorem map_comap (J : Ideal S) : Ideal.map (algebraMap R S) (Ideal.comap (algebraMap R S) J) = J :=\n  le_antisymm (Ideal.map_le_iff_le_comap.2 le_rfl) fun x hJ =>\n    by\n    obtain ⟨r, s, hx⟩ := mk'_surjective M x\n    rw [← hx] at hJ⊢\n    exact\n      Ideal.mul_mem_right _ _\n        (Ideal.mem_map_of_mem _\n          (show (algebraMap R S) r ∈ J from mk'_spec S r s ▸ J.mul_mem_right ((algebraMap R S) s) hJ))\n#align map_comap map_comap\n\n",
 "is_prime_of_is_prime_disjoint":
 "/-- If `R` is a ring, then prime ideals in the localization at `M`\ncorrespond to prime ideals in the original ring `R` that are disjoint from `M`.\nThis lemma gives the particular case for an ideal and its map,\nsee `le_rel_iso_of_prime` for the more general relation isomorphism, and the reverse implication -/\ntheorem is_prime_of_is_prime_disjoint (I : Ideal R) (hp : I.is_prime) (hd : Disjoint (M : Set R) ↑I) :\n    (Ideal.map (algebraMap R S) I).is_prime :=\n  by\n  rw [is_prime_iff_is_prime_disjoint M S, comap_map_of_is_prime_disjoint M S I hp hd]\n  exact ⟨hp, hd⟩\n#align is_prime_of_is_prime_disjoint is_prime_of_is_prime_disjoint\n\n",
 "is_prime_iff_is_prime_disjoint":
 "/-- If `R` is a ring, then prime ideals in the localization at `M`\ncorrespond to prime ideals in the original ring `R` that are disjoint from `M`.\nThis lemma gives the particular case for an ideal and its comap,\nsee `le_rel_iso_of_prime` for the more general relation isomorphism -/\ntheorem is_prime_iff_is_prime_disjoint (J : Ideal S) :\n    J.is_prime ↔ (Ideal.comap (algebraMap R S) J).is_prime ∧ Disjoint (M : Set R) ↑(Ideal.comap (algebraMap R S) J) :=\n  by\n  constructor\n  · refine' fun h =>\n      ⟨⟨_, _⟩,\n        set.disjoint_left.mpr fun m hm1 hm2 => h.ne_top (Ideal.eq_top_of_isUnit_mem _ hm2 (map_units S ⟨m, hm1⟩))⟩\n    · refine' fun hJ => h.ne_top _\n      rw [eq_top_iff, ← (OrderEmbedding M S).le_iff_le]\n      exact le_of_eq hJ.symm\n    · intro x y hxy\n      rw [Ideal.mem_comap, RingHom.map_mul] at hxy\n      exact h.mem_or_mem hxy\n  · refine' fun h => ⟨fun hJ => h.left.ne_top (eq_top_iff.2 _), _⟩\n    · rwa [eq_top_iff, ← (OrderEmbedding M S).le_iff_le] at hJ\n    · intro x y hxy\n      obtain ⟨a, s, ha⟩ := mk'_surjective M x\n      obtain ⟨b, t, hb⟩ := mk'_surjective M y\n      have : mk' S (a * b) (s * t) ∈ J := by rwa [mk'_mul, ha, hb]\n      rw [mk'_mem_iff, ← Ideal.mem_comap] at this\n      replace this := h.left.mem_or_mem this\n      rw [Ideal.mem_comap, Ideal.mem_comap] at this\n      rwa [← ha, ← hb, mk'_mem_iff, mk'_mem_iff]\n#align is_prime_iff_is_prime_disjoint is_prime_iff_is_prime_disjoint\n\n",
 "comap_map_of_is_prime_disjoint":
 "theorem comap_map_of_is_prime_disjoint (I : Ideal R) (hI : I.is_prime) (hM : Disjoint (M : Set R) I) :\n    Ideal.comap (algebraMap R S) (Ideal.map (algebraMap R S) I) = I :=\n  by\n  refine' le_antisymm (fun a ha => _) Ideal.le_comap_map\n  obtain ⟨⟨b, s⟩, h⟩ := (mem_map_algebra_map_iff M S).1 (Ideal.mem_comap.1 ha)\n  replace h : algebraMap R S (s * a) = algebraMap R S b := by simpa only [← map_mul, mul_comm] using h\n  obtain ⟨c, hc⟩ := (eq_iff_exists M S).1 h\n  have : ↑c * ↑s * a ∈ I := by\n    rw [mul_assoc, hc]\n    exact I.mul_mem_left c b.2\n  exact (hI.mem_or_mem this).resolve_left fun hsc => hM.le_bot ⟨(c * s).2, hsc⟩\n#align comap_map_of_is_prime_disjoint comap_map_of_is_prime_disjoint\n\n",
 "bot_lt_comap_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem bot_lt_comap_prime [IsDomain R] (hM : M ≤ non_zero_divisors R) (p : Ideal S) [hpp : p.is_prime]\n    (hp0 : p ≠ «expr⊥») : «expr⊥» < Ideal.comap (algebraMap R S) p :=\n  by\n  haveI : IsDomain S := is_domain_of_le_non_zero_divisors _ hM\n  convert(order_iso_of_prime M S).lt_iff_lt.mpr\n      (show (⟨«expr⊥», Ideal.bot_prime⟩ : { p : Ideal S // p.is_prime }) < ⟨p, hpp⟩ from hp0.bot_lt)\n  exact (Ideal.comap_bot_of_injective (algebraMap R S) (IsLocalization.injective _ hM)).symm\n#align bot_lt_comap_prime bot_lt_comap_prime\n\n"}