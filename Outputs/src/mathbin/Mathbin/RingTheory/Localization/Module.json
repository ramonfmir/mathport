{"localization_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print SpanEqTop.localization_localization /-\ntheorem SpanEqTop.localization_localization {v : Set A} (hv : span R v = «expr⊤») :\n    span Rₛ («expr '' » (algebraMap A Aₛ) v) = «expr⊤» :=\n  by\n  rw [eq_top_iff]\n  rintro a' -\n  obtain ⟨a, ⟨_, s, hs, rfl⟩, rfl⟩ := IsLocalization.mk'_surjective (Algebra.algebraMapSubmonoid A S) a'\n  rw [IsLocalization.mk'_eq_mul_mk'_one, mul_comm, ← map_one (algebraMap R A)]\n  erw [← IsLocalization.algebraMap_mk' A Rₛ Aₛ (1 : R) ⟨s, hs⟩]\n  -- `erw` needed to unify `⟨s, hs⟩`\n  rw [← Algebra.smul_def]\n  refine' smul_mem _ _ (span_subset_span R _ _ _)\n  rw [← Algebra.coe_linearMap, ← LinearMap.coe_restrictScalars R, ← LinearMap.map_span]\n  exact mem_map_of_mem (hv.symm ▸ mem_top)\n  · infer_instance\n#align span_eq_top.localization_localization SpanEqTop.localization_localization\n-/\n\n",
 "localizationLocalization_repr_algebraMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.localizationLocalization_repr_algebraMap /-\n@[simp]\ntheorem Basis.localizationLocalization_repr_algebraMap {ι : Type _} (b : Basis ι R A) (x i) :\n    (b.localization_localization Rₛ S Aₛ).repr (algebraMap A Aₛ x) i = algebraMap R Rₛ (b.repr x i) :=\n  calc\n    (b.localization_localization Rₛ S Aₛ).repr (algebraMap A Aₛ x) i =\n        (b.localization_localization Rₛ S Aₛ).repr\n          ((b.repr x).sum fun j c => «expr • » (algebraMap R Rₛ c) (algebraMap A Aₛ (b j))) i :=\n      by\n      simp_rw [IsScalarTower.algebraMap_smul, Algebra.smul_def, IsScalarTower.algebraMap_apply R A Aₛ, ← _root_.map_mul,\n        ← map_finsupp_sum, ← Algebra.smul_def, ← Finsupp.total_apply, Basis.total_repr]\n    _ = (b.repr x).sum fun j c => «expr • » (algebraMap R Rₛ c) (Finsupp.single j 1 i) := by\n      simp_rw [← b.localization_localization_apply Rₛ S Aₛ, map_finsupp_sum, LinearEquiv.map_smul, Basis.repr_self,\n        Finsupp.sum_apply, Finsupp.smul_apply]\n    _ = _ := (Finset.sum_eq_single i (fun j _ hj => by simp [hj]) fun hi => by simp [finsupp.not_mem_support_iff.mp hi])\n    _ = algebraMap R Rₛ (b.repr x i) := by simp [Algebra.smul_def]\n    \n#align basis.localization_localization_repr_algebra_map Basis.localizationLocalization_repr_algebraMap\n-/\n\n",
 "localizationLocalization_apply":
 "#print Basis.localizationLocalization_apply /-\n@[simp]\ntheorem Basis.localizationLocalization_apply {ι : Type _} (b : Basis ι R A) (i) :\n    b.localization_localization Rₛ S Aₛ i = algebraMap A Aₛ (b i) :=\n  Basis.mk_apply _ _ _\n#align basis.localization_localization_apply Basis.localizationLocalization_apply\n-/\n\n",
 "localization":
 "#print LinearIndependent.localization /-\n/-\nCopyright (c) 2022 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Junyan Xu, Anne Baanen\n-/\ntheorem LinearIndependent.localization {ι : Type _} {b : ι → M} (hli : LinearIndependent R b) :\n    LinearIndependent Rₛ b := by\n  rw [linearIndependent_iff'] at hli⊢\n  intro s g hg i hi\n  choose! a g' hg' using IsLocalization.exist_integer_multiples S s g\n  specialize hli s g' _ i hi\n  · rw [← @smul_zero _ M _ _ (a : R), ← hg, Finset.smul_sum]\n    refine' Finset.sum_congr rfl fun i hi => _\n    rw [← IsScalarTower.algebraMap_smul Rₛ, hg' i hi, smul_assoc]\n    infer_instance\n  refine' (is_localization.map_units Rₛ a).mul_right_eq_zero.mp _\n  rw [← Algebra.smul_def, ← map_zero (algebraMap R Rₛ), ← hli, hg' i hi]\n#align linear_independent.localization LinearIndependent.localization\n-/\n\n",
 "iff_fractionRing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n#print LinearIndependent.iff_fractionRing /-\ntheorem LinearIndependent.iff_fractionRing {ι : Type _} {b : ι → V} : LinearIndependent R b ↔ LinearIndependent K b :=\n  ⟨LinearIndependent.localization K (non_zero_divisors R),\n    LinearIndependent.restrict_scalars (smul_left_injective R one_ne_zero)⟩\n#align linear_independent.iff_fraction_ring LinearIndependent.iff_fractionRing\n-/\n\n"}