{"scale_roots_common_denom_mem_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_localization.scale_roots_common_denom_mem_lifts (p : polynomial Rₘ)\n    (hp : p.leading_coeff ∈ (algebra_map R Rₘ).range) :\n    p.scale_roots (algebra_map R Rₘ <| is_localization.common_denom M p.support p.coeff) ∈\n      polynomial.lifts (algebra_map R Rₘ) :=\n  by\n  rw [polynomial.lifts_iff_coeff_lifts]\n  intro n\n  rw [polynomial.coeff_scale_roots]\n  by_cases h₁ : n ∈ p.support\n  by_cases h₂ : n = p.nat_degree\n  · rwa [h₂, polynomial.coeff_nat_degree, tsub_self, pow_zero, _root_.mul_one]\n  · have : n + 1 ≤ p.nat_degree := lt_of_le_of_ne (polynomial.le_nat_degree_of_mem_supp _ h₁) h₂\n    rw [← tsub_add_cancel_of_le (le_tsub_of_add_le_left this), pow_add, pow_one, mul_comm, _root_.mul_assoc, ← map_pow]\n    change _ ∈ (algebra_map R Rₘ).range\n    apply mul_mem\n    · exact ring_hom.mem_range_self _ _\n    · rw [← algebra.smul_def]\n      exact ⟨_, is_localization.map_integer_multiple M p.support p.coeff ⟨n, h₁⟩⟩\n  · rw [polynomial.not_mem_support_iff] at h₁\n    rw [h₁, zero_mul]\n    exact zero_mem (algebra_map R Rₘ).range\n#align is_localization.scale_roots_common_denom_mem_lifts is_localization.scale_roots_common_denom_mem_lifts\n\n",
 "is_integral_localization_at_leading_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- Given a particular witness to an element being algebraic over an algebra `R → S`,\nWe can localize to a submonoid containing the leading coefficient to make it integral.\nExplicitly, the map between the localizations will be an integral ring morphism -/\ntheorem is_integral_localization_at_leading_coeff {x : S} (p : polynomial R) (hp : aeval x p = 0)\n    (hM : p.leading_coeff ∈ M) :\n    (map Sₘ (algebra_map R S) (show _ ≤ (algebra.algebra_map_submonoid S M).comap _ from M.le_comap_map) :\n          «expr →+* » Rₘ _).is_integral_elem\n      (algebra_map S Sₘ x) :=\n  (algebra_map R S).is_integral_elem_localization_at_leading_coeff x p hp M hM\n#align is_integral_localization_at_leading_coeff is_integral_localization_at_leading_coeff\n\n",
 "is_integral_localization'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_integral_localization' {R S : Type _} [CommRing R] [CommRing S] {f : «expr →+* » R S} (hf : f.is_integral)\n    (M : Submonoid R) :\n    (map (localization (M.map (f : «expr →* » R S))) f (M.le_comap_map : _ ≤ Submonoid.comap (f : «expr →* » R S) _) :\n        «expr →+* » (localization M) _).is_integral :=\n  @is_integral_localization R _ M S _ f.to_algebra _ _ _ _ _ _ _ _ hf\n#align is_integral_localization' is_integral_localization'\n\n",
 "is_integral_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `R → S` is an integral extension, `M` is a submonoid of `R`,\n`Rₘ` is the localization of `R` at `M`,\nand `Sₘ` is the localization of `S` at the image of `M` under the extension map,\nthen the induced map `Rₘ → Sₘ` is also an integral extension -/\ntheorem is_integral_localization (H : algebra.is_integral R S) :\n    (map Sₘ (algebra_map R S) (show _ ≤ (algebra.algebra_map_submonoid S M).comap _ from M.le_comap_map) :\n        «expr →+* » Rₘ _).is_integral :=\n  by\n  intro x\n  obtain ⟨⟨s, ⟨u, hu⟩⟩, hx⟩ := surj (algebra.algebra_map_submonoid S M) x\n  obtain ⟨v, hv⟩ := hu\n  obtain ⟨v', hv'⟩ := isUnit_iff_exists_inv'.1 (map_units Rₘ ⟨v, hv.1⟩)\n  refine' @is_integral_of_is_integral_mul_unit Rₘ _ _ _ (localization_algebra M S) x (algebra_map S Sₘ u) v' _ _\n  · replace hv' := congr_arg (@algebra_map Rₘ Sₘ _ _ (localization_algebra M S)) hv'\n    rw [RingHom.map_mul, RingHom.map_one, ← RingHom.comp_apply _ (algebra_map R Rₘ)] at hv'\n    erw [is_localization.map_comp] at hv'\n    exact hv.2 ▸ hv'\n  · obtain ⟨p, hp⟩ := H s\n    exact hx.symm ▸ is_integral_localization_at_leading_coeff p hp.2 (hp.1.symm ▸ M.one_mem)\n#align is_integral_localization is_integral_localization\n\n",
 "is_integral_elem_localization_at_leading_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ring_hom.is_integral_elem_localization_at_leading_coeff {R S : Type _} [CommRing R] [CommRing S]\n    (f : «expr →+* » R S) (x : S) (p : polynomial R) (hf : p.eval₂ f x = 0) (M : Submonoid R) (hM : p.leading_coeff ∈ M)\n    {Rₘ Sₘ : Type _} [CommRing Rₘ] [CommRing Sₘ] [algebra R Rₘ] [is_localization M Rₘ] [algebra S Sₘ]\n    [is_localization (M.map f : Submonoid S) Sₘ] :\n    (map Sₘ f M.le_comap_map : «expr →+* » Rₘ _).is_integral_elem (algebra_map S Sₘ x) :=\n  by\n  by_cases triv : (1 : Rₘ) = 0\n  · exact ⟨0, ⟨trans leading_coeff_zero triv.symm, eval₂_zero _ _⟩⟩\n  haveI : nontrivial Rₘ := nontrivial_of_ne 1 0 triv\n  obtain ⟨b, hb⟩ := is_unit_iff_exists_inv.mp (map_units Rₘ ⟨p.leading_coeff, hM⟩)\n  refine' ⟨p.map (algebra_map R Rₘ) * C b, ⟨_, _⟩⟩\n  · refine' monic_mul_C_of_leading_coeff_mul_eq_one _\n    rwa [leading_coeff_map_of_leading_coeff_ne_zero (algebra_map R Rₘ)]\n    refine' fun hfp => zero_ne_one (trans (zero_mul b).symm (hfp ▸ hb) : (0 : Rₘ) = 1)\n  · refine' eval₂_mul_eq_zero_of_left _ _ _ _\n    erw [eval₂_map, is_localization.map_comp, ← hom_eval₂ _ f (algebra_map S Sₘ) x]\n    exact trans (congr_arg (algebra_map S Sₘ) hf) (RingHom.map_zero _)\n#align ring_hom.is_integral_elem_localization_at_leading_coeff ring_hom.is_integral_elem_localization_at_leading_coeff\n\n",
 "is_fraction_ring_of_finite_extension":
 "/-- If the field `L` is a finite extension of the fraction field of the integral domain `A`,\nthe integral closure of `A` in `L` has fraction field `L`. -/\ntheorem is_fraction_ring_of_finite_extension [algebra A L] [algebra K L] [IsScalarTower A K L]\n    [finite_dimensional K L] : is_fraction_ring (integral_closure A L) L :=\n  is_integral_closure.is_fraction_ring_of_finite_extension A K L (integral_closure A L)\n#align is_fraction_ring_of_finite_extension is_fraction_ring_of_finite_extension\n\n",
 "is_fraction_ring_of_algebraic":
 "/-- If the field `L` is an algebraic extension of the integral domain `A`,\nthe integral closure of `A` in `L` has fraction field `L`. -/\ntheorem is_fraction_ring_of_algebraic [algebra A L] (alg : is_algebraic A L)\n    (inj : ∀ x, algebra_map A L x = 0 → x = 0) : is_fraction_ring (integral_closure A L) L :=\n  is_integral_closure.is_fraction_ring_of_algebraic A (integral_closure A L) alg inj\n#align is_fraction_ring_of_algebraic is_fraction_ring_of_algebraic\n\n",
 "is_algebraic_iff'":
 "/-- `S` is algebraic over `R` iff a fraction ring of `S` is algebraic over `R` -/\ntheorem is_algebraic_iff' [Field K] [IsDomain R] [IsDomain S] [algebra R K] [algebra S K] [NoZeroSMulDivisors R K]\n    [is_fraction_ring S K] [IsScalarTower R S K] : algebra.is_algebraic R S ↔ algebra.is_algebraic R K :=\n  by\n  simp only [algebra.is_algebraic]\n  constructor\n  · intro h x\n    rw [is_fraction_ring.is_algebraic_iff R (fraction_ring R) K, is_algebraic_iff_is_integral]\n    obtain ⟨a : S, b, ha, rfl⟩ := @div_surjective S _ _ _ _ _ _ x\n    obtain ⟨f, hf₁, hf₂⟩ := h b\n    rw [div_eq_mul_inv]\n    refine' is_integral_mul _ _\n    · rw [← is_algebraic_iff_is_integral]\n      refine'\n        _root_.is_algebraic_of_larger_base_of_injective\n          (no_zero_smul_divisors.algebra_map_injective R (fraction_ring R)) _\n      exact is_algebraic_algebra_map_of_is_algebraic (h a)\n    · rw [← is_algebraic_iff_is_integral]\n      use (f.map (algebra_map R (fraction_ring R))).reverse\n      constructor\n      ·\n        rwa [ne.def, polynomial.reverse_eq_zero, ← polynomial.degree_eq_bot,\n          polynomial.degree_map_eq_of_injective (no_zero_smul_divisors.algebra_map_injective R (fraction_ring R)),\n          polynomial.degree_eq_bot]\n      · have : Invertible (algebra_map S K b) :=\n          IsUnit.invertible\n            (is_unit_of_mem_non_zero_divisors\n              (mem_non_zero_divisors_iff_ne_zero.2 fun h =>\n                non_zero_divisors.ne_zero ha\n                  ((injective_iff_map_eq_zero (algebra_map S K)).1 (no_zero_smul_divisors.algebra_map_injective _ _) b\n                    h)))\n        rw [polynomial.aeval_def, ← invOf_eq_inv, polynomial.eval₂_reverse_eq_zero_iff, polynomial.eval₂_map, ←\n          is_scalar_tower.algebra_map_eq, ← polynomial.aeval_def, polynomial.aeval_algebra_map_apply, hf₂,\n          RingHom.map_zero]\n  · intro h x\n    obtain ⟨f, hf₁, hf₂⟩ := h (algebra_map S K x)\n    use f, hf₁\n    rw [polynomial.aeval_algebra_map_apply] at hf₂\n    exact (injective_iff_map_eq_zero (algebra_map S K)).1 (no_zero_smul_divisors.algebra_map_injective _ _) _ hf₂\n#align is_algebraic_iff' is_algebraic_iff'\n\n",
 "is_algebraic_iff":
 "/-- An element of a ring is algebraic over the ring `A` iff it is algebraic\nover the field of fractions of `A`.\n-/\ntheorem is_algebraic_iff [algebra A C] [algebra K C] [IsScalarTower A K C] {x : C} :\n    is_algebraic A x ↔ is_algebraic K x :=\n  by\n  constructor <;> rintro ⟨p, hp, px⟩\n  · refine' ⟨p.map (algebra_map A K), fun h => hp (polynomial.ext fun i => _), _⟩\n    · have : algebra_map A K (p.coeff i) = 0 := trans (polynomial.coeff_map _ _).symm (by simp [h])\n      exact to_map_eq_zero_iff.mp this\n    · exact (polynomial.aeval_map_algebra_map K _ _).trans px\n  ·\n    exact\n      ⟨integer_normalization _ p, mt integer_normalization_eq_zero_iff.mp hp,\n        integer_normalization_aeval_eq_zero _ p px⟩\n#align is_algebraic_iff is_algebraic_iff\n\n",
 "integer_normalization_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem integer_normalization_spec (p : polynomial S) :\n    ∃ b : M, ∀ i, algebra_map R S ((integer_normalization M p).coeff i) = «expr • » (b : R) (p.coeff i) :=\n  by\n  use Classical.choose (exist_integer_multiples_of_finset M (p.support.image p.coeff))\n  intro i\n  rw [integer_normalization_coeff, coeff_integer_normalization]\n  split_ifs with hi\n  ·\n    exact\n      Classical.choose_spec\n        (Classical.choose_spec (exist_integer_multiples_of_finset M (p.support.image p.coeff)) (p.coeff i)\n          (finset.mem_image.mpr ⟨i, hi, rfl⟩))\n  · convert (smul_zero _).symm\n    · apply RingHom.map_zero\n    · exact not_mem_support_iff.mp hi\n#align integer_normalization_spec integer_normalization_spec\n\n",
 "integer_normalization_map_to_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem integer_normalization_map_to_map (p : polynomial S) :\n    ∃ b : M, (integer_normalization M p).map (algebra_map R S) = «expr • » (b : R) p :=\n  let ⟨b, hb⟩ := integer_normalization_spec M p\n  ⟨b,\n    polynomial.ext fun i => by\n      rw [coeff_map, coeff_smul]\n      exact hb i⟩\n#align integer_normalization_map_to_map integer_normalization_map_to_map\n\n",
 "integer_normalization_eval₂_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem integer_normalization_eval₂_eq_zero (g : «expr →+* » S R') (p : polynomial S) {x : R'} (hx : eval₂ g x p = 0) :\n    eval₂ (g.comp (algebra_map R S)) x (integer_normalization M p) = 0 :=\n  let ⟨b, hb⟩ := integer_normalization_map_to_map M p\n  trans (eval₂_map (algebra_map R S) g x).symm\n    (by rw [hb, ← is_scalar_tower.algebra_map_smul S (b : R) p, eval₂_smul, hx, mul_zero])\n#align integer_normalization_eval₂_eq_zero integer_normalization_eval₂_eq_zero\n\n",
 "integer_normalization_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem integer_normalization_eq_zero_iff {p : polynomial K} :\n    integer_normalization (non_zero_divisors A) p = 0 ↔ p = 0 :=\n  by\n  refine' polynomial.ext_iff.trans (polynomial.ext_iff.trans _).symm\n  obtain ⟨⟨b, nonzero⟩, hb⟩ := integer_normalization_spec _ p\n  constructor <;> intro h i\n  · apply to_map_eq_zero_iff.mp\n    rw [hb i, h i]\n    apply smul_zero\n    assumption\n  · have hi := h i\n    rw [polynomial.coeff_zero, ← @to_map_eq_zero_iff A _ K, hb i, algebra.smul_def] at hi\n    apply or.resolve_left (eq_zero_or_eq_zero_of_mul_eq_zero hi)\n    intro h\n    apply mem_non_zero_divisors_iff_ne_zero.mp nonzero\n    exact to_map_eq_zero_iff.mp h\n#align integer_normalization_eq_zero_iff integer_normalization_eq_zero_iff\n\n",
 "integer_normalization_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem integer_normalization_coeff (p : polynomial S) (i : ℕ) :\n    (integer_normalization M p).coeff i = coeff_integer_normalization M p i := by\n  simp (config := { contextual := true }) [integer_normalization, coeff_monomial,\n    coeff_integer_normalization_of_not_mem_support]\n#align integer_normalization_coeff integer_normalization_coeff\n\n",
 "integer_normalization_aeval_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem integer_normalization_aeval_eq_zero [algebra R R'] [algebra S R'] [IsScalarTower R S R'] (p : polynomial S)\n    {x : R'} (hx : aeval x p = 0) : aeval x (integer_normalization M p) = 0 := by\n  rw [aeval_def, is_scalar_tower.algebra_map_eq R S R', integer_normalization_eval₂_eq_zero _ _ _ hx]\n#align integer_normalization_aeval_eq_zero integer_normalization_aeval_eq_zero\n\n",
 "ideal_span_singleton_map_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If the `S`-multiples of `a` are contained in some `R`-span, then `Frac(S)`-multiples of `a`\nare contained in the equivalent `Frac(R)`-span. -/\ntheorem ideal_span_singleton_map_subset {L : Type _} [IsDomain R] [IsDomain S] [Field K] [Field L] [algebra R K]\n    [algebra R L] [algebra S L] [is_integral_closure S R L] [is_fraction_ring S L] [algebra K L] [IsScalarTower R S L]\n    [IsScalarTower R K L] {a : S} {b : set S} (alg : algebra.is_algebraic R L)\n    (inj : function.injective (algebra_map R L)) (h : (ideal.span ({a} : set S) : set S) ⊆ submodule.span R b) :\n    (ideal.span ({algebra_map S L a} : set L) : set L) ⊆ submodule.span K («expr '' » (algebra_map S L) b) :=\n  by\n  intro x hx\n  obtain ⟨x', rfl⟩ := ideal.mem_span_singleton.mp hx\n  obtain ⟨y', z', rfl⟩ := is_localization.mk'_surjective (non_zero_divisors S) x'\n  obtain ⟨y, z, hz0, yz_eq⟩ := is_integral_closure.exists_smul_eq_mul alg inj y' (non_zero_divisors.coe_ne_zero z')\n  have injRS : function.injective (algebra_map R S) :=\n    by\n    refine' function.injective.of_comp (show function.injective (algebra_map S L ∘ algebra_map R S) from _)\n    rwa [← RingHom.coe_comp, ← is_scalar_tower.algebra_map_eq]\n  have hz0' : algebra_map R S z ∈ non_zero_divisors S :=\n    map_mem_non_zero_divisors (algebra_map R S) injRS (mem_non_zero_divisors_of_ne_zero hz0)\n  have mk_yz_eq : is_localization.mk' L y' z' = is_localization.mk' L y ⟨_, hz0'⟩ :=\n    by\n    rw [algebra.smul_def, mul_comm _ y, mul_comm _ y', ← [anonymous] (algebra_map R S z) hz0'] at yz_eq\n    exact is_localization.mk'_eq_of_eq yz_eq.symm\n  suffices hy : algebra_map S L (a * y) ∈ submodule.span K («expr '' » («expr⇑ » (algebra_map S L)) b)\n  · rw [mk_yz_eq, is_fraction_ring.mk'_eq_div, [anonymous], ← is_scalar_tower.algebra_map_apply,\n      is_scalar_tower.algebra_map_apply R K L, div_eq_mul_inv, ← mul_assoc, mul_comm, ← map_inv₀, ← algebra.smul_def, ←\n      _root_.map_mul]\n    exact (submodule.span K _).smul_mem _ hy\n  refine' submodule.span_subset_span R K _ _\n  rw [submodule.span_algebra_map_image_of_tower]\n  exact submodule.mem_map_of_mem (h (ideal.mem_span_singleton.mpr ⟨y, rfl⟩))\n#align ideal_span_singleton_map_subset ideal_span_singleton_map_subset\n\n",
 "exists_multiple_integral_of_is_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_integral.exists_multiple_integral_of_is_localization [algebra Rₘ S] [IsScalarTower R Rₘ S] (x : S)\n    (hx : is_integral Rₘ x) : ∃ m : M, is_integral R («expr • » m x) :=\n  by\n  cases' subsingleton_or_nontrivial Rₘ with _ nontriv <;> skip\n  · haveI := (algebra_map Rₘ S).codomain_trivial\n    exact ⟨1, polynomial.X, polynomial.monic_X, subsingleton.elim _ _⟩\n  obtain ⟨p, hp₁, hp₂⟩ := hx\n  obtain ⟨p', hp'₁, -, hp'₂⟩ :=\n    lifts_and_nat_degree_eq_and_monic (is_localization.scale_roots_common_denom_mem_lifts M p _) _\n  · refine' ⟨is_localization.common_denom M p.support p.coeff, p', hp'₂, _⟩\n    rw [is_scalar_tower.algebra_map_eq R Rₘ S, ← polynomial.eval₂_map, hp'₁, Submonoid.smul_def, algebra.smul_def,\n      is_scalar_tower.algebra_map_apply R Rₘ S]\n    exact polynomial.scale_roots_eval₂_eq_zero _ hp₂\n  · rw [hp₁.leading_coeff]\n    exact one_mem _\n  · rwa [polynomial.monic_scale_roots_iff]\n#align is_integral.exists_multiple_integral_of_is_localization is_integral.exists_multiple_integral_of_is_localization\n\n",
 "comap_is_algebraic_iff":
 "/-- A ring is algebraic over the ring `A` iff it is algebraic over the field of fractions of `A`.\n-/\ntheorem comap_is_algebraic_iff [algebra A C] [algebra K C] [IsScalarTower A K C] :\n    algebra.is_algebraic A C ↔ algebra.is_algebraic K C :=\n  ⟨fun h x => (is_algebraic_iff A K C).mp (h x), fun h x => (is_algebraic_iff A K C).mpr (h x)⟩\n#align comap_is_algebraic_iff comap_is_algebraic_iff\n\n",
 "coeff_integer_normalization_of_not_mem_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\ntheorem coeff_integer_normalization_of_not_mem_support (p : polynomial S) (i : ℕ) (h : coeff p i = 0) :\n    coeff_integer_normalization M p i = 0 := by\n  simp only [coeff_integer_normalization, h, mem_support_iff, eq_self_iff_true, not_true, ne.def, dif_neg,\n    not_false_iff]\n#align coeff_integer_normalization_of_not_mem_support coeff_integer_normalization_of_not_mem_support\n\n",
 "coeff_integer_normalization_mem_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_integer_normalization_mem_support (p : polynomial S) (i : ℕ) (h : coeff_integer_normalization M p i ≠ 0) :\n    i ∈ p.support := by\n  contrapose h\n  rw [ne.def, not_not, coeff_integer_normalization, dif_neg h]\n#align coeff_integer_normalization_mem_support coeff_integer_normalization_mem_support\n\n"}