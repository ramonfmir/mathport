{"scale_roots_common_denom_mem_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_localization.scale_roots_common_denom_mem_lifts (p : polynomial Rₘ)\n    (hp : p.leading_coeff ∈ (algebraMap R Rₘ).range) :\n    p.scale_roots (algebraMap R Rₘ <| IsLocalization.commonDenom M p.support p.coeff) ∈\n      Polynomial.lifts (algebraMap R Rₘ) :=\n  by\n  rw [Polynomial.lifts_iff_coeff_lifts]\n  intro n\n  rw [Polynomial.coeff_scaleRoots]\n  by_cases h₁ : n ∈ p.support\n  by_cases h₂ : n = p.nat_degree\n  · rwa [h₂, Polynomial.coeff_natDegree, tsub_self, pow_zero, _root_.mul_one]\n  · have : n + 1 ≤ p.nat_degree := lt_of_le_of_ne (Polynomial.le_natDegree_of_mem_supp _ h₁) h₂\n    rw [← tsub_add_cancel_of_le (le_tsub_of_add_le_left this), pow_add, pow_one, mul_comm, _root_.mul_assoc, ← map_pow]\n    change _ ∈ (algebraMap R Rₘ).range\n    apply mul_mem\n    · exact RingHom.mem_range_self _ _\n    · rw [← Algebra.smul_def]\n      exact ⟨_, IsLocalization.map_integerMultiple M p.support p.coeff ⟨n, h₁⟩⟩\n  · rw [Polynomial.not_mem_support_iff] at h₁\n    rw [h₁, MulZeroClass.zero_mul]\n    exact zero_mem (algebraMap R Rₘ).range\n#align is_localization.scale_roots_common_denom_mem_lifts is_localization.scale_roots_common_denom_mem_lifts\n\n",
 "is_integral_localization_at_leading_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- Given a particular witness to an element being algebraic over an algebra `R → S`,\nWe can localize to a submonoid containing the leading coefficient to make it integral.\nExplicitly, the map between the localizations will be an integral ring morphism -/\ntheorem is_integral_localization_at_leading_coeff {x : S} (p : polynomial R) (hp : aeval x p = 0)\n    (hM : p.leading_coeff ∈ M) :\n    (map Sₘ (algebraMap R S) (show _ ≤ (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map) :\n          «expr →+* » Rₘ _).is_integral_elem\n      (algebraMap S Sₘ x) :=\n  (algebraMap R S).is_integral_elem_localization_at_leading_coeff x p hp M hM\n#align is_integral_localization_at_leading_coeff is_integral_localization_at_leading_coeff\n\n",
 "is_integral_localization'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_integral_localization' {R S : Type _} [CommRing R] [CommRing S] {f : «expr →+* » R S} (hf : f.is_integral)\n    (M : Submonoid R) :\n    (map (Localization (M.map (f : «expr →* » R S))) f (M.le_comap_map : _ ≤ Submonoid.comap (f : «expr →* » R S) _) :\n        «expr →+* » (Localization M) _).is_integral :=\n  @is_integral_localization R _ M S _ f.to_algebra _ _ _ _ _ _ _ _ hf\n#align is_integral_localization' is_integral_localization'\n\n",
 "is_integral_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `R → S` is an integral extension, `M` is a submonoid of `R`,\n`Rₘ` is the localization of `R` at `M`,\nand `Sₘ` is the localization of `S` at the image of `M` under the extension map,\nthen the induced map `Rₘ → Sₘ` is also an integral extension -/\ntheorem is_integral_localization (H : algebra.is_integral R S) :\n    (map Sₘ (algebraMap R S) (show _ ≤ (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map) :\n        «expr →+* » Rₘ _).is_integral :=\n  by\n  intro x\n  obtain ⟨⟨s, ⟨u, hu⟩⟩, hx⟩ := surj (Algebra.algebraMapSubmonoid S M) x\n  obtain ⟨v, hv⟩ := hu\n  obtain ⟨v', hv'⟩ := isUnit_iff_exists_inv'.1 (map_units Rₘ ⟨v, hv.1⟩)\n  refine' @is_integral_of_is_integral_mul_unit Rₘ _ _ _ (localizationAlgebra M S) x (algebraMap S Sₘ u) v' _ _\n  · replace hv' := congr_arg (@algebraMap Rₘ Sₘ _ _ (localizationAlgebra M S)) hv'\n    rw [RingHom.map_mul, RingHom.map_one, ← RingHom.comp_apply _ (algebraMap R Rₘ)] at hv'\n    erw [IsLocalization.map_comp] at hv'\n    exact hv.2 ▸ hv'\n  · obtain ⟨p, hp⟩ := H s\n    exact hx.symm ▸ is_integral_localization_at_leading_coeff p hp.2 (hp.1.symm ▸ M.one_mem)\n#align is_integral_localization is_integral_localization\n\n",
 "is_integral_elem_localization_at_leading_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ring_hom.is_integral_elem_localization_at_leading_coeff {R S : Type _} [CommRing R] [CommRing S]\n    (f : «expr →+* » R S) (x : S) (p : polynomial R) (hf : p.eval₂ f x = 0) (M : Submonoid R) (hM : p.leading_coeff ∈ M)\n    {Rₘ Sₘ : Type _} [CommRing Rₘ] [CommRing Sₘ] [Algebra R Rₘ] [IsLocalization M Rₘ] [Algebra S Sₘ]\n    [IsLocalization (M.map f : Submonoid S) Sₘ] :\n    (map Sₘ f M.le_comap_map : «expr →+* » Rₘ _).is_integral_elem (algebraMap S Sₘ x) :=\n  by\n  by_cases triv : (1 : Rₘ) = 0\n  · exact ⟨0, ⟨trans leading_coeff_zero triv.symm, eval₂_zero _ _⟩⟩\n  haveI : Nontrivial Rₘ := nontrivial_of_ne 1 0 triv\n  obtain ⟨b, hb⟩ := is_unit_iff_exists_inv.mp (map_units Rₘ ⟨p.leading_coeff, hM⟩)\n  refine' ⟨p.map (algebraMap R Rₘ) * C b, ⟨_, _⟩⟩\n  · refine' monic_mul_C_of_leading_coeff_mul_eq_one _\n    rwa [leading_coeff_map_of_leading_coeff_ne_zero (algebraMap R Rₘ)]\n    refine' fun hfp => zero_ne_one (trans (MulZeroClass.zero_mul b).symm (hfp ▸ hb) : (0 : Rₘ) = 1)\n  · refine' eval₂_mul_eq_zero_of_left _ _ _ _\n    erw [eval₂_map, IsLocalization.map_comp, ← hom_eval₂ _ f (algebraMap S Sₘ) x]\n    exact trans (congr_arg (algebraMap S Sₘ) hf) (RingHom.map_zero _)\n#align ring_hom.is_integral_elem_localization_at_leading_coeff ring_hom.is_integral_elem_localization_at_leading_coeff\n\n",
 "is_fraction_ring_of_finite_extension":
 "/-- If the field `L` is a finite extension of the fraction field of the integral domain `A`,\nthe integral closure of `A` in `L` has fraction field `L`. -/\ntheorem is_fraction_ring_of_finite_extension [Algebra A L] [Algebra K L] [IsScalarTower A K L] [FiniteDimensional K L] :\n    IsFractionRing (integral_closure A L) L :=\n  is_integral_closure.is_fraction_ring_of_finite_extension A K L (integral_closure A L)\n#align is_fraction_ring_of_finite_extension is_fraction_ring_of_finite_extension\n\n",
 "is_fraction_ring_of_algebraic":
 "/-- If the field `L` is an algebraic extension of the integral domain `A`,\nthe integral closure of `A` in `L` has fraction field `L`. -/\ntheorem is_fraction_ring_of_algebraic [Algebra A L] (alg : is_algebraic A L) (inj : ∀ x, algebraMap A L x = 0 → x = 0) :\n    IsFractionRing (integral_closure A L) L :=\n  is_integral_closure.is_fraction_ring_of_algebraic A (integral_closure A L) alg inj\n#align is_fraction_ring_of_algebraic is_fraction_ring_of_algebraic\n\n",
 "is_algebraic_iff'":
 "/-- `S` is algebraic over `R` iff a fraction ring of `S` is algebraic over `R` -/\ntheorem is_algebraic_iff' [Field K] [IsDomain R] [IsDomain S] [Algebra R K] [Algebra S K] [NoZeroSMulDivisors R K]\n    [IsFractionRing S K] [IsScalarTower R S K] : algebra.is_algebraic R S ↔ algebra.is_algebraic R K :=\n  by\n  simp only [algebra.is_algebraic]\n  constructor\n  · intro h x\n    rw [is_fraction_ring.is_algebraic_iff R (FractionRing R) K, is_algebraic_iff_is_integral]\n    obtain ⟨a : S, b, ha, rfl⟩ := @div_surjective S _ _ _ _ _ _ x\n    obtain ⟨f, hf₁, hf₂⟩ := h b\n    rw [div_eq_mul_inv]\n    refine' is_integral_mul _ _\n    · rw [← is_algebraic_iff_is_integral]\n      refine'\n        _root_.is_algebraic_of_larger_base_of_injective (NoZeroSMulDivisors.algebraMap_injective R (FractionRing R)) _\n      exact is_algebraic_algebra_map_of_is_algebraic (h a)\n    · rw [← is_algebraic_iff_is_integral]\n      use (f.map (algebraMap R (FractionRing R))).reverse\n      constructor\n      ·\n        rwa [ne.def, Polynomial.reverse_eq_zero, ← Polynomial.degree_eq_bot,\n          Polynomial.degree_map_eq_of_injective (NoZeroSMulDivisors.algebraMap_injective R (FractionRing R)),\n          Polynomial.degree_eq_bot]\n      · have : Invertible (algebraMap S K b) :=\n          IsUnit.invertible\n            (isUnit_of_mem_nonZeroDivisors\n              (mem_nonZeroDivisors_iff_ne_zero.2 fun h =>\n                nonZeroDivisors.ne_zero ha\n                  ((injective_iff_map_eq_zero (algebraMap S K)).1 (NoZeroSMulDivisors.algebraMap_injective _ _) b h)))\n        rw [Polynomial.aeval_def, ← invOf_eq_inv, Polynomial.eval₂_reverse_eq_zero_iff, Polynomial.eval₂_map, ←\n          IsScalarTower.algebraMap_eq, ← Polynomial.aeval_def, Polynomial.aeval_algebraMap_apply, hf₂, RingHom.map_zero]\n  · intro h x\n    obtain ⟨f, hf₁, hf₂⟩ := h (algebraMap S K x)\n    use f, hf₁\n    rw [Polynomial.aeval_algebraMap_apply] at hf₂\n    exact (injective_iff_map_eq_zero (algebraMap S K)).1 (NoZeroSMulDivisors.algebraMap_injective _ _) _ hf₂\n#align is_algebraic_iff' is_algebraic_iff'\n\n",
 "is_algebraic_iff":
 "/-- An element of a ring is algebraic over the ring `A` iff it is algebraic\nover the field of fractions of `A`.\n-/\ntheorem is_algebraic_iff [Algebra A C] [Algebra K C] [IsScalarTower A K C] {x : C} :\n    is_algebraic A x ↔ is_algebraic K x :=\n  by\n  constructor <;> rintro ⟨p, hp, px⟩\n  · refine' ⟨p.map (algebraMap A K), fun h => hp (Polynomial.ext fun i => _), _⟩\n    · have : algebraMap A K (p.coeff i) = 0 := trans (Polynomial.coeff_map _ _).symm (by simp [h])\n      exact to_map_eq_zero_iff.mp this\n    · exact (Polynomial.aeval_map_algebraMap K _ _).trans px\n  ·\n    exact\n      ⟨integer_normalization _ p, mt integer_normalization_eq_zero_iff.mp hp,\n        integer_normalization_aeval_eq_zero _ p px⟩\n#align is_algebraic_iff is_algebraic_iff\n\n",
 "integer_normalization_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem integer_normalization_spec (p : polynomial S) :\n    ∃ b : M, ∀ i, algebraMap R S ((integer_normalization M p).coeff i) = «expr • » (b : R) (p.coeff i) :=\n  by\n  use Classical.choose (exist_integer_multiples_of_finset M (p.support.image p.coeff))\n  intro i\n  rw [integer_normalization_coeff, coeff_integer_normalization]\n  split_ifs with hi\n  ·\n    exact\n      Classical.choose_spec\n        (Classical.choose_spec (exist_integer_multiples_of_finset M (p.support.image p.coeff)) (p.coeff i)\n          (finset.mem_image.mpr ⟨i, hi, rfl⟩))\n  · convert(smul_zero _).symm\n    · apply RingHom.map_zero\n    · exact not_mem_support_iff.mp hi\n#align integer_normalization_spec integer_normalization_spec\n\n",
 "integer_normalization_map_to_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem integer_normalization_map_to_map (p : polynomial S) :\n    ∃ b : M, (integer_normalization M p).map (algebraMap R S) = «expr • » (b : R) p :=\n  let ⟨b, hb⟩ := integer_normalization_spec M p\n  ⟨b,\n    Polynomial.ext fun i => by\n      rw [coeff_map, coeff_smul]\n      exact hb i⟩\n#align integer_normalization_map_to_map integer_normalization_map_to_map\n\n",
 "integer_normalization_eval₂_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem integer_normalization_eval₂_eq_zero (g : «expr →+* » S R') (p : polynomial S) {x : R'} (hx : eval₂ g x p = 0) :\n    eval₂ (g.comp (algebraMap R S)) x (integer_normalization M p) = 0 :=\n  let ⟨b, hb⟩ := integer_normalization_map_to_map M p\n  trans (eval₂_map (algebraMap R S) g x).symm\n    (by rw [hb, ← IsScalarTower.algebraMap_smul S (b : R) p, eval₂_smul, hx, MulZeroClass.mul_zero])\n#align integer_normalization_eval₂_eq_zero integer_normalization_eval₂_eq_zero\n\n",
 "integer_normalization_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem integer_normalization_eq_zero_iff {p : polynomial K} :\n    integer_normalization (nonZeroDivisors A) p = 0 ↔ p = 0 :=\n  by\n  refine' polynomial.ext_iff.trans (polynomial.ext_iff.trans _).symm\n  obtain ⟨⟨b, nonzero⟩, hb⟩ := integer_normalization_spec _ p\n  constructor <;> intro h i\n  · apply to_map_eq_zero_iff.mp\n    rw [hb i, h i]\n    apply smul_zero\n    assumption\n  · have hi := h i\n    rw [Polynomial.coeff_zero, ← @to_map_eq_zero_iff A _ K, hb i, Algebra.smul_def] at hi\n    apply or.resolve_left (eq_zero_or_eq_zero_of_mul_eq_zero hi)\n    intro h\n    apply mem_non_zero_divisors_iff_ne_zero.mp nonzero\n    exact to_map_eq_zero_iff.mp h\n#align integer_normalization_eq_zero_iff integer_normalization_eq_zero_iff\n\n",
 "integer_normalization_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem integer_normalization_coeff (p : polynomial S) (i : ℕ) :\n    (integer_normalization M p).coeff i = coeff_integer_normalization M p i := by\n  simp (config := { contextual := true }) [integer_normalization, coeff_monomial,\n    coeff_integer_normalization_of_not_mem_support]\n#align integer_normalization_coeff integer_normalization_coeff\n\n",
 "integer_normalization_aeval_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem integer_normalization_aeval_eq_zero [Algebra R R'] [Algebra S R'] [IsScalarTower R S R'] (p : polynomial S)\n    {x : R'} (hx : aeval x p = 0) : aeval x (integer_normalization M p) = 0 := by\n  rw [aeval_def, IsScalarTower.algebraMap_eq R S R', integer_normalization_eval₂_eq_zero _ _ _ hx]\n#align integer_normalization_aeval_eq_zero integer_normalization_aeval_eq_zero\n\n",
 "ideal_span_singleton_map_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If the `S`-multiples of `a` are contained in some `R`-span, then `Frac(S)`-multiples of `a`\nare contained in the equivalent `Frac(R)`-span. -/\ntheorem ideal_span_singleton_map_subset {L : Type _} [IsDomain R] [IsDomain S] [Field K] [Field L] [Algebra R K]\n    [Algebra R L] [Algebra S L] [is_integral_closure S R L] [IsFractionRing S L] [Algebra K L] [IsScalarTower R S L]\n    [IsScalarTower R K L] {a : S} {b : Set S} (alg : algebra.is_algebraic R L)\n    (inj : function.injective (algebraMap R L)) (h : (Ideal.span ({a} : Set S) : Set S) ⊆ Submodule.span R b) :\n    (Ideal.span ({algebraMap S L a} : Set L) : Set L) ⊆ Submodule.span K («expr '' » (algebraMap S L) b) :=\n  by\n  intro x hx\n  obtain ⟨x', rfl⟩ := ideal.mem_span_singleton.mp hx\n  obtain ⟨y', z', rfl⟩ := IsLocalization.mk'_surjective (non_zero_divisors S) x'\n  obtain ⟨y, z, hz0, yz_eq⟩ := is_integral_closure.exists_smul_eq_mul alg inj y' (nonZeroDivisors.coe_ne_zero z')\n  have injRS : function.injective (algebraMap R S) :=\n    by\n    refine' Function.Injective.of_comp (show function.injective (algebraMap S L ∘ algebraMap R S) from _)\n    rwa [← RingHom.coe_comp, ← IsScalarTower.algebraMap_eq]\n  have hz0' : algebraMap R S z ∈ non_zero_divisors S :=\n    map_mem_nonZeroDivisors (algebraMap R S) injRS (mem_nonZeroDivisors_of_ne_zero hz0)\n  have mk_yz_eq : IsLocalization.mk' L y' z' = IsLocalization.mk' L y ⟨_, hz0'⟩ :=\n    by\n    rw [Algebra.smul_def, mul_comm _ y, mul_comm _ y', ← [anonymous] (algebraMap R S z) hz0'] at yz_eq\n    exact IsLocalization.mk'_eq_of_eq (by rw [mul_comm _ y, mul_comm _ y', yz_eq])\n  suffices hy : algebraMap S L (a * y) ∈ Submodule.span K («expr '' » («expr⇑ » (algebraMap S L)) b)\n  · rw [mk_yz_eq, IsFractionRing.mk'_eq_div, [anonymous], ← IsScalarTower.algebraMap_apply,\n      IsScalarTower.algebraMap_apply R K L, div_eq_mul_inv, ← mul_assoc, mul_comm, ← map_inv₀, ← Algebra.smul_def, ←\n      _root_.map_mul]\n    exact (Submodule.span K _).smul_mem _ hy\n  refine' Submodule.span_subset_span R K _ _\n  rw [Submodule.span_algebraMap_image_of_tower]\n  exact Submodule.mem_map_of_mem (h (ideal.mem_span_singleton.mpr ⟨y, rfl⟩))\n#align ideal_span_singleton_map_subset ideal_span_singleton_map_subset\n\n",
 "exists_multiple_integral_of_is_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_integral.exists_multiple_integral_of_is_localization [Algebra Rₘ S] [IsScalarTower R Rₘ S] (x : S)\n    (hx : is_integral Rₘ x) : ∃ m : M, is_integral R («expr • » m x) :=\n  by\n  cases' subsingleton_or_nontrivial Rₘ with _ nontriv <;> skip\n  · haveI := (algebraMap Rₘ S).codomain_trivial\n    exact ⟨1, Polynomial.X, Polynomial.monic_X, subsingleton.elim _ _⟩\n  obtain ⟨p, hp₁, hp₂⟩ := hx\n  obtain ⟨p', hp'₁, -, hp'₂⟩ :=\n    lifts_and_nat_degree_eq_and_monic (is_localization.scale_roots_common_denom_mem_lifts M p _) _\n  · refine' ⟨IsLocalization.commonDenom M p.support p.coeff, p', hp'₂, _⟩\n    rw [IsScalarTower.algebraMap_eq R Rₘ S, ← Polynomial.eval₂_map, hp'₁, Submonoid.smul_def, Algebra.smul_def,\n      IsScalarTower.algebraMap_apply R Rₘ S]\n    exact Polynomial.scaleRoots_eval₂_eq_zero _ hp₂\n  · rw [hp₁.leading_coeff]\n    exact one_mem _\n  · rwa [Polynomial.monic_scaleRoots_iff]\n#align is_integral.exists_multiple_integral_of_is_localization is_integral.exists_multiple_integral_of_is_localization\n\n",
 "comap_is_algebraic_iff":
 "/-- A ring is algebraic over the ring `A` iff it is algebraic over the field of fractions of `A`.\n-/\ntheorem comap_is_algebraic_iff [Algebra A C] [Algebra K C] [IsScalarTower A K C] :\n    algebra.is_algebraic A C ↔ algebra.is_algebraic K C :=\n  ⟨fun h x => (is_algebraic_iff A K C).mp (h x), fun h x => (is_algebraic_iff A K C).mpr (h x)⟩\n#align comap_is_algebraic_iff comap_is_algebraic_iff\n\n",
 "coeff_integer_normalization_of_not_mem_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\ntheorem coeff_integer_normalization_of_not_mem_support (p : polynomial S) (i : ℕ) (h : coeff p i = 0) :\n    coeff_integer_normalization M p i = 0 := by\n  simp only [coeff_integer_normalization, h, mem_support_iff, eq_self_iff_true, not_true, ne.def, dif_neg,\n    not_false_iff]\n#align coeff_integer_normalization_of_not_mem_support coeff_integer_normalization_of_not_mem_support\n\n",
 "coeff_integer_normalization_mem_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_integer_normalization_mem_support (p : polynomial S) (i : ℕ) (h : coeff_integer_normalization M p i ≠ 0) :\n    i ∈ p.support := by\n  contrapose h\n  rw [ne.def, Classical.not_not, coeff_integer_normalization, dif_neg h]\n#align coeff_integer_normalization_mem_support coeff_integer_normalization_mem_support\n\n"}