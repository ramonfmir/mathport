{"to_map_mem_maximal_iff":
 "-- Can't use typeclasses to infer the `local_ring` instance, so use an `opt_param` instead\n-- (since `local_ring` is a `Prop`, there should be no unification issues.)\ntheorem to_map_mem_maximal_iff (x : R) (h : _root_.local_ring S := local_ring S I) :\n    algebraMap R S x ∈ local_ring.maximal_ideal S ↔ x ∈ I :=\n  not_iff_not.mp <| by\n    simpa only [local_ring.mem_maximal_ideal, mem_nonunits_iff, Classical.not_not] using is_unit_to_map_iff S I x\n#align to_map_mem_maximal_iff to_map_mem_maximal_iff\n\n",
 "prime_compl_le_non_zero_divisors":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\ntheorem prime_compl_le_non_zero_divisors [NoZeroDivisors R] : I.prime_compl ≤ nonZeroDivisors R :=\n  le_nonZeroDivisors_of_noZeroDivisors <| not_not_intro I.zero_mem\n#align prime_compl_le_non_zero_divisors prime_compl_le_non_zero_divisors\n\n",
 "nontrivial":
 "theorem at_prime.nontrivial [is_localization.at_prime S I] : Nontrivial S :=\n  nontrivial_of_ne (0 : S) 1 fun hze =>\n    by\n    rw [← (algebraMap R S).map_one, ← (algebraMap R S).map_zero] at hze\n    obtain ⟨t, ht⟩ := (eq_iff_exists I.prime_compl S).1 hze\n    have htz : (t : R) = 0 := by simpa using ht.symm\n    exact t.2 (htz.symm ▸ I.zero_mem : ↑t ∈ I)\n#align at_prime.nontrivial at_prime.nontrivial\n\n",
 "mk'_mem_maximal_iff":
 "theorem mk'_mem_maximal_iff (x : R) (y : I.prime_compl) (h : _root_.local_ring S := local_ring S I) :\n    mk' S x y ∈ local_ring.maximal_ideal S ↔ x ∈ I :=\n  not_iff_not.mp <| by\n    simpa only [local_ring.mem_maximal_ideal, mem_nonunits_iff, Classical.not_not] using is_unit_mk'_iff S I x y\n#align mk'_mem_maximal_iff mk'_mem_maximal_iff\n\n",
 "map_eq_maximal_ideal":
 "/-- The image of `I` in the localization at `I.prime_compl` is a maximal ideal, and in particular\nit is the unique maximal ideal given by the local ring structure `at_prime.local_ring` -/\ntheorem at_prime.map_eq_maximal_ideal :\n    Ideal.map (algebraMap R (localization.at_prime I)) I = local_ring.maximal_ideal (Localization I.prime_compl) :=\n  by\n  convert congr_arg (Ideal.map _) at_prime.comap_maximal_ideal.symm\n  rw [map_comap I.prime_compl]\n#align at_prime.map_eq_maximal_ideal at_prime.map_eq_maximal_ideal\n\n",
 "local_ring_hom_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem local_ring_hom_unique (J : Ideal P) [hJ : J.is_prime] (f : «expr →+* » R P) (hIJ : I = J.comap f)\n    {j : «expr →+* » (localization.at_prime I) (localization.at_prime J)}\n    (hj : ∀ x : R, j (algebraMap _ _ x) = algebraMap _ _ (f x)) : local_ring_hom I J f hIJ = j :=\n  map_unique _ _ hj\n#align local_ring_hom_unique local_ring_hom_unique\n\n",
 "local_ring_hom_to_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem local_ring_hom_to_map (J : Ideal P) [hJ : J.is_prime] (f : «expr →+* » R P) (hIJ : I = J.comap f) (x : R) :\n    local_ring_hom I J f hIJ (algebraMap _ _ x) = algebraMap _ _ (f x) :=\n  map_eq _ _\n#align local_ring_hom_to_map local_ring_hom_to_map\n\n",
 "local_ring_hom_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem local_ring_hom_mk' (J : Ideal P) [hJ : J.is_prime] (f : «expr →+* » R P) (hIJ : I = J.comap f) (x : R)\n    (y : I.prime_compl) :\n    local_ring_hom I J f hIJ (IsLocalization.mk' _ x y) =\n      IsLocalization.mk' (localization.at_prime J) (f x)\n        (⟨f y, le_comap_prime_compl_iff.mpr (ge_of_eq hIJ) y.2⟩ : J.prime_compl) :=\n  map_mk' _ _ _\n#align local_ring_hom_mk' local_ring_hom_mk'\n\n",
 "local_ring_hom_id":
 "@[simp]\ntheorem local_ring_hom_id : local_ring_hom I I (RingHom.id R) (Ideal.comap_id I).symm = RingHom.id _ :=\n  local_ring_hom_unique _ _ _ _ fun x => rfl\n#align local_ring_hom_id local_ring_hom_id\n\n",
 "local_ring_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem local_ring_hom_comp {S : Type _} [CommSemiring S] (J : Ideal S) [hJ : J.is_prime] (K : Ideal P)\n    [hK : K.is_prime] (f : «expr →+* » R S) (hIJ : I = J.comap f) (g : «expr →+* » S P) (hJK : J = K.comap g) :\n    local_ring_hom I K (g.comp f) (by rw [hIJ, hJK, Ideal.comap_comap f g]) =\n      (local_ring_hom J K g hJK).comp (local_ring_hom I J f hIJ) :=\n  local_ring_hom_unique _ _ _ _ fun r => by simp only [Function.comp_apply, RingHom.coe_comp, local_ring_hom_to_map]\n#align local_ring_hom_comp local_ring_hom_comp\n\n",
 "local_ring":
 "theorem at_prime.local_ring [is_localization.at_prime S I] : local_ring S :=\n  local_ring.of_nonunits_add\n    (by\n      intro x y hx hy hu\n      cases' isUnit_iff_exists_inv.1 hu with z hxyz\n      have : ∀ {r : R} {s : I.prime_compl}, mk' S r s ∈ nonunits S → r ∈ I := fun (r : R) (s : I.prime_compl) =>\n        not_imp_comm.1 fun nr =>\n          isUnit_iff_exists_inv.2 ⟨mk' S ↑s (⟨r, nr⟩ : I.prime_compl), mk'_mul_mk'_eq_one' _ _ nr⟩\n      rcases mk'_surjective I.prime_compl x with ⟨rx, sx, hrx⟩\n      rcases mk'_surjective I.prime_compl y with ⟨ry, sy, hry⟩\n      rcases mk'_surjective I.prime_compl z with ⟨rz, sz, hrz⟩\n      rw [← hrx, ← hry, ← hrz, ← mk'_add, ← mk'_mul, ← mk'_self S I.prime_compl.one_mem] at hxyz\n      rw [← hrx] at hx\n      rw [← hry] at hy\n      obtain ⟨t, ht⟩ := IsLocalization.eq.1 hxyz\n      simp only [mul_one, one_mul, Submonoid.coe_mul, Subtype.coe_mk] at ht\n      suffices : ↑t * (↑sx * ↑sy * ↑sz) ∈ I\n      exact\n        not_or_of_not (mt hp.mem_or_mem <| not_or_of_not sx.2 sy.2) sz.2\n          (hp.mem_or_mem <| (hp.mem_or_mem this).resolve_left t.2)\n      rw [← ht]\n      exact\n        I.mul_mem_left _ (I.mul_mem_right _ (I.add_mem (I.mul_mem_right _ <| this hx) (I.mul_mem_right _ <| this hy))))\n#align at_prime.local_ring at_prime.local_ring\n\n",
 "le_comap_prime_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem le_comap_prime_compl_iff {J : Ideal P} [hJ : J.is_prime] {f : «expr →+* » R P} :\n    I.prime_compl ≤ J.prime_compl.comap f ↔ J.comap f ≤ I :=\n  ⟨fun h x hx => by\n    contrapose! hx\n    exact h hx, fun h x hx hfxJ => hx (h hfxJ)⟩\n#align le_comap_prime_compl_iff le_comap_prime_compl_iff\n\n",
 "is_unit_to_map_iff":
 "theorem is_unit_to_map_iff (x : R) : IsUnit ((algebraMap R S) x) ↔ x ∈ I.prime_compl :=\n  ⟨fun h hx =>\n    (isPrime_of_isPrime_disjoint I.prime_compl S I hI disjoint_compl_left).ne_top <|\n      (Ideal.map (algebraMap R S) I).eq_top_of_is_unit_mem (Ideal.mem_map_of_mem _ hx) h,\n    fun h => map_units S ⟨x, h⟩⟩\n#align is_unit_to_map_iff is_unit_to_map_iff\n\n",
 "is_unit_mk'_iff":
 "theorem is_unit_mk'_iff (x : R) (y : I.prime_compl) : IsUnit (mk' S x y) ↔ x ∈ I.prime_compl :=\n  ⟨fun h hx => mk'_mem_iff.mpr ((to_map_mem_maximal_iff S I x).mpr hx) h, fun h =>\n    isUnit_iff_exists_inv.mpr ⟨mk' S ↑y ⟨x, h⟩, mk'_mul_mk'_eq_one ⟨x, h⟩ y⟩⟩\n#align is_unit_mk'_iff is_unit_mk'_iff\n\n",
 "comap_maximal_ideal":
 "/-- The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. -/\ntheorem at_prime.comap_maximal_ideal :\n    Ideal.comap (algebraMap R (localization.at_prime I)) (local_ring.maximal_ideal (Localization I.prime_compl)) = I :=\n  at_prime.comap_maximal_ideal _ _\n#align at_prime.comap_maximal_ideal at_prime.comap_maximal_ideal\n\n"}