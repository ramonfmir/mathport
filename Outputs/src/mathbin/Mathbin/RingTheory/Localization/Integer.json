{"map_integer_multiple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem map_integer_multiple {ι : Type _} (s : Finset ι) (f : ι → S) (i : s) :\n    algebraMap R S (integerMultiple M s f i) = «expr • » (commonDenom M s f) (f i) :=\n  ((exist_integer_multiples M s f).some_spec _ i.prop).some_spec\n#align map_integer_multiple map_integer_multiple\n\n",
 "is_integer_zero":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\n-- TODO: define a subalgebra of `is_integer`s\ntheorem is_integer_zero : IsInteger R (0 : S) :=\n  Subring.zero_mem _\n#align is_integer_zero is_integer_zero\n\n",
 "is_integer_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_integer_smul {a : R} {b : S} (hb : IsInteger R b) : IsInteger R («expr • » a b) :=\n  by\n  rcases hb with ⟨b', hb⟩\n  use a * b'\n  rw [← hb, (algebraMap R S).map_mul, Algebra.smul_def]\n#align is_integer_smul is_integer_smul\n\n",
 "is_integer_one":
 "theorem is_integer_one : IsInteger R (1 : S) :=\n  Subring.one_mem _\n#align is_integer_one is_integer_one\n\n",
 "is_integer_mul":
 "theorem is_integer_mul {a b : S} (ha : IsInteger R a) (hb : IsInteger R b) : IsInteger R (a * b) :=\n  Subring.mul_mem _ ha hb\n#align is_integer_mul is_integer_mul\n\n",
 "is_integer_add":
 "theorem is_integer_add {a b : S} (ha : IsInteger R a) (hb : IsInteger R b) : IsInteger R (a + b) :=\n  Subring.add_mem _ ha hb\n#align is_integer_add is_integer_add\n\n",
 "finset_integer_multiple_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem finset_integer_multiple_image [DecidableEq R] (s : Finset S) :\n    «expr '' » (algebraMap R S) (finsetIntegerMultiple M s) = «expr • » (commonDenomOfFinset M s) s :=\n  by\n  delta finset_integer_multiple common_denom\n  rw [Finset.coe_image]\n  ext\n  constructor\n  · rintro ⟨_, ⟨x, -, rfl⟩, rfl⟩\n    rw [map_integer_multiple]\n    exact Set.mem_image_of_mem _ x.prop\n  · rintro ⟨x, hx, rfl⟩\n    exact ⟨_, ⟨⟨x, hx⟩, s.mem_attach _, rfl⟩, map_integer_multiple M s id _⟩\n#align finset_integer_multiple_image finset_integer_multiple_image\n\n",
 "exists_integer_multiple'":
 "/-- Each element `a : S` has an `M`-multiple which is an integer.\n\nThis version multiplies `a` on the right, matching the argument order in `localization_map.surj`.\n-/\ntheorem exists_integer_multiple' (a : S) : ∃ b : M, IsInteger R (a * algebraMap R S b) :=\n  let ⟨⟨Num, denom⟩, h⟩ := is_localization.surj _ a\n  ⟨denom, Set.mem_range.mpr ⟨Num, h.symm⟩⟩\n#align exists_integer_multiple' exists_integer_multiple'\n\n",
 "exists_integer_multiple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Each element `a : S` has an `M`-multiple which is an integer.\n\nThis version multiplies `a` on the left, matching the argument order in the `has_smul` instance.\n-/\ntheorem exists_integer_multiple (a : S) : ∃ b : M, IsInteger R («expr • » (b : R) a) :=\n  by\n  simp_rw [Algebra.smul_def, mul_comm _ a]\n  apply exists_integer_multiple'\n#align exists_integer_multiple exists_integer_multiple\n\n",
 "exist_integer_multiples_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- We can clear the denominators of a finite set of fractions. -/\ntheorem exist_integer_multiples_of_finset (s : Finset S) : ∃ b : M, ∀ a ∈ s, IsInteger R («expr • » (b : R) a) :=\n  exist_integer_multiples M s id\n#align exist_integer_multiples_of_finset exist_integer_multiples_of_finset\n\n",
 "exist_integer_multiples_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- We can clear the denominators of a finite indexed family of fractions. -/\ntheorem exist_integer_multiples_of_finite {ι : Type _} [Finite ι] (f : ι → S) :\n    ∃ b : M, ∀ i, IsLocalization.IsInteger R («expr • » (b : R) (f i)) :=\n  by\n  cases nonempty_fintype ι\n  obtain ⟨b, hb⟩ := exist_integer_multiples M Finset.univ f\n  exact ⟨b, fun i => hb i (Finset.mem_univ _)⟩\n#align exist_integer_multiples_of_finite exist_integer_multiples_of_finite\n\n",
 "exist_integer_multiples":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- We can clear the denominators of a `finset`-indexed family of fractions. -/\ntheorem exist_integer_multiples {ι : Type _} (s : Finset ι) (f : ι → S) :\n    ∃ b : M, ∀ i ∈ s, IsLocalization.IsInteger R («expr • » (b : R) (f i)) :=\n  by\n  haveI := classical.prop_decidable\n  refine'\n    ⟨finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (sec M (f i)).2,\n      fun i hi => ⟨_, _⟩⟩\n  ·\n    exact\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.erase i)\n          (sec M (f j)).2 *\n        (sec M (f i)).1\n  rw [RingHom.map_mul, sec_spec', ← mul_assoc, ← (algebraMap R S).map_mul, ← Algebra.smul_def]\n  congr 2\n  refine' trans _ ((Submonoid.subtype M).map_prod _ _).symm\n  rw [mul_comm, ← Finset.prod_insert (s.not_mem_erase i), Finset.insert_erase hi]\n  rfl\n#align exist_integer_multiples exist_integer_multiples\n\n"}