{"mem_localization_localization_submodule":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\n-- This should only be defined when `S` is the localization `M⁻¹R`, hence the nolint.\n@[simp]\ntheorem mem_localization_localization_submodule {x : R} :\n    x ∈ localization_localization_submodule M N ↔ ∃ (y : N)(z : M), algebraMap R S x = y * algebraMap R S z :=\n  by\n  rw [localization_localization_submodule, Submonoid.mem_comap, Submonoid.mem_sup]\n  constructor\n  · rintro ⟨y, hy, _, ⟨z, hz, rfl⟩, e⟩\n    exact ⟨⟨y, hy⟩, ⟨z, hz⟩, e.symm⟩\n  · rintro ⟨y, z, e⟩\n    exact ⟨y, y.prop, _, ⟨z, z.prop, rfl⟩, e.symm⟩\n#align mem_localization_localization_submodule mem_localization_localization_submodule\n\n",
 "localization_localization_surj":
 "theorem localization_localization_surj [IsLocalization N T] (x : T) :\n    ∃ y : R × localization_localization_submodule M N, x * algebraMap R T y.2 = algebraMap R T y.1 :=\n  by\n  rcases is_localization.surj N x with ⟨⟨y, s⟩, eq₁⟩\n  -- x = y / s\n  rcases is_localization.surj M y with ⟨⟨z, t⟩, eq₂⟩\n  -- y = z / t\n  rcases is_localization.surj M (s : S) with ⟨⟨z', t'⟩, eq₃⟩\n  -- s = z' / t'\n  dsimp only at eq₁ eq₂ eq₃\n  use z * t'; use z' * t\n  -- x = y / s = (z * t') / (z' * t)\n  · rw [mem_localization_localization_submodule]\n    refine' ⟨s, t * t', _⟩\n    rw [RingHom.map_mul, ← eq₃, mul_assoc, ← RingHom.map_mul, mul_comm t, Submonoid.coe_mul]\n  · simp only [Subtype.coe_mk, RingHom.map_mul, IsScalarTower.algebraMap_apply R S T, ← eq₃, ← eq₂, ← eq₁]\n    ring\n#align localization_localization_surj localization_localization_surj\n\n",
 "localization_localization_map_units":
 "theorem localization_localization_map_units [IsLocalization N T] (y : localization_localization_submodule M N) :\n    IsUnit (algebraMap R T y) :=\n  by\n  obtain ⟨y', z, eq⟩ := mem_localization_localization_submodule.mp y.prop\n  rw [IsScalarTower.algebraMap_apply R S T, Eq, RingHom.map_mul, IsUnit.mul_iff]\n  exact ⟨is_localization.map_units T y', (is_localization.map_units _ z).map (algebraMap S T)⟩\n#align localization_localization_map_units localization_localization_map_units\n\n",
 "localization_localization_is_localization_of_has_all_units":
 "/-- Given submodules `M ⊆ R` and `N ⊆ S = M⁻¹R`, with `f : R →+* S` the localization map, if\n`N` contains all the units of `S`, then `N ⁻¹ S = T = (f⁻¹ N) ⁻¹ R`. I.e., the localization of a\nlocalization is a localization.\n-/\ntheorem localization_localization_is_localization_of_has_all_units [IsLocalization N T]\n    (H : ∀ x : S, IsUnit x → x ∈ N) : IsLocalization (N.comap (algebraMap R S)) T :=\n  by\n  convert localization_localization_is_localization M N T\n  symm\n  rw [sup_eq_left]\n  rintro _ ⟨x, hx, rfl⟩\n  exact H _ (is_localization.map_units _ ⟨x, hx⟩)\n#align localization_localization_is_localization_of_has_all_units localization_localization_is_localization_of_has_all_units\n\n",
 "localization_localization_is_localization":
 "/-- Given submodules `M ⊆ R` and `N ⊆ S = M⁻¹R`, with `f : R →+* S` the localization map, we have\n`N ⁻¹ S = T = (f⁻¹ (N • f(M))) ⁻¹ R`. I.e., the localization of a localization is a localization.\n-/\ntheorem localization_localization_is_localization [IsLocalization N T] :\n    IsLocalization (localization_localization_submodule M N) T :=\n  { map_units := localization_localization_map_units M N T\n    surj := localization_localization_surj M N T\n    eq_iff_exists := localization_localization_eq_iff_exists M N T }\n#align localization_localization_is_localization localization_localization_is_localization\n\n",
 "localization_localization_eq_iff_exists":
 "theorem localization_localization_eq_iff_exists [IsLocalization N T] (x y : R) :\n    algebraMap R T x = algebraMap R T y ↔ ∃ c : localization_localization_submodule M N, ↑c * x = ↑c * y :=\n  by\n  rw [IsScalarTower.algebraMap_apply R S T, IsScalarTower.algebraMap_apply R S T, is_localization.eq_iff_exists N T]\n  constructor\n  · rintro ⟨z, eq₁⟩\n    rcases is_localization.surj M (z : S) with ⟨⟨z', s⟩, eq₂⟩\n    dsimp only at eq₂\n    obtain ⟨c, eq₃ : ↑c * (x * z') = ↑c * (y * z')⟩ := (is_localization.eq_iff_exists M S).mp _\n    swap\n    · rw [map_mul, map_mul, ← eq₂, ← mul_assoc, ← mul_assoc, mul_comm _ ↑z, eq₁, mul_comm _ ↑z]\n    use c * z'\n    · rw [mem_localization_localization_submodule]\n      refine' ⟨z, c * s, _⟩\n      rw [map_mul, ← eq₂, Submonoid.coe_mul, map_mul, mul_left_comm]\n    · rwa [mul_comm _ z', mul_comm _ z', ← mul_assoc, ← mul_assoc] at eq₃\n  · rintro ⟨⟨c, hc⟩, eq₁ : c * x = c * y⟩\n    rw [mem_localization_localization_submodule] at hc\n    rcases hc with ⟨z₁, z, eq₂⟩\n    use z₁\n    refine' (is_localization.map_units S z).mul_right_inj.mp _\n    rw [← mul_assoc, mul_comm _ ↑z₁, ← eq₂, ← map_mul, eq₁, map_mul, eq₂, ← mul_assoc, mul_comm _ ↑z₁]\n#align localization_localization_eq_iff_exists localization_localization_eq_iff_exists\n\n",
 "localization_is_scalar_tower_of_submonoid_le":
 "/-- If `M ≤ N` are submonoids of `R`, then the natural map `M⁻¹S →+* N⁻¹S` commutes with the\nlocalization maps -/\ntheorem localization_is_scalar_tower_of_submonoid_le (M N : Submonoid R) (h : M ≤ N) [IsLocalization M S]\n    [IsLocalization N T] : @IsScalarTower R S T _ (localization_algebra_of_submonoid_le S T M N h).to_has_smul _ :=\n  letI := localization_algebra_of_submonoid_le S T M N h\n  IsScalarTower.of_algebraMap_eq' (IsLocalization.lift_comp _).symm\n#align localization_is_scalar_tower_of_submonoid_le localization_is_scalar_tower_of_submonoid_le\n\n",
 "is_localization_of_submonoid_le":
 "/-- If `M ≤ N` are submonoids of `R`, then `N⁻¹S` is also the localization of `M⁻¹S` at `N`. -/\ntheorem is_localization_of_submonoid_le (M N : Submonoid R) (h : M ≤ N) [IsLocalization M S] [IsLocalization N T]\n    [Algebra S T] [IsScalarTower R S T] : IsLocalization (N.map (algebraMap R S)) T :=\n  { map_units := by\n      rintro ⟨_, ⟨y, hy, rfl⟩⟩\n      convert is_localization.map_units T ⟨y, hy⟩\n      exact (IsScalarTower.algebraMap_apply _ _ _ _).symm\n    surj := fun y => by\n      obtain ⟨⟨x, s⟩, e⟩ := is_localization.surj N y\n      refine' ⟨⟨algebraMap _ _ x, _, _, s.prop, rfl⟩, _⟩\n      simpa [← IsScalarTower.algebraMap_apply] using e\n    eq_iff_exists := fun x₁ x₂ => by\n      obtain ⟨⟨y₁, s₁⟩, e₁⟩ := is_localization.surj M x₁\n      obtain ⟨⟨y₂, s₂⟩, e₂⟩ := is_localization.surj M x₂\n      refine' iff.trans _ (Set.exists_image_iff (algebraMap R S) N fun c => c * x₁ = c * x₂).symm\n      dsimp only at e₁ e₂⊢\n      suffices\n        algebraMap R T (y₁ * s₂) = algebraMap R T (y₂ * s₁) ↔\n          ∃ a : N, algebraMap R S (a * (y₁ * s₂)) = algebraMap R S (a * (y₂ * s₁))\n        by\n        have h₁ := (is_localization.map_units T ⟨_, h s₁.prop⟩).mul_left_inj\n        have h₂ := (is_localization.map_units T ⟨_, h s₂.prop⟩).mul_left_inj\n        simp only [IsScalarTower.algebraMap_apply R S T, Subtype.coe_mk] at h₁ h₂\n        simp only [IsScalarTower.algebraMap_apply R S T, map_mul, ← e₁, ← e₂, ← mul_assoc,\n          mul_right_comm _ (algebraMap R S s₂), mul_right_comm _ (algebraMap S T (algebraMap R S s₂)),\n          (is_localization.map_units S s₁).mul_left_inj, (is_localization.map_units S s₂).mul_left_inj] at this\n        rw [h₂, h₁] at this\n        simpa only [mul_comm] using this\n      simp_rw [is_localization.eq_iff_exists N T, is_localization.eq_iff_exists M S]\n      constructor\n      · rintro ⟨a, e⟩\n        exact ⟨a, 1, by convert e using 1 <;> simp <;> ring⟩\n      · rintro ⟨a, b, e⟩\n        exact ⟨a * (⟨_, h b.prop⟩ : N), by convert e using 1 <;> simp <;> ring⟩ }\n#align is_localization_of_submonoid_le is_localization_of_submonoid_le\n\n",
 "is_localization_of_is_exists_mul_mem":
 "/-- If `M ≤ N` are submonoids of `R` such that `∀ x : N, ∃ m : R, m * x ∈ M`, then the\nlocalization at `N` is equal to the localizaton of `M`. -/\ntheorem is_localization_of_is_exists_mul_mem (M N : Submonoid R) [IsLocalization M S] (h : M ≤ N)\n    (h' : ∀ x : N, ∃ m : R, m * x ∈ M) : IsLocalization N S :=\n  { map_units := fun y => by\n      obtain ⟨m, hm⟩ := h' y\n      have := is_localization.map_units S ⟨_, hm⟩\n      erw [map_mul] at this\n      exact (is_unit.mul_iff.mp this).2\n    surj := fun z => by\n      obtain ⟨⟨y, s⟩, e⟩ := is_localization.surj M z\n      exact ⟨⟨y, _, h s.prop⟩, e⟩\n    eq_iff_exists := fun x₁ x₂ => by\n      rw [is_localization.eq_iff_exists M]\n      refine' ⟨fun ⟨x, hx⟩ => ⟨⟨_, h x.prop⟩, hx⟩, _⟩\n      rintro ⟨x, h⟩\n      obtain ⟨m, hm⟩ := h' x\n      refine' ⟨⟨_, hm⟩, _⟩\n      simp [h, mul_assoc] }\n#align is_localization_of_is_exists_mul_mem is_localization_of_is_exists_mul_mem\n\n",
 "is_localization_is_localization_at_prime_is_localization":
 "/-- Given a submodule `M ⊆ R` and a prime ideal `p` of `S = M⁻¹R`, with `f : R →+* S` the localization\nmap, then `T = Sₚ` is the localization of `R` at `f⁻¹(p)`.\n-/\ntheorem is_localization_is_localization_at_prime_is_localization (p : Ideal S) [Hp : p.is_prime]\n    [is_localization.at_prime T p] : is_localization.at_prime T (p.comap (algebraMap R S)) :=\n  by\n  apply localization_localization_is_localization_of_has_all_units M p.prime_compl T\n  intro x hx hx'\n  exact (Hp.1 : ¬_) (p.eq_top_of_is_unit_mem hx' hx)\n#align is_localization_is_localization_at_prime_is_localization is_localization_is_localization_at_prime_is_localization\n\n",
 "is_fraction_ring_of_is_localization":
 "theorem is_fraction_ring_of_is_localization (S T : Type _) [CommRing S] [CommRing T] [Algebra R S] [Algebra R T]\n    [Algebra S T] [IsScalarTower R S T] [IsLocalization M S] [IsFractionRing R T] (hM : M ≤ nonZeroDivisors R) :\n    IsFractionRing S T := by\n  have := is_localization_of_submonoid_le S T M (nonZeroDivisors R) _\n  refine' @is_localization_of_is_exists_mul_mem _ _ _ _ _ _ this _ _\n  · exact map_non_zero_divisors_le M S\n  · rintro ⟨x, hx⟩\n    obtain ⟨⟨y, s⟩, e⟩ := is_localization.surj M x\n    use algebraMap R S s\n    rw [mul_comm, Subtype.coe_mk, e]\n    refine' Set.mem_image_of_mem (algebraMap R S) _\n    intro z hz\n    apply IsLocalization.injective S hM\n    rw [map_zero]\n    apply hx\n    rw [← (map_units S s).mul_left_inj, mul_assoc, e, ← map_mul, hz, map_zero, MulZeroClass.zero_mul]\n  · exact hM\n#align is_fraction_ring_of_is_localization is_fraction_ring_of_is_localization\n\n",
 "is_fraction_ring_of_is_domain_of_is_localization":
 "theorem is_fraction_ring_of_is_domain_of_is_localization [IsDomain R] (S T : Type _) [CommRing S] [CommRing T]\n    [Algebra R S] [Algebra R T] [Algebra S T] [IsScalarTower R S T] [IsLocalization M S] [IsFractionRing R T] :\n    IsFractionRing S T := by\n  haveI := IsFractionRing.nontrivial R T\n  haveI := (algebraMap S T).domain_nontrivial\n  apply is_fraction_ring_of_is_localization M S T\n  intro x hx\n  rw [mem_nonZeroDivisors_iff_ne_zero]\n  intro hx'\n  apply @zero_ne_one S\n  rw [← (algebraMap R S).map_one, ← @mk'_one R _ M, @comm _ Eq, mk'_eq_zero_iff]\n  exact ⟨⟨x, hx⟩, by simp [hx']⟩\n#align is_fraction_ring_of_is_domain_of_is_localization is_fraction_ring_of_is_domain_of_is_localization\n\n"}