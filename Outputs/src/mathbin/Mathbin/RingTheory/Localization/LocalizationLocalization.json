{"mem_localization_localization_submodule":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\n-- This should only be defined when `S` is the localization `M⁻¹R`, hence the nolint.\n@[simp]\ntheorem mem_localization_localization_submodule {x : R} :\n    x ∈ localization_localization_submodule M N ↔ ∃ (y : N)(z : M), algebra_map R S x = y * algebra_map R S z :=\n  by\n  rw [localization_localization_submodule, Submonoid.mem_comap, submonoid.mem_sup]\n  constructor\n  · rintro ⟨y, hy, _, ⟨z, hz, rfl⟩, e⟩\n    exact ⟨⟨y, hy⟩, ⟨z, hz⟩, e.symm⟩\n  · rintro ⟨y, z, e⟩\n    exact ⟨y, y.prop, _, ⟨z, z.prop, rfl⟩, e.symm⟩\n#align mem_localization_localization_submodule mem_localization_localization_submodule\n\n",
 "localization_localization_surj":
 "theorem localization_localization_surj [is_localization N T] (x : T) :\n    ∃ y : R × localization_localization_submodule M N, x * algebra_map R T y.2 = algebra_map R T y.1 :=\n  by\n  rcases is_localization.surj N x with ⟨⟨y, s⟩, eq₁⟩\n  -- x = y / s\n  rcases is_localization.surj M y with ⟨⟨z, t⟩, eq₂⟩\n  -- y = z / t\n  rcases is_localization.surj M (s : S) with ⟨⟨z', t'⟩, eq₃⟩\n  -- s = z' / t'\n  dsimp only at eq₁ eq₂ eq₃\n  use z * t'; use z' * t\n  -- x = y / s = (z * t') / (z' * t)\n  · rw [mem_localization_localization_submodule]\n    refine' ⟨s, t * t', _⟩\n    rw [RingHom.map_mul, ← eq₃, mul_assoc, ← RingHom.map_mul, mul_comm t, Submonoid.coe_mul]\n  · simp only [subtype.coe_mk, RingHom.map_mul, is_scalar_tower.algebra_map_apply R S T, ← eq₃, ← eq₂, ← eq₁]\n    ring\n#align localization_localization_surj localization_localization_surj\n\n",
 "localization_localization_map_units":
 "theorem localization_localization_map_units [is_localization N T] (y : localization_localization_submodule M N) :\n    is_unit (algebra_map R T y) :=\n  by\n  obtain ⟨y', z, eq⟩ := mem_localization_localization_submodule.mp y.prop\n  rw [is_scalar_tower.algebra_map_apply R S T, eq, RingHom.map_mul, IsUnit.mul_iff]\n  exact ⟨is_localization.map_units T y', (is_localization.map_units _ z).map (algebra_map S T)⟩\n#align localization_localization_map_units localization_localization_map_units\n\n",
 "localization_localization_is_localization_of_has_all_units":
 "/-- Given submodules `M ⊆ R` and `N ⊆ S = M⁻¹R`, with `f : R →+* S` the localization map, if\n`N` contains all the units of `S`, then `N ⁻¹ S = T = (f⁻¹ N) ⁻¹ R`. I.e., the localization of a\nlocalization is a localization.\n-/\ntheorem localization_localization_is_localization_of_has_all_units [is_localization N T]\n    (H : ∀ x : S, is_unit x → x ∈ N) : is_localization (N.comap (algebra_map R S)) T :=\n  by\n  convert localization_localization_is_localization M N T\n  symm\n  rw [sup_eq_left]\n  rintro _ ⟨x, hx, rfl⟩\n  exact H _ (is_localization.map_units _ ⟨x, hx⟩)\n#align\n  localization_localization_is_localization_of_has_all_units localization_localization_is_localization_of_has_all_units\n\n",
 "localization_localization_is_localization":
 "/-- Given submodules `M ⊆ R` and `N ⊆ S = M⁻¹R`, with `f : R →+* S` the localization map, we have\n`N ⁻¹ S = T = (f⁻¹ (N • f(M))) ⁻¹ R`. I.e., the localization of a localization is a localization.\n-/\ntheorem localization_localization_is_localization [is_localization N T] :\n    is_localization (localization_localization_submodule M N) T :=\n  { map_units := localization_localization_map_units M N T\n    surj := localization_localization_surj M N T\n    eq_iff_exists := localization_localization_eq_iff_exists M N T }\n#align localization_localization_is_localization localization_localization_is_localization\n\n",
 "localization_localization_eq_iff_exists":
 "theorem localization_localization_eq_iff_exists [is_localization N T] (x y : R) :\n    algebra_map R T x = algebra_map R T y ↔ ∃ c : localization_localization_submodule M N, x * c = y * c :=\n  by\n  rw [is_scalar_tower.algebra_map_apply R S T, is_scalar_tower.algebra_map_apply R S T,\n    is_localization.eq_iff_exists N T]\n  constructor\n  · rintro ⟨z, eq₁⟩\n    rcases is_localization.surj M (z : S) with ⟨⟨z', s⟩, eq₂⟩\n    dsimp only at eq₂\n    obtain ⟨c, eq₃ : x * z' * ↑c = y * z' * ↑c⟩ := (is_localization.eq_iff_exists M S).mp _\n    swap\n    · rw [RingHom.map_mul, RingHom.map_mul, ← eq₂, ← mul_assoc, ← mul_assoc, ← eq₁]\n    use z' * c\n    · rw [mem_localization_localization_submodule]\n      refine' ⟨z, s * c, _⟩\n      rw [RingHom.map_mul, ← eq₂, mul_assoc, ← RingHom.map_mul, Submonoid.coe_mul]\n    · simpa only [mul_assoc] using eq₃\n  · rintro ⟨⟨c, hc⟩, eq₁ : x * c = y * c⟩\n    rw [mem_localization_localization_submodule] at hc\n    rcases hc with ⟨z₁, z, eq₂⟩\n    use z₁\n    refine' (is_localization.map_units S z).mul_left_inj.mp _\n    rw [mul_assoc, mul_assoc, ← eq₂, ← RingHom.map_mul, ← RingHom.map_mul, eq₁]\n#align localization_localization_eq_iff_exists localization_localization_eq_iff_exists\n\n",
 "localization_is_scalar_tower_of_submonoid_le":
 "/-- If `M ≤ N` are submonoids of `R`, then the natural map `M⁻¹S →+* N⁻¹S` commutes with the\nlocalization maps -/\ntheorem localization_is_scalar_tower_of_submonoid_le (M N : Submonoid R) (h : M ≤ N) [is_localization M S]\n    [is_localization N T] : @IsScalarTower R S T _ (localization_algebra_of_submonoid_le S T M N h).to_has_smul _ :=\n  letI := localization_algebra_of_submonoid_le S T M N h\n  is_scalar_tower.of_algebra_map_eq' (is_localization.lift_comp _).symm\n#align localization_is_scalar_tower_of_submonoid_le localization_is_scalar_tower_of_submonoid_le\n\n",
 "is_localization_of_submonoid_le":
 "/-- If `M ≤ N` are submonoids of `R`, then `N⁻¹S` is also the localization of `M⁻¹S` at `N`. -/\ntheorem is_localization_of_submonoid_le (M N : Submonoid R) (h : M ≤ N) [is_localization M S] [is_localization N T]\n    [algebra S T] [IsScalarTower R S T] : is_localization (N.map (algebra_map R S)) T :=\n  { map_units := by\n      rintro ⟨_, ⟨y, hy, rfl⟩⟩\n      convert is_localization.map_units T ⟨y, hy⟩\n      exact (is_scalar_tower.algebra_map_apply _ _ _ _).symm\n    surj := fun y => by\n      obtain ⟨⟨x, s⟩, e⟩ := is_localization.surj N y\n      refine' ⟨⟨algebra_map _ _ x, _, _, s.prop, rfl⟩, _⟩\n      simpa [← is_scalar_tower.algebra_map_apply] using e\n    eq_iff_exists := fun x₁ x₂ => by\n      obtain ⟨⟨y₁, s₁⟩, e₁⟩ := is_localization.surj M x₁\n      obtain ⟨⟨y₂, s₂⟩, e₂⟩ := is_localization.surj M x₂\n      refine' iff.trans _ (Set.exists_image_iff (algebra_map R S) N fun c => x₁ * c = x₂ * c).symm\n      dsimp only at e₁ e₂⊢\n      suffices\n        algebra_map R T (y₁ * s₂) = algebra_map R T (y₂ * s₁) ↔\n          ∃ a : N, algebra_map R S (a * (y₁ * s₂)) = algebra_map R S (a * (y₂ * s₁))\n        by\n        have h₁ := (is_localization.map_units T ⟨_, h s₁.prop⟩).mul_left_inj\n        have h₂ := (is_localization.map_units T ⟨_, h s₂.prop⟩).mul_left_inj\n        simp only [is_scalar_tower.algebra_map_apply R S T, subtype.coe_mk] at h₁ h₂\n        simp only [is_scalar_tower.algebra_map_apply R S T, map_mul, ← e₁, ← e₂, ← mul_assoc,\n          mul_right_comm _ (algebra_map R S s₂), mul_right_comm _ (algebra_map S T (algebra_map R S s₂)),\n          (is_localization.map_units S s₁).mul_left_inj, (is_localization.map_units S s₂).mul_left_inj] at this\n        rw [h₂, h₁] at this\n        simpa only [mul_comm] using this\n      simp_rw [is_localization.eq_iff_exists N T, is_localization.eq_iff_exists M S]\n      constructor\n      · rintro ⟨a, e⟩\n        exact ⟨a, 1, by convert e using 1 <;> simp <;> ring⟩\n      · rintro ⟨a, b, e⟩\n        exact ⟨a * (⟨_, h b.prop⟩ : N), by convert e using 1 <;> simp <;> ring⟩ }\n#align is_localization_of_submonoid_le is_localization_of_submonoid_le\n\n",
 "is_localization_of_is_exists_mul_mem":
 "/-- If `M ≤ N` are submonoids of `R` such that `∀ x : N, ∃ m : R, m * x ∈ M`, then the\nlocalization at `N` is equal to the localizaton of `M`. -/\ntheorem is_localization_of_is_exists_mul_mem (M N : Submonoid R) [is_localization M S] (h : M ≤ N)\n    (h' : ∀ x : N, ∃ m : R, m * x ∈ M) : is_localization N S :=\n  { map_units := fun y => by\n      obtain ⟨m, hm⟩ := h' y\n      have := is_localization.map_units S ⟨_, hm⟩\n      erw [map_mul] at this\n      exact (is_unit.mul_iff.mp this).2\n    surj := fun z => by\n      obtain ⟨⟨y, s⟩, e⟩ := is_localization.surj M z\n      exact ⟨⟨y, _, h s.prop⟩, e⟩\n    eq_iff_exists := fun x₁ x₂ => by\n      rw [is_localization.eq_iff_exists M]\n      refine' ⟨fun ⟨x, hx⟩ => ⟨⟨_, h x.prop⟩, hx⟩, _⟩\n      rintro ⟨x, h⟩\n      obtain ⟨m, hm⟩ := h' x\n      refine' ⟨⟨_, hm⟩, _⟩\n      simp [mul_comm m, ← mul_assoc, h] }\n#align is_localization_of_is_exists_mul_mem is_localization_of_is_exists_mul_mem\n\n",
 "is_localization_is_localization_at_prime_is_localization":
 "/-- Given a submodule `M ⊆ R` and a prime ideal `p` of `S = M⁻¹R`, with `f : R →+* S` the localization\nmap, then `T = Sₚ` is the localization of `R` at `f⁻¹(p)`.\n-/\ntheorem is_localization_is_localization_at_prime_is_localization (p : ideal S) [Hp : p.is_prime]\n    [is_localization.at_prime T p] : is_localization.at_prime T (p.comap (algebra_map R S)) :=\n  by\n  apply localization_localization_is_localization_of_has_all_units M p.prime_compl T\n  intro x hx hx'\n  exact (Hp.1 : ¬_) (p.eq_top_of_is_unit_mem hx' hx)\n#align is_localization_is_localization_at_prime_is_localization is_localization_is_localization_at_prime_is_localization\n\n",
 "is_fraction_ring_of_is_localization":
 "theorem is_fraction_ring_of_is_localization (S T : Type _) [CommRing S] [CommRing T] [algebra R S] [algebra R T]\n    [algebra S T] [IsScalarTower R S T] [is_localization M S] [is_fraction_ring R T] (hM : M ≤ non_zero_divisors R) :\n    is_fraction_ring S T :=\n  by\n  have := is_localization_of_submonoid_le S T M (non_zero_divisors R) _\n  refine' @is_localization_of_is_exists_mul_mem _ _ _ _ _ _ this _ _\n  · exact map_non_zero_divisors_le M S\n  · rintro ⟨x, hx⟩\n    obtain ⟨⟨y, s⟩, e⟩ := is_localization.surj M x\n    use algebra_map R S s\n    rw [mul_comm, subtype.coe_mk, e]\n    refine' Set.mem_image_of_mem (algebra_map R S) _\n    intro z hz\n    apply is_localization.injective S hM\n    rw [map_zero]\n    apply hx\n    rw [← (map_units S s).mul_left_inj, mul_assoc, e, ← map_mul, hz, map_zero, zero_mul]\n  · exact hM\n#align is_fraction_ring_of_is_localization is_fraction_ring_of_is_localization\n\n",
 "is_fraction_ring_of_is_domain_of_is_localization":
 "theorem is_fraction_ring_of_is_domain_of_is_localization [IsDomain R] (S T : Type _) [CommRing S] [CommRing T]\n    [algebra R S] [algebra R T] [algebra S T] [IsScalarTower R S T] [is_localization M S] [is_fraction_ring R T] :\n    is_fraction_ring S T := by\n  haveI := is_fraction_ring.nontrivial R T\n  haveI := (algebra_map S T).domain_nontrivial\n  apply is_fraction_ring_of_is_localization M S T\n  intro x hx\n  rw [mem_non_zero_divisors_iff_ne_zero]\n  intro hx'\n  apply @zero_ne_one S\n  rw [← (algebra_map R S).map_one, ← @mk'_one R _ M, @comm _ eq, mk'_eq_zero_iff]\n  exact ⟨⟨_, hx⟩, (one_mul x).symm ▸ hx'⟩\n#align is_fraction_ring_of_is_domain_of_is_localization is_fraction_ring_of_is_domain_of_is_localization\n\n"}