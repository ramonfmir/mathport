{"to_map_ne_zero_of_mem_non_zero_divisors":
 "protected theorem to_map_ne_zero_of_mem_non_zero_divisors [nontrivial R] (hM : M ≤ non_zero_divisors R) {x : R}\n    (hx : x ∈ non_zero_divisors R) : algebra_map R S x ≠ 0 :=\n  show (algebra_map R S).to_monoid_with_zero_hom x ≠ 0 from\n    map_ne_zero_of_mem_non_zero_divisors (algebra_map R S) (is_localization.injective S hM) hx\n#align to_map_ne_zero_of_mem_non_zero_divisors to_map_ne_zero_of_mem_non_zero_divisors\n\n",
 "to_map_eq_zero_iff":
 "theorem to_map_eq_zero_iff {x : R} (hM : M ≤ non_zero_divisors R) : algebra_map R S x = 0 ↔ x = 0 :=\n  by\n  rw [← (algebra_map R S).map_zero]\n  constructor <;> intro h\n  · cases' (eq_iff_exists M S).mp h with c hc\n    rw [zero_mul] at hc\n    exact hM c.2 x hc\n  · rw [h]\n#align to_map_eq_zero_iff to_map_eq_zero_iff\n\n",
 "to_localization_map_to_map_apply":
 "theorem to_localization_map_to_map_apply (x) : (to_localization_map M S).to_map x = algebra_map R S x :=\n  rfl\n#align to_localization_map_to_map_apply to_localization_map_to_map_apply\n\n",
 "to_localization_map_to_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n@[simp]\ntheorem to_localization_map_to_map : (to_localization_map M S).to_map = (algebra_map R S : «expr →*₀ » R S) :=\n  rfl\n#align to_localization_map_to_map to_localization_map_to_map\n\n",
 "to_localization_map_sec":
 "@[simp]\ntheorem to_localization_map_sec : (to_localization_map M S).sec = sec M :=\n  rfl\n#align to_localization_map_sec to_localization_map_sec\n\n",
 "to_localization_map_eq_monoid_of":
 "@[simp]\ntheorem to_localization_map_eq_monoid_of : to_localization_map M (localization M) = monoid_of M :=\n  rfl\n#align to_localization_map_eq_monoid_of to_localization_map_eq_monoid_of\n\n",
 "sub_mk":
 "theorem sub_mk (a c) (b d) : (mk a b : localization M) - mk c d = mk (d * a - b * c) (b * d) :=\n  calc\n    mk a b - mk c d = mk a b + -mk c d := sub_eq_add_neg _ _\n    _ = mk a b + mk (-c) d := by rw [neg_mk]\n    _ = mk (b * -c + d * a) (b * d) := add_mk _ _ _ _\n    _ = mk (d * a - b * c) (b * d) := by congr <;> ring\n    \n#align sub_mk sub_mk\n\n",
 "sec_spec'":
 "/-- Given `z : S`, `is_localization.sec M z` is defined to be a pair `(x, y) : R × M` such\nthat `z * f y = f x`, so this lemma is just an application of `S`'s commutativity. -/\ntheorem sec_spec' (z : S) :\n    algebra_map R S (is_localization.sec M z).1 = algebra_map R S (is_localization.sec M z).2 * z := by\n  rw [mul_comm, sec_spec]\n#align sec_spec' sec_spec'\n\n",
 "sec_spec":
 "/-- Given `z : S`, `is_localization.sec M z` is defined to be a pair `(x, y) : R × M` such\nthat `z * f y = f x` (so this lemma is true by definition). -/\ntheorem sec_spec (z : S) :\n    z * algebra_map R S (is_localization.sec M z).2 = algebra_map R S (is_localization.sec M z).1 :=\n  Classical.choose_spec <| is_localization.surj _ z\n#align sec_spec sec_spec\n\n",
 "sec_snd_ne_zero":
 "theorem sec_snd_ne_zero [nontrivial R] (hM : M ≤ non_zero_divisors R) (x : S) : ((sec M x).snd : R) ≠ 0 :=\n  non_zero_divisors.coe_ne_zero ⟨(sec M x).snd.val, hM (sec M x).snd.property⟩\n#align sec_snd_ne_zero sec_snd_ne_zero\n\n",
 "sec_fst_ne_zero":
 "theorem sec_fst_ne_zero [nontrivial R] [no_zero_divisors S] (hM : M ≤ non_zero_divisors R) {x : S} (hx : x ≠ 0) :\n    (sec M x).fst ≠ 0 := by\n  have hsec := sec_spec M x\n  intro hfst\n  rw [hfst, map_zero, mul_eq_zero, _root_.map_eq_zero_iff] at hsec\n  · exact or.elim hsec hx (sec_snd_ne_zero hM x)\n  · exact is_localization.injective S hM\n#align sec_fst_ne_zero sec_fst_ne_zero\n\n",
 "ring_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- See note [partially-applied ext lemmas] -/\ntheorem ring_hom_ext ⦃j k : «expr →+* » S P⦄ (h : j.comp (algebra_map R S) = k.comp (algebra_map R S)) : j = k :=\n  RingHom.coe_monoidHom_injective <| monoid_hom_ext M <| MonoidHom.ext <| RingHom.congr_fun h\n#align ring_hom_ext ring_hom_ext\n\n",
 "ring_equiv_of_ring_equiv_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\ntheorem ring_equiv_of_ring_equiv_mk' {j : «expr ≃+* » R P} (H : M.map j.to_monoid_hom = T) (x : R) (y : M) :\n    ring_equiv_of_ring_equiv S Q j H (mk' S x y) =\n      mk' Q (j x) ⟨j y, show j y ∈ T from H ▸ Set.mem_image_of_mem j y.2⟩ :=\n  map_mk' _ _ _\n#align ring_equiv_of_ring_equiv_mk' ring_equiv_of_ring_equiv_mk'\n\n",
 "ring_equiv_of_ring_equiv_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ring_equiv_of_ring_equiv_eq_map {j : «expr ≃+* » R P} (H : M.map j.to_monoid_hom = T) :\n    (ring_equiv_of_ring_equiv S Q j H : «expr →+* » S Q) =\n      map Q (j : «expr →+* » R P) (M.le_comap_of_map_le (le_of_eq H)) :=\n  rfl\n#align ring_equiv_of_ring_equiv_eq_map ring_equiv_of_ring_equiv_eq_map\n\n",
 "ring_equiv_of_ring_equiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem ring_equiv_of_ring_equiv_eq {j : «expr ≃+* » R P} (H : M.map j.to_monoid_hom = T) (x) :\n    ring_equiv_of_ring_equiv S Q j H ((algebra_map R S) x) = algebra_map P Q (j x) :=\n  map_eq _ _\n#align ring_equiv_of_ring_equiv_eq ring_equiv_of_ring_equiv_eq\n\n",
 "of_le":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\ntheorem of_le (N : Submonoid R) (h₁ : M ≤ N) (h₂ : ∀ r ∈ N, is_unit (algebra_map R S r)) : is_localization N S :=\n  { map_units := fun r => h₂ r r.2\n    surj := fun s => by\n      obtain ⟨⟨x, y, hy⟩, H⟩ := is_localization.surj M s\n      exact ⟨⟨x, y, h₁ hy⟩, H⟩\n    eq_iff_exists := fun x y => by\n      constructor\n      · rw [is_localization.eq_iff_exists M]\n        rintro ⟨c, hc⟩\n        exact ⟨⟨c, h₁ c.2⟩, hc⟩\n      · rintro ⟨c, h⟩\n        simpa only [[anonymous], map_mul, (h₂ c c.2).mul_left_inj] using congr_arg (algebra_map R S) h }\n#align of_le of_le\n\n",
 "non_zero_divisors_le_comap":
 "theorem non_zero_divisors_le_comap [is_localization M S] :\n    non_zero_divisors R ≤ (non_zero_divisors S).comap (algebra_map R S) :=\n  by\n  rintro a ha b (e : b * algebra_map R S a = 0)\n  obtain ⟨x, s, rfl⟩ := mk'_surjective M b\n  rw [← @mk'_one R _ M, ← mk'_mul, ← (algebra_map R S).map_zero, ← @mk'_one R _ M, is_localization.eq] at e\n  obtain ⟨c, e⟩ := e\n  rw [zero_mul, zero_mul, Submonoid.coe_one, mul_one, mul_comm x a, mul_assoc, mul_comm] at e\n  rw [mk'_eq_zero_iff]\n  exact ⟨c, ha _ e⟩\n#align non_zero_divisors_le_comap non_zero_divisors_le_comap\n\n",
 "no_zero_divisors_of_le_non_zero_divisors":
 "/-- A `comm_ring` `S` which is the localization of a ring `R` without zero divisors at a subset of\nnon-zero elements does not have zero divisors.\nSee note [reducible non-instances]. -/\n@[reducible]\ntheorem no_zero_divisors_of_le_non_zero_divisors [algebra A S] {M : Submonoid A} [is_localization M S]\n    (hM : M ≤ non_zero_divisors A) : no_zero_divisors S :=\n  {\n    eq_zero_or_eq_zero_of_mul_eq_zero := by\n      intro z w h\n      cases' surj M z with x hx\n      cases' surj M w with y hy\n      have : z * w * algebra_map A S y.2 * algebra_map A S x.2 = algebra_map A S x.1 * algebra_map A S y.1 := by\n        rw [mul_assoc z, hy, ← hx] <;> ring\n      rw [h, zero_mul, zero_mul, ← (algebra_map A S).map_mul] at this\n      cases' eq_zero_or_eq_zero_of_mul_eq_zero ((to_map_eq_zero_iff S hM).mp this.symm) with H H\n      · exact or.inl (eq_zero_of_fst_eq_zero hx H)\n      · exact or.inr (eq_zero_of_fst_eq_zero hy H) }\n#align no_zero_divisors_of_le_non_zero_divisors no_zero_divisors_of_le_non_zero_divisors\n\n",
 "neg_mk":
 "theorem neg_mk (a b) : -(mk a b : localization M) = mk (-a) b :=\n  by\n  unfold has_neg.neg localization.neg\n  apply lift_on_mk\n#align neg_mk neg_mk\n\n",
 "ne_zero_of_mk'_ne_zero":
 "theorem ne_zero_of_mk'_ne_zero {x : R} {y : M} (hxy : is_localization.mk' S x y ≠ 0) : x ≠ 0 :=\n  by\n  rintro rfl\n  exact hxy (is_localization.mk'_zero _)\n#align ne_zero_of_mk'_ne_zero ne_zero_of_mk'_ne_zero\n\n",
 "mul_mk'_eq_mk'_of_mul":
 "theorem mul_mk'_eq_mk'_of_mul (x y : R) (z : M) : (algebra_map R S) x * mk' S y z = mk' S (x * y) z :=\n  (to_localization_map M S).mul_mk'_eq_mk'_of_mul _ _ _\n#align mul_mk'_eq_mk'_of_mul mul_mk'_eq_mk'_of_mul\n\n",
 "mul_add_inv_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem mul_add_inv_left {g : «expr →+* » R P} (h : ∀ y : M, is_unit (g y)) (y : M) (w z₁ z₂ : P) :\n    w * ↑(IsUnit.liftRight (g.to_monoid_hom.restrict M) h y)⁻¹ + z₁ = z₂ ↔ w + g y * z₁ = g y * z₂ :=\n  by\n  rw [mul_comm, ← one_mul z₁, ← Units.inv_mul (IsUnit.liftRight (g.to_monoid_hom.restrict M) h y), mul_assoc, ← mul_add,\n    units.inv_mul_eq_iff_eq_mul, Units.inv_mul_cancel_left, IsUnit.coe_liftRight]\n  simp only [RingHom.toMonoidHom_eq_coe, MonoidHom.restrict_apply, [anonymous]]\n#align mul_add_inv_left mul_add_inv_left\n\n",
 "monoid_of_eq_algebra_map":
 "theorem monoid_of_eq_algebra_map (x) : (monoid_of M).to_map x = algebra_map R (localization M) x :=\n  rfl\n#align monoid_of_eq_algebra_map monoid_of_eq_algebra_map\n\n",
 "monoid_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- See note [partially-applied ext lemmas] -/\ntheorem monoid_hom_ext ⦃j k : «expr →* » S P⦄\n    (h : j.comp (algebra_map R S : «expr →* » R S) = k.comp (algebra_map R S)) : j = k :=\n  submonoid.localization_map.epic_of_localization_map (to_localization_map M S) <| MonoidHom.congr_fun h\n#align monoid_hom_ext monoid_hom_ext\n\n",
 "mk_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mk_sum {ι : Type _} (f : ι → R) (s : Finset ι) (b : M) :\n    mk (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)) b =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (mk (f i) b) :=\n  (mk_add_monoid_hom b).map_sum f s\n#align mk_sum mk_sum\n\n",
 "mk_one_eq_algebra_map":
 "theorem mk_one_eq_algebra_map (x) : mk x 1 = algebra_map R (localization M) x :=\n  rfl\n#align mk_one_eq_algebra_map mk_one_eq_algebra_map\n\n",
 "mk_nat_cast":
 "theorem mk_nat_cast (m : ℕ) : (mk m 1 : localization M) = m := by simpa using @mk_algebra_map R _ M ℕ _ _ m\n#align mk_nat_cast mk_nat_cast\n\n",
 "mk_multiset_sum":
 "theorem mk_multiset_sum (l : Multiset R) (b : M) : mk l.sum b = (l.map fun a => mk a b).sum :=\n  (mk_add_monoid_hom b).map_multiset_sum l\n#align mk_multiset_sum mk_multiset_sum\n\n",
 "mk_list_sum":
 "theorem mk_list_sum (l : list R) (b : M) : mk l.sum b = (l.map fun a => mk a b).sum :=\n  (mk_add_monoid_hom b).map_list_sum l\n#align mk_list_sum mk_list_sum\n\n",
 "mk_int_cast":
 "theorem mk_int_cast (m : ℤ) : (mk m 1 : localization M) = m := by simpa using @mk_algebra_map R _ M ℤ _ _ m\n#align mk_int_cast mk_int_cast\n\n",
 "mk_eq_mk'_apply":
 "theorem mk_eq_mk'_apply (x y) : mk x y = is_localization.mk' (localization M) x y := by\n  rw [mk_eq_monoid_of_mk'_apply, mk', to_localization_map_eq_monoid_of]\n#align mk_eq_mk'_apply mk_eq_mk'_apply\n\n",
 "mk_eq_mk'":
 "@[simp]\ntheorem mk_eq_mk' : (mk : R → M → localization M) = is_localization.mk' (localization M) :=\n  mk_eq_monoid_of_mk'\n#align mk_eq_mk' mk_eq_mk'\n\n",
 "mk_algebra_map":
 "theorem mk_algebra_map {A : Type _} [CommSemiring A] [algebra A R] (m : A) :\n    mk (algebra_map A R m) 1 = algebra_map A (localization M) m := by\n  rw [mk_eq_mk', mk'_eq_iff_eq_mul, Submonoid.coe_one, map_one, mul_one] <;> rfl\n#align mk_algebra_map mk_algebra_map\n\n",
 "mk'_zero":
 "@[simp]\ntheorem mk'_zero (s : M) : is_localization.mk' S 0 s = 0 := by\n  rw [eq_comm, is_localization.eq_mk'_iff_mul_eq, zero_mul, map_zero]\n#align mk'_zero mk'_zero\n\n",
 "mk'_surjective":
 "theorem mk'_surjective (z : S) : ∃ (x : _)(y : M), mk' S x y = z :=\n  let ⟨r, hr⟩ := is_localization.surj _ z\n  ⟨r.1, r.2, (eq_mk'_iff_mul_eq.2 hr).symm⟩\n#align mk'_surjective mk'_surjective\n\n",
 "mk'_spec_mk":
 "@[simp]\ntheorem mk'_spec_mk (x) (y : R) (hy : y ∈ M) : mk' S x ⟨y, hy⟩ * algebra_map R S y = algebra_map R S x :=\n  mk'_spec S x ⟨y, hy⟩\n#align mk'_spec_mk mk'_spec_mk\n\n",
 "mk'_spec'_mk":
 "@[simp]\ntheorem mk'_spec'_mk (x) (y : R) (hy : y ∈ M) : algebra_map R S y * mk' S x ⟨y, hy⟩ = algebra_map R S x :=\n  mk'_spec' S x ⟨y, hy⟩\n#align mk'_spec'_mk mk'_spec'_mk\n\n",
 "mk'_spec'":
 "@[simp]\ntheorem mk'_spec' (x) (y : M) : algebra_map R S y * mk' S x y = algebra_map R S x :=\n  (to_localization_map M S).mk'_spec' _ _\n#align mk'_spec' mk'_spec'\n\n",
 "mk'_spec":
 "@[simp]\ntheorem mk'_spec (x) (y : M) : mk' S x y * algebra_map R S y = algebra_map R S x :=\n  (to_localization_map M S).mk'_spec _ _\n#align mk'_spec mk'_spec\n\n",
 "mk'_self''":
 "theorem mk'_self'' {x : M} : mk' S x.1 x = 1 :=\n  mk'_self' _\n#align mk'_self'' mk'_self''\n\n",
 "mk'_self'":
 "@[simp]\ntheorem mk'_self' {x : M} : mk' S (x : R) x = 1 :=\n  (to_localization_map M S).mk'_self' _\n#align mk'_self' mk'_self'\n\n",
 "mk'_self":
 "@[simp]\ntheorem mk'_self {x : R} (hx : x ∈ M) : mk' S x ⟨x, hx⟩ = 1 :=\n  (to_localization_map M S).mk'_self _ hx\n#align mk'_self mk'_self\n\n",
 "mk'_sec":
 "@[simp]\ntheorem mk'_sec (z : S) : mk' S (is_localization.sec M z).1 (is_localization.sec M z).2 = z :=\n  (to_localization_map M S).mk'_sec _\n#align mk'_sec mk'_sec\n\n",
 "mk'_one":
 "theorem mk'_one (x) : mk' S x (1 : M) = algebra_map R S x :=\n  (to_localization_map M S).mk'_one _\n#align mk'_one mk'_one\n\n",
 "mk'_mul_mk'_eq_one'":
 "theorem mk'_mul_mk'_eq_one' (x : R) (y : M) (h : x ∈ M) : mk' S x y * mk' S (y : R) ⟨x, h⟩ = 1 :=\n  mk'_mul_mk'_eq_one ⟨x, h⟩ _\n#align mk'_mul_mk'_eq_one' mk'_mul_mk'_eq_one'\n\n",
 "mk'_mul_mk'_eq_one":
 "@[simp]\ntheorem mk'_mul_mk'_eq_one (x y : M) : mk' S (x : R) y * mk' S (y : R) x = 1 := by\n  rw [← mk'_mul, mul_comm] <;> exact mk'_self _ _\n#align mk'_mul_mk'_eq_one mk'_mul_mk'_eq_one\n\n",
 "mk'_mul_cancel_right":
 "theorem mk'_mul_cancel_right (x : R) (y : M) : mk' S (x * y) y = (algebra_map R S) x :=\n  (to_localization_map M S).mk'_mul_cancel_right _ _\n#align mk'_mul_cancel_right mk'_mul_cancel_right\n\n",
 "mk'_mul_cancel_left":
 "@[simp]\ntheorem mk'_mul_cancel_left (x : R) (y : M) : mk' S (y * x : R) y = (algebra_map R S) x :=\n  (to_localization_map M S).mk'_mul_cancel_left _ _\n#align mk'_mul_cancel_left mk'_mul_cancel_left\n\n",
 "mk'_mul":
 "theorem mk'_mul (x₁ x₂ : R) (y₁ y₂ : M) : mk' S (x₁ * x₂) (y₁ * y₂) = mk' S x₁ y₁ * mk' S x₂ y₂ :=\n  (to_localization_map M S).mk'_mul _ _ _ _\n#align mk'_mul mk'_mul\n\n",
 "mk'_mem_iff":
 "theorem mk'_mem_iff {x} {y : M} {I : ideal S} : mk' S x y ∈ I ↔ algebra_map R S x ∈ I :=\n  by\n  constructor <;> intro h\n  · rw [← mk'_spec S x y, mul_comm]\n    exact I.mul_mem_left ((algebra_map R S) y) h\n  · rw [← mk'_spec S x y] at h\n    obtain ⟨b, hb⟩ := isUnit_iff_exists_inv.1 (map_units S y)\n    have := I.mul_mem_left b h\n    rwa [mul_comm, mul_assoc, hb, mul_one] at this\n#align mk'_mem_iff mk'_mem_iff\n\n",
 "mk'_eq_zero_iff":
 "theorem mk'_eq_zero_iff (x : R) (s : M) : mk' S x s = 0 ↔ ∃ m : M, x * m = 0 := by\n  rw [← (map_units S s).mul_left_inj, mk'_spec, zero_mul, map_eq_zero_iff M]\n#align mk'_eq_zero_iff mk'_eq_zero_iff\n\n",
 "mk'_eq_of_eq":
 "theorem mk'_eq_of_eq {a₁ b₁ : R} {a₂ b₂ : M} (H : b₁ * a₂ = a₁ * b₂) : mk' S a₁ a₂ = mk' S b₁ b₂ :=\n  (to_localization_map M S).mk'_eq_of_eq H\n#align mk'_eq_of_eq mk'_eq_of_eq\n\n",
 "mk'_eq_mul_mk'_one":
 "theorem mk'_eq_mul_mk'_one (x : R) (y : M) : mk' S x y = (algebra_map R S) x * mk' S 1 y :=\n  ((to_localization_map M S).mul_mk'_one_eq_mk' _ _).symm\n#align mk'_eq_mul_mk'_one mk'_eq_mul_mk'_one\n\n",
 "mk'_eq_iff_mk'_eq":
 "theorem mk'_eq_iff_mk'_eq {x₁ x₂} {y₁ y₂ : M} : mk' S x₁ y₁ = mk' S x₂ y₂ ↔ mk' P x₁ y₁ = mk' P x₂ y₂ :=\n  (to_localization_map M S).mk'_eq_iff_mk'_eq (to_localization_map M P)\n#align mk'_eq_iff_mk'_eq mk'_eq_iff_mk'_eq\n\n",
 "mk'_eq_iff_eq_mul":
 "theorem mk'_eq_iff_eq_mul {x} {y : M} {z} : mk' S x y = z ↔ algebra_map R S x = z * algebra_map R S y :=\n  (to_localization_map M S).mk'_eq_iff_eq_mul\n#align mk'_eq_iff_eq_mul mk'_eq_iff_eq_mul\n\n",
 "mk'_eq_iff_eq":
 "theorem mk'_eq_iff_eq {x₁ x₂} {y₁ y₂ : M} :\n    mk' S x₁ y₁ = mk' S x₂ y₂ ↔ algebra_map R S (x₁ * y₂) = algebra_map R S (x₂ * y₁) :=\n  (to_localization_map M S).mk'_eq_iff_eq\n#align mk'_eq_iff_eq mk'_eq_iff_eq\n\n",
 "mk'_add_eq_iff_add_mul_eq_mul":
 "theorem mk'_add_eq_iff_add_mul_eq_mul {x} {y : M} {z₁ z₂} :\n    mk' S x y + z₁ = z₂ ↔ algebra_map R S x + z₁ * algebra_map R S y = z₂ * algebra_map R S y := by\n  rw [← mk'_spec S x y, ← is_unit.mul_left_inj (is_localization.map_units S y), right_distrib]\n#align mk'_add_eq_iff_add_mul_eq_mul mk'_add_eq_iff_add_mul_eq_mul\n\n",
 "mk'_add":
 "theorem mk'_add (x₁ x₂ : R) (y₁ y₂ : M) : mk' S (x₁ * y₂ + x₂ * y₁) (y₁ * y₂) = mk' S x₁ y₁ + mk' S x₂ y₂ :=\n  mk'_eq_iff_eq_mul.2 <|\n    eq.symm\n      (by\n        rw [mul_comm (_ + _), mul_add, mul_mk'_eq_mk'_of_mul, mk'_add_eq_iff_add_mul_eq_mul, mul_comm (_ * _), ←\n          mul_assoc, add_comm, ← map_mul, mul_mk'_eq_mk'_of_mul, mk'_add_eq_iff_add_mul_eq_mul]\n        simp only [map_add, Submonoid.coe_mul, map_mul]\n        ring)\n#align mk'_add mk'_add\n\n",
 "map_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_unique (j : «expr →+* » S Q) (hj : ∀ x : R, j (algebra_map R S x) = algebra_map P Q (g x)) :\n    map Q g hy = j :=\n  lift_unique (fun y => map_units _ ⟨g y, hy y.2⟩) hj\n#align map_unique map_unique\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_smul (x : S) (z : R) : map Q g hy («expr • » z x : S) = «expr • » (g z) (map Q g hy x) := by\n  rw [algebra.smul_def, algebra.smul_def, RingHom.map_mul, map_eq]\n#align map_smul map_smul\n\n",
 "map_right_cancel":
 "theorem map_right_cancel {x y} {c : M} (h : algebra_map R S (c * x) = algebra_map R S (c * y)) :\n    algebra_map R S x = algebra_map R S y :=\n  (to_localization_map M S).map_right_cancel h\n#align map_right_cancel map_right_cancel\n\n",
 "map_non_zero_divisors_le":
 "theorem map_non_zero_divisors_le [is_localization M S] :\n    (non_zero_divisors R).map (algebra_map R S) ≤ non_zero_divisors S :=\n  Submonoid.map_le_iff_le_comap.mpr (non_zero_divisors_le_comap M S)\n#align map_non_zero_divisors_le map_non_zero_divisors_le\n\n",
 "map_mk'":
 "theorem map_mk' (x) (y : M) : map Q g hy (mk' S x y) = mk' Q (g x) ⟨g y, hy y.2⟩ :=\n  @submonoid.localization_map.map_mk' _ _ _ _ _ _ _ (to_localization_map M S) g.to_monoid_hom _ (fun y => hy y.2) _ _\n    (to_localization_map T Q) _ _\n#align map_mk' map_mk'\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `comm_semiring` homs `g : R →+* P, l : P →+* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\ntheorem map_map {A : Type _} [CommSemiring A] {U : Submonoid A} {W} [CommSemiring W] [algebra A W] [is_localization U W]\n    {l : «expr →+* » P A} (hl : T ≤ U.comap l) (x : S) :\n    map W l hl (map Q g hy x) = map W (l.comp g) (fun x hx => hl (hy hx)) x := by rw [← map_comp_map hy hl] <;> rfl\n#align map_map map_map\n\n",
 "map_left_cancel":
 "theorem map_left_cancel {x y} {c : M} (h : algebra_map R S (x * c) = algebra_map R S (y * c)) :\n    algebra_map R S x = algebra_map R S y :=\n  (to_localization_map M S).map_left_cancel h\n#align map_left_cancel map_left_cancel\n\n",
 "map_injective_of_injective":
 "/-- Injectivity of a map descends to the map induced on localizations. -/\ntheorem map_injective_of_injective (hg : function.injective g) [is_localization (M.map g : Submonoid P) Q] :\n    function.injective (map Q g M.le_comap_map : S → Q) :=\n  by\n  rw [injective_iff_map_eq_zero]\n  intro z hz\n  obtain ⟨a, b, rfl⟩ := mk'_surjective M z\n  rw [map_mk', mk'_eq_zero_iff] at hz\n  obtain ⟨⟨m', hm'⟩, hm⟩ := hz\n  rw [Submonoid.mem_map] at hm'\n  obtain ⟨n, hn, hnm⟩ := hm'\n  rw [subtype.coe_mk, ← hnm, ← map_mul, ← map_zero g] at hm\n  rw [mk'_eq_zero_iff]\n  exact ⟨⟨n, hn⟩, hg hm⟩\n#align map_injective_of_injective map_injective_of_injective\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (z : S) (h : M ≤ M.comap (RingHom.id R) := le_refl M) : map S (RingHom.id _) h z = z :=\n  lift_id _\n#align map_id map_id\n\n",
 "map_eq_zero_iff":
 "#print map_eq_zero_iff /-\ntheorem map_eq_zero_iff (r : R) : algebra_map R S r = 0 ↔ ∃ m : M, r * m = 0 :=\n  by\n  constructor\n  intro h\n  · obtain ⟨m, hm⟩ := (is_localization.eq_iff_exists M S).mp ((algebra_map R S).map_zero.trans h.symm)\n    exact ⟨m, by simpa using hm.symm⟩\n  · rintro ⟨m, hm⟩\n    rw [← (is_localization.map_units S m).mul_left_inj, zero_mul, ← RingHom.map_mul, hm, RingHom.map_zero]\n#align map_eq_zero_iff map_eq_zero_iff\n-/\n\n",
 "map_eq":
 "theorem map_eq (x) : map Q g hy ((algebra_map R S) x) = algebra_map P Q (g x) :=\n  lift_eq (fun y => map_units _ ⟨g y, hy y.2⟩) x\n#align map_eq map_eq\n\n",
 "map_comp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `comm_semiring` homs `g : R →+* P, l : P →+* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\ntheorem map_comp_map {A : Type _} [CommSemiring A] {U : Submonoid A} {W} [CommSemiring W] [algebra A W]\n    [is_localization U W] {l : «expr →+* » P A} (hl : T ≤ U.comap l) :\n    (map W l hl).comp (map Q g hy : «expr →+* » S _) = map W (l.comp g) fun x hx => hl (hy hx) :=\n  RingHom.ext fun x =>\n    @submonoid.localization_map.map_map _ _ _ _ _ P _ (to_localization_map M S) g _ _ _ _ _ _ _ _ _ _\n      (to_localization_map U W) l _ x\n#align map_comp_map map_comp_map\n\n",
 "map_comp":
 "@[simp]\ntheorem map_comp : (map Q g hy).comp (algebra_map R S) = (algebra_map P Q).comp g :=\n  lift_comp fun y => map_units _ ⟨g y, hy y.2⟩\n#align map_comp map_comp\n\n",
 "localization_map_bijective":
 "/-- If `R` is a field, then localizing at a submonoid not containing `0` adds no new elements. -/\ntheorem field.localization_map_bijective {K Kₘ : Type _} [Field K] [CommRing Kₘ] {M : Submonoid K} (hM : (0 : K) ∉ M)\n    [algebra K Kₘ] [is_localization M Kₘ] : function.bijective (algebra_map K Kₘ) :=\n  (Field.toIsField K).localization_map_bijective hM\n#align field.localization_map_bijective field.localization_map_bijective\n\n",
 "localization_algebra_injective":
 "/-- Injectivity of the underlying `algebra_map` descends to the algebra induced by localization. -/\ntheorem localization_algebra_injective (hRS : function.injective (algebra_map R S)) :\n    function.injective (@algebra_map Rₘ Sₘ _ _ (localization_algebra M S)) :=\n  is_localization.map_injective_of_injective M Rₘ Sₘ hRS\n#align localization_algebra_injective localization_algebra_injective\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem lift_unique {j : «expr →+* » S P} (hj : ∀ x, j ((algebra_map R S) x) = g x) : lift hg = j :=\n  RingHom.ext <|\n    MonoidHom.ext_iff.1 <|\n      @submonoid.localization_map.lift_unique _ _ _ _ _ _ _ (to_localization_map M S) g.to_monoid_hom hg j.to_monoid_hom\n        hj\n#align lift_unique lift_unique\n\n",
 "lift_surjective_iff":
 "theorem lift_surjective_iff : surjective (lift hg : S → P) ↔ ∀ v : P, ∃ x : R × M, v * g x.2 = g x.1 :=\n  (to_localization_map M S).lift_surjective_iff hg\n#align lift_surjective_iff lift_surjective_iff\n\n",
 "lift_spec_mul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem lift_spec_mul_add {g : «expr →+* » R P} (hg : ∀ y : M, is_unit (g y)) (z w w' v) :\n    ((to_localization_with_zero_map M S).lift g.to_monoid_with_zero_hom hg) z * w + w' = v ↔\n      g ((to_localization_map M S).sec z).1 * w + g ((to_localization_map M S).sec z).2 * w' =\n        g ((to_localization_map M S).sec z).2 * v :=\n  by\n  show _ * _ * _ + _ = _ ↔ _ = _\n  erw [mul_comm, ← mul_assoc, mul_add_inv_left hg, mul_comm]\n  rfl\n#align lift_spec_mul_add lift_spec_mul_add\n\n",
 "lift_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem lift_of_comp (j : «expr →+* » S P) : lift (is_unit_comp M j) = j :=\n  RingHom.ext <| MonoidHom.ext_iff.1 <| (to_localization_map M S).lift_of_comp j.to_monoid_hom\n#align lift_of_comp lift_of_comp\n\n",
 "lift_mk'_spec":
 "theorem lift_mk'_spec (x v) (y : M) : lift hg (mk' S x y) = v ↔ g x = g y * v :=\n  (to_localization_map M S).lift_mk'_spec _ _ _ _\n#align lift_mk'_spec lift_mk'_spec\n\n",
 "lift_mk'":
 "/-- Given a localization map `f : R →+* S` for a submonoid `M ⊆ R` and a map of `comm_semiring`s\n`g : R →* P` such that `g y` is invertible for all `y : M`, the homomorphism induced from\n`S` to `P` maps `f x * (f y)⁻¹` to `g x * (g y)⁻¹` for all `x : R, y ∈ M`. -/\ntheorem lift_mk' (x y) : lift hg (mk' S x y) = g x * ↑(IsUnit.liftRight (g.to_monoid_hom.restrict M) hg y)⁻¹ :=\n  (to_localization_map M S).lift_mk' _ _ _\n#align lift_mk' lift_mk'\n\n",
 "lift_injective_iff":
 "theorem lift_injective_iff : injective (lift hg : S → P) ↔ ∀ x y, algebra_map R S x = algebra_map R S y ↔ g x = g y :=\n  (to_localization_map M S).lift_injective_iff hg\n#align lift_injective_iff lift_injective_iff\n\n",
 "lift_id":
 "@[simp]\ntheorem lift_id (x) : lift (map_units S : ∀ y : M, is_unit _) x = x :=\n  (to_localization_map M S).lift_id _\n#align lift_id lift_id\n\n",
 "lift_eq_iff":
 "theorem lift_eq_iff {x y : R × M} : lift hg (mk' S x.1 x.2) = lift hg (mk' S y.1 y.2) ↔ g (x.1 * y.2) = g (y.1 * x.2) :=\n  (to_localization_map M S).lift_eq_iff _\n#align lift_eq_iff lift_eq_iff\n\n",
 "lift_eq":
 "@[simp]\ntheorem lift_eq (x : R) : lift hg ((algebra_map R S) x) = g x :=\n  (to_localization_map M S).lift_eq _ _\n#align lift_eq lift_eq\n\n",
 "lift_comp":
 "@[simp]\ntheorem lift_comp : (lift hg).comp (algebra_map R S) = g :=\n  RingHom.ext <| MonoidHom.ext_iff.1 <| (to_localization_map M S).lift_comp _\n#align lift_comp lift_comp\n\n",
 "is_unit_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_unit_comp (j : «expr →+* » S P) (y : M) : is_unit (j.comp (algebra_map R S) y) :=\n  (to_localization_map M S).is_unit_comp j.to_monoid_hom _\n#align is_unit_comp is_unit_comp\n\n",
 "is_localization_of_base_ring_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\ntheorem is_localization_of_base_ring_equiv [is_localization M S] (h : «expr ≃+* » R P) :\n    @is_localization _ (M.map h.to_monoid_hom) S _ ((algebra_map R S).comp h.symm.to_ring_hom).to_algebra :=\n  by\n  constructor\n  · rintro ⟨_, ⟨y, hy, rfl⟩⟩\n    convert is_localization.map_units S ⟨y, hy⟩\n    dsimp only [ring_hom.algebra_map_to_algebra, RingHom.comp_apply]\n    exact congr_arg _ (h.symm_apply_apply _)\n  · intro y\n    obtain ⟨⟨x, s⟩, e⟩ := is_localization.surj M y\n    refine' ⟨⟨h x, _, _, s.prop, rfl⟩, _⟩\n    dsimp only [ring_hom.algebra_map_to_algebra, RingHom.comp_apply] at e⊢\n    convert e <;> exact h.symm_apply_apply _\n  · intro x y\n    rw [ring_hom.algebra_map_to_algebra, RingHom.comp_apply, RingHom.comp_apply, is_localization.eq_iff_exists M S]\n    simp_rw [← h.to_equiv.apply_eq_iff_eq]\n    change (∃ c : M, h (h.symm x * c) = h (h.symm y * c)) ↔ _\n    simp only [RingEquiv.apply_symm_apply, RingEquiv.map_mul]\n    exact ⟨fun ⟨c, e⟩ => ⟨⟨_, _, c.prop, rfl⟩, e⟩, fun ⟨⟨_, c, h, e₁⟩, e₂⟩ => ⟨⟨_, h⟩, e₁.symm ▸ e₂⟩⟩\n#align is_localization_of_base_ring_equiv is_localization_of_base_ring_equiv\n\n",
 "is_localization_of_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem is_localization_of_alg_equiv [algebra R P] [is_localization M S] (h : «expr ≃ₐ[ ] » S R P) :\n    is_localization M P := by\n  constructor\n  · intro y\n    convert (is_localization.map_units S y).map h.to_alg_hom.to_ring_hom.to_monoid_hom\n    exact (h.commutes y).symm\n  · intro y\n    obtain ⟨⟨x, s⟩, e⟩ := is_localization.surj M (h.symm y)\n    apply_fun h  at e\n    simp only [h.map_mul, h.apply_symm_apply, h.commutes] at e\n    exact ⟨⟨x, s⟩, e⟩\n  · intro x y\n    rw [← h.symm.to_equiv.injective.eq_iff, ← is_localization.eq_iff_exists M S, ← h.symm.commutes, ← h.symm.commutes]\n    rfl\n#align is_localization_of_alg_equiv is_localization_of_alg_equiv\n\n",
 "is_localization_iff_of_ring_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\ntheorem is_localization_iff_of_ring_equiv (h : «expr ≃+* » S P) :\n    is_localization M S ↔ @is_localization _ M P _ (h.to_ring_hom.comp <| algebra_map R S).to_algebra :=\n  letI := (h.to_ring_hom.comp <| algebra_map R S).to_algebra\n  is_localization_iff_of_alg_equiv M { h with commutes' := fun _ => rfl }\n#align is_localization_iff_of_ring_equiv is_localization_iff_of_ring_equiv\n\n",
 "is_localization_iff_of_base_ring_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\ntheorem is_localization_iff_of_base_ring_equiv (h : «expr ≃+* » R P) :\n    is_localization M S ↔\n      @is_localization _ (M.map h.to_monoid_hom) S _ ((algebra_map R S).comp h.symm.to_ring_hom).to_algebra :=\n  by\n  refine' ⟨fun _ => is_localization_of_base_ring_equiv _ _ h, _⟩\n  letI := ((algebra_map R S).comp h.symm.to_ring_hom).to_algebra\n  intro H\n  convert @is_localization_of_base_ring_equiv _ _ _ _ _ _ H h.symm\n  · erw [Submonoid.map_equiv_eq_comap_symm, Submonoid.comap_map_eq_of_injective]\n    exact h.to_equiv.injective\n  rw [ring_hom.algebra_map_to_algebra, RingHom.comp_assoc]\n  simp only [RingHom.comp_id, RingEquiv.symm_symm, RingEquiv.symm_toRingHom_comp_toRingHom]\n  apply algebra.algebra_ext\n  intro r\n  rw [ring_hom.algebra_map_to_algebra]\n#align is_localization_iff_of_base_ring_equiv is_localization_iff_of_base_ring_equiv\n\n",
 "is_localization_iff_of_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem is_localization_iff_of_alg_equiv [algebra R P] (h : «expr ≃ₐ[ ] » S R P) :\n    is_localization M S ↔ is_localization M P :=\n  ⟨fun _ => is_localization_of_alg_equiv M h, fun _ => is_localization_of_alg_equiv M h.symm⟩\n#align is_localization_iff_of_alg_equiv is_localization_iff_of_alg_equiv\n\n",
 "is_domain_of_le_non_zero_divisors":
 "/-- A `comm_ring` `S` which is the localization of an integral domain `R` at a subset of\nnon-zero elements is an integral domain.\nSee note [reducible non-instances]. -/\n@[reducible]\ntheorem is_domain_of_le_non_zero_divisors [algebra A S] {M : Submonoid A} [is_localization M S]\n    (hM : M ≤ non_zero_divisors A) : IsDomain S :=\n  by\n  apply NoZeroDivisors.to_isDomain _\n  · exact ⟨⟨(algebra_map A S) 0, (algebra_map A S) 1, fun h => zero_ne_one (is_localization.injective S hM h)⟩⟩\n  · exact no_zero_divisors_of_le_non_zero_divisors _ hM\n#align is_domain_of_le_non_zero_divisors is_domain_of_le_non_zero_divisors\n\n",
 "is_domain_localization":
 "/-- The localization at of an integral domain to a set of non-zero elements is an integral domain.\nSee note [reducible non-instances]. -/\n@[reducible]\ntheorem is_domain_localization {M : Submonoid A} (hM : M ≤ non_zero_divisors A) : IsDomain (localization M) :=\n  is_domain_of_le_non_zero_divisors _ hM\n#align is_domain_localization is_domain_localization\n\n",
 "injective":
 "protected theorem injective (hM : M ≤ non_zero_divisors R) : injective (algebra_map R S) :=\n  by\n  rw [injective_iff_map_eq_zero (algebra_map R S)]\n  intro a ha\n  rwa [to_map_eq_zero_iff S hM] at ha\n#align injective injective\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- To show `j` and `k` agree on the whole localization, it suffices to show they agree\non the image of the base ring, if they preserve `1` and `*`. -/\nprotected theorem ext (j k : S → P) (hj1 : j 1 = 1) (hk1 : k 1 = 1) (hjm : ∀ a b, j (a * b) = j a * j b)\n    (hkm : ∀ a b, k (a * b) = k a * k b) (h : ∀ a, j (algebra_map R S a) = k (algebra_map R S a)) : j = k :=\n  monoid_hom.mk.inj (monoid_hom_ext M <| MonoidHom.ext h : (⟨j, hj1, hjm⟩ : «expr →* » S P) = ⟨k, hk1, hkm⟩)\n#align ext ext\n\n",
 "eq_zero_of_fst_eq_zero":
 "theorem eq_zero_of_fst_eq_zero {z x} {y : M} (h : z * algebra_map R S y = algebra_map R S x) (hx : x = 0) : z = 0 :=\n  by\n  rw [hx, (algebra_map R S).map_zero] at h\n  exact (IsUnit.mul_left_eq_zero (is_localization.map_units S y)).1 h\n#align eq_zero_of_fst_eq_zero eq_zero_of_fst_eq_zero\n\n",
 "eq_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- Given a localization map `f : R →+* S` for a submonoid `M ⊆ R` and a map of `comm_semiring`s\n`g : R →+* P` such that `g(M) ⊆ units P`, `f x = f y → g x = g y` for all `x y : R`. -/\ntheorem eq_of_eq {g : «expr →+* » R P} (hg : ∀ y : M, is_unit (g y)) {x y}\n    (h : (algebra_map R S) x = (algebra_map R S) y) : g x = g y :=\n  @submonoid.localization_map.eq_of_eq _ _ _ _ _ _ _ (to_localization_map M S) g.to_monoid_hom hg _ _ h\n#align eq_of_eq eq_of_eq\n\n",
 "eq_mk'_iff_mul_eq":
 "theorem eq_mk'_iff_mul_eq {x} {y : M} {z} : z = mk' S x y ↔ z * algebra_map R S y = algebra_map R S x :=\n  (to_localization_map M S).eq_mk'_iff_mul_eq\n#align eq_mk'_iff_mul_eq eq_mk'_iff_mul_eq\n\n",
 "eq_iff_eq":
 "theorem eq_iff_eq {x y} : algebra_map R S x = algebra_map R S y ↔ algebra_map R P x = algebra_map R P y :=\n  (to_localization_map M S).eq_iff_eq (to_localization_map M P)\n#align eq_iff_eq eq_iff_eq\n\n",
 "eq":
 "protected theorem eq {a₁ b₁} {a₂ b₂ : M} : mk' S a₁ a₂ = mk' S b₁ b₂ ↔ ∃ c : M, a₁ * b₂ * c = b₁ * a₂ * c :=\n  (to_localization_map M S).eq\n#align eq eq\n\n",
 "algebra_map_mk'":
 "-- this looks weird due to the `letI` inside the above lemma, but trying to do it the other\n-- way round causes issues with defeq of instances, so this is actually easier.\ntheorem algebra_map_mk' (r : R) (m : M) :\n    (@algebra_map Rₘ Sₘ _ _ (localization_algebra M S)) (mk' Rₘ r m) =\n      mk' Sₘ (algebra_map R S r) ⟨algebra_map R S m, algebra.mem_algebra_map_submonoid_of_mem m⟩ :=\n  map_mk' _ _ _\n#align algebra_map_mk' algebra_map_mk'\n\n",
 "alg_hom_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- This is not an instance because the submonoid `M` would become a metavariable\n  in typeclass search. -/\ntheorem alg_hom_subsingleton [algebra R P] : subsingleton («expr →ₐ[ ] » S R P) :=\n  ⟨fun f g =>\n    alg_hom.coe_ring_hom_injective <| is_localization.ring_hom_ext M <| by rw [f.comp_algebra_map, g.comp_algebra_map]⟩\n#align alg_hom_subsingleton alg_hom_subsingleton\n\n",
 "alg_equiv_symm_mk'":
 "@[simp]\ntheorem alg_equiv_symm_mk' (x : R) (y : M) : (alg_equiv M S).symm (mk' S x y) = mk' (localization M) x y :=\n  alg_equiv_symm_mk' _ _\n#align alg_equiv_symm_mk' alg_equiv_symm_mk'\n\n",
 "alg_equiv_symm_mk":
 "theorem alg_equiv_symm_mk (x : R) (y : M) : (alg_equiv M S).symm (mk' S x y) = mk x y := by\n  rw [mk_eq_mk', alg_equiv_symm_mk']\n#align alg_equiv_symm_mk alg_equiv_symm_mk\n\n",
 "alg_equiv_mk'":
 "@[simp]\ntheorem alg_equiv_mk' (x : R) (y : M) : alg_equiv M S (mk' (localization M) x y) = mk' S x y :=\n  alg_equiv_mk' _ _\n#align alg_equiv_mk' alg_equiv_mk'\n\n",
 "alg_equiv_mk":
 "theorem alg_equiv_mk (x y) : alg_equiv M S (mk x y) = mk' S x y := by rw [mk_eq_mk', alg_equiv_mk']\n#align alg_equiv_mk alg_equiv_mk\n\n",
 "add_mk_self":
 "theorem add_mk_self (a b c) : (mk a b : localization M) + mk c b = mk (a + c) b :=\n  by\n  rw [add_mk, mk_eq_mk_iff, r_eq_r']\n  refine' (r' M).symm ⟨1, _⟩\n  simp only [Submonoid.coe_one, Submonoid.coe_mul]\n  ring\n#align add_mk_self add_mk_self\n\n",
 "add_mk":
 "theorem add_mk (a b c d) : (mk a b : localization M) + mk c d = mk (b * c + d * a) (b * d) :=\n  by\n  unfold has_add.add localization.add\n  apply lift_on₂_mk\n#align add_mk add_mk\n\n"}