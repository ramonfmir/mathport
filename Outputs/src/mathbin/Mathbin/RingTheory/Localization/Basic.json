{"to_map_ne_zero_of_mem_non_zero_divisors":
 "protected theorem to_map_ne_zero_of_mem_non_zero_divisors [Nontrivial R] (hM : M ≤ nonZeroDivisors R) {x : R}\n    (hx : x ∈ nonZeroDivisors R) : algebraMap R S x ≠ 0 :=\n  show (algebraMap R S).to_monoid_with_zero_hom x ≠ 0 from\n    map_ne_zero_of_mem_nonZeroDivisors (algebraMap R S) (IsLocalization.injective S hM) hx\n#align to_map_ne_zero_of_mem_non_zero_divisors to_map_ne_zero_of_mem_non_zero_divisors\n\n",
 "to_map_eq_zero_iff":
 "theorem to_map_eq_zero_iff {x : R} (hM : M ≤ nonZeroDivisors R) : algebraMap R S x = 0 ↔ x = 0 :=\n  by\n  rw [← (algebraMap R S).map_zero]\n  constructor <;> intro h\n  · cases' (eq_iff_exists M S).mp h with c hc\n    rw [MulZeroClass.mul_zero, mul_comm] at hc\n    exact hM c.2 x hc\n  · rw [h]\n#align to_map_eq_zero_iff to_map_eq_zero_iff\n\n",
 "to_localization_map_to_map_apply":
 "theorem to_localization_map_to_map_apply (x) : (toLocalizationMap M S).to_map x = algebraMap R S x :=\n  rfl\n#align to_localization_map_to_map_apply to_localization_map_to_map_apply\n\n",
 "to_localization_map_to_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n@[simp]\ntheorem to_localization_map_to_map : (toLocalizationMap M S).to_map = (algebraMap R S : «expr →*₀ » R S) :=\n  rfl\n#align to_localization_map_to_map to_localization_map_to_map\n\n",
 "to_localization_map_sec":
 "@[simp]\ntheorem to_localization_map_sec : (toLocalizationMap M S).sec = sec M :=\n  rfl\n#align to_localization_map_sec to_localization_map_sec\n\n",
 "to_localization_map_eq_monoid_of":
 "@[simp]\ntheorem to_localization_map_eq_monoid_of : toLocalizationMap M (Localization M) = monoidOf M :=\n  rfl\n#align to_localization_map_eq_monoid_of to_localization_map_eq_monoid_of\n\n",
 "sub_mk":
 "theorem sub_mk (a c) (b d) : (mk a b : Localization M) - mk c d = mk (d * a - b * c) (b * d) :=\n  calc\n    mk a b - mk c d = mk a b + -mk c d := sub_eq_add_neg _ _\n    _ = mk a b + mk (-c) d := by rw [neg_mk]\n    _ = mk (b * -c + d * a) (b * d) := (add_mk _ _ _ _)\n    _ = mk (d * a - b * c) (b * d) := by congr <;> ring\n    \n#align sub_mk sub_mk\n\n",
 "sec_spec'":
 "/-- Given `z : S`, `is_localization.sec M z` is defined to be a pair `(x, y) : R × M` such\nthat `z * f y = f x`, so this lemma is just an application of `S`'s commutativity. -/\ntheorem sec_spec' (z : S) : algebraMap R S (IsLocalization.sec M z).1 = algebraMap R S (IsLocalization.sec M z).2 * z :=\n  by rw [mul_comm, sec_spec]\n#align sec_spec' sec_spec'\n\n",
 "sec_spec":
 "/-- Given `z : S`, `is_localization.sec M z` is defined to be a pair `(x, y) : R × M` such\nthat `z * f y = f x` (so this lemma is true by definition). -/\ntheorem sec_spec (z : S) : z * algebraMap R S (IsLocalization.sec M z).2 = algebraMap R S (IsLocalization.sec M z).1 :=\n  Classical.choose_spec <| is_localization.surj _ z\n#align sec_spec sec_spec\n\n",
 "sec_snd_ne_zero":
 "theorem sec_snd_ne_zero [Nontrivial R] (hM : M ≤ nonZeroDivisors R) (x : S) : ((sec M x).snd : R) ≠ 0 :=\n  nonZeroDivisors.coe_ne_zero ⟨(sec M x).snd.val, hM (sec M x).snd.property⟩\n#align sec_snd_ne_zero sec_snd_ne_zero\n\n",
 "sec_fst_ne_zero":
 "theorem sec_fst_ne_zero [Nontrivial R] [NoZeroDivisors S] (hM : M ≤ nonZeroDivisors R) {x : S} (hx : x ≠ 0) :\n    (sec M x).fst ≠ 0 := by\n  have hsec := sec_spec M x\n  intro hfst\n  rw [hfst, map_zero, mul_eq_zero, _root_.map_eq_zero_iff] at hsec\n  · exact or.elim hsec hx (sec_snd_ne_zero hM x)\n  · exact IsLocalization.injective S hM\n#align sec_fst_ne_zero sec_fst_ne_zero\n\n",
 "ring_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- See note [partially-applied ext lemmas] -/\ntheorem ring_hom_ext ⦃j k : «expr →+* » S P⦄ (h : j.comp (algebraMap R S) = k.comp (algebraMap R S)) : j = k :=\n  RingHom.coe_monoidHom_injective <| monoidHom_ext M <| MonoidHom.ext <| RingHom.congr_fun h\n#align ring_hom_ext ring_hom_ext\n\n",
 "ring_equiv_of_ring_equiv_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\ntheorem ring_equiv_of_ring_equiv_mk' {j : «expr ≃+* » R P} (H : M.map j.to_monoid_hom = T) (x : R) (y : M) :\n    ringEquivOfRingEquiv S Q j H (mk' S x y) = mk' Q (j x) ⟨j y, show j y ∈ T from H ▸ Set.mem_image_of_mem j y.2⟩ :=\n  map_mk' _ _ _\n#align ring_equiv_of_ring_equiv_mk' ring_equiv_of_ring_equiv_mk'\n\n",
 "ring_equiv_of_ring_equiv_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ring_equiv_of_ring_equiv_eq_map {j : «expr ≃+* » R P} (H : M.map j.to_monoid_hom = T) :\n    (ringEquivOfRingEquiv S Q j H : «expr →+* » S Q) =\n      map Q (j : «expr →+* » R P) (M.le_comap_of_map_le (le_of_eq H)) :=\n  rfl\n#align ring_equiv_of_ring_equiv_eq_map ring_equiv_of_ring_equiv_eq_map\n\n",
 "ring_equiv_of_ring_equiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem ring_equiv_of_ring_equiv_eq {j : «expr ≃+* » R P} (H : M.map j.to_monoid_hom = T) (x) :\n    ringEquivOfRingEquiv S Q j H ((algebraMap R S) x) = algebraMap P Q (j x) :=\n  map_eq _ _\n#align ring_equiv_of_ring_equiv_eq ring_equiv_of_ring_equiv_eq\n\n",
 "of_le":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\ntheorem of_le (N : Submonoid R) (h₁ : M ≤ N) (h₂ : ∀ r ∈ N, IsUnit (algebraMap R S r)) : IsLocalization N S :=\n  { map_units := fun r => h₂ r r.2\n    surj := fun s => by\n      obtain ⟨⟨x, y, hy⟩, H⟩ := is_localization.surj M s\n      exact ⟨⟨x, y, h₁ hy⟩, H⟩\n    eq_iff_exists := fun x y => by\n      constructor\n      · rw [is_localization.eq_iff_exists M]\n        rintro ⟨c, hc⟩\n        exact ⟨⟨c, h₁ c.2⟩, hc⟩\n      · rintro ⟨c, h⟩\n        simpa only [[anonymous], map_mul, (h₂ c c.2).mul_right_inj] using congr_arg (algebraMap R S) h }\n#align of_le of_le\n\n",
 "non_zero_divisors_le_comap":
 "theorem non_zero_divisors_le_comap [IsLocalization M S] :\n    nonZeroDivisors R ≤ (nonZeroDivisors S).comap (algebraMap R S) :=\n  by\n  rintro a ha b (e : b * algebraMap R S a = 0)\n  obtain ⟨x, s, rfl⟩ := mk'_surjective M b\n  rw [← @mk'_one R _ M, ← mk'_mul, ← (algebraMap R S).map_zero, ← @mk'_one R _ M, IsLocalization.eq] at e\n  obtain ⟨c, e⟩ := e\n  rw [MulZeroClass.mul_zero, MulZeroClass.mul_zero, Submonoid.coe_one, one_mul, ← mul_assoc] at e\n  rw [mk'_eq_zero_iff]\n  exact ⟨c, ha _ e⟩\n#align non_zero_divisors_le_comap non_zero_divisors_le_comap\n\n",
 "no_zero_divisors_of_le_non_zero_divisors":
 "/-- A `comm_ring` `S` which is the localization of a ring `R` without zero divisors at a subset of\nnon-zero elements does not have zero divisors.\nSee note [reducible non-instances]. -/\n@[reducible]\ntheorem no_zero_divisors_of_le_non_zero_divisors [Algebra A S] {M : Submonoid A} [IsLocalization M S]\n    (hM : M ≤ nonZeroDivisors A) : NoZeroDivisors S :=\n  {\n    eq_zero_or_eq_zero_of_mul_eq_zero := by\n      intro z w h\n      cases' surj M z with x hx\n      cases' surj M w with y hy\n      have : z * w * algebraMap A S y.2 * algebraMap A S x.2 = algebraMap A S x.1 * algebraMap A S y.1 := by\n        rw [mul_assoc z, hy, ← hx] <;> ring\n      rw [h, MulZeroClass.zero_mul, MulZeroClass.zero_mul, ← (algebraMap A S).map_mul] at this\n      cases' eq_zero_or_eq_zero_of_mul_eq_zero ((to_map_eq_zero_iff S hM).mp this.symm) with H H\n      · exact or.inl (eq_zero_of_fst_eq_zero hx H)\n      · exact or.inr (eq_zero_of_fst_eq_zero hy H) }\n#align no_zero_divisors_of_le_non_zero_divisors no_zero_divisors_of_le_non_zero_divisors\n\n",
 "neg_mk":
 "theorem neg_mk (a b) : -(mk a b : Localization M) = mk (-a) b :=\n  by\n  unfold has_neg.neg Localization.neg\n  apply lift_on_mk\n#align neg_mk neg_mk\n\n",
 "ne_zero_of_mk'_ne_zero":
 "theorem ne_zero_of_mk'_ne_zero {x : R} {y : M} (hxy : IsLocalization.mk' S x y ≠ 0) : x ≠ 0 :=\n  by\n  rintro rfl\n  exact hxy (IsLocalization.mk'_zero _)\n#align ne_zero_of_mk'_ne_zero ne_zero_of_mk'_ne_zero\n\n",
 "mul_mk'_eq_mk'_of_mul":
 "theorem mul_mk'_eq_mk'_of_mul (x y : R) (z : M) : (algebraMap R S) x * mk' S y z = mk' S (x * y) z :=\n  (toLocalizationMap M S).mul_mk'_eq_mk'_of_mul _ _ _\n#align mul_mk'_eq_mk'_of_mul mul_mk'_eq_mk'_of_mul\n\n",
 "mul_add_inv_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem mul_add_inv_left {g : «expr →+* » R P} (h : ∀ y : M, IsUnit (g y)) (y : M) (w z₁ z₂ : P) :\n    w * ↑(IsUnit.liftRight (g.to_monoid_hom.restrict M) h y)⁻¹ + z₁ = z₂ ↔ w + g y * z₁ = g y * z₂ :=\n  by\n  rw [mul_comm, ← one_mul z₁, ← Units.inv_mul (IsUnit.liftRight (g.to_monoid_hom.restrict M) h y), mul_assoc, ← mul_add,\n    Units.inv_mul_eq_iff_eq_mul, Units.inv_mul_cancel_left, IsUnit.coe_liftRight]\n  simp only [RingHom.toMonoidHom_eq_coe, MonoidHom.restrict_apply, [anonymous]]\n#align mul_add_inv_left mul_add_inv_left\n\n",
 "monoid_of_eq_algebra_map":
 "theorem monoid_of_eq_algebra_map (x) : (monoidOf M).to_map x = algebraMap R (Localization M) x :=\n  rfl\n#align monoid_of_eq_algebra_map monoid_of_eq_algebra_map\n\n",
 "monoid_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- See note [partially-applied ext lemmas] -/\ntheorem monoid_hom_ext ⦃j k : «expr →* » S P⦄ (h : j.comp (algebraMap R S : «expr →* » R S) = k.comp (algebraMap R S)) :\n    j = k :=\n  Submonoid.LocalizationMap.epic_of_localizationMap (toLocalizationMap M S) <| MonoidHom.congr_fun h\n#align monoid_hom_ext monoid_hom_ext\n\n",
 "mk_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mk_sum {ι : Type _} (f : ι → R) (s : Finset ι) (b : M) :\n    mk (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)) b =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (mk (f i) b) :=\n  (mkAddMonoidHom b).map_sum f s\n#align mk_sum mk_sum\n\n",
 "mk_one_eq_algebra_map":
 "theorem mk_one_eq_algebra_map (x) : mk x 1 = algebraMap R (Localization M) x :=\n  rfl\n#align mk_one_eq_algebra_map mk_one_eq_algebra_map\n\n",
 "mk_nat_cast":
 "theorem mk_nat_cast (m : ℕ) : (mk m 1 : Localization M) = m := by simpa using @mk_algebra_map R _ M ℕ _ _ m\n#align mk_nat_cast mk_nat_cast\n\n",
 "mk_multiset_sum":
 "theorem mk_multiset_sum (l : Multiset R) (b : M) : mk l.sum b = (l.map fun a => mk a b).sum :=\n  (mkAddMonoidHom b).map_multiset_sum l\n#align mk_multiset_sum mk_multiset_sum\n\n",
 "mk_list_sum":
 "theorem mk_list_sum (l : List R) (b : M) : mk l.sum b = (l.map fun a => mk a b).sum :=\n  (mkAddMonoidHom b).map_list_sum l\n#align mk_list_sum mk_list_sum\n\n",
 "mk_int_cast":
 "theorem mk_int_cast (m : ℤ) : (mk m 1 : Localization M) = m := by simpa using @mk_algebra_map R _ M ℤ _ _ m\n#align mk_int_cast mk_int_cast\n\n",
 "mk_eq_mk'_apply":
 "theorem mk_eq_mk'_apply (x y) : mk x y = IsLocalization.mk' (Localization M) x y := by\n  rw [mk_eq_monoid_of_mk'_apply, mk', to_localization_map_eq_monoid_of]\n#align mk_eq_mk'_apply mk_eq_mk'_apply\n\n",
 "mk_eq_mk'":
 "@[simp]\ntheorem mk_eq_mk' : (mk : R → M → Localization M) = IsLocalization.mk' (Localization M) :=\n  mk_eq_monoidOf_mk'\n#align mk_eq_mk' mk_eq_mk'\n\n",
 "mk_algebra_map":
 "theorem mk_algebra_map {A : Type _} [CommSemiring A] [Algebra A R] (m : A) :\n    mk (algebraMap A R m) 1 = algebraMap A (Localization M) m := by\n  rw [mk_eq_mk', mk'_eq_iff_eq_mul, Submonoid.coe_one, map_one, mul_one] <;> rfl\n#align mk_algebra_map mk_algebra_map\n\n",
 "mk'_zero":
 "@[simp]\ntheorem mk'_zero (s : M) : IsLocalization.mk' S 0 s = 0 := by\n  rw [eq_comm, IsLocalization.eq_mk'_iff_mul_eq, MulZeroClass.zero_mul, map_zero]\n#align mk'_zero mk'_zero\n\n",
 "mk'_surjective":
 "theorem mk'_surjective (z : S) : ∃ (x : _)(y : M), mk' S x y = z :=\n  let ⟨r, hr⟩ := is_localization.surj _ z\n  ⟨r.1, r.2, (eq_mk'_iff_mul_eq.2 hr).symm⟩\n#align mk'_surjective mk'_surjective\n\n",
 "mk'_spec_mk":
 "@[simp]\ntheorem mk'_spec_mk (x) (y : R) (hy : y ∈ M) : mk' S x ⟨y, hy⟩ * algebraMap R S y = algebraMap R S x :=\n  mk'_spec S x ⟨y, hy⟩\n#align mk'_spec_mk mk'_spec_mk\n\n",
 "mk'_spec'_mk":
 "@[simp]\ntheorem mk'_spec'_mk (x) (y : R) (hy : y ∈ M) : algebraMap R S y * mk' S x ⟨y, hy⟩ = algebraMap R S x :=\n  mk'_spec' S x ⟨y, hy⟩\n#align mk'_spec'_mk mk'_spec'_mk\n\n",
 "mk'_spec'":
 "@[simp]\ntheorem mk'_spec' (x) (y : M) : algebraMap R S y * mk' S x y = algebraMap R S x :=\n  (toLocalizationMap M S).mk'_spec' _ _\n#align mk'_spec' mk'_spec'\n\n",
 "mk'_spec":
 "@[simp]\ntheorem mk'_spec (x) (y : M) : mk' S x y * algebraMap R S y = algebraMap R S x :=\n  (toLocalizationMap M S).mk'_spec _ _\n#align mk'_spec mk'_spec\n\n",
 "mk'_self''":
 "theorem mk'_self'' {x : M} : mk' S x.1 x = 1 :=\n  mk'_self' _\n#align mk'_self'' mk'_self''\n\n",
 "mk'_self'":
 "@[simp]\ntheorem mk'_self' {x : M} : mk' S (x : R) x = 1 :=\n  (toLocalizationMap M S).mk'_self' _\n#align mk'_self' mk'_self'\n\n",
 "mk'_self":
 "@[simp]\ntheorem mk'_self {x : R} (hx : x ∈ M) : mk' S x ⟨x, hx⟩ = 1 :=\n  (toLocalizationMap M S).mk'_self _ hx\n#align mk'_self mk'_self\n\n",
 "mk'_sec":
 "@[simp]\ntheorem mk'_sec (z : S) : mk' S (IsLocalization.sec M z).1 (IsLocalization.sec M z).2 = z :=\n  (toLocalizationMap M S).mk'_sec _\n#align mk'_sec mk'_sec\n\n",
 "mk'_one":
 "theorem mk'_one (x) : mk' S x (1 : M) = algebraMap R S x :=\n  (toLocalizationMap M S).mk'_one _\n#align mk'_one mk'_one\n\n",
 "mk'_mul_mk'_eq_one'":
 "theorem mk'_mul_mk'_eq_one' (x : R) (y : M) (h : x ∈ M) : mk' S x y * mk' S (y : R) ⟨x, h⟩ = 1 :=\n  mk'_mul_mk'_eq_one ⟨x, h⟩ _\n#align mk'_mul_mk'_eq_one' mk'_mul_mk'_eq_one'\n\n",
 "mk'_mul_mk'_eq_one":
 "@[simp]\ntheorem mk'_mul_mk'_eq_one (x y : M) : mk' S (x : R) y * mk' S (y : R) x = 1 := by\n  rw [← mk'_mul, mul_comm] <;> exact mk'_self _ _\n#align mk'_mul_mk'_eq_one mk'_mul_mk'_eq_one\n\n",
 "mk'_mul_cancel_right":
 "theorem mk'_mul_cancel_right (x : R) (y : M) : mk' S (x * y) y = (algebraMap R S) x :=\n  (toLocalizationMap M S).mk'_mul_cancel_right _ _\n#align mk'_mul_cancel_right mk'_mul_cancel_right\n\n",
 "mk'_mul_cancel_left":
 "@[simp]\ntheorem mk'_mul_cancel_left (x : R) (y : M) : mk' S (y * x : R) y = (algebraMap R S) x :=\n  (toLocalizationMap M S).mk'_mul_cancel_left _ _\n#align mk'_mul_cancel_left mk'_mul_cancel_left\n\n",
 "mk'_mul":
 "theorem mk'_mul (x₁ x₂ : R) (y₁ y₂ : M) : mk' S (x₁ * x₂) (y₁ * y₂) = mk' S x₁ y₁ * mk' S x₂ y₂ :=\n  (toLocalizationMap M S).mk'_mul _ _ _ _\n#align mk'_mul mk'_mul\n\n",
 "mk'_mem_iff":
 "theorem mk'_mem_iff {x} {y : M} {I : Ideal S} : mk' S x y ∈ I ↔ algebraMap R S x ∈ I :=\n  by\n  constructor <;> intro h\n  · rw [← mk'_spec S x y, mul_comm]\n    exact I.mul_mem_left ((algebraMap R S) y) h\n  · rw [← mk'_spec S x y] at h\n    obtain ⟨b, hb⟩ := isUnit_iff_exists_inv.1 (map_units S y)\n    have := I.mul_mem_left b h\n    rwa [mul_comm, mul_assoc, hb, mul_one] at this\n#align mk'_mem_iff mk'_mem_iff\n\n",
 "mk'_eq_zero_iff":
 "theorem mk'_eq_zero_iff (x : R) (s : M) : mk' S x s = 0 ↔ ∃ m : M, ↑m * x = 0 := by\n  rw [← (map_units S s).mul_left_inj, mk'_spec, MulZeroClass.zero_mul, map_eq_zero_iff M]\n#align mk'_eq_zero_iff mk'_eq_zero_iff\n\n",
 "mk'_eq_of_eq'":
 "theorem mk'_eq_of_eq' {a₁ b₁ : R} {a₂ b₂ : M} (H : b₁ * ↑a₂ = a₁ * ↑b₂) : mk' S a₁ a₂ = mk' S b₁ b₂ :=\n  (toLocalizationMap M S).mk'_eq_of_eq' H\n#align mk'_eq_of_eq' mk'_eq_of_eq'\n\n",
 "mk'_eq_of_eq":
 "theorem mk'_eq_of_eq {a₁ b₁ : R} {a₂ b₂ : M} (H : ↑a₂ * b₁ = ↑b₂ * a₁) : mk' S a₁ a₂ = mk' S b₁ b₂ :=\n  (toLocalizationMap M S).mk'_eq_of_eq H\n#align mk'_eq_of_eq mk'_eq_of_eq\n\n",
 "mk'_eq_mul_mk'_one":
 "theorem mk'_eq_mul_mk'_one (x : R) (y : M) : mk' S x y = (algebraMap R S) x * mk' S 1 y :=\n  ((toLocalizationMap M S).mul_mk'_one_eq_mk' _ _).symm\n#align mk'_eq_mul_mk'_one mk'_eq_mul_mk'_one\n\n",
 "mk'_eq_iff_mk'_eq":
 "theorem mk'_eq_iff_mk'_eq {x₁ x₂} {y₁ y₂ : M} : mk' S x₁ y₁ = mk' S x₂ y₂ ↔ mk' P x₁ y₁ = mk' P x₂ y₂ :=\n  (toLocalizationMap M S).mk'_eq_iff_mk'_eq (toLocalizationMap M P)\n#align mk'_eq_iff_mk'_eq mk'_eq_iff_mk'_eq\n\n",
 "mk'_eq_iff_eq_mul":
 "theorem mk'_eq_iff_eq_mul {x} {y : M} {z} : mk' S x y = z ↔ algebraMap R S x = z * algebraMap R S y :=\n  (toLocalizationMap M S).mk'_eq_iff_eq_mul\n#align mk'_eq_iff_eq_mul mk'_eq_iff_eq_mul\n\n",
 "mk'_eq_iff_eq'":
 "theorem mk'_eq_iff_eq' {x₁ x₂} {y₁ y₂ : M} :\n    mk' S x₁ y₁ = mk' S x₂ y₂ ↔ algebraMap R S (x₁ * y₂) = algebraMap R S (x₂ * y₁) :=\n  (toLocalizationMap M S).mk'_eq_iff_eq'\n#align mk'_eq_iff_eq' mk'_eq_iff_eq'\n\n",
 "mk'_eq_iff_eq":
 "theorem mk'_eq_iff_eq {x₁ x₂} {y₁ y₂ : M} :\n    mk' S x₁ y₁ = mk' S x₂ y₂ ↔ algebraMap R S (y₂ * x₁) = algebraMap R S (y₁ * x₂) :=\n  (toLocalizationMap M S).mk'_eq_iff_eq\n#align mk'_eq_iff_eq mk'_eq_iff_eq\n\n",
 "mk'_add_eq_iff_add_mul_eq_mul":
 "theorem mk'_add_eq_iff_add_mul_eq_mul {x} {y : M} {z₁ z₂} :\n    mk' S x y + z₁ = z₂ ↔ algebraMap R S x + z₁ * algebraMap R S y = z₂ * algebraMap R S y := by\n  rw [← mk'_spec S x y, ← IsUnit.mul_left_inj (is_localization.map_units S y), right_distrib]\n#align mk'_add_eq_iff_add_mul_eq_mul mk'_add_eq_iff_add_mul_eq_mul\n\n",
 "mk'_add":
 "theorem mk'_add (x₁ x₂ : R) (y₁ y₂ : M) : mk' S (x₁ * y₂ + x₂ * y₁) (y₁ * y₂) = mk' S x₁ y₁ + mk' S x₂ y₂ :=\n  mk'_eq_iff_eq_mul.2 <|\n    Eq.symm\n      (by\n        rw [mul_comm (_ + _), mul_add, mul_mk'_eq_mk'_of_mul, mk'_add_eq_iff_add_mul_eq_mul, mul_comm (_ * _), ←\n          mul_assoc, add_comm, ← map_mul, mul_mk'_eq_mk'_of_mul, mk'_add_eq_iff_add_mul_eq_mul]\n        simp only [map_add, Submonoid.coe_mul, map_mul]\n        ring)\n#align mk'_add mk'_add\n\n",
 "map_units_map_submonoid":
 "#print IsLocalization.map_units_map_submonoid /-\n-- this looks weird due to the `letI` inside the above lemma, but trying to do it the other\n-- way round causes issues with defeq of instances, so this is actually easier.\ntheorem IsLocalization.map_units_map_submonoid (y : M) : IsUnit (algebraMap R Sₘ y) :=\n  by\n  rw [IsScalarTower.algebraMap_apply _ S]\n  exact is_localization.map_units Sₘ ⟨algebraMap R S y, Algebra.mem_algebraMapSubmonoid_of_mem y⟩\n#align is_localization.map_units_map_submonoid IsLocalization.map_units_map_submonoid\n-/\n\n",
 "map_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_unique (j : «expr →+* » S Q) (hj : ∀ x : R, j (algebraMap R S x) = algebraMap P Q (g x)) : map Q g hy = j :=\n  lift_unique (fun y => map_units _ ⟨g y, hy y.2⟩) hj\n#align map_unique map_unique\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_smul (x : S) (z : R) : map Q g hy («expr • » z x : S) = «expr • » (g z) (map Q g hy x) := by\n  rw [Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, map_eq]\n#align map_smul map_smul\n\n",
 "map_right_cancel":
 "theorem map_right_cancel {x y} {c : M} (h : algebraMap R S (c * x) = algebraMap R S (c * y)) :\n    algebraMap R S x = algebraMap R S y :=\n  (toLocalizationMap M S).map_right_cancel h\n#align map_right_cancel map_right_cancel\n\n",
 "map_non_zero_divisors_le":
 "theorem map_non_zero_divisors_le [IsLocalization M S] : (nonZeroDivisors R).map (algebraMap R S) ≤ nonZeroDivisors S :=\n  Submonoid.map_le_iff_le_comap.mpr (nonZeroDivisors_le_comap M S)\n#align map_non_zero_divisors_le map_non_zero_divisors_le\n\n",
 "map_mk'":
 "theorem map_mk' (x) (y : M) : map Q g hy (mk' S x y) = mk' Q (g x) ⟨g y, hy y.2⟩ :=\n  @Submonoid.LocalizationMap.map_mk' _ _ _ _ _ _ _ (toLocalizationMap M S) g.to_monoid_hom _ (fun y => hy y.2) _ _\n    (toLocalizationMap T Q) _ _\n#align map_mk' map_mk'\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `comm_semiring` homs `g : R →+* P, l : P →+* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\ntheorem map_map {A : Type _} [CommSemiring A] {U : Submonoid A} {W} [CommSemiring W] [Algebra A W] [IsLocalization U W]\n    {l : «expr →+* » P A} (hl : T ≤ U.comap l) (x : S) :\n    map W l hl (map Q g hy x) = map W (l.comp g) (fun x hx => hl (hy hx)) x := by rw [← map_comp_map hy hl] <;> rfl\n#align map_map map_map\n\n",
 "map_left_cancel":
 "theorem map_left_cancel {x y} {c : M} (h : algebraMap R S (x * c) = algebraMap R S (y * c)) :\n    algebraMap R S x = algebraMap R S y :=\n  (toLocalizationMap M S).map_left_cancel h\n#align map_left_cancel map_left_cancel\n\n",
 "map_injective_of_injective":
 "/-- Injectivity of a map descends to the map induced on localizations. -/\ntheorem map_injective_of_injective (hg : function.injective g) [IsLocalization (M.map g : Submonoid P) Q] :\n    function.injective (map Q g M.le_comap_map : S → Q) :=\n  by\n  rw [injective_iff_map_eq_zero]\n  intro z hz\n  obtain ⟨a, b, rfl⟩ := mk'_surjective M z\n  rw [map_mk', mk'_eq_zero_iff] at hz\n  obtain ⟨⟨m', hm'⟩, hm⟩ := hz\n  rw [Submonoid.mem_map] at hm'\n  obtain ⟨n, hn, hnm⟩ := hm'\n  rw [Subtype.coe_mk, ← hnm, ← map_mul, ← map_zero g] at hm\n  rw [mk'_eq_zero_iff]\n  exact ⟨⟨n, hn⟩, hg hm⟩\n#align map_injective_of_injective map_injective_of_injective\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (z : S) (h : M ≤ M.comap (RingHom.id R) := le_refl M) : map S (RingHom.id _) h z = z :=\n  lift_id _\n#align map_id map_id\n\n",
 "map_eq_zero_iff":
 "#print map_eq_zero_iff /-\ntheorem map_eq_zero_iff (r : R) : algebraMap R S r = 0 ↔ ∃ m : M, ↑m * r = 0 :=\n  by\n  constructor\n  intro h\n  · obtain ⟨m, hm⟩ := (is_localization.eq_iff_exists M S).mp ((algebraMap R S).map_zero.trans h.symm)\n    exact ⟨m, by simpa using hm.symm⟩\n  · rintro ⟨m, hm⟩\n    rw [← (is_localization.map_units S m).mul_right_inj, MulZeroClass.mul_zero, ← RingHom.map_mul, hm, RingHom.map_zero]\n#align map_eq_zero_iff map_eq_zero_iff\n-/\n\n",
 "map_eq":
 "theorem map_eq (x) : map Q g hy ((algebraMap R S) x) = algebraMap P Q (g x) :=\n  lift_eq (fun y => map_units _ ⟨g y, hy y.2⟩) x\n#align map_eq map_eq\n\n",
 "map_comp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `comm_semiring` homs `g : R →+* P, l : P →+* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\ntheorem map_comp_map {A : Type _} [CommSemiring A] {U : Submonoid A} {W} [CommSemiring W] [Algebra A W]\n    [IsLocalization U W] {l : «expr →+* » P A} (hl : T ≤ U.comap l) :\n    (map W l hl).comp (map Q g hy : «expr →+* » S _) = map W (l.comp g) fun x hx => hl (hy hx) :=\n  RingHom.ext fun x =>\n    @Submonoid.LocalizationMap.map_map _ _ _ _ _ P _ (toLocalizationMap M S) g _ _ _ _ _ _ _ _ _ _\n      (toLocalizationMap U W) l _ x\n#align map_comp_map map_comp_map\n\n",
 "map_comp":
 "@[simp]\ntheorem map_comp : (map Q g hy).comp (algebraMap R S) = (algebraMap P Q).comp g :=\n  lift_comp fun y => map_units _ ⟨g y, hy y.2⟩\n#align map_comp map_comp\n\n",
 "localization_map_bijective":
 "#print Field.localization_map_bijective /-\n/-- If `R` is a field, then localizing at a submonoid not containing `0` adds no new elements. -/\ntheorem Field.localization_map_bijective {K Kₘ : Type _} [Field K] [CommRing Kₘ] {M : Submonoid K} (hM : (0 : K) ∉ M)\n    [Algebra K Kₘ] [IsLocalization M Kₘ] : function.bijective (algebraMap K Kₘ) :=\n  (Field.toIsField K).localization_map_bijective hM\n#align field.localization_map_bijective Field.localization_map_bijective\n-/\n\n",
 "localizationAlgebra_injective":
 "#print localizationAlgebra_injective /-\n/-- Injectivity of the underlying `algebra_map` descends to the algebra induced by localization. -/\ntheorem localizationAlgebra_injective (hRS : function.injective (algebraMap R S)) :\n    function.injective (@algebraMap Rₘ Sₘ _ _ (localizationAlgebra M S)) :=\n  IsLocalization.map_injective_of_injective M Rₘ Sₘ hRS\n#align localization_algebra_injective localizationAlgebra_injective\n-/\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem lift_unique {j : «expr →+* » S P} (hj : ∀ x, j ((algebraMap R S) x) = g x) : lift hg = j :=\n  RingHom.ext <|\n    MonoidHom.ext_iff.1 <|\n      @Submonoid.LocalizationMap.lift_unique _ _ _ _ _ _ _ (toLocalizationMap M S) g.to_monoid_hom hg j.to_monoid_hom hj\n#align lift_unique lift_unique\n\n",
 "lift_surjective_iff":
 "theorem lift_surjective_iff : surjective (lift hg : S → P) ↔ ∀ v : P, ∃ x : R × M, v * g x.2 = g x.1 :=\n  (toLocalizationMap M S).lift_surjective_iff hg\n#align lift_surjective_iff lift_surjective_iff\n\n",
 "lift_spec_mul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem lift_spec_mul_add {g : «expr →+* » R P} (hg : ∀ y : M, IsUnit (g y)) (z w w' v) :\n    ((toLocalizationWithZeroMap M S).lift g.to_monoid_with_zero_hom hg) z * w + w' = v ↔\n      g ((toLocalizationMap M S).sec z).1 * w + g ((toLocalizationMap M S).sec z).2 * w' =\n        g ((toLocalizationMap M S).sec z).2 * v :=\n  by\n  show _ * _ * _ + _ = _ ↔ _ = _\n  erw [mul_comm, ← mul_assoc, mul_add_inv_left hg, mul_comm]\n  rfl\n#align lift_spec_mul_add lift_spec_mul_add\n\n",
 "lift_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem lift_of_comp (j : «expr →+* » S P) : lift (isUnit_comp M j) = j :=\n  RingHom.ext <| MonoidHom.ext_iff.1 <| (toLocalizationMap M S).lift_of_comp j.to_monoid_hom\n#align lift_of_comp lift_of_comp\n\n",
 "lift_mk'_spec":
 "theorem lift_mk'_spec (x v) (y : M) : lift hg (mk' S x y) = v ↔ g x = g y * v :=\n  (toLocalizationMap M S).lift_mk'_spec _ _ _ _\n#align lift_mk'_spec lift_mk'_spec\n\n",
 "lift_mk'":
 "/-- Given a localization map `f : R →+* S` for a submonoid `M ⊆ R` and a map of `comm_semiring`s\n`g : R →* P` such that `g y` is invertible for all `y : M`, the homomorphism induced from\n`S` to `P` maps `f x * (f y)⁻¹` to `g x * (g y)⁻¹` for all `x : R, y ∈ M`. -/\ntheorem lift_mk' (x y) : lift hg (mk' S x y) = g x * ↑(IsUnit.liftRight (g.to_monoid_hom.restrict M) hg y)⁻¹ :=\n  (toLocalizationMap M S).lift_mk' _ _ _\n#align lift_mk' lift_mk'\n\n",
 "lift_injective_iff":
 "theorem lift_injective_iff : injective (lift hg : S → P) ↔ ∀ x y, algebraMap R S x = algebraMap R S y ↔ g x = g y :=\n  (toLocalizationMap M S).lift_injective_iff hg\n#align lift_injective_iff lift_injective_iff\n\n",
 "lift_id":
 "@[simp]\ntheorem lift_id (x) : lift (map_units S : ∀ y : M, IsUnit _) x = x :=\n  (toLocalizationMap M S).lift_id _\n#align lift_id lift_id\n\n",
 "lift_eq_iff":
 "theorem lift_eq_iff {x y : R × M} : lift hg (mk' S x.1 x.2) = lift hg (mk' S y.1 y.2) ↔ g (x.1 * y.2) = g (y.1 * x.2) :=\n  (toLocalizationMap M S).lift_eq_iff _\n#align lift_eq_iff lift_eq_iff\n\n",
 "lift_eq":
 "@[simp]\ntheorem lift_eq (x : R) : lift hg ((algebraMap R S) x) = g x :=\n  (toLocalizationMap M S).lift_eq _ _\n#align lift_eq lift_eq\n\n",
 "lift_comp":
 "@[simp]\ntheorem lift_comp : (lift hg).comp (algebraMap R S) = g :=\n  RingHom.ext <| MonoidHom.ext_iff.1 <| (toLocalizationMap M S).lift_comp _\n#align lift_comp lift_comp\n\n",
 "lift_algebraMap_eq_algebraMap":
 "#print IsLocalization.lift_algebraMap_eq_algebraMap /-\ntheorem IsLocalization.lift_algebraMap_eq_algebraMap :\n    @IsLocalization.lift R _ M Rₘ _ _ Sₘ _ _ (algebraMap R Sₘ) (IsLocalization.map_units_map_submonoid S Sₘ) =\n      algebraMap Rₘ Sₘ :=\n  IsLocalization.lift_unique _ fun x => (IsScalarTower.algebraMap_apply _ _ _ _).symm\n#align is_localization.lift_algebra_map_eq_algebra_map IsLocalization.lift_algebraMap_eq_algebraMap\n-/\n\n",
 "is_unit_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_unit_comp (j : «expr →+* » S P) (y : M) : IsUnit (j.comp (algebraMap R S) y) :=\n  (toLocalizationMap M S).is_unit_comp j.to_monoid_hom _\n#align is_unit_comp is_unit_comp\n\n",
 "is_localization_of_base_ring_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\ntheorem is_localization_of_base_ring_equiv [IsLocalization M S] (h : «expr ≃+* » R P) :\n    @IsLocalization _ (M.map h.to_monoid_hom) S _ ((algebraMap R S).comp h.symm.to_ring_hom).to_algebra :=\n  by\n  constructor\n  · rintro ⟨_, ⟨y, hy, rfl⟩⟩\n    convert is_localization.map_units S ⟨y, hy⟩\n    dsimp only [RingHom.algebraMap_toAlgebra, RingHom.comp_apply]\n    exact congr_arg _ (h.symm_apply_apply _)\n  · intro y\n    obtain ⟨⟨x, s⟩, e⟩ := is_localization.surj M y\n    refine' ⟨⟨h x, _, _, s.prop, rfl⟩, _⟩\n    dsimp only [RingHom.algebraMap_toAlgebra, RingHom.comp_apply] at e⊢\n    convert e <;> exact h.symm_apply_apply _\n  · intro x y\n    rw [RingHom.algebraMap_toAlgebra, RingHom.comp_apply, RingHom.comp_apply, is_localization.eq_iff_exists M S]\n    simp_rw [← h.to_equiv.apply_eq_iff_eq]\n    change (∃ c : M, h (c * h.symm x) = h (c * h.symm y)) ↔ _\n    simp only [RingEquiv.apply_symm_apply, RingEquiv.map_mul]\n    exact ⟨fun ⟨c, e⟩ => ⟨⟨_, _, c.prop, rfl⟩, e⟩, fun ⟨⟨_, c, h, e₁⟩, e₂⟩ => ⟨⟨_, h⟩, e₁.symm ▸ e₂⟩⟩\n#align is_localization_of_base_ring_equiv is_localization_of_base_ring_equiv\n\n",
 "is_localization_of_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem is_localization_of_alg_equiv [Algebra R P] [IsLocalization M S] (h : «expr ≃ₐ[ ] » S R P) :\n    IsLocalization M P := by\n  constructor\n  · intro y\n    convert(is_localization.map_units S y).map h.to_alg_hom.to_ring_hom.to_monoid_hom\n    exact (h.commutes y).symm\n  · intro y\n    obtain ⟨⟨x, s⟩, e⟩ := is_localization.surj M (h.symm y)\n    apply_fun h  at e\n    simp only [h.map_mul, h.apply_symm_apply, h.commutes] at e\n    exact ⟨⟨x, s⟩, e⟩\n  · intro x y\n    rw [← h.symm.to_equiv.injective.eq_iff, ← is_localization.eq_iff_exists M S, ← h.symm.commutes, ← h.symm.commutes]\n    rfl\n#align is_localization_of_alg_equiv is_localization_of_alg_equiv\n\n",
 "is_localization_iff_of_ring_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\ntheorem is_localization_iff_of_ring_equiv (h : «expr ≃+* » S P) :\n    IsLocalization M S ↔ @IsLocalization _ M P _ (h.to_ring_hom.comp <| algebraMap R S).to_algebra :=\n  letI := (h.to_ring_hom.comp <| algebraMap R S).to_algebra\n  is_localization_iff_of_alg_equiv M { h with commutes' := fun _ => rfl }\n#align is_localization_iff_of_ring_equiv is_localization_iff_of_ring_equiv\n\n",
 "is_localization_iff_of_base_ring_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\ntheorem is_localization_iff_of_base_ring_equiv (h : «expr ≃+* » R P) :\n    IsLocalization M S ↔\n      @IsLocalization _ (M.map h.to_monoid_hom) S _ ((algebraMap R S).comp h.symm.to_ring_hom).to_algebra :=\n  by\n  refine' ⟨fun _ => is_localization_of_base_ring_equiv _ _ h, _⟩\n  letI := ((algebraMap R S).comp h.symm.to_ring_hom).to_algebra\n  intro H\n  convert@is_localization_of_base_ring_equiv _ _ _ _ _ _ H h.symm\n  · erw [Submonoid.map_equiv_eq_comap_symm, Submonoid.comap_map_eq_of_injective]\n    exact h.to_equiv.injective\n  rw [RingHom.algebraMap_toAlgebra, RingHom.comp_assoc]\n  simp only [RingHom.comp_id, RingEquiv.symm_symm, RingEquiv.symm_toRingHom_comp_toRingHom]\n  apply Algebra.algebra_ext\n  intro r\n  rw [RingHom.algebraMap_toAlgebra]\n#align is_localization_iff_of_base_ring_equiv is_localization_iff_of_base_ring_equiv\n\n",
 "is_localization_iff_of_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem is_localization_iff_of_alg_equiv [Algebra R P] (h : «expr ≃ₐ[ ] » S R P) :\n    IsLocalization M S ↔ IsLocalization M P :=\n  ⟨fun _ => is_localization_of_alg_equiv M h, fun _ => is_localization_of_alg_equiv M h.symm⟩\n#align is_localization_iff_of_alg_equiv is_localization_iff_of_alg_equiv\n\n",
 "is_domain_of_le_non_zero_divisors":
 "/-- A `comm_ring` `S` which is the localization of an integral domain `R` at a subset of\nnon-zero elements is an integral domain.\nSee note [reducible non-instances]. -/\n@[reducible]\ntheorem is_domain_of_le_non_zero_divisors [Algebra A S] {M : Submonoid A} [IsLocalization M S]\n    (hM : M ≤ nonZeroDivisors A) : IsDomain S :=\n  by\n  apply NoZeroDivisors.to_isDomain _\n  · exact ⟨⟨(algebraMap A S) 0, (algebraMap A S) 1, fun h => zero_ne_one (IsLocalization.injective S hM h)⟩⟩\n  · exact no_zero_divisors_of_le_non_zero_divisors _ hM\n#align is_domain_of_le_non_zero_divisors is_domain_of_le_non_zero_divisors\n\n",
 "is_domain_localization":
 "/-- The localization at of an integral domain to a set of non-zero elements is an integral domain.\nSee note [reducible non-instances]. -/\n@[reducible]\ntheorem is_domain_localization {M : Submonoid A} (hM : M ≤ nonZeroDivisors A) : IsDomain (Localization M) :=\n  isDomain_of_le_nonZeroDivisors _ hM\n#align is_domain_localization is_domain_localization\n\n",
 "injective":
 "protected theorem injective (hM : M ≤ nonZeroDivisors R) : injective (algebraMap R S) :=\n  by\n  rw [injective_iff_map_eq_zero (algebraMap R S)]\n  intro a ha\n  rwa [to_map_eq_zero_iff S hM] at ha\n#align injective injective\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- To show `j` and `k` agree on the whole localization, it suffices to show they agree\non the image of the base ring, if they preserve `1` and `*`. -/\nprotected theorem ext (j k : S → P) (hj1 : j 1 = 1) (hk1 : k 1 = 1) (hjm : ∀ a b, j (a * b) = j a * j b)\n    (hkm : ∀ a b, k (a * b) = k a * k b) (h : ∀ a, j (algebraMap R S a) = k (algebraMap R S a)) : j = k :=\n  monoid_hom.mk.inj (monoidHom_ext M <| MonoidHom.ext h : (⟨j, hj1, hjm⟩ : «expr →* » S P) = ⟨k, hk1, hkm⟩)\n#align ext ext\n\n",
 "eq_zero_of_fst_eq_zero":
 "theorem eq_zero_of_fst_eq_zero {z x} {y : M} (h : z * algebraMap R S y = algebraMap R S x) (hx : x = 0) : z = 0 :=\n  by\n  rw [hx, (algebraMap R S).map_zero] at h\n  exact (IsUnit.mul_left_eq_zero (is_localization.map_units S y)).1 h\n#align eq_zero_of_fst_eq_zero eq_zero_of_fst_eq_zero\n\n",
 "eq_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- Given a localization map `f : R →+* S` for a submonoid `M ⊆ R` and a map of `comm_semiring`s\n`g : R →+* P` such that `g(M) ⊆ units P`, `f x = f y → g x = g y` for all `x y : R`. -/\ntheorem eq_of_eq {g : «expr →+* » R P} (hg : ∀ y : M, IsUnit (g y)) {x y}\n    (h : (algebraMap R S) x = (algebraMap R S) y) : g x = g y :=\n  @Submonoid.LocalizationMap.eq_of_eq _ _ _ _ _ _ _ (toLocalizationMap M S) g.to_monoid_hom hg _ _ h\n#align eq_of_eq eq_of_eq\n\n",
 "eq_mk'_iff_mul_eq":
 "theorem eq_mk'_iff_mul_eq {x} {y : M} {z} : z = mk' S x y ↔ z * algebraMap R S y = algebraMap R S x :=\n  (toLocalizationMap M S).eq_mk'_iff_mul_eq\n#align eq_mk'_iff_mul_eq eq_mk'_iff_mul_eq\n\n",
 "eq_iff_eq":
 "theorem eq_iff_eq {x y} : algebraMap R S x = algebraMap R S y ↔ algebraMap R P x = algebraMap R P y :=\n  (toLocalizationMap M S).eq_iff_eq (toLocalizationMap M P)\n#align eq_iff_eq eq_iff_eq\n\n",
 "algebraMap_mk'":
 "#print IsLocalization.algebraMap_mk' /-\n@[simp]\ntheorem IsLocalization.algebraMap_mk' (x : R) (y : M) :\n    algebraMap Rₘ Sₘ (IsLocalization.mk' Rₘ x y) =\n      IsLocalization.mk' Sₘ (algebraMap R S x) ⟨algebraMap R S y, Algebra.mem_algebraMapSubmonoid_of_mem y⟩ :=\n  by\n  rw [IsLocalization.eq_mk'_iff_mul_eq, Subtype.coe_mk, ← IsScalarTower.algebraMap_apply, ←\n    IsScalarTower.algebraMap_apply, IsScalarTower.algebraMap_apply R Rₘ Sₘ, IsScalarTower.algebraMap_apply R Rₘ Sₘ, ←\n    _root_.map_mul, mul_comm, IsLocalization.mul_mk'_eq_mk'_of_mul]\n  exact congr_arg (algebraMap Rₘ Sₘ) (IsLocalization.mk'_mul_cancel_left x y)\n#align is_localization.algebra_map_mk' IsLocalization.algebraMap_mk'\n-/\n\n",
 "algebraMap_eq_map_map_submonoid":
 "#print IsLocalization.algebraMap_eq_map_map_submonoid /-\n/-- If the square below commutes, the bottom map is uniquely specified:\n```\nR  →  S\n↓     ↓\nRₘ → Sₘ\n```\n-/\ntheorem IsLocalization.algebraMap_eq_map_map_submonoid :\n    algebraMap Rₘ Sₘ =\n      map Sₘ (algebraMap R S) (show _ ≤ (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map) :=\n  Eq.symm <|\n    IsLocalization.map_unique _ (algebraMap Rₘ Sₘ) fun x => by\n      rw [← IsScalarTower.algebraMap_apply R S Sₘ, ← IsScalarTower.algebraMap_apply R Rₘ Sₘ]\n#align is_localization.algebra_map_eq_map_map_submonoid IsLocalization.algebraMap_eq_map_map_submonoid\n-/\n\n",
 "algebraMap_apply_eq_map_map_submonoid":
 "#print IsLocalization.algebraMap_apply_eq_map_map_submonoid /-\n/-- If the square below commutes, the bottom map is uniquely specified:\n```\nR  →  S\n↓     ↓\nRₘ → Sₘ\n```\n-/\ntheorem IsLocalization.algebraMap_apply_eq_map_map_submonoid (x) :\n    algebraMap Rₘ Sₘ x =\n      map Sₘ (algebraMap R S) (show _ ≤ (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map) x :=\n  FunLike.congr_fun (IsLocalization.algebraMap_eq_map_map_submonoid _ _ _ _) x\n#align is_localization.algebra_map_apply_eq_map_map_submonoid IsLocalization.algebraMap_apply_eq_map_map_submonoid\n-/\n\n",
 "alg_hom_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- This is not an instance because the submonoid `M` would become a metavariable\n  in typeclass search. -/\ntheorem alg_hom_subsingleton [Algebra R P] : subsingleton («expr →ₐ[ ] » S R P) :=\n  ⟨fun f g =>\n    AlgHom.coe_ringHom_injective <| IsLocalization.ringHom_ext M <| by rw [f.comp_algebra_map, g.comp_algebra_map]⟩\n#align alg_hom_subsingleton alg_hom_subsingleton\n\n",
 "alg_equiv_symm_mk'":
 "@[simp]\ntheorem alg_equiv_symm_mk' (x : R) (y : M) : (algEquiv M S).symm (mk' S x y) = mk' (Localization M) x y :=\n  algEquiv_symm_mk' _ _\n#align alg_equiv_symm_mk' alg_equiv_symm_mk'\n\n",
 "alg_equiv_symm_mk":
 "theorem alg_equiv_symm_mk (x : R) (y : M) : (algEquiv M S).symm (mk' S x y) = mk x y := by\n  rw [mk_eq_mk', alg_equiv_symm_mk']\n#align alg_equiv_symm_mk alg_equiv_symm_mk\n\n",
 "alg_equiv_mk'":
 "@[simp]\ntheorem alg_equiv_mk' (x : R) (y : M) : algEquiv M S (mk' (Localization M) x y) = mk' S x y :=\n  algEquiv_mk' _ _\n#align alg_equiv_mk' alg_equiv_mk'\n\n",
 "alg_equiv_mk":
 "theorem alg_equiv_mk (x y) : algEquiv M S (mk x y) = mk' S x y := by rw [mk_eq_mk', alg_equiv_mk']\n#align alg_equiv_mk alg_equiv_mk\n\n",
 "add_mk_self":
 "theorem add_mk_self (a b c) : (mk a b : Localization M) + mk c b = mk (a + c) b :=\n  by\n  rw [add_mk, mk_eq_mk_iff, r_eq_r']\n  refine' (r' M).symm ⟨1, _⟩\n  simp only [Submonoid.coe_one, Submonoid.coe_mul]\n  ring\n#align add_mk_self add_mk_self\n\n",
 "add_mk":
 "theorem add_mk (a b c d) : (mk a b : Localization M) + mk c d = mk (b * c + d * a) (b * d) :=\n  by\n  unfold has_add.add Localization.add\n  apply lift_on₂_mk\n#align add_mk add_mk\n\n",
 "Eq":
 "#print Eq /-\nprotected theorem Eq {a₁ b₁} {a₂ b₂ : M} : mk' S a₁ a₂ = mk' S b₁ b₂ ↔ ∃ c : M, ↑c * (↑b₂ * a₁) = c * (a₂ * b₁) :=\n  (toLocalizationMap M S).eq\n#align eq Eq\n-/\n\n"}