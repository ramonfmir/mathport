{"mul_inv_self":
 "#print mul_inv_self /-\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\n@[simp]\ntheorem mul_inv_self : algebra_map R S x * inv_self x = 1 :=\n  by\n  convert is_localization.mk'_mul_mk'_eq_one _ 1\n  symm\n  apply is_localization.mk'_one\n#align mul_inv_self mul_inv_self\n-/\n\n",
 "lift_eq":
 "@[simp]\ntheorem away_map.lift_eq (hg : is_unit (g x)) (a : R) : lift x hg ((algebra_map R S) a) = g a :=\n  lift_eq _ _\n#align away_map.lift_eq away_map.lift_eq\n\n",
 "lift_comp":
 "@[simp]\ntheorem away_map.lift_comp (hg : is_unit (g x)) : (lift x hg).comp (algebra_map R S) = g :=\n  lift_comp _\n#align away_map.lift_comp away_map.lift_comp\n\n",
 "finite_presentation":
 "theorem is_localization.away.finite_presentation (r : R) {S} [CommRing S] [algebra R S] [is_localization.away r S] :\n    algebra.finite_presentation R S :=\n  (adjoin_root.finite_presentation _).equiv <|\n    (localization.away_equiv_adjoin r).symm.trans <| is_localization.alg_equiv (submonoid.powers r) _ _\n#align is_localization.away.finite_presentation is_localization.away.finite_presentation\n\n",
 "away_of_is_unit_of_bijective":
 "theorem away_of_is_unit_of_bijective {R : Type _} (S : Type _) [CommRing R] [CommRing S] [algebra R S] {r : R}\n    (hr : is_unit r) (H : function.bijective (algebra_map R S)) : is_localization.away r S :=\n  { map_units := by\n      rintro ⟨_, n, rfl⟩\n      exact (algebra_map R S).is_unit_map (hr.pow _)\n    surj := fun z => by\n      obtain ⟨z', rfl⟩ := H.2 z\n      exact ⟨⟨z', 1⟩, by simp⟩\n    eq_iff_exists := fun x y => by\n      erw [H.1.eq_iff]\n      constructor\n      · rintro rfl\n        exact ⟨1, rfl⟩\n      · rintro ⟨⟨_, n, rfl⟩, e⟩\n        exact (hr.pow _).mul_left_inj.mp e }\n#align away_of_is_unit_of_bijective away_of_is_unit_of_bijective\n\n",
 "adjoin_inv":
 "theorem is_localization.adjoin_inv (r : R) : is_localization.away r (adjoin_root <| C r * X - 1) :=\n  is_localization.is_localization_of_alg_equiv _ (localization.away_equiv_adjoin r)\n#align is_localization.adjoin_inv is_localization.adjoin_inv\n\n"}