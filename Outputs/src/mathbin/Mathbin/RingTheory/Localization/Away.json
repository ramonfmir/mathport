{"self_zpow_zero":
 "@[simp]\ntheorem self_zpow_zero : self_zpow x B 0 = 1 := by simp [self_zpow_of_nonneg _ _ le_rfl]\n#align self_zpow_zero self_zpow_zero\n\n",
 "self_zpow_sub_cast_nat":
 "@[simp]\ntheorem self_zpow_sub_cast_nat {n m : ℕ} : self_zpow x B (n - m) = mk' _ (x ^ n) (Submonoid.pow x m) :=\n  by\n  by_cases h : m ≤ n\n  ·\n    rw [IsLocalization.eq_mk'_iff_mul_eq, Submonoid.pow_apply, Subtype.coe_mk, ← Int.ofNat_sub h, self_zpow_coe_nat, ←\n      map_pow, ← map_mul, ← pow_add, nat.sub_add_cancel h]\n  · rw [← neg_sub, ← Int.ofNat_sub (le_of_not_le h), self_zpow_neg_coe_nat, IsLocalization.mk'_eq_iff_eq]\n    simp [Submonoid.pow_apply, ← pow_add, nat.sub_add_cancel (le_of_not_le h)]\n#align self_zpow_sub_cast_nat self_zpow_sub_cast_nat\n\n",
 "self_zpow_pow_sub":
 "theorem self_zpow_pow_sub (a : R) (b : B) (m d : ℤ) :\n    self_zpow x B (m - d) * mk' B a (1 : Submonoid.powers x) = b ↔\n      self_zpow x B m * mk' B a (1 : Submonoid.powers x) = self_zpow x B d * b :=\n  by\n  rw [sub_eq_add_neg, self_zpow_add, mul_assoc, mul_comm _ (mk' B a 1), ← mul_assoc]\n  constructor\n  · intro h\n    have := congr_arg (fun s : B => s * self_zpow x B d) h\n    simp only at this\n    rwa [mul_assoc, mul_assoc, self_zpow_neg_mul, mul_one, mul_comm b _] at this\n  · intro h\n    have := congr_arg (fun s : B => s * self_zpow x B (-d)) h\n    simp only at this\n    rwa [mul_comm _ b, mul_assoc b _ _, self_zpow_mul_neg, mul_one] at this\n#align self_zpow_pow_sub self_zpow_pow_sub\n\n",
 "self_zpow_of_nonpos":
 "theorem self_zpow_of_nonpos {n : ℤ} (hn : n ≤ 0) : self_zpow x B n = mk' _ (1 : R) (Submonoid.pow x n.nat_abs) :=\n  by\n  by_cases hn0 : n = 0\n  · simp [hn0, self_zpow_zero, Submonoid.pow_apply]\n  · simp [self_zpow_of_neg _ _ (lt_of_le_of_ne hn hn0)]\n#align self_zpow_of_nonpos self_zpow_of_nonpos\n\n",
 "self_zpow_of_nonneg":
 "theorem self_zpow_of_nonneg {n : ℤ} (hn : 0 ≤ n) : self_zpow x B n = algebraMap R B x ^ n.nat_abs :=\n  dif_pos hn\n#align self_zpow_of_nonneg self_zpow_of_nonneg\n\n",
 "self_zpow_of_neg":
 "theorem self_zpow_of_neg {n : ℤ} (hn : n < 0) : self_zpow x B n = mk' _ (1 : R) (Submonoid.pow x n.nat_abs) :=\n  dif_neg hn.not_le\n#align self_zpow_of_neg self_zpow_of_neg\n\n",
 "self_zpow_neg_mul":
 "theorem self_zpow_neg_mul (d : ℤ) : self_zpow x B (-d) * self_zpow x B d = 1 := by\n  rw [mul_comm, self_zpow_mul_neg x B d]\n#align self_zpow_neg_mul self_zpow_neg_mul\n\n",
 "self_zpow_neg_coe_nat":
 "@[simp]\ntheorem self_zpow_neg_coe_nat (d : ℕ) : self_zpow x B (-d) = mk' _ (1 : R) (Submonoid.pow x d) := by\n  simp [self_zpow_of_nonpos _ _ (neg_nonpos.mpr (Int.coe_nat_nonneg d))]\n#align self_zpow_neg_coe_nat self_zpow_neg_coe_nat\n\n",
 "self_zpow_mul_neg":
 "theorem self_zpow_mul_neg (d : ℤ) : self_zpow x B d * self_zpow x B (-d) = 1 :=\n  by\n  by_cases hd : d ≤ 0\n  · erw [self_zpow_of_nonpos x B hd, self_zpow_of_nonneg, ← map_pow, Int.natAbs_neg, IsLocalization.mk'_spec, map_one]\n    apply nonneg_of_neg_nonpos\n    rwa [neg_neg]\n  · erw [self_zpow_of_nonneg x B (le_of_not_le hd), self_zpow_of_nonpos, ← map_pow, Int.natAbs_neg,\n      @IsLocalization.mk'_spec' R _ (Submonoid.powers x) B _ _ _ 1 (Submonoid.pow x d.nat_abs), map_one]\n    refine' nonpos_of_neg_nonneg (le_of_lt _)\n    rwa [neg_neg, ← not_le]\n#align self_zpow_mul_neg self_zpow_mul_neg\n\n",
 "self_zpow_coe_nat":
 "@[simp]\ntheorem self_zpow_coe_nat (d : ℕ) : self_zpow x B d = algebraMap R B x ^ d :=\n  self_zpow_of_nonneg _ _ (Int.coe_nat_nonneg d)\n#align self_zpow_coe_nat self_zpow_coe_nat\n\n",
 "self_zpow_add":
 "@[simp]\ntheorem self_zpow_add {n m : ℤ} : self_zpow x B (n + m) = self_zpow x B n * self_zpow x B m :=\n  by\n  cases' le_or_lt 0 n with hn hn <;> cases' le_or_lt 0 m with hm hm\n  ·\n    rw [self_zpow_of_nonneg _ _ hn, self_zpow_of_nonneg _ _ hm, self_zpow_of_nonneg _ _ (add_nonneg hn hm),\n      int.nat_abs_add_nonneg hn hm, pow_add]\n  · have : n + m = n.nat_abs - m.nat_abs := by\n      rw [Int.natAbs_of_nonneg hn, Int.ofNat_natAbs_of_nonpos hm.le, sub_neg_eq_add]\n    rw [self_zpow_of_nonneg _ _ hn, self_zpow_of_neg _ _ hm, this, self_zpow_sub_cast_nat,\n      IsLocalization.mk'_eq_mul_mk'_one, map_pow]\n  · have : n + m = m.nat_abs - n.nat_abs := by\n      rw [Int.natAbs_of_nonneg hm, Int.ofNat_natAbs_of_nonpos hn.le, sub_neg_eq_add, add_comm]\n    rw [self_zpow_of_nonneg _ _ hm, self_zpow_of_neg _ _ hn, this, self_zpow_sub_cast_nat,\n      IsLocalization.mk'_eq_mul_mk'_one, map_pow, mul_comm]\n  · rw [self_zpow_of_neg _ _ hn, self_zpow_of_neg _ _ hm, self_zpow_of_neg _ _ (add_neg hn hm),\n      int.nat_abs_add_neg hn hm, ← mk'_mul, one_mul]\n    congr\n    ext\n    simp [pow_add]\n#align self_zpow_add self_zpow_add\n\n",
 "mul_inv_self":
 "#print mul_inv_self /-\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen\n-/\n@[simp]\ntheorem mul_inv_self : algebraMap R S x * inv_self x = 1 :=\n  by\n  convert IsLocalization.mk'_mul_mk'_eq_one _ 1\n  symm\n  apply IsLocalization.mk'_one\n#align mul_inv_self mul_inv_self\n-/\n\n",
 "lift_eq":
 "@[simp]\ntheorem away_map.lift_eq (hg : IsUnit (g x)) (a : R) : lift x hg ((algebraMap R S) a) = g a :=\n  lift_eq _ _\n#align away_map.lift_eq away_map.lift_eq\n\n",
 "lift_comp":
 "@[simp]\ntheorem away_map.lift_comp (hg : IsUnit (g x)) : (lift x hg).comp (algebraMap R S) = g :=\n  lift_comp _\n#align away_map.lift_comp away_map.lift_comp\n\n",
 "finite_presentation":
 "theorem is_localization.away.finite_presentation (r : R) {S} [CommRing S] [Algebra R S] [is_localization.away r S] :\n    algebra.finite_presentation R S :=\n  (adjoin_root.finite_presentation _).equiv <|\n    (localization.away_equiv_adjoin r).symm.trans <| IsLocalization.algEquiv (Submonoid.powers r) _ _\n#align is_localization.away.finite_presentation is_localization.away.finite_presentation\n\n",
 "exists_reduced_fraction'":
 "theorem exists_reduced_fraction' {b : B} (hb : b ≠ 0) (hx : Irreducible x) :\n    ∃ (a : R)(n : ℤ), ¬x ∣ a ∧ self_zpow x B n * algebraMap R B a = b := by\n  classical\n    obtain ⟨⟨a₀, y⟩, H⟩ := surj (Submonoid.powers x) b\n    obtain ⟨d, hy⟩ := (Submonoid.mem_powers_iff y.1 x).mp y.2\n    have ha₀ : a₀ ≠ 0 :=\n      by\n      haveI :=\n        @is_domain_of_le_non_zero_divisors B _ R _ _ _ (Submonoid.powers x) _\n          (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)\n      simp only [map_zero, ← subtype.val_eq_coe, ← hy, map_pow] at H\n      apply ((injective_iff_map_eq_zero' (algebraMap R B)).mp _ a₀).mpr.mt\n      rw [← H]\n      apply mul_ne_zero hb (pow_ne_zero _ _)\n      exact\n        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)\n          (mem_non_zero_divisors_iff_ne_zero.mpr hx.ne_zero)\n      exact IsLocalization.injective B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)\n    simp only [← subtype.val_eq_coe, ← hy] at H\n    obtain ⟨m, a, hyp1, hyp2⟩ := max_power_factor ha₀ hx\n    refine' ⟨a, m - d, _⟩\n    rw [← mk'_one B, self_zpow_pow_sub, self_zpow_coe_nat, self_zpow_coe_nat, ← map_pow _ _ d, mul_comm _ b, H, hyp2,\n      map_mul, map_pow _ _ m]\n    exact ⟨hyp1, congr_arg _ (IsLocalization.mk'_one _ _)⟩\n#align exists_reduced_fraction' exists_reduced_fraction'\n\n",
 "away_of_is_unit_of_bijective":
 "theorem away_of_is_unit_of_bijective {R : Type _} (S : Type _) [CommRing R] [CommRing S] [Algebra R S] {r : R}\n    (hr : IsUnit r) (H : function.bijective (algebraMap R S)) : is_localization.away r S :=\n  { map_units := by\n      rintro ⟨_, n, rfl⟩\n      exact (algebraMap R S).is_unit_map (hr.pow _)\n    surj := fun z => by\n      obtain ⟨z', rfl⟩ := H.2 z\n      exact ⟨⟨z', 1⟩, by simp⟩\n    eq_iff_exists := fun x y => by\n      erw [H.1.eq_iff]\n      constructor\n      · rintro rfl\n        exact ⟨1, rfl⟩\n      · rintro ⟨⟨_, n, rfl⟩, e⟩\n        exact (hr.pow _).mul_right_inj.mp e }\n#align away_of_is_unit_of_bijective away_of_is_unit_of_bijective\n\n",
 "adjoin_inv":
 "theorem is_localization.adjoin_inv (r : R) : is_localization.away r (adjoin_root <| C r * X - 1) :=\n  IsLocalization.isLocalization_of_algEquiv _ (localization.away_equiv_adjoin r)\n#align is_localization.adjoin_inv is_localization.adjoin_inv\n\n"}