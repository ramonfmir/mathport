{"zero_le":
 "#print zero_le /-\ntheorem zero_le (I : fractional_ideal S P) : 0 ≤ I := by\n  intro x hx\n  convert submodule.zero_mem _\n  simpa using hx\n#align zero_le zero_le\n-/\n\n",
 "val_eq_coe":
 "@[simp]\ntheorem val_eq_coe (I : fractional_ideal S P) : I.val = I :=\n  rfl\n#align val_eq_coe val_eq_coe\n\n",
 "sup_eq_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_eq_add (I J : fractional_ideal S P) : «expr ⊔ » I J = I + J :=\n  rfl\n#align sup_eq_add sup_eq_add\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem _root_.is_fractional.sup {I J : submodule R P} :\n    is_fractional S I → is_fractional S J → is_fractional S («expr ⊔ » I J)\n  | ⟨aI, haI, hI⟩, ⟨aJ, haJ, hJ⟩ =>\n    ⟨aI * aJ, S.mul_mem haI haJ, fun b hb =>\n      by\n      rcases mem_sup.mp hb with ⟨bI, hbI, bJ, hbJ, rfl⟩\n      rw [smul_add]\n      apply is_integer_add\n      · rw [mul_smul, smul_comm]\n        exact is_integer_smul (hI bI hbI)\n      · rw [mul_smul]\n        exact is_integer_smul (hJ bJ hbJ)⟩\n#align is_fractional.sup is_fractional.sup\n\n",
 "span_singleton_zero":
 "@[simp]\ntheorem span_singleton_zero : span_singleton S (0 : P) = 0 :=\n  by\n  ext\n  simp [submodule.mem_span_singleton, eq_comm]\n#align span_singleton_zero span_singleton_zero\n\n",
 "span_singleton_pow":
 "@[simp]\ntheorem span_singleton_pow (x : P) (n : ℕ) : span_singleton S x ^ n = span_singleton S (x ^ n) :=\n  by\n  induction' n with n hn\n  · rw [pow_zero, pow_zero, span_singleton_one]\n  · rw [pow_succ, hn, span_singleton_mul_span_singleton, pow_succ]\n#align span_singleton_pow span_singleton_pow\n\n",
 "span_singleton_one":
 "@[simp]\ntheorem span_singleton_one : span_singleton S (1 : P) = 1 :=\n  by\n  ext\n  refine' (mem_span_singleton S).trans ((exists_congr _).trans (mem_one_iff S).symm)\n  intro x'\n  rw [algebra.smul_def, mul_one]\n#align span_singleton_one span_singleton_one\n\n",
 "span_singleton_ne_zero_iff":
 "theorem span_singleton_ne_zero_iff {y : P} : span_singleton S y ≠ 0 ↔ y ≠ 0 :=\n  not_congr span_singleton_eq_zero_iff\n#align span_singleton_ne_zero_iff span_singleton_ne_zero_iff\n\n",
 "span_singleton_mul_span_singleton":
 "@[simp]\ntheorem span_singleton_mul_span_singleton (x y : P) :\n    span_singleton S x * span_singleton S y = span_singleton S (x * y) :=\n  by\n  apply coe_to_submodule_injective\n  simp only [coe_mul, coe_span_singleton, span_mul_span, singleton_mul_singleton]\n#align span_singleton_mul_span_singleton span_singleton_mul_span_singleton\n\n",
 "span_singleton_mul_le_iff":
 "theorem span_singleton_mul_le_iff {x : P} {I J : fractional_ideal S P} :\n    span_singleton _ x * I ≤ J ↔ ∀ z ∈ I, x * z ∈ J :=\n  by\n  simp only [mul_le, mem_singleton_mul, mem_span_singleton]\n  constructor\n  · intro h zI hzI\n    exact h x ⟨1, one_smul _ _⟩ zI hzI\n  · rintro h _ ⟨z, rfl⟩ zI hzI\n    rw [algebra.smul_mul_assoc]\n    exact submodule.smul_mem J.1 _ (h zI hzI)\n#align span_singleton_mul_le_iff span_singleton_mul_le_iff\n\n",
 "span_singleton_mul_coe_ideal_eq_coe_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem span_singleton_mul_coe_ideal_eq_coe_ideal {I J : ideal R₁} {z : K} :\n    span_singleton (non_zero_divisors R₁) z * (I : fractional_ideal (non_zero_divisors R₁) K) = J ↔\n      ideal.span {((is_localization.sec (non_zero_divisors R₁) z).1 : R₁)} * I =\n        ideal.span {(is_localization.sec (non_zero_divisors R₁) z).2} * J :=\n  by-- `erw` to deal with the distinction between `y` and `⟨y.1, y.2⟩`\n  erw [← mk'_mul_coe_ideal_eq_coe_ideal K (is_localization.sec (non_zero_divisors R₁) z).2.prop,\n    is_localization.mk'_sec K z]\n#align span_singleton_mul_coe_ideal_eq_coe_ideal span_singleton_mul_coe_ideal_eq_coe_ideal\n\n",
 "span_singleton_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem span_singleton_eq_zero_iff {y : P} : span_singleton S y = 0 ↔ y = 0 :=\n  ⟨fun h => span_eq_bot.mp (by simpa using congr_arg subtype.val h : span R {y} = «expr⊥») y (mem_singleton y), fun h =>\n    by simp [h]⟩\n#align span_singleton_eq_zero_iff span_singleton_eq_zero_iff\n\n",
 "span_singleton_eq_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem span_singleton_eq_span_singleton [NoZeroSMulDivisors R P] {x y : P} :\n    span_singleton S x = span_singleton S y ↔ ∃ z : «expr ˣ» R, «expr • » z x = y :=\n  by\n  rw [← submodule.span_singleton_eq_span_singleton, span_singleton, span_singleton]\n  exact subtype.mk_eq_mk\n#align span_singleton_eq_span_singleton span_singleton_eq_span_singleton\n\n",
 "span_finset_ne_zero":
 "theorem span_finset_ne_zero {ι : Type _} {s : Finset ι} {f : ι → K} : span_finset R₁ s f ≠ 0 ↔ ∃ j ∈ s, f j ≠ 0 := by\n  simp\n#align span_finset_ne_zero span_finset_ne_zero\n\n",
 "span_finset_eq_zero":
 "@[simp]\ntheorem span_finset_eq_zero {ι : Type _} {s : Finset ι} {f : ι → K} : span_finset R₁ s f = 0 ↔ ∀ j ∈ s, f j = 0 := by\n  simp only [← coe_to_submodule_inj, span_finset_coe, coe_zero, submodule.span_eq_bot, Set.mem_image, Finset.mem_coe,\n    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n#align span_finset_eq_zero span_finset_eq_zero\n\n",
 "pow":
 "theorem _root_.is_fractional.pow {I : submodule R P} (h : is_fractional S I) :\n    ∀ n : ℕ, is_fractional S (I ^ n : submodule R P)\n  | 0 => is_fractional_of_le_one _ (pow_zero _).le\n  | n + 1 => (pow_succ I n).symm ▸ h.mul (_root_.is_fractional.pow n)\n#align is_fractional.pow is_fractional.pow\n\n",
 "one_mem_one":
 "theorem one_mem_one : (1 : P) ∈ (1 : fractional_ideal S P) :=\n  (mem_one_iff S).mpr ⟨1, RingHom.map_one _⟩\n#align one_mem_one one_mem_one\n\n",
 "one_div_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem one_div_span_singleton (x : K) :\n    1 / span_singleton (non_zero_divisors R₁) x = span_singleton (non_zero_divisors R₁) x⁻¹ :=\n  if h : x = 0 then by simp [h] else (eq_one_div_of_mul_eq_one_right _ _ (by simp [h])).symm\n#align one_div_span_singleton one_div_span_singleton\n\n",
 "nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem _root_.is_fractional.nsmul {I : submodule R P} :\n    ∀ n : ℕ, is_fractional S I → is_fractional S («expr • » n I : submodule R P)\n  | 0, _ => by\n    rw [zero_smul]\n    convert ((0 : ideal R) : fractional_ideal S P).is_fractional\n    simp\n  | n + 1, h => by\n    rw [succ_nsmul]\n    exact h.sup (_root_.is_fractional.nsmul n h)\n#align is_fractional.nsmul is_fractional.nsmul\n\n",
 "ne_zero_of_mul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem ne_zero_of_mul_eq_one (I J : fractional_ideal (non_zero_divisors R₁) K) (h : I * J = 1) : I ≠ 0 := fun hI =>\n  zero_ne_one' (fractional_ideal (non_zero_divisors R₁) K)\n    (by\n      convert h\n      simp [hI])\n#align ne_zero_of_mul_eq_one ne_zero_of_mul_eq_one\n\n",
 "mul_self_le_self":
 "theorem mul_self_le_self {I : fractional_ideal S P} (hI : I ≤ 1) : I * I ≤ I :=\n  by\n  convert mul_left_mono I hI\n  exact (mul_one I).symm\n#align mul_self_le_self mul_self_le_self\n\n",
 "mul_right_mono":
 "theorem mul_right_mono (I : fractional_ideal S P) : monotone fun J => J * I :=\n  by\n  intro J J' h\n  simp only [mul_def]\n  exact mul_le.mpr fun x hx y hy => mul_mem_mul (h hx) hy\n#align mul_right_mono mul_right_mono\n\n",
 "mul_one_div_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mul_one_div_le_one {I : fractional_ideal (non_zero_divisors R₁) K} : I * (1 / I) ≤ 1 :=\n  by\n  by_cases hI : I = 0\n  · rw [hI, div_zero, mul_zero]\n    exact zero_le 1\n  · rw [← coe_le_coe, coe_mul, coe_div hI, coe_one]\n    apply submodule.mul_one_div_le_one\n#align mul_one_div_le_one mul_one_div_le_one\n\n",
 "mul_mem_mul":
 "theorem mul_mem_mul {I J : fractional_ideal S P} {i j : P} (hi : i ∈ I) (hj : j ∈ J) : i * j ∈ I * J :=\n  by\n  simp only [mul_def]\n  exact submodule.mul_mem_mul hi hj\n#align mul_mem_mul mul_mem_mul\n\n",
 "mul_left_mono":
 "theorem mul_left_mono (I : fractional_ideal S P) : monotone ((· * ·) I) :=\n  by\n  intro J J' h\n  simp only [mul_def]\n  exact mul_le.mpr fun x hx y hy => mul_mem_mul hx (h hy)\n#align mul_left_mono mul_left_mono\n\n",
 "mul_le_mul_left":
 "#print mul_le_mul_left /-\ntheorem mul_le_mul_left {I J : fractional_ideal S P} (hIJ : I ≤ J) (J' : fractional_ideal S P) : J' * I ≤ J' * J :=\n  mul_le.mpr fun k hk j hj => mul_mem_mul hk (hIJ hj)\n#align mul_le_mul_left mul_le_mul_left\n-/\n\n",
 "mul_le":
 "theorem mul_le {I J K : fractional_ideal S P} : I * J ≤ K ↔ ∀ i ∈ I, ∀ j ∈ J, i * j ∈ K :=\n  by\n  simp only [mul_def]\n  exact submodule.mul_le\n#align mul_le mul_le\n\n",
 "mul_induction_on":
 "@[elab_as_elim]\nprotected theorem mul_induction_on {I J : fractional_ideal S P} {C : P → Prop} {r : P} (hr : r ∈ I * J)\n    (hm : ∀ i ∈ I, ∀ j ∈ J, C (i * j)) (ha : ∀ x y, C x → C y → C (x + y)) : C r :=\n  by\n  simp only [mul_def] at hr\n  exact submodule.mul_induction_on hr hm ha\n#align mul_induction_on mul_induction_on\n\n",
 "mul_eq_mul":
 "-- local attribute [semireducible] mul\n@[simp]\ntheorem mul_eq_mul (I J : fractional_ideal S P) : mul I J = I * J :=\n  rfl\n#align mul_eq_mul mul_eq_mul\n\n",
 "mul_div_self_cancel_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mul_div_self_cancel_iff {I : fractional_ideal (non_zero_divisors R₁) K} : I * (1 / I) = 1 ↔ ∃ J, I * J = 1 :=\n  ⟨fun h => ⟨1 / I, h⟩, fun ⟨J, hJ⟩ => by rwa [← eq_one_div_of_mul_eq_one_right I J hJ]⟩\n#align mul_div_self_cancel_iff mul_div_self_cancel_iff\n\n",
 "mul_def":
 "theorem mul_def (I J : fractional_ideal S P) : I * J = ⟨I * J, I.is_fractional.mul J.is_fractional⟩ := by\n  simp only [← mul_eq_mul, mul]\n#align mul_def mul_def\n\n",
 "mul":
 "theorem _root_.is_fractional.mul {I J : submodule R P} :\n    is_fractional S I → is_fractional S J → is_fractional S (I * J : submodule R P)\n  | ⟨aI, haI, hI⟩, ⟨aJ, haJ, hJ⟩ =>\n    ⟨aI * aJ, S.mul_mem haI haJ, fun b hb =>\n      by\n      apply submodule.mul_induction_on hb\n      · intro m hm n hn\n        obtain ⟨n', hn'⟩ := hJ n hn\n        rw [mul_smul, mul_comm m, ← smul_mul_assoc, ← hn', ← algebra.smul_def]\n        apply hI\n        exact submodule.smul_mem _ _ hm\n      · intro x y hx hy\n        rw [smul_add]\n        apply is_integer_add hx hy⟩\n#align is_fractional.mul is_fractional.mul\n\n",
 "mk'_mul_coe_ideal_eq_coe_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mk'_mul_coe_ideal_eq_coe_ideal {I J : ideal R₁} {x y : R₁} (hy : y ∈ non_zero_divisors R₁) :\n    span_singleton (non_zero_divisors R₁) (is_localization.mk' K x ⟨y, hy⟩) * I =\n        (J : fractional_ideal (non_zero_divisors R₁) K) ↔\n      ideal.span {x} * I = ideal.span {y} * J :=\n  by\n  have :\n    span_singleton (non_zero_divisors R₁) (is_localization.mk' _ (1 : R₁) ⟨y, hy⟩) *\n        span_singleton (non_zero_divisors R₁) (algebra_map R₁ K y) =\n      1 :=\n    by\n    rw [span_singleton_mul_span_singleton, mul_comm, ← is_localization.mk'_eq_mul_mk'_one, is_localization.mk'_self,\n      span_singleton_one]\n  let y' : «expr ˣ» (fractional_ideal (non_zero_divisors R₁) K) := units.mk_of_mul_eq_one _ _ this\n  have coe_y' : ↑y' = span_singleton (non_zero_divisors R₁) (is_localization.mk' K (1 : R₁) ⟨y, hy⟩) := rfl\n  refine' iff.trans _ (y'.mul_right_inj.trans coe_ideal_inj)\n  rw [coe_y', coe_ideal_mul, coe_ideal_span_singleton, coe_ideal_mul, coe_ideal_span_singleton, ← mul_assoc,\n    span_singleton_mul_span_singleton, ← mul_assoc, span_singleton_mul_span_singleton, mul_comm (mk' _ _ _), ←\n    is_localization.mk'_eq_mul_mk'_one, mul_comm (mk' _ _ _), ← is_localization.mk'_eq_mul_mk'_one,\n    is_localization.mk'_self, span_singleton_one, one_mul]\n#align mk'_mul_coe_ideal_eq_coe_ideal mk'_mul_coe_ideal_eq_coe_ideal\n\n",
 "mem_zero_iff":
 "@[simp]\ntheorem mem_zero_iff {x : P} : x ∈ (0 : fractional_ideal S P) ↔ x = 0 :=\n  ⟨fun ⟨x', x'_mem_zero, x'_eq_x⟩ => by\n    have x'_eq_zero : x' = 0 := x'_mem_zero\n    simp [x'_eq_x.symm, x'_eq_zero], fun hx => ⟨0, rfl, by simp [hx]⟩⟩\n#align mem_zero_iff mem_zero_iff\n\n",
 "mem_span_singleton_self":
 "theorem mem_span_singleton_self (x : P) : x ∈ span_singleton S x :=\n  (mem_span_singleton S).mpr ⟨1, one_smul _ _⟩\n#align mem_span_singleton_self mem_span_singleton_self\n\n",
 "mem_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mem_span_singleton {x y : P} : x ∈ span_singleton S y ↔ ∃ z : R, «expr • » z y = x :=\n  by\n  rw [span_singleton]\n  exact submodule.mem_span_singleton\n#align mem_span_singleton mem_span_singleton\n\n",
 "mem_span_mul_finite_of_mem_mul":
 "theorem mem_span_mul_finite_of_mem_mul {I J : fractional_ideal S P} {x : P} (hx : x ∈ I * J) :\n    ∃ T T' : Finset P, (T : set P) ⊆ I ∧ (T' : set P) ⊆ J ∧ x ∈ span R (T * T' : set P) :=\n  submodule.mem_span_mul_finite_of_mem_mul (by simpa using mem_coe.mpr hx)\n#align mem_span_mul_finite_of_mem_mul mem_span_mul_finite_of_mem_mul\n\n",
 "mem_singleton_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_singleton_mul {x y : P} {I : fractional_ideal S P} : y ∈ span_singleton S x * I ↔ ∃ y' ∈ I, y = x * y' :=\n  by\n  constructor\n  · intro h\n    apply fractional_ideal.mul_induction_on h\n    · intro x' hx' y' hy'\n      obtain ⟨a, ha⟩ := (mem_span_singleton S).mp hx'\n      use «expr • » a y', submodule.smul_mem I a hy'\n      rw [← ha, algebra.mul_smul_comm, algebra.smul_mul_assoc]\n    · rintro _ _ ⟨y, hy, rfl⟩ ⟨y', hy', rfl⟩\n      exact ⟨y + y', submodule.add_mem I hy hy', (mul_add _ _ _).symm⟩\n  · rintro ⟨y', hy', rfl⟩\n    exact mul_mem_mul ((mem_span_singleton S).mpr ⟨1, one_smul _ _⟩) hy'\n#align mem_singleton_mul mem_singleton_mul\n\n",
 "mem_one_iff":
 "theorem mem_one_iff {x : P} : x ∈ (1 : fractional_ideal S P) ↔ ∃ x' : R, algebra_map R P x' = x :=\n  iff.intro (fun ⟨x', _, h⟩ => ⟨x', h⟩) fun ⟨x', h⟩ => ⟨x', ⟨⟩, h⟩\n#align mem_one_iff mem_one_iff\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem mem_map {I : fractional_ideal S P} {g : «expr →ₐ[ ] » P R P'} {y : P'} : y ∈ I.map g ↔ ∃ x, x ∈ I ∧ g x = y :=\n  submodule.mem_map\n#align mem_map mem_map\n\n",
 "mem_div_iff_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mem_div_iff_of_nonzero {I J : fractional_ideal (non_zero_divisors R₁) K} (h : J ≠ 0) {x} :\n    x ∈ I / J ↔ ∀ y ∈ J, x * y ∈ I := by\n  rw [div_nonzero h]\n  exact submodule.mem_div_iff_forall_mul_mem\n#align mem_div_iff_of_nonzero mem_div_iff_of_nonzero\n\n",
 "mem_coe_ideal_of_mem":
 "theorem mem_coe_ideal_of_mem {x : R} {I : ideal R} (hx : x ∈ I) : algebra_map R P x ∈ (I : fractional_ideal S P) :=\n  (mem_coe_ideal S).mpr ⟨x, hx, rfl⟩\n#align mem_coe_ideal_of_mem mem_coe_ideal_of_mem\n\n",
 "mem_coe_ideal":
 "@[simp]\ntheorem mem_coe_ideal {x : P} {I : ideal R} : x ∈ (I : fractional_ideal S P) ↔ ∃ x', x' ∈ I ∧ algebra_map R P x' = x :=\n  mem_coe_submodule _ _\n#align mem_coe_ideal mem_coe_ideal\n\n",
 "mem_coe":
 "@[simp]\ntheorem mem_coe {I : fractional_ideal S P} {x : P} : x ∈ (I : submodule R P) ↔ x ∈ I :=\n  iff.rfl\n#align mem_coe mem_coe\n\n",
 "mem_canonical_equiv_apply":
 "@[simp]\ntheorem mem_canonical_equiv_apply {I : fractional_ideal S P} {x : P'} :\n    x ∈ canonical_equiv S P P' I ↔\n      ∃ y ∈ I,\n        is_localization.map P' (RingHom.id R) (fun y (hy : y ∈ S) => show RingHom.id R y ∈ S from hy) (y : P) = x :=\n  by\n  rw [canonical_equiv, map_equiv_apply, mem_map]\n  exact ⟨fun ⟨y, mem, eq⟩ => ⟨y, mem, eq⟩, fun ⟨y, mem, eq⟩ => ⟨y, mem, eq⟩⟩\n#align mem_canonical_equiv_apply mem_canonical_equiv_apply\n\n",
 "mem_adjoin_integral_self":
 "theorem mem_adjoin_integral_self : x ∈ adjoin_integral S x hx :=\n  algebra.subset_adjoin (Set.mem_singleton x)\n#align mem_adjoin_integral_self mem_adjoin_integral_self\n\n",
 "map_zero":
 "#print map_zero /-\n@[simp]\ntheorem map_zero : (0 : fractional_ideal S P).map g = 0 :=\n  map_coe_ideal g 0\n#align map_zero map_zero\n-/\n\n",
 "map_symm_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem map_symm_map (I : fractional_ideal S P') (g : «expr ≃ₐ[ ] » P R P') :\n    (I.map (g.symm : «expr →ₐ[ ] » P' R P)).map (g : «expr →ₐ[ ] » P R P') = I := by\n  rw [← map_comp, g.comp_symm, map_id]\n#align map_symm_map map_symm_map\n\n",
 "map_one_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem map_one_div (I : fractional_ideal (non_zero_divisors R₁) K) (h : «expr ≃ₐ[ ] » K R₁ K') :\n    (1 / I).map (h : «expr →ₐ[ ] » K R₁ K') = 1 / I.map h := by rw [map_div, map_one]\n#align map_one_div map_one_div\n\n",
 "map_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print map_one /-\n@[simp]\ntheorem map_one : (1 : fractional_ideal S P).map g = 1 :=\n  map_coe_ideal g («expr⊤»)\n#align map_one map_one\n-/\n\n",
 "map_ne_zero":
 "#print map_ne_zero /-\ntheorem map_ne_zero [nontrivial R] (hI : I ≠ 0) : I.map h ≠ 0 :=\n  by\n  obtain ⟨x, x_ne_zero, hx⟩ := exists_ne_zero_mem_is_integer hI\n  contrapose! x_ne_zero with map_eq_zero\n  refine' is_fraction_ring.to_map_eq_zero_iff.mp (eq_zero_iff.mp map_eq_zero _ (mem_map.mpr _))\n  exact ⟨algebra_map R K x, hx, h.commutes x⟩\n#align map_ne_zero map_ne_zero\n-/\n\n",
 "map_mul":
 "#print map_mul /-\n@[simp]\ntheorem map_mul : (I * J).map g = I.map g * J.map g :=\n  by\n  simp only [mul_def]\n  exact coe_to_submodule_injective (submodule.map_mul _ _ _)\n#align map_mul map_mul\n-/\n\n",
 "map_mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_mem_map {f : «expr →ₐ[ ] » P R P'} (h : function.injective f) {x : P} {I : fractional_ideal S P} :\n    f x ∈ map f I ↔ x ∈ I :=\n  mem_map.trans ⟨fun ⟨x', hx', x'_eq⟩ => h x'_eq ▸ hx', fun h => ⟨x, h, rfl⟩⟩\n#align map_mem_map map_mem_map\n\n",
 "map_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem map_map_symm (g : «expr ≃ₐ[ ] » P R P') :\n    (I.map (g : «expr →ₐ[ ] » P R P')).map (g.symm : «expr →ₐ[ ] » P' R P) = I := by\n  rw [← map_comp, g.symm_comp, map_id]\n#align map_map_symm map_map_symm\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_injective (f : «expr →ₐ[ ] » P R P') (h : function.injective f) :\n    function.injective (map f : fractional_ideal S P → fractional_ideal S P') := fun I J hIJ =>\n  ext fun x => (map_mem_map h).symm.trans (hIJ.symm ▸ map_mem_map h)\n#align map_injective map_injective\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : I.map (alg_hom.id _ _) = I :=\n  coe_to_submodule_injective (submodule.map_id I)\n#align map_id map_id\n\n",
 "map_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem map_equiv_symm (g : «expr ≃ₐ[ ] » P R P') :\n    ((map_equiv g).symm : «expr ≃+* » (fractional_ideal S P') _) = map_equiv g.symm :=\n  rfl\n#align map_equiv_symm map_equiv_symm\n\n",
 "map_equiv_refl":
 "@[simp]\ntheorem map_equiv_refl : map_equiv alg_equiv.refl = RingEquiv.refl (fractional_ideal S P) :=\n  RingEquiv.ext fun x => by simp\n#align map_equiv_refl map_equiv_refl\n\n",
 "map_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem map_equiv_apply (g : «expr ≃ₐ[ ] » P R P') (I : fractional_ideal S P) : map_equiv g I = map (↑g) I :=\n  rfl\n#align map_equiv_apply map_equiv_apply\n\n",
 "map_eq_zero_iff":
 "#print map_eq_zero_iff /-\n@[simp]\ntheorem map_eq_zero_iff [nontrivial R] : I.map h = 0 ↔ I = 0 :=\n  ⟨imp_of_not_imp_not _ _ (map_ne_zero _), fun hI => hI.symm ▸ map_zero h⟩\n#align map_eq_zero_iff map_eq_zero_iff\n-/\n\n",
 "map_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n#print map_div /-\n@[simp]\ntheorem map_div (I J : fractional_ideal (non_zero_divisors R₁) K) (h : «expr ≃ₐ[ ] » K R₁ K') :\n    (I / J).map (h : «expr →ₐ[ ] » K R₁ K') = I.map h / J.map h :=\n  by\n  by_cases H : J = 0\n  · rw [H, div_zero, map_zero, div_zero]\n  · apply coe_to_submodule_injective\n    simp [div_nonzero H, div_nonzero (map_ne_zero _ H), submodule.map_div]\n#align map_div map_div\n-/\n\n",
 "map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem map_comp (g' : «expr →ₐ[ ] » P' R P'') : I.map (g'.comp g) = (I.map g).map g' :=\n  coe_to_submodule_injective (submodule.map_comp g.to_linear_map g'.to_linear_map I)\n#align map_comp map_comp\n\n",
 "map_coe_ideal":
 "@[simp, norm_cast]\ntheorem map_coe_ideal (I : ideal R) : (I : fractional_ideal S P).map g = I :=\n  by\n  ext x\n  simp only [mem_coe_ideal]\n  constructor\n  · rintro ⟨_, ⟨y, hy, rfl⟩, rfl⟩\n    exact ⟨y, hy, (g.commutes y).symm⟩\n  · rintro ⟨y, hy, rfl⟩\n    exact ⟨_, ⟨y, hy, rfl⟩, g.commutes y⟩\n#align map_coe_ideal map_coe_ideal\n\n",
 "map_add":
 "#print map_add /-\n@[simp]\ntheorem map_add : (I + J).map g = I.map g + J.map g :=\n  coe_to_submodule_injective (submodule.map_sup _ _ _)\n#align map_add map_add\n-/\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem _root_.is_fractional.map (g : «expr →ₐ[ ] » P R P') {I : submodule R P} :\n    is_fractional S I → is_fractional S (submodule.map g.to_linear_map I)\n  | ⟨a, a_nonzero, hI⟩ =>\n    ⟨a, a_nonzero, fun b hb => by\n      obtain ⟨b', b'_mem, hb'⟩ := submodule.mem_map.mp hb\n      obtain ⟨x, hx⟩ := hI b' b'_mem\n      use x\n      erw [← g.commutes, hx, g.map_smul, hb']⟩\n#align is_fractional.map is_fractional.map\n\n",
 "le_zero_iff":
 "#print le_zero_iff /-\n@[simp]\ntheorem le_zero_iff {I : fractional_ideal S P} : I ≤ 0 ↔ I = 0 :=\n  le_bot_iff\n#align le_zero_iff le_zero_iff\n-/\n\n",
 "le_span_singleton_mul_iff":
 "theorem le_span_singleton_mul_iff {x : P} {I J : fractional_ideal S P} :\n    I ≤ span_singleton S x * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI :=\n  show (∀ {zI} (hzI : zI ∈ I), zI ∈ span_singleton _ x * J) ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI by\n    simp only [mem_singleton_mul, eq_comm]\n#align le_span_singleton_mul_iff le_span_singleton_mul_iff\n\n",
 "le_self_mul_self":
 "theorem le_self_mul_self {I : fractional_ideal S P} (hI : 1 ≤ I) : I ≤ I * I :=\n  by\n  convert mul_left_mono I hI\n  exact (mul_one I).symm\n#align le_self_mul_self le_self_mul_self\n\n",
 "le_self_mul_one_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem le_self_mul_one_div {I : fractional_ideal (non_zero_divisors R₁) K}\n    (hI : I ≤ (1 : fractional_ideal (non_zero_divisors R₁) K)) : I ≤ I * (1 / I) :=\n  by\n  by_cases hI_nz : I = 0\n  · rw [hI_nz, div_zero, mul_zero]\n    exact zero_le 0\n  · rw [← coe_le_coe, coe_mul, coe_div hI_nz, coe_one]\n    rw [← coe_le_coe, coe_one] at hI\n    exact submodule.le_self_mul_one_div hI\n#align le_self_mul_one_div le_self_mul_one_div\n\n",
 "le_one_iff_exists_coe_ideal":
 "theorem le_one_iff_exists_coe_ideal {J : fractional_ideal S P} :\n    J ≤ (1 : fractional_ideal S P) ↔ ∃ I : ideal R, ↑I = J :=\n  by\n  constructor\n  · intro hJ\n    refine' ⟨⟨{ x : R | algebra_map R P x ∈ J }, _, _, _⟩, _⟩\n    · intro a b ha hb\n      rw [mem_set_of_eq, RingHom.map_add]\n      exact J.val.add_mem ha hb\n    · rw [mem_set_of_eq, RingHom.map_zero]\n      exact J.val.zero_mem\n    · intro c x hx\n      rw [smul_eq_mul, mem_set_of_eq, RingHom.map_mul, ← algebra.smul_def]\n      exact J.val.smul_mem c hx\n    · ext x\n      constructor\n      · rintro ⟨y, hy, eq_y⟩\n        rwa [← eq_y]\n      · intro hx\n        obtain ⟨y, eq_x⟩ := (mem_one_iff S).mp (hJ hx)\n        rw [← eq_x] at *\n        exact ⟨y, hx, rfl⟩\n  · rintro ⟨I, hI⟩\n    rw [← hI]\n    apply coe_ideal_le_one\n#align le_one_iff_exists_coe_ideal le_one_iff_exists_coe_ideal\n\n",
 "le_div_iff_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem le_div_iff_of_nonzero {I J J' : fractional_ideal (non_zero_divisors R₁) K} (hJ' : J' ≠ 0) :\n    I ≤ J / J' ↔ ∀ x ∈ I, ∀ y ∈ J', x * y ∈ J :=\n  ⟨fun h x hx => (mem_div_iff_of_nonzero hJ').mp (h hx), fun h x hx => (mem_div_iff_of_nonzero hJ').mpr (h x hx)⟩\n#align le_div_iff_of_nonzero le_div_iff_of_nonzero\n\n",
 "le_div_iff_mul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n#print le_div_iff_mul_le /-\ntheorem le_div_iff_mul_le {I J J' : fractional_ideal (non_zero_divisors R₁) K} (hJ' : J' ≠ 0) :\n    I ≤ J / J' ↔ I * J' ≤ J := by\n  rw [div_nonzero hJ']\n  convert submodule.le_div_iff_mul_le using 1\n  rw [← coe_mul, coe_le_coe]\n#align le_div_iff_mul_le le_div_iff_mul_le\n-/\n\n",
 "is_principal_iff":
 "theorem is_principal_iff (I : fractional_ideal S P) : is_principal (I : submodule R P) ↔ ∃ x, I = span_singleton S x :=\n  ⟨fun h => ⟨@generator _ _ _ _ _ (↑I) h, @eq_span_singleton_of_principal _ _ _ _ _ _ _ I h⟩, fun ⟨x, hx⟩ =>\n    { principal := ⟨x, trans (congr_arg _ hx) (coe_span_singleton _ x)⟩ }⟩\n#align is_principal_iff is_principal_iff\n\n",
 "is_noetherian_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem is_noetherian_zero : is_noetherian R₁ (0 : fractional_ideal (non_zero_divisors R₁) K) :=\n  is_noetherian_submodule.mpr fun I (hI : I ≤ (0 : fractional_ideal (non_zero_divisors R₁) K)) =>\n    by\n    rw [coe_zero] at hI\n    rw [le_bot_iff.mp hI]\n    exact fg_bot\n#align is_noetherian_zero is_noetherian_zero\n\n",
 "is_noetherian_span_singleton_inv_to_map_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem is_noetherian_span_singleton_inv_to_map_mul (x : R₁) {I : fractional_ideal (non_zero_divisors R₁) K}\n    (hI : is_noetherian R₁ I) :\n    is_noetherian R₁\n      (span_singleton (non_zero_divisors R₁) (algebra_map R₁ K x)⁻¹ * I : fractional_ideal (non_zero_divisors R₁) K) :=\n  by\n  by_cases hx : x = 0\n  · rw [hx, RingHom.map_zero, _root_.inv_zero, span_singleton_zero, zero_mul]\n    exact is_noetherian_zero\n  have h_gx : algebra_map R₁ K x ≠ 0 :=\n    mt ((injective_iff_map_eq_zero (algebra_map R₁ K)).mp (is_fraction_ring.injective _ _) x) hx\n  have h_spanx : span_singleton (non_zero_divisors R₁) (algebra_map R₁ K x) ≠ 0 := span_singleton_ne_zero_iff.mpr h_gx\n  rw [is_noetherian_iff] at hI⊢\n  intro J hJ\n  rw [← div_span_singleton, le_div_iff_mul_le h_spanx] at hJ\n  obtain ⟨s, hs⟩ := hI _ hJ\n  use s * {(algebra_map R₁ K x)⁻¹}\n  rw [finset.coe_mul, Finset.coe_singleton, ← span_mul_span, hs, ← coe_span_singleton (non_zero_divisors R₁), ← coe_mul,\n    mul_assoc, span_singleton_mul_span_singleton, mul_inv_cancel h_gx, span_singleton_one, mul_one]\n#align is_noetherian_span_singleton_inv_to_map_mul is_noetherian_span_singleton_inv_to_map_mul\n\n",
 "is_noetherian_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem is_noetherian_iff {I : fractional_ideal (non_zero_divisors R₁) K} :\n    is_noetherian R₁ I ↔ ∀ J ≤ I, (J : submodule R₁ K).fg :=\n  is_noetherian_submodule.trans ⟨fun h J hJ => h _ hJ, fun h J hJ => h ⟨J, is_fractional_of_le hJ⟩ hJ⟩\n#align is_noetherian_iff is_noetherian_iff\n\n",
 "is_noetherian_coe_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem is_noetherian_coe_ideal [_root_.is_noetherian_ring R₁] (I : ideal R₁) :\n    is_noetherian R₁ (I : fractional_ideal (non_zero_divisors R₁) K) :=\n  by\n  rw [is_noetherian_iff]\n  intro J hJ\n  obtain ⟨J, rfl⟩ := le_one_iff_exists_coe_ideal.mp (le_trans hJ coe_ideal_le_one)\n  exact (is_noetherian.noetherian J).map _\n#align is_noetherian_coe_ideal is_noetherian_coe_ideal\n\n",
 "is_noetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- Every fractional ideal of a noetherian integral domain is noetherian. -/\ntheorem is_noetherian [_root_.is_noetherian_ring R₁] (I : fractional_ideal (non_zero_divisors R₁) K) :\n    is_noetherian R₁ I := by\n  obtain ⟨d, J, h_nzd, rfl⟩ := exists_eq_span_singleton_mul I\n  apply is_noetherian_span_singleton_inv_to_map_mul\n  apply is_noetherian_coe_ideal\n#align is_noetherian is_noetherian\n\n",
 "is_fractional_span_singleton":
 "theorem is_fractional_span_singleton (x : P) : is_fractional S (span R {x} : submodule R P) :=\n  let ⟨a, ha⟩ := exists_integer_multiple S x\n  is_fractional_span_iff.mpr ⟨a, a.2, fun x' hx' => (Set.mem_singleton_iff.mp hx').symm ▸ ha⟩\n#align is_fractional_span_singleton is_fractional_span_singleton\n\n",
 "is_fractional_span_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_fractional_span_iff {s : set P} :\n    is_fractional S (span R s) ↔ ∃ a ∈ S, ∀ b : P, b ∈ s → is_integer R («expr • » a b) :=\n  ⟨fun ⟨a, a_mem, h⟩ => ⟨a, a_mem, fun b hb => h b (subset_span hb)⟩, fun ⟨a, a_mem, h⟩ =>\n    ⟨a, a_mem, fun b hb =>\n      span_induction hb h\n        (by\n          rw [smul_zero]\n          exact is_integer_zero)\n        (fun x y hx hy => by\n          rw [smul_add]\n          exact is_integer_add hx hy)\n        fun s x hx => by\n        rw [smul_comm]\n        exact is_integer_smul hx⟩⟩\n#align is_fractional_span_iff is_fractional_span_iff\n\n",
 "is_fractional_of_le_one":
 "theorem is_fractional_of_le_one (I : submodule R P) (h : I ≤ 1) : is_fractional S I :=\n  by\n  use 1, S.one_mem\n  intro b hb\n  rw [one_smul]\n  obtain ⟨b', b'_mem, rfl⟩ := h hb\n  exact Set.mem_range_self b'\n#align is_fractional_of_le_one is_fractional_of_le_one\n\n",
 "is_fractional_of_le":
 "theorem is_fractional_of_le {I : submodule R P} {J : fractional_ideal S P} (hIJ : I ≤ J) : is_fractional S I :=\n  by\n  obtain ⟨a, a_mem, ha⟩ := J.is_fractional\n  use a, a_mem\n  intro b b_mem\n  exact ha b (hIJ b_mem)\n#align is_fractional_of_le is_fractional_of_le\n\n",
 "is_fractional_of_fg":
 "theorem is_fractional_of_fg {I : submodule R P} (hI : I.fg) : is_fractional S I :=\n  by\n  rcases hI with ⟨I, rfl⟩\n  rcases exist_integer_multiples_of_finset S I with ⟨⟨s, hs1⟩, hs⟩\n  rw [is_fractional_span_iff]\n  exact ⟨s, hs1, hs⟩\n#align is_fractional_of_fg is_fractional_of_fg\n\n",
 "is_fractional_adjoin_integral":
 "/-- `A[x]` is a fractional ideal for every integral `x`. -/\ntheorem is_fractional_adjoin_integral : is_fractional S (algebra.adjoin R ({x} : set P)).to_submodule :=\n  is_fractional_of_fg (fg_adjoin_singleton_of_integral x hx)\n#align is_fractional_adjoin_integral is_fractional_adjoin_integral\n\n",
 "is_fractional":
 "/-\nCopyright (c) 2020 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen, Filippo A. E. Nuccio\n-/\nprotected theorem is_fractional (I : fractional_ideal S P) : is_fractional S (I : submodule R P) :=\n  I.prop\n#align is_fractional is_fractional\n\n",
 "inf_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem _root_.is_fractional.inf_right {I : submodule R P} : is_fractional S I → ∀ J, is_fractional S («expr ⊓ » I J)\n  | ⟨aI, haI, hI⟩, J =>\n    ⟨aI, haI, fun b hb => by\n      rcases mem_inf.mp hb with ⟨hbI, hbJ⟩\n      exact hI b hbI⟩\n#align is_fractional.inf_right is_fractional.inf_right\n\n",
 "fractional_div_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem fractional_div_of_nonzero {I J : fractional_ideal (non_zero_divisors R₁) K} (h : J ≠ 0) :\n    is_fractional (non_zero_divisors R₁) (I / J : submodule R₁ K) :=\n  I.is_fractional.div_of_nonzero J.is_fractional fun H => h <| coe_to_submodule_injective <| H.trans coe_zero.symm\n#align fractional_div_of_nonzero fractional_div_of_nonzero\n\n",
 "fg_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem fg_unit (I : «expr ˣ» (fractional_ideal S P)) : fg (I : submodule R P) :=\n  by\n  have : (1 : P) ∈ (I * ↑I⁻¹ : fractional_ideal S P) :=\n    by\n    rw [Units.mul_inv]\n    exact one_mem_one _\n  obtain ⟨T, T', hT, hT', one_mem⟩ := mem_span_mul_finite_of_mem_mul this\n  refine' ⟨T, submodule.span_eq_of_le _ hT _⟩\n  rw [← one_mul ↑I, ← mul_one (span R ↑T)]\n  conv_rhs => rw [← coe_one, ← Units.mul_inv I, coe_mul, mul_comm ↑↑I, ← mul_assoc]\n  refine' submodule.mul_le_mul_left (le_trans _ (submodule.mul_le_mul_right (submodule.span_le.mpr hT')))\n  rwa [submodule.one_le, submodule.span_mul_span]\n#align fg_unit fg_unit\n\n",
 "fg_of_is_unit":
 "theorem _root_.ideal.fg_of_is_unit (inj : function.injective (algebra_map R P)) (I : ideal R)\n    (h : is_unit (I : fractional_ideal S P)) : I.fg :=\n  by\n  rw [← coe_ideal_fg S inj I]\n  exact fg_of_is_unit I h\n#align ideal.fg_of_is_unit ideal.fg_of_is_unit\n\n",
 "ext":
 "@[ext]\ntheorem ext {I J : fractional_ideal S P} : (∀ x, x ∈ I ↔ x ∈ J) → I = J :=\n  SetLike.ext\n#align ext ext\n\n",
 "exists_ne_zero_mem_is_integer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x «expr ≠ » (0 : R)) -/\n/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem exists_ne_zero_mem_is_integer [nontrivial R] (hI : I ≠ 0) : ∃ (x : _)(_ : x ≠ (0 : R)), algebra_map R K x ∈ I :=\n  by\n  obtain ⟨y, y_mem, y_not_mem⟩ := SetLike.exists_of_lt (by simpa only using bot_lt_iff_ne_bot.mpr hI)\n  have y_ne_zero : y ≠ 0 := by simpa using y_not_mem\n  obtain ⟨z, ⟨x, hx⟩⟩ := exists_integer_multiple (non_zero_divisors R) y\n  refine' ⟨x, _, _⟩\n  · rw [ne.def, ← @is_fraction_ring.to_map_eq_zero_iff R _ K, hx, algebra.smul_def]\n    exact mul_ne_zero (is_fraction_ring.to_map_ne_zero_of_mem_non_zero_divisors z.2) y_ne_zero\n  · rw [hx]\n    exact smul_mem _ _ y_mem\n#align exists_ne_zero_mem_is_integer exists_ne_zero_mem_is_integer\n\n",
 "exists_mem_to_map_eq":
 "@[simp]\ntheorem exists_mem_to_map_eq {x : R} {I : ideal R} (h : S ≤ non_zero_divisors R) :\n    (∃ x', x' ∈ I ∧ algebra_map R P x' = algebra_map R P x) ↔ x ∈ I :=\n  ⟨fun ⟨x', hx', eq⟩ => is_localization.injective _ h eq ▸ hx', fun h => ⟨x, h, rfl⟩⟩\n#align exists_mem_to_map_eq exists_mem_to_map_eq\n\n",
 "exists_eq_span_singleton_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem exists_eq_span_singleton_mul (I : fractional_ideal (non_zero_divisors R₁) K) :\n    ∃ (a : R₁)(aI : ideal R₁), a ≠ 0 ∧ I = span_singleton (non_zero_divisors R₁) (algebra_map R₁ K a)⁻¹ * aI :=\n  by\n  obtain ⟨a_inv, nonzero, ha⟩ := I.is_fractional\n  have nonzero := mem_non_zero_divisors_iff_ne_zero.mp nonzero\n  have map_a_nonzero : algebra_map R₁ K a_inv ≠ 0 := mt is_fraction_ring.to_map_eq_zero_iff.mp nonzero\n  refine'\n    ⟨a_inv,\n      submodule.comap (algebra.linear_map R₁ K) ↑(span_singleton (non_zero_divisors R₁) (algebra_map R₁ K a_inv) * I),\n      nonzero, ext fun x => iff.trans ⟨_, _⟩ mem_singleton_mul.symm⟩\n  · intro hx\n    obtain ⟨x', hx'⟩ := ha x hx\n    rw [algebra.smul_def] at hx'\n    refine' ⟨algebra_map R₁ K x', (mem_coe_ideal _).mpr ⟨x', mem_singleton_mul.mpr _, rfl⟩, _⟩\n    · exact ⟨x, hx, hx'⟩\n    · rw [hx', ← mul_assoc, inv_mul_cancel map_a_nonzero, one_mul]\n  · rintro ⟨y, hy, rfl⟩\n    obtain ⟨x', hx', rfl⟩ := (mem_coe_ideal _).mp hy\n    obtain ⟨y', hy', hx'⟩ := mem_singleton_mul.mp hx'\n    rw [algebra.linear_map_apply] at hx'\n    rwa [hx', ← mul_assoc, inv_mul_cancel map_a_nonzero, one_mul]\n#align exists_eq_span_singleton_mul exists_eq_span_singleton_mul\n\n",
 "eq_zero_or_one_of_is_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem eq_zero_or_one_of_is_field (hF : IsField R₁) (I : fractional_ideal (non_zero_divisors R₁) K) : I = 0 ∨ I = 1 :=\n  letI : Field R₁ := hF.to_field\n  eq_zero_or_one I\n#align eq_zero_or_one_of_is_field eq_zero_or_one_of_is_field\n\n",
 "eq_zero_or_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem eq_zero_or_one (I : fractional_ideal (non_zero_divisors K) L) : I = 0 ∨ I = 1 :=\n  by\n  rw [or_iff_not_imp_left]\n  intro hI\n  simp_rw [@SetLike.ext_iff _ _ _ I 1, mem_one_iff]\n  intro x\n  constructor\n  · intro x_mem\n    obtain ⟨n, d, rfl⟩ := is_localization.mk'_surjective (non_zero_divisors K) x\n    refine' ⟨n / d, _⟩\n    rw [map_div₀, is_fraction_ring.mk'_eq_div]\n  · rintro ⟨x, rfl⟩\n    obtain ⟨y, y_ne, y_mem⟩ := exists_ne_zero_mem_is_integer hI\n    rw [← div_mul_cancel x y_ne, RingHom.map_mul, ← algebra.smul_def]\n    exact submodule.smul_mem I _ y_mem\n#align eq_zero_or_one eq_zero_or_one\n\n",
 "eq_zero_iff":
 "theorem eq_zero_iff {I : fractional_ideal S P} : I = 0 ↔ ∀ x ∈ I, x = (0 : P) :=\n  ⟨fun h x hx => by simpa [h, mem_zero_iff] using hx, fun h => le_bot_iff.mp fun x hx => (mem_zero_iff S).mpr (h x hx)⟩\n#align eq_zero_iff eq_zero_iff\n\n",
 "eq_span_singleton_of_principal":
 "theorem eq_span_singleton_of_principal (I : fractional_ideal S P) [is_principal (I : submodule R P)] :\n    I = span_singleton S (generator (I : submodule R P)) :=\n  by\n  rw [span_singleton]\n  exact coe_to_submodule_injective (span_singleton_generator ↑I).symm\n#align eq_span_singleton_of_principal eq_span_singleton_of_principal\n\n",
 "eq_span_singleton_mul":
 "theorem eq_span_singleton_mul {x : P} {I J : fractional_ideal S P} :\n    I = span_singleton _ x * J ↔ (∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI) ∧ ∀ z ∈ J, x * z ∈ I := by\n  simp only [le_antisymm_iff, le_span_singleton_mul_iff, span_singleton_mul_le_iff]\n#align eq_span_singleton_mul eq_span_singleton_mul\n\n",
 "eq_one_div_of_mul_eq_one_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n#print eq_one_div_of_mul_eq_one_right /-\ntheorem eq_one_div_of_mul_eq_one_right (I J : fractional_ideal (non_zero_divisors R₁) K) (h : I * J = 1) : J = 1 / I :=\n  by\n  have hI : I ≠ 0 := ne_zero_of_mul_eq_one I J h\n  suffices h' : I * (1 / I) = 1\n  · exact congr_arg Units.inv <| @Units.ext _ _ (units.mk_of_mul_eq_one _ _ h) (units.mk_of_mul_eq_one _ _ h') rfl\n  apply le_antisymm\n  · apply mul_le.mpr _\n    intro x hx y hy\n    rw [mul_comm]\n    exact (mem_div_iff_of_nonzero hI).mp hy x hx\n  rw [← h]\n  apply mul_left_mono I\n  apply (le_div_iff_of_nonzero hI).mpr _\n  intro y hy x hx\n  rw [mul_comm]\n  exact mul_mem_mul hx hy\n#align eq_one_div_of_mul_eq_one_right eq_one_div_of_mul_eq_one_right\n-/\n\n",
 "div_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n#print div_zero /-\n@[simp]\ntheorem div_zero {I : fractional_ideal (non_zero_divisors R₁) K} : I / 0 = 0 :=\n  dif_pos rfl\n#align div_zero div_zero\n-/\n\n",
 "div_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem div_span_singleton (J : fractional_ideal (non_zero_divisors R₁) K) (d : K) :\n    J / span_singleton (non_zero_divisors R₁) d = span_singleton (non_zero_divisors R₁) d⁻¹ * J :=\n  by\n  rw [← one_div_span_singleton]\n  by_cases hd : d = 0\n  · simp only [hd, span_singleton_zero, div_zero, zero_mul]\n  have h_spand : span_singleton (non_zero_divisors R₁) d ≠ 0 := mt span_singleton_eq_zero_iff.mp hd\n  apply le_antisymm\n  · intro x hx\n    rw [← mem_coe, coe_div h_spand, submodule.mem_div_iff_forall_mul_mem] at hx\n    specialize hx d (mem_span_singleton_self (non_zero_divisors R₁) d)\n    have h_xd : x = d⁻¹ * (x * d) := by field_simp\n    rw [← mem_coe, coe_mul, one_div_span_singleton, h_xd]\n    exact submodule.mul_mem_mul (mem_span_singleton_self (non_zero_divisors R₁) _) hx\n  · rw [le_div_iff_mul_le h_spand, mul_assoc, mul_left_comm, one_div_span_singleton, span_singleton_mul_span_singleton,\n      inv_mul_cancel hd, span_singleton_one, mul_one]\n    exact le_refl J\n#align div_span_singleton div_span_singleton\n\n",
 "div_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n#print div_one /-\n@[simp]\ntheorem div_one {I : fractional_ideal (non_zero_divisors R₁) K} : I / 1 = I :=\n  by\n  rw [div_nonzero (one_ne_zero' (fractional_ideal (non_zero_divisors R₁) K))]\n  ext\n  constructor <;> intro h\n  · simpa using mem_div_iff_forall_mul_mem.mp h 1 ((algebra_map R₁ K).map_one ▸ coe_mem_one (non_zero_divisors R₁) 1)\n  · apply mem_div_iff_forall_mul_mem.mpr\n    rintro y ⟨y', _, rfl⟩\n    rw [mul_comm]\n    convert submodule.smul_mem _ y' h\n    exact (algebra.smul_def _ _).symm\n#align div_one div_one\n-/\n\n",
 "div_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem _root_.is_fractional.div_of_nonzero {I J : submodule R₁ K} :\n    is_fractional (non_zero_divisors R₁) I →\n      is_fractional (non_zero_divisors R₁) J → J ≠ 0 → is_fractional (non_zero_divisors R₁) (I / J)\n  | ⟨aI, haI, hI⟩, ⟨aJ, haJ, hJ⟩, h =>\n    by\n    obtain ⟨y, mem_J, not_mem_zero⟩ := SetLike.exists_of_lt (by simpa only using bot_lt_iff_ne_bot.mpr h)\n    obtain ⟨y', hy'⟩ := hJ y mem_J\n    use aI * y'\n    constructor\n    · apply (non_zero_divisors R₁).mul_mem haI (mem_non_zero_divisors_iff_ne_zero.mpr _)\n      intro y'_eq_zero\n      have : algebra_map R₁ K aJ * y = 0 := by rw [← algebra.smul_def, ← hy', y'_eq_zero, RingHom.map_zero]\n      have y_zero :=\n        (mul_eq_zero.mp this).resolve_left\n          (mt ((injective_iff_map_eq_zero (algebra_map R₁ K)).1 (is_fraction_ring.injective _ _) _)\n            (mem_non_zero_divisors_iff_ne_zero.mp haJ))\n      apply not_mem_zero\n      simpa only using (mem_zero_iff (non_zero_divisors R₁)).mpr y_zero\n    intro b hb\n    convert hI _ (hb _ (submodule.smul_mem _ aJ mem_J)) using 1\n    rw [← hy', mul_comm b, ← algebra.smul_def, mul_smul]\n#align is_fractional.div_of_nonzero is_fractional.div_of_nonzero\n\n",
 "div_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem div_nonzero {I J : fractional_ideal (non_zero_divisors R₁) K} (h : J ≠ 0) :\n    I / J = ⟨I / J, fractional_div_of_nonzero h⟩ :=\n  dif_neg h\n#align div_nonzero div_nonzero\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, norm_cast]\ntheorem coe_zero : ↑(0 : fractional_ideal S P) = («expr⊥» : submodule R P) :=\n  submodule.ext fun _ => mem_zero_iff S\n#align coe_zero coe_zero\n\n",
 "coe_to_submodule_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem coe_to_submodule_ne_bot {I : fractional_ideal S P} : ↑I ≠ («expr⊥» : submodule R P) ↔ I ≠ 0 :=\n  not_iff_not.mpr coe_to_submodule_eq_bot\n#align coe_to_submodule_ne_bot coe_to_submodule_ne_bot\n\n",
 "coe_to_submodule_injective":
 "theorem coe_to_submodule_injective : function.injective (coe : fractional_ideal S P → submodule R P) :=\n  subtype.coe_injective\n#align coe_to_submodule_injective coe_to_submodule_injective\n\n",
 "coe_to_submodule_inj":
 "theorem coe_to_submodule_inj {I J : fractional_ideal S P} : (I : submodule R P) = J ↔ I = J :=\n  coe_to_submodule_injective.eq_iff\n#align coe_to_submodule_inj coe_to_submodule_inj\n\n",
 "coe_to_submodule_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem coe_to_submodule_eq_bot {I : fractional_ideal S P} : (I : submodule R P) = «expr⊥» ↔ I = 0 :=\n  ⟨fun h => coe_to_submodule_injective (by simp [h]), fun h => by simp [h]⟩\n#align coe_to_submodule_eq_bot coe_to_submodule_eq_bot\n\n",
 "coe_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[norm_cast]\ntheorem coe_sup (I J : fractional_ideal S P) : ↑(«expr ⊔ » I J) = («expr ⊔ » I J : submodule R P) :=\n  rfl\n#align coe_sup coe_sup\n\n",
 "coe_span_singleton":
 "-- local attribute [semireducible] span_singleton\n@[simp]\ntheorem coe_span_singleton (x : P) : (span_singleton S x : submodule R P) = span R {x} :=\n  by\n  rw [span_singleton]\n  rfl\n#align coe_span_singleton coe_span_singleton\n\n",
 "coe_pow":
 "@[simp, norm_cast]\ntheorem coe_pow (I : fractional_ideal S P) (n : ℕ) : ↑(I ^ n) = (I ^ n : submodule R P) :=\n  rfl\n#align coe_pow coe_pow\n\n",
 "coe_one_eq_coe_submodule_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- `(1 : fractional_ideal S P)` is defined as the R-submodule `f(R) ≤ P`.\n\nHowever, this is not definitionally equal to `1 : submodule R P`,\nwhich is proved in the actual `simp` lemma `coe_one`. -/\ntheorem coe_one_eq_coe_submodule_top : ↑(1 : fractional_ideal S P) = coe_submodule P («expr⊤» : ideal R) :=\n  rfl\n#align coe_one_eq_coe_submodule_top coe_one_eq_coe_submodule_top\n\n",
 "coe_one":
 "@[simp, norm_cast]\ntheorem coe_one : (↑(1 : fractional_ideal S P) : submodule R P) = 1 := by\n  rw [coe_one_eq_coe_submodule_top, coe_submodule_top]\n#align coe_one coe_one\n\n",
 "coe_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[norm_cast]\ntheorem coe_nsmul (n : ℕ) (I : fractional_ideal S P) : (↑(«expr • » n I) : submodule R P) = «expr • » n I :=\n  rfl\n#align coe_nsmul coe_nsmul\n\n",
 "coe_nat_cast":
 "theorem coe_nat_cast (n : ℕ) : ((n : fractional_ideal S P) : submodule R P) = n :=\n  show ↑n.unary_cast = ↑n by induction n <;> simp [*, Nat.unaryCast]\n#align coe_nat_cast coe_nat_cast\n\n",
 "coe_mul":
 "@[simp, norm_cast]\ntheorem coe_mul (I J : fractional_ideal S P) : (↑(I * J) : submodule R P) = I * J :=\n  by\n  simp only [mul_def]\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_mk":
 "@[simp, norm_cast]\ntheorem coe_mk (I : submodule R P) (hI : is_fractional S I) : (subtype.mk I hI : submodule R P) = I :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_mem_one":
 "theorem coe_mem_one (x : R) : algebra_map R P x ∈ (1 : fractional_ideal S P) :=\n  (mem_one_iff S).mpr ⟨x, rfl⟩\n#align coe_mem_one coe_mem_one\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_map (g : «expr →ₐ[ ] » P R P') (I : fractional_ideal S P) : ↑(map g I) = submodule.map g.to_linear_map I :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_le_coe":
 "@[simp]\ntheorem coe_le_coe {I J : fractional_ideal S P} : (I : submodule R P) ≤ (J : submodule R P) ↔ I ≤ J :=\n  iff.rfl\n#align coe_le_coe coe_le_coe\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, norm_cast]\ntheorem coe_inf (I J : fractional_ideal S P) : ↑(«expr ⊓ » I J) = («expr ⊓ » I J : submodule R P) :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_ideal_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, norm_cast]\ntheorem coe_ideal_top : ((«expr⊤» : ideal R) : fractional_ideal S P) = 1 :=\n  rfl\n#align coe_ideal_top coe_ideal_top\n\n",
 "coe_ideal_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp, norm_cast]\ntheorem coe_ideal_sup (I J : ideal R) : ↑(«expr ⊔ » I J) = (I + J : fractional_ideal S P) :=\n  coe_to_submodule_injective <| coe_submodule_sup _ _ _\n#align coe_ideal_sup coe_ideal_sup\n\n",
 "coe_ideal_span_singleton":
 "@[simp]\ntheorem coe_ideal_span_singleton (x : R) :\n    (↑(ideal.span {x} : ideal R) : fractional_ideal S P) = span_singleton S (algebra_map R P x) :=\n  by\n  ext y\n  refine' (mem_coe_ideal S).trans (iff.trans _ (mem_span_singleton S).symm)\n  constructor\n  · rintro ⟨y', hy', rfl⟩\n    obtain ⟨x', rfl⟩ := submodule.mem_span_singleton.mp hy'\n    use x'\n    rw [smul_eq_mul, RingHom.map_mul, algebra.smul_def]\n  · rintro ⟨y', rfl⟩\n    refine' ⟨y' * x, submodule.mem_span_singleton.mpr ⟨y', rfl⟩, _⟩\n    rw [RingHom.map_mul, algebra.smul_def]\n#align coe_ideal_span_singleton coe_ideal_span_singleton\n\n",
 "coe_ideal_pow":
 "theorem coe_ideal_pow (I : ideal R) (n : ℕ) : (↑(I ^ n) : fractional_ideal S P) = I ^ n :=\n  (coe_ideal_hom S P).map_pow _ n\n#align coe_ideal_pow coe_ideal_pow\n\n",
 "coe_ideal_ne_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem coe_ideal_ne_zero' {I : ideal R} (h : S ≤ non_zero_divisors R) :\n    (I : fractional_ideal S P) ≠ 0 ↔ I ≠ («expr⊥» : ideal R) :=\n  not_iff_not.mpr <| coe_ideal_eq_zero' h\n#align coe_ideal_ne_zero' coe_ideal_ne_zero'\n\n",
 "coe_ideal_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem coe_ideal_ne_zero {I : ideal R} : (I : fractional_ideal (non_zero_divisors R) K) ≠ 0 ↔ I ≠ «expr⊥» :=\n  coe_ideal_ne_zero' le_rfl\n#align coe_ideal_ne_zero coe_ideal_ne_zero\n\n",
 "coe_ideal_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem coe_ideal_ne_one {I : ideal R} : (I : fractional_ideal (non_zero_divisors R) K) ≠ 1 ↔ I ≠ 1 :=\n  not_iff_not.mpr coe_ideal_eq_one\n#align coe_ideal_ne_one coe_ideal_ne_one\n\n",
 "coe_ideal_mul":
 "@[simp, norm_cast]\ntheorem coe_ideal_mul (I J : ideal R) : (↑(I * J) : fractional_ideal S P) = I * J :=\n  by\n  simp only [mul_def]\n  exact coe_to_submodule_injective (coe_submodule_mul _ _ _)\n#align coe_ideal_mul coe_ideal_mul\n\n",
 "coe_ideal_le_one":
 "theorem coe_ideal_le_one {I : ideal R} : (I : fractional_ideal S P) ≤ 1 := fun x hx =>\n  let ⟨y, _, hy⟩ := (mem_coe_ideal S).mp hx\n  (mem_one_iff S).mpr ⟨y, hy⟩\n#align coe_ideal_le_one coe_ideal_le_one\n\n",
 "coe_ideal_le_coe_ideal'":
 "theorem coe_ideal_le_coe_ideal' [is_localization S P] (h : S ≤ non_zero_divisors R) {I J : ideal R} :\n    (I : fractional_ideal S P) ≤ J ↔ I ≤ J :=\n  coe_submodule_le_coe_submodule h\n#align coe_ideal_le_coe_ideal' coe_ideal_le_coe_ideal'\n\n",
 "coe_ideal_le_coe_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem coe_ideal_le_coe_ideal (K : Type _) [CommRing K] [algebra R K] [is_fraction_ring R K] {I J : ideal R} :\n    (I : fractional_ideal (non_zero_divisors R) K) ≤ J ↔ I ≤ J :=\n  is_fraction_ring.coe_submodule_le_coe_submodule\n#align coe_ideal_le_coe_ideal coe_ideal_le_coe_ideal\n\n",
 "coe_ideal_injective'":
 "theorem coe_ideal_injective' (h : S ≤ non_zero_divisors R) :\n    function.injective (coe : ideal R → fractional_ideal S P) := fun _ _ h' =>\n  ((coe_ideal_le_coe_ideal' S h).mp h'.le).antisymm ((coe_ideal_le_coe_ideal' S h).mp h'.ge)\n#align coe_ideal_injective' coe_ideal_injective'\n\n",
 "coe_ideal_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem coe_ideal_injective : function.injective (coe : ideal R → fractional_ideal (non_zero_divisors R) K) :=\n  coe_ideal_injective' le_rfl\n#align coe_ideal_injective coe_ideal_injective\n\n",
 "coe_ideal_inj'":
 "theorem coe_ideal_inj' (h : S ≤ non_zero_divisors R) {I J : ideal R} : (I : fractional_ideal S P) = J ↔ I = J :=\n  (coe_ideal_injective' h).eq_iff\n#align coe_ideal_inj' coe_ideal_inj'\n\n",
 "coe_ideal_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem coe_ideal_inj {I J : ideal R} :\n    (I : fractional_ideal (non_zero_divisors R) K) = (J : fractional_ideal (non_zero_divisors R) K) ↔ I = J :=\n  coe_ideal_inj' le_rfl\n#align coe_ideal_inj coe_ideal_inj\n\n",
 "coe_ideal_finprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\ntheorem coe_ideal_finprod [is_localization S P] {α : Sort _} {f : α → ideal R} (hS : S ≤ non_zero_divisors R) :\n    ((finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f a) : ideal R) :\n        fractional_ideal S P) =\n      finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\"\n        (f a : fractional_ideal S P) :=\n  monoid_hom.map_finprod_of_injective (coe_ideal_hom S P).to_monoid_hom (coe_ideal_injective' hS) f\n#align coe_ideal_finprod coe_ideal_finprod\n\n",
 "coe_ideal_fg":
 "theorem coe_ideal_fg (inj : function.injective (algebra_map R P)) (I : ideal R) :\n    fg ((I : fractional_ideal S P) : submodule R P) ↔ I.fg :=\n  coe_submodule_fg _ inj _\n#align coe_ideal_fg coe_ideal_fg\n\n",
 "coe_ideal_eq_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_ideal_eq_zero' {I : ideal R} (h : S ≤ non_zero_divisors R) :\n    (I : fractional_ideal S P) = 0 ↔ I = («expr⊥» : ideal R) :=\n  coe_ideal_inj' h\n#align coe_ideal_eq_zero' coe_ideal_eq_zero'\n\n",
 "coe_ideal_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_ideal_eq_zero {I : ideal R} : (I : fractional_ideal (non_zero_divisors R) K) = 0 ↔ I = «expr⊥» :=\n  coe_ideal_eq_zero' le_rfl\n#align coe_ideal_eq_zero coe_ideal_eq_zero\n\n",
 "coe_ideal_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem coe_ideal_eq_one {I : ideal R} : (I : fractional_ideal (non_zero_divisors R) K) = 1 ↔ I = 1 := by\n  simpa only [ideal.one_eq_top] using coe_ideal_inj\n#align coe_ideal_eq_one coe_ideal_eq_one\n\n",
 "coe_ideal_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, norm_cast]\ntheorem coe_ideal_bot : ((«expr⊥» : ideal R) : fractional_ideal S P) = 0 :=\n  rfl\n#align coe_ideal_bot coe_ideal_bot\n\n",
 "coe_fun_map_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem coe_fun_map_equiv (g : «expr ≃ₐ[ ] » P R P') :\n    (map_equiv g : fractional_ideal S P → fractional_ideal S P') = map g :=\n  rfl\n#align coe_fun_map_equiv coe_fun_map_equiv\n\n",
 "coe_eq":
 "theorem coe_eq (p : fractional_ideal S P) (s : set P) (hs : s = ↑p) : p.copy s hs = p :=\n  SetLike.coe_injective hs\n#align coe_eq coe_eq\n\n",
 "coe_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem coe_div {I J : fractional_ideal (non_zero_divisors R₁) K} (hJ : J ≠ 0) :\n    (↑(I / J) : submodule R₁ K) = ↑I / (↑J : submodule R₁ K) :=\n  congr_arg _ (dif_neg hJ)\n#align coe_div coe_div\n\n",
 "coe_copy":
 "@[simp]\ntheorem coe_copy (p : fractional_ideal S P) (s : set P) (hs : s = ↑p) : ↑(p.copy s hs) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_coe_ideal":
 "-- Is a `coe_t` rather than `coe` to speed up failing inference, see library note [use has_coe_t]\n@[simp, norm_cast]\ntheorem coe_coe_ideal (I : ideal R) : ((I : fractional_ideal S P) : submodule R P) = coe_submodule P I :=\n  rfl\n#align coe_coe_ideal coe_coe_ideal\n\n",
 "coe_add":
 "@[simp, norm_cast]\ntheorem coe_add (I J : fractional_ideal S P) : (↑(I + J) : submodule R P) = I + J :=\n  rfl\n#align coe_add coe_add\n\n",
 "canonical_equiv_trans_canonical_equiv":
 "theorem canonical_equiv_trans_canonical_equiv (P'' : Type _) [CommRing P''] [algebra R P''] [is_localization S P''] :\n    (canonical_equiv S P P').trans (canonical_equiv S P' P'') = canonical_equiv S P P'' :=\n  RingEquiv.ext (canonical_equiv_canonical_equiv S P P' P'')\n#align canonical_equiv_trans_canonical_equiv canonical_equiv_trans_canonical_equiv\n\n",
 "canonical_equiv_symm":
 "@[simp]\ntheorem canonical_equiv_symm : (canonical_equiv S P P').symm = canonical_equiv S P' P :=\n  RingEquiv.ext fun I =>\n    SetLike.ext_iff.mpr fun x =>\n      by\n      rw [mem_canonical_equiv_apply, canonical_equiv, map_equiv_symm, map_equiv, [anonymous], mem_map]\n      exact ⟨fun ⟨y, mem, eq⟩ => ⟨y, mem, eq⟩, fun ⟨y, mem, eq⟩ => ⟨y, mem, eq⟩⟩\n#align canonical_equiv_symm canonical_equiv_symm\n\n",
 "canonical_equiv_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem canonical_equiv_span_singleton {P'} [CommRing P'] [algebra R P'] [is_localization S P'] (x : P) :\n    canonical_equiv S P P' (span_singleton S x) =\n      span_singleton S\n        (is_localization.map P' (RingHom.id R) (fun y (hy : y ∈ S) => show RingHom.id R y ∈ S from hy) x) :=\n  by\n  apply set_like.ext_iff.mpr\n  intro y\n  constructor <;> intro h\n  · rw [mem_span_singleton]\n    obtain ⟨x', hx', rfl⟩ := (mem_canonical_equiv_apply _ _ _).mp h\n    obtain ⟨z, rfl⟩ := (mem_span_singleton _).mp hx'\n    use z\n    rw [is_localization.map_smul]\n    rfl\n  · rw [mem_canonical_equiv_apply]\n    obtain ⟨z, rfl⟩ := (mem_span_singleton _).mp h\n    use «expr • » z x\n    use (mem_span_singleton _).mpr ⟨z, rfl⟩\n    simp [is_localization.map_smul]\n#align canonical_equiv_span_singleton canonical_equiv_span_singleton\n\n",
 "canonical_equiv_self":
 "@[simp]\ntheorem canonical_equiv_self : canonical_equiv S P P = RingEquiv.refl _ :=\n  by\n  rw [← canonical_equiv_trans_canonical_equiv S P P]\n  convert (canonical_equiv S P P).symm_trans_self\n  exact (canonical_equiv_symm S P P).symm\n#align canonical_equiv_self canonical_equiv_self\n\n",
 "canonical_equiv_flip":
 "theorem canonical_equiv_flip (I) : canonical_equiv S P P' (canonical_equiv S P' P I) = I := by\n  rw [← canonical_equiv_symm, RingEquiv.symm_apply_apply]\n#align canonical_equiv_flip canonical_equiv_flip\n\n",
 "canonical_equiv_coe_ideal":
 "@[simp]\ntheorem canonical_equiv_coe_ideal (I : ideal R) : canonical_equiv S P P' I = I :=\n  by\n  ext\n  simp [is_localization.map_eq]\n#align canonical_equiv_coe_ideal canonical_equiv_coe_ideal\n\n",
 "canonical_equiv_canonical_equiv":
 "@[simp]\ntheorem canonical_equiv_canonical_equiv (P'' : Type _) [CommRing P''] [algebra R P''] [is_localization S P'']\n    (I : fractional_ideal S P) : canonical_equiv S P' P'' (canonical_equiv S P P' I) = canonical_equiv S P P'' I :=\n  by\n  ext\n  simp only [is_localization.map_map, ring_hom_inv_pair.comp_eq₂, mem_canonical_equiv_apply, exists_prop,\n    exists_exists_and_eq_and]\n  rfl\n#align canonical_equiv_canonical_equiv canonical_equiv_canonical_equiv\n\n",
 "bot_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print bot_eq_zero /-\n@[simp]\ntheorem bot_eq_zero : («expr⊥» : fractional_ideal S P) = 0 :=\n  rfl\n#align bot_eq_zero bot_eq_zero\n-/\n\n",
 "add_le_add_left":
 "#print add_le_add_left /-\ntheorem add_le_add_left {I J : fractional_ideal S P} (hIJ : I ≤ J) (J' : fractional_ideal S P) : J' + I ≤ J' + J :=\n  sup_le_sup_left hIJ J'\n#align add_le_add_left add_le_add_left\n-/\n\n"}