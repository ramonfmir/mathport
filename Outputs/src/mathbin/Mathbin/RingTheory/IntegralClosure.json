{"zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_integral.zsmul {x : A} (h : is_integral R x) (n : ℤ) : is_integral R («expr • » n x) :=\n  (integral_closure R A).zsmul_mem h n\n#align is_integral.zsmul is_integral.zsmul\n\n",
 "to_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ring_hom.finite.to_is_integral (h : f.finite) : f.is_integral :=\n  letI := f.to_algebra\n  fun x => is_integral_of_mem_of_fg («expr⊤») h.1 _ trivial\n#align ring_hom.finite.to_is_integral ring_hom.finite.to_is_integral\n\n",
 "to_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ring_hom.is_integral.to_finite (h : f.is_integral) (h' : f.finite_type) : f.finite :=\n  by\n  letI := f.to_algebra\n  obtain ⟨s, hs⟩ := h'\n  constructor\n  change («expr⊤» : subalgebra R S).to_submodule.fg\n  rw [← hs]\n  exact fg_adjoin_of_finite (set.to_finite _) fun x _ => h x\n#align ring_hom.is_integral.to_finite ring_hom.is_integral.to_finite\n\n",
 "tmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\ntheorem is_integral.tmul (x : A) {y : B} (h : is_integral R y) : is_integral A («expr ⊗ₜ[ ] » x R y) :=\n  by\n  obtain ⟨p, hp, hp'⟩ := h\n  refine' ⟨(p.map (algebra_map R A)).scale_roots x, _, _⟩\n  · rw [polynomial.monic_scale_roots_iff]\n    exact hp.map _\n  convert\n    @polynomial.scale_roots_eval₂_mul (tensor_product A R B) A _ _ _ algebra.tensor_product.include_left.to_ring_hom\n      («expr ⊗ₜ » 1 y) x using\n    2\n  ·\n    simp only [alg_hom.to_ring_hom_eq_coe, alg_hom.coe_to_ring_hom, mul_one, one_mul,\n      algebra.tensor_product.include_left_apply, algebra.tensor_product.tmul_mul_tmul]\n  convert (mul_zero _).symm\n  rw [polynomial.eval₂_map, algebra.tensor_product.include_left_comp_algebra_map, ← polynomial.eval₂_map]\n  convert polynomial.eval₂_at_apply algebra.tensor_product.include_right.to_ring_hom y\n  rw [polynomial.eval_map, hp', _root_.map_zero]\n#align is_integral.tmul is_integral.tmul\n\n",
 "sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem is_integral.sum {α : Type _} {s : Finset α} (f : α → A) (h : ∀ x ∈ s, is_integral R (f x)) :\n    is_integral R\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)) :=\n  (integral_closure R A).sum_mem h\n#align is_integral.sum is_integral.sum\n\n",
 "roots_mem_integral_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_mem_integral_closure {f : polynomial R} (hf : f.monic) {a : S}\n    (ha : a ∈ (f.map <| algebra_map R S).roots) : a ∈ integral_closure R S :=\n  ⟨f, hf, (eval₂_eq_eval_map _).trans <| (mem_roots <| (hf.map _).ne_zero).1 ha⟩\n#align roots_mem_integral_closure roots_mem_integral_closure\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem is_integral.prod {α : Type _} {s : Finset α} (f : α → A) (h : ∀ x ∈ s, is_integral R (f x)) :\n    is_integral R\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x)) :=\n  (integral_closure R A).prod_mem h\n#align is_integral.prod is_integral.prod\n\n",
 "pow_iff":
 "@[simp]\ntheorem is_integral.pow_iff {x : A} {n : ℕ} (hn : 0 < n) : is_integral R (x ^ n) ↔ is_integral R x :=\n  ⟨is_integral_of_pow hn, fun hx => is_integral.pow hx n⟩\n#align is_integral.pow_iff is_integral.pow_iff\n\n",
 "pow":
 "theorem is_integral.pow {x : A} (h : is_integral R x) (n : ℕ) : is_integral R (x ^ n) :=\n  (integral_closure R A).pow_mem h n\n#align is_integral.pow is_integral.pow\n\n",
 "of_finite":
 "theorem algebra.is_integral.of_finite [h : module.finite R A] : algebra.is_integral R A :=\n  by\n  apply ring_hom.finite.to_is_integral\n  delta ring_hom.finite; convert h; ext; exact (algebra.smul_def _ _).symm\n#align algebra.is_integral.of_finite algebra.is_integral.of_finite\n\n",
 "nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_integral.nsmul {x : A} (h : is_integral R x) (n : ℕ) : is_integral R («expr • » n x) :=\n  (integral_closure R A).nsmul_mem h n\n#align is_integral.nsmul is_integral.nsmul\n\n",
 "normalize_scale_roots_support":
 "theorem normalize_scale_roots_support : (normalize_scale_roots p).support ≤ p.support :=\n  by\n  intro x\n  contrapose\n  simp only [not_mem_support_iff, normalize_scale_roots, finset_sum_coeff, coeff_monomial, finset.sum_ite_eq',\n    mem_support_iff, ne.def, not_not, ite_eq_right_iff]\n  intro h₁ h₂\n  exact (h₂ h₁).rec _\n#align normalize_scale_roots_support normalize_scale_roots_support\n\n",
 "normalize_scale_roots_monic":
 "theorem normalize_scale_roots_monic (h : p ≠ 0) : (normalize_scale_roots p).monic :=\n  by\n  delta monic leading_coeff\n  rw [nat_degree_eq_of_degree_eq (normalize_scale_roots_degree p)]\n  suffices p = 0 → (0 : R) = 1 by simpa [normalize_scale_roots, coeff_monomial]\n  exact fun h' => (h h').rec _\n#align normalize_scale_roots_monic normalize_scale_roots_monic\n\n",
 "normalize_scale_roots_eval₂_leading_coeff_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem normalize_scale_roots_eval₂_leading_coeff_mul (h : 1 ≤ p.nat_degree) (f : «expr →+* » R S) (x : S) :\n    (normalize_scale_roots p).eval₂ f (f p.leading_coeff * x) = f p.leading_coeff ^ (p.nat_degree - 1) * p.eval₂ f x :=\n  by\n  rw [eval₂_eq_sum_range, eval₂_eq_sum_range, finset.mul_sum]\n  apply finset.sum_congr\n  · rw [nat_degree_eq_of_degree_eq (normalize_scale_roots_degree p)]\n  intro n hn\n  rw [mul_pow, ← mul_assoc, ← f.map_pow, ← f.map_mul, normalize_scale_roots_coeff_mul_leading_coeff_pow _ _ h,\n    f.map_mul, f.map_pow]\n  ring\n#align normalize_scale_roots_eval₂_leading_coeff_mul normalize_scale_roots_eval₂_leading_coeff_mul\n\n",
 "normalize_scale_roots_degree":
 "theorem normalize_scale_roots_degree : (normalize_scale_roots p).degree = p.degree :=\n  by\n  apply le_antisymm\n  · exact finset.sup_mono (normalize_scale_roots_support p)\n  · rw [← degree_scale_roots, ← leading_coeff_smul_normalize_scale_roots]\n    exact degree_smul_le _ _\n#align normalize_scale_roots_degree normalize_scale_roots_degree\n\n",
 "normalize_scale_roots_coeff_mul_leading_coeff_pow":
 "theorem normalize_scale_roots_coeff_mul_leading_coeff_pow (i : ℕ) (hp : 1 ≤ nat_degree p) :\n    (normalize_scale_roots p).coeff i * p.leading_coeff ^ i = p.coeff i * p.leading_coeff ^ (p.nat_degree - 1) :=\n  by\n  simp only [normalize_scale_roots, finset_sum_coeff, coeff_monomial, finset.sum_ite_eq', one_mul, zero_mul,\n    mem_support_iff, ite_mul, ne.def, ite_not]\n  split_ifs with h₁ h₂\n  · simp [h₁]\n  · rw [h₂, leading_coeff, ← pow_succ, tsub_add_cancel_of_le hp]\n  · rw [mul_assoc, ← pow_add, tsub_add_cancel_of_le]\n    apply Nat.le_pred_of_lt\n    rw [lt_iff_le_and_ne]\n    exact ⟨le_nat_degree_of_ne_zero h₁, h₂⟩\n#align normalize_scale_roots_coeff_mul_leading_coeff_pow normalize_scale_roots_coeff_mul_leading_coeff_pow\n\n",
 "multiset_sum":
 "theorem is_integral.multiset_sum {s : Multiset A} (h : ∀ x ∈ s, is_integral R x) : is_integral R s.sum :=\n  (integral_closure R A).multiset_sum_mem h\n#align is_integral.multiset_sum is_integral.multiset_sum\n\n",
 "multiset_prod":
 "theorem is_integral.multiset_prod {s : Multiset A} (h : ∀ x ∈ s, is_integral R x) : is_integral R s.prod :=\n  (integral_closure R A).multiset_prod_mem h\n#align is_integral.multiset_prod is_integral.multiset_prod\n\n",
 "mk'_zero":
 "@[simp]\ntheorem mk'_zero (h : is_integral R (0 : B) := is_integral_zero) : mk' A 0 h = 0 :=\n  algebra_map_injective A R B <| by rw [algebra_map_mk', RingHom.map_zero]\n#align mk'_zero mk'_zero\n\n",
 "mk'_one":
 "@[simp]\ntheorem mk'_one (h : is_integral R (1 : B) := is_integral_one) : mk' A 1 h = 1 :=\n  algebra_map_injective A R B <| by rw [algebra_map_mk', RingHom.map_one]\n#align mk'_one mk'_one\n\n",
 "mk'_mul":
 "@[simp]\ntheorem mk'_mul (x y : B) (hx : is_integral R x) (hy : is_integral R y) :\n    mk' A (x * y) (is_integral_mul hx hy) = mk' A x hx * mk' A y hy :=\n  algebra_map_injective A R B <| by simp only [algebra_map_mk', RingHom.map_mul]\n#align mk'_mul mk'_mul\n\n",
 "mk'_algebra_map":
 "@[simp]\ntheorem mk'_algebra_map [algebra R A] [IsScalarTower R A B] (x : R)\n    (h : is_integral R (algebra_map R B x) := is_integral_algebra_map) :\n    is_integral_closure.mk' A (algebra_map R B x) h = algebra_map R A x :=\n  algebra_map_injective A R B <| by rw [algebra_map_mk', ← is_scalar_tower.algebra_map_apply]\n#align mk'_algebra_map mk'_algebra_map\n\n",
 "mk'_add":
 "@[simp]\ntheorem mk'_add (x y : B) (hx : is_integral R x) (hy : is_integral R y) :\n    mk' A (x + y) (is_integral_add hx hy) = mk' A x hx + mk' A y hy :=\n  algebra_map_injective A R B <| by simp only [algebra_map_mk', RingHom.map_add]\n#align mk'_add mk'_add\n\n",
 "mem_integral_closure_iff_mem_fg":
 "theorem mem_integral_closure_iff_mem_fg {r : A} :\n    r ∈ integral_closure R A ↔ ∃ M : subalgebra R A, M.to_submodule.fg ∧ r ∈ M :=\n  ⟨fun hr => ⟨algebra.adjoin R {r}, fg_adjoin_singleton_of_integral _ hr, algebra.subset_adjoin rfl⟩,\n    fun ⟨M, Hf, hrM⟩ => is_integral_of_mem_of_fg M Hf _ hrM⟩\n#align mem_integral_closure_iff_mem_fg mem_integral_closure_iff_mem_fg\n\n",
 "map_is_integral_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_is_integral_int {B C F : Type _} [Ring B] [Ring C] {b : B} [RingHomClass F B C] (f : F)\n    (hb : is_integral ℤ b) : is_integral ℤ (f b) :=\n  map_is_integral (f : «expr →+* » B C).to_int_alg_hom hb\n#align map_is_integral_int map_is_integral_int\n\n",
 "map_is_integral":
 "theorem map_is_integral {B C F : Type _} [Ring B] [Ring C] [algebra R B] [algebra A B] [algebra R C]\n    [IsScalarTower R A B] [algebra A C] [IsScalarTower R A C] {b : B} [alg_hom_class F A B C] (f : F)\n    (hb : is_integral R b) : is_integral R (f b) :=\n  by\n  obtain ⟨P, hP⟩ := hb\n  refine' ⟨P, hP.1, _⟩\n  rw [← aeval_def, show (aeval (f b)) P = (aeval (f b)) (P.map (algebra_map R A)) by simp, aeval_alg_hom_apply,\n    aeval_map_algebra_map, aeval_def, hP.2, _root_.map_zero]\n#align map_is_integral map_is_integral\n\n",
 "leading_coeff_smul_normalize_scale_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem leading_coeff_smul_normalize_scale_roots (p : polynomial R) :\n    «expr • » p.leading_coeff (normalize_scale_roots p) = scale_roots p p.leading_coeff :=\n  by\n  ext\n  simp only [coeff_scale_roots, normalize_scale_roots, coeff_monomial, coeff_smul, finset.smul_sum, ne.def,\n    finset.sum_ite_eq', finset_sum_coeff, smul_ite, smul_zero, mem_support_iff]\n  split_ifs with h₁ h₂\n  · simp [*]\n  · simp [*]\n  · rw [algebra.id.smul_eq_mul, mul_comm, mul_assoc, ← pow_succ', tsub_right_comm, tsub_add_cancel_of_le]\n    rw [Nat.succ_le_iff]\n    exact tsub_pos_of_lt (lt_of_le_of_ne (le_nat_degree_of_ne_zero h₁) h₂)\n#align leading_coeff_smul_normalize_scale_roots leading_coeff_smul_normalize_scale_roots\n\n",
 "le_integral_closure_iff_is_integral":
 "theorem le_integral_closure_iff_is_integral {S : subalgebra R A} : S ≤ integral_closure R A ↔ algebra.is_integral R S :=\n  SetLike.forall.symm.trans\n    (forall_congr' fun x =>\n      show is_integral R (algebra_map S A x) ↔ is_integral R x from is_integral_algebra_map_iff subtype.coe_injective)\n#align le_integral_closure_iff_is_integral le_integral_closure_iff_is_integral\n\n",
 "is_noetherian_adjoin_finset":
 "theorem is_noetherian_adjoin_finset [is_noetherian_ring R] (s : Finset A) (hs : ∀ x ∈ s, is_integral R x) :\n    is_noetherian R (algebra.adjoin R (↑s : set A)) :=\n  is_noetherian_of_fg_of_noetherian _ (fg_adjoin_of_finite s.finite_to_set hs)\n#align is_noetherian_adjoin_finset is_noetherian_adjoin_finset\n\n",
 "is_integral_zero":
 "theorem is_integral_zero : is_integral R (0 : A) :=\n  (algebra_map R A).is_integral_zero\n#align is_integral_zero is_integral_zero\n\n",
 "is_integral_trans_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_integral_trans_aux (x : B) {p : polynomial A} (pmonic : monic p) (hp : aeval x p = 0) :\n    is_integral (adjoin R (↑(p.map <| algebra_map A B).frange : set B)) x :=\n  by\n  generalize hS : (↑(p.map <| algebra_map A B).frange : set B) = S\n  have coeffs_mem : ∀ i, (p.map <| algebra_map A B).coeff i ∈ adjoin R S :=\n    by\n    intro i\n    by_cases hi : (p.map <| algebra_map A B).coeff i = 0\n    · rw [hi]\n      exact subalgebra.zero_mem _\n    rw [← hS]\n    exact subset_adjoin (coeff_mem_frange _ _ hi)\n  obtain ⟨q, hq⟩ : ∃ q : polynomial (adjoin R S), q.map (algebra_map (adjoin R S) B) = (p.map <| algebra_map A B) :=\n    by\n    rw [← Set.mem_range]\n    exact (polynomial.mem_map_range _).2 fun i => ⟨⟨_, coeffs_mem i⟩, rfl⟩\n  use q\n  constructor\n  · suffices h : (q.map (algebra_map (adjoin R S) B)).monic\n    · refine' monic_of_injective _ h\n      exact subtype.val_injective\n    · rw [hq]\n      exact pmonic.map _\n  · convert hp using 1\n    replace hq := congr_arg (eval x) hq\n    convert hq using 1 <;> symm <;> apply eval_map\n#align is_integral_trans_aux is_integral_trans_aux\n\n",
 "is_integral_trans":
 "theorem ring_hom.is_integral_trans (hf : f.is_integral) (hg : g.is_integral) : (g.comp f).is_integral :=\n  @algebra.is_integral_trans R S T _ _ _ g.to_algebra (g.comp f).to_algebra f.to_algebra\n    (@is_scalar_tower.of_algebra_map_eq R S T _ _ _ f.to_algebra g.to_algebra (g.comp f).to_algebra\n      (RingHom.comp_apply g f))\n    hf hg\n#align ring_hom.is_integral_trans ring_hom.is_integral_trans\n\n",
 "is_integral_tower_top_of_is_integral":
 "/-- If `R → A → B` is an algebra tower,\nthen if the entire tower is an integral extension so is `A → B`. -/\ntheorem is_integral_tower_top_of_is_integral {x : B} (h : is_integral R x) : is_integral A x :=\n  by\n  rcases h with ⟨p, ⟨hp, hp'⟩⟩\n  refine' ⟨p.map (algebra_map R A), ⟨hp.map (algebra_map R A), _⟩⟩\n  rw [is_scalar_tower.algebra_map_eq R A B, ← eval₂_map] at hp'\n  exact hp'\n#align is_integral_tower_top_of_is_integral is_integral_tower_top_of_is_integral\n\n",
 "is_integral_tower_bot_of_is_integral_field":
 "theorem is_integral_tower_bot_of_is_integral_field {R A B : Type _} [CommRing R] [Field A] [CommRing B] [nontrivial B]\n    [algebra R A] [algebra A B] [algebra R B] [IsScalarTower R A B] {x : A} (h : is_integral R (algebra_map A B x)) :\n    is_integral R x :=\n  is_integral_tower_bot_of_is_integral (algebra_map A B).injective h\n#align is_integral_tower_bot_of_is_integral_field is_integral_tower_bot_of_is_integral_field\n\n",
 "is_integral_tower_bot_of_is_integral":
 "theorem ring_hom.is_integral_tower_bot_of_is_integral (hg : function.injective g) (hfg : (g.comp f).is_integral) :\n    f.is_integral := fun x =>\n  @is_integral_tower_bot_of_is_integral R S T _ _ _ g.to_algebra (g.comp f).to_algebra f.to_algebra\n    (@is_scalar_tower.of_algebra_map_eq R S T _ _ _ f.to_algebra g.to_algebra (g.comp f).to_algebra\n      (RingHom.comp_apply g f))\n    hg x (hfg (g x))\n#align ring_hom.is_integral_tower_bot_of_is_integral ring_hom.is_integral_tower_bot_of_is_integral\n\n",
 "is_integral_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem is_integral_sup {S T : subalgebra R A} :\n    algebra.is_integral R («expr↥ » («expr ⊔ » S T)) ↔ algebra.is_integral R S ∧ algebra.is_integral R T := by\n  simp only [← le_integral_closure_iff_is_integral, sup_le_iff]\n#align is_integral_sup is_integral_sup\n\n",
 "is_integral_sub":
 "theorem is_integral_sub {x y : A} (hx : is_integral R x) (hy : is_integral R y) : is_integral R (x - y) :=\n  (algebra_map R A).is_integral_sub hx hy\n#align is_integral_sub is_integral_sub\n\n",
 "is_integral_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_integral_smul [algebra S A] [algebra R S] [IsScalarTower R S A] {x : A} (r : R) (hx : is_integral S x) :\n    is_integral S («expr • » r x) :=\n  by\n  rw [algebra.smul_def, is_scalar_tower.algebra_map_apply R S A]\n  exact is_integral_mul is_integral_algebra_map hx\n#align is_integral_smul is_integral_smul\n\n",
 "is_integral_quotient_of_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem is_integral_quotient_of_is_integral {I : ideal A} (hRA : is_integral R A) :\n    is_integral («expr ⧸ » R (I.comap (algebra_map R A))) («expr ⧸ » A I) :=\n  (algebra_map R A).is_integral_quotient_of_is_integral hRA\n#align is_integral_quotient_of_is_integral is_integral_quotient_of_is_integral\n\n",
 "is_integral_quotient_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem is_integral_quotient_map_iff {I : ideal S} :\n    (ideal.quotient_map I f le_rfl).is_integral ↔\n      ((ideal.quotient.mk I).comp f : «expr →+* » R («expr ⧸ » S I)).is_integral :=\n  by\n  let g := ideal.quotient.mk (I.comap f)\n  have := ideal.quotient_map_comp_mk le_rfl\n  refine' ⟨fun h => _, fun h => ring_hom.is_integral_tower_top_of_is_integral g _ (this ▸ h)⟩\n  refine' this ▸ ring_hom.is_integral_trans g (ideal.quotient_map I f le_rfl) _ h\n  exact ring_hom.is_integral_of_surjective g ideal.quotient.mk_surjective\n#align is_integral_quotient_map_iff is_integral_quotient_map_iff\n\n",
 "is_integral_one":
 "theorem is_integral_one : is_integral R (1 : A) :=\n  (algebra_map R A).is_integral_one\n#align is_integral_one is_integral_one\n\n",
 "is_integral_of_surjective":
 "theorem is_integral_of_surjective (h : function.surjective (algebra_map R A)) : is_integral R A :=\n  (algebra_map R A).is_integral_of_surjective h\n#align is_integral_of_surjective is_integral_of_surjective\n\n",
 "is_integral_of_subring":
 "theorem is_integral_of_subring {x : A} (T : subring R) (hx : is_integral T x) : is_integral R x :=\n  is_integral_of_is_scalar_tower hx\n#align is_integral_of_subring is_integral_of_subring\n\n",
 "is_integral_of_submodule_noetherian":
 "theorem is_integral_of_submodule_noetherian (S : subalgebra R A) (H : is_noetherian R S.to_submodule) (x : A)\n    (hx : x ∈ S) : is_integral R x :=\n  by\n  suffices is_integral R (show S from ⟨x, hx⟩)\n    by\n    rcases this with ⟨p, hpm, hpx⟩\n    replace hpx := congr_arg S.val hpx\n    refine' ⟨p, hpm, eq.trans _ hpx⟩\n    simp only [aeval_def, eval₂, sum_def]\n    rw [S.val.map_sum]\n    refine' finset.sum_congr rfl fun n hn => _\n    rw [S.val.map_mul, S.val.map_pow, S.val.commutes, S.val_apply, subtype.coe_mk]\n  refine' is_integral_of_noetherian H ⟨x, hx⟩\n#align is_integral_of_submodule_noetherian is_integral_of_submodule_noetherian\n\n",
 "is_integral_of_smul_mem_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Suppose `A` is an `R`-algebra, `M` is an `A`-module such that `a • m ≠ 0` for all non-zero `a`\nand `m`. If `x : A` fixes a nontrivial f.g. `R`-submodule `N` of `M`, then `x` is `R`-integral. -/\ntheorem is_integral_of_smul_mem_submodule {M : Type _} [add_comm_group M] [Module R M] [Module A M]\n    [IsScalarTower R A M] [NoZeroSMulDivisors A M] (N : submodule R M) (hN : N ≠ «expr⊥») (hN' : N.fg) (x : A)\n    (hx : ∀ n ∈ N, «expr • » x n ∈ N) : is_integral R x :=\n  by\n  let A' : subalgebra R A :=\n    { carrier := { x | ∀ n ∈ N, «expr • » x n ∈ N }\n      mul_mem' := fun a b ha hb n hn => smul_smul a b n ▸ ha _ (hb _ hn)\n      one_mem' := fun n hn => (one_smul A n).symm ▸ hn\n      add_mem' := fun a b ha hb n hn => (add_smul a b n).symm ▸ N.add_mem (ha _ hn) (hb _ hn)\n      zero_mem' := fun n hn => (zero_smul A n).symm ▸ N.zero_mem\n      algebra_map_mem' := fun r n hn => (algebra_map_smul A r n).symm ▸ N.smul_mem r hn }\n  let f : «expr →ₐ[ ] » A' R (module.End R N) :=\n    alg_hom.of_linear_map\n      { to_fun := fun x => (distrib_mul_action.to_linear_map R M x).restrict x.prop\n        map_add' := fun x y => linear_map.ext fun n => subtype.ext <| add_smul x y n\n        map_smul' := fun r s => linear_map.ext fun n => subtype.ext <| smul_assoc r s n }\n      (linear_map.ext fun n => subtype.ext <| one_smul _ _) fun x y =>\n      linear_map.ext fun n => subtype.ext <| mul_smul x y n\n  obtain ⟨a, ha₁, ha₂⟩ : ∃ a ∈ N, a ≠ (0 : M) := by\n    by_contra h'\n    push_neg  at h'\n    apply hN\n    rwa [eq_bot_iff]\n  have : function.injective f := by\n    show function.injective f.to_linear_map\n    rw [← linear_map.ker_eq_bot, eq_bot_iff]\n    intro s hs\n    have : «expr • » s.1 a = 0 := congr_arg subtype.val (linear_map.congr_fun hs ⟨a, ha₁⟩)\n    exact subtype.ext ((eq_zero_or_eq_zero_of_smul_eq_zero this).resolve_right ha₂)\n  show is_integral R (A'.val ⟨x, hx⟩)\n  rw [is_integral_alg_hom_iff A'.val subtype.val_injective, ← is_integral_alg_hom_iff f this]\n  haveI : module.finite R N := by rwa [module.finite_def, submodule.fg_top]\n  apply module.End.is_integral\n#align is_integral_of_smul_mem_submodule is_integral_of_smul_mem_submodule\n\n",
 "is_integral_of_pow":
 "theorem is_integral_of_pow {x : A} {n : ℕ} (hn : 0 < n) (hx : is_integral R <| x ^ n) : is_integral R x :=\n  by\n  rcases hx with ⟨p, ⟨hmonic, heval⟩⟩\n  exact ⟨expand R n p, monic.expand hn hmonic, by rwa [eval₂_eq_eval_map, map_expand, expand_eval, ← eval₂_eq_eval_map]⟩\n#align is_integral_of_pow is_integral_of_pow\n\n",
 "is_integral_of_noetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_integral_of_noetherian (H : is_noetherian R A) (x : A) : is_integral R x :=\n  by\n  let leval : «expr →ₗ[ ] » (polynomial R) R A := (aeval x).to_linear_map\n  let D : ℕ → submodule R A := fun n => (degree_le R n).map leval\n  let M := WellFounded.min (is_noetherian_iff_well_founded.1 H) (Set.range D) ⟨_, ⟨0, rfl⟩⟩\n  have HM : M ∈ Set.range D := WellFounded.min_mem _ _ _\n  cases' HM with N HN\n  have HM : ¬M < D (N + 1) := WellFounded.not_lt_min (is_noetherian_iff_well_founded.1 H) (Set.range D) _ ⟨N + 1, rfl⟩\n  rw [← HN] at HM\n  have HN2 : D (N + 1) ≤ D N :=\n    by_contradiction fun H => HM (lt_of_le_not_le (map_mono (degree_le_mono (WithBot.coe_le_coe.2 (nat.le_succ N)))) H)\n  have HN3 : leval (X ^ (N + 1)) ∈ D N := HN2 (mem_map_of_mem (mem_degree_le.2 (degree_X_pow_le _)))\n  rcases HN3 with ⟨p, hdp, hpe⟩\n  refine' ⟨X ^ (N + 1) - p, monic_X_pow_sub (mem_degree_le.1 hdp), _⟩\n  show leval (X ^ (N + 1) - p) = 0\n  rw [linear_map.map_sub, hpe, sub_self]\n#align is_integral_of_noetherian is_integral_of_noetherian\n\n",
 "is_integral_of_mem_of_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `S` is a sub-`R`-algebra of `A` and `S` is finitely-generated as an `R`-module,\n  then all elements of `S` are integral over `R`. -/\ntheorem is_integral_of_mem_of_fg (S : subalgebra R A) (HS : S.to_submodule.fg) (x : A) (hx : x ∈ S) : is_integral R x :=\n  by\n  -- say `x ∈ S`. We want to prove that `x` is integral over `R`.\n  -- Say `S` is generated as an `R`-module by the set `y`.\n  cases' HS with y hy\n  -- We can write `x` as `∑ rᵢ yᵢ` for `yᵢ ∈ Y`.\n  obtain ⟨lx, hlx1, hlx2⟩ : ∃ (l : «expr →₀ » A R)(H : l ∈ finsupp.supported R R ↑y), (finsupp.total A A R id) l = x :=\n    by rwa [← @finsupp.mem_span_image_iff_total A A R _ _ _ id (↑y) x, Set.image_id ↑y, hy]\n  -- Note that `y ⊆ S`.\n  have hyS : ∀ {p}, p ∈ y → p ∈ S := fun p hp =>\n    show p ∈ S.to_submodule by\n      rw [← hy]\n      exact subset_span hp\n  -- Now `S` is a subalgebra so the product of two elements of `y` is also in `S`.\n  have : ∀ jk : (↑(finset.product y y) : set (A × A)), jk.1.1 * jk.1.2 ∈ S.to_submodule := fun jk =>\n    S.mul_mem (hyS (finset.mem_product.1 jk.2).1) (hyS (finset.mem_product.1 jk.2).2)\n  rw [← hy, ← Set.image_id ↑y] at this\n  simp only [finsupp.mem_span_image_iff_total] at this\n  -- Say `yᵢyⱼ = ∑rᵢⱼₖ yₖ`\n  choose ly hly1 hly2\n  -- Now let `S₀` be the subring of `R` generated by the `rᵢ` and the `rᵢⱼₖ`.\n  let S₀ : subring R := subring.closure ↑(lx.frange ∪ Finset.bunionᵢ finset.univ (finsupp.frange ∘ ly))\n  -- It suffices to prove that `x` is integral over `S₀`.\n  refine' is_integral_of_subring S₀ _\n  letI : CommRing S₀ := subring_class.to_comm_ring S₀\n  letI : algebra S₀ A := algebra.of_subring S₀\n  -- Claim: the `S₀`-module span (in `A`) of the set `y ∪ {1}` is closed under\n  -- multiplication (indeed, this is the motivation for the definition of `S₀`).\n  have : span S₀ (insert 1 ↑y : set A) * span S₀ (insert 1 ↑y : set A) ≤ span S₀ (insert 1 ↑y : set A) :=\n    by\n    rw [span_mul_span]\n    refine' span_le.2 fun z hz => _\n    rcases Set.mem_mul.1 hz with ⟨p, q, rfl | hp, hq, rfl⟩\n    · rw [one_mul]\n      exact subset_span hq\n    rcases hq with (rfl | hq)\n    · rw [mul_one]\n      exact subset_span (or.inr hp)\n    erw [← hly2 ⟨(p, q), finset.mem_product.2 ⟨hp, hq⟩⟩]\n    rw [finsupp.total_apply, finsupp.sum]\n    refine' (span S₀ (insert 1 ↑y : set A)).sum_mem fun t ht => _\n    have : ly ⟨(p, q), finset.mem_product.2 ⟨hp, hq⟩⟩ t ∈ S₀ :=\n      subring.subset_closure\n        (Finset.mem_union_right _ <|\n          Finset.mem_bunionᵢ.2\n            ⟨⟨(p, q), finset.mem_product.2 ⟨hp, hq⟩⟩, finset.mem_univ _,\n              finsupp.mem_frange.2 ⟨finsupp.mem_support_iff.1 ht, _, rfl⟩⟩)\n    change «expr • » (⟨_, this⟩ : S₀) t ∈ _\n    exact smul_mem _ _ (subset_span <| or.inr <| hly1 _ ht)\n  -- Hence this span is a subring. Call this subring `S₁`.\n  let S₁ : subring A :=\n    { carrier := span S₀ (insert 1 ↑y : set A)\n      one_mem' := subset_span <| or.inl rfl\n      mul_mem' := fun p q hp hq => this <| mul_mem_mul hp hq\n      zero_mem' := (span S₀ (insert 1 ↑y : set A)).zero_mem\n      add_mem' := fun _ _ => (span S₀ (insert 1 ↑y : set A)).add_mem\n      neg_mem' := fun _ => (span S₀ (insert 1 ↑y : set A)).neg_mem }\n  have : S₁ = subalgebra.to_subring (algebra.adjoin S₀ (↑y : set A)) :=\n    by\n    ext z\n    suffices z ∈ span («expr↥ » S₀) (insert 1 ↑y : set A) ↔ z ∈ (algebra.adjoin («expr↥ » S₀) (y : set A)).to_submodule\n      by simpa\n    constructor <;> intro hz\n    · exact (span_le.2 (Set.insert_subset.2 ⟨(algebra.adjoin S₀ ↑y).one_mem, algebra.subset_adjoin⟩)) hz\n    · rw [subalgebra.mem_to_submodule, algebra.mem_adjoin_iff] at hz\n      suffices subring.closure (Set.range («expr⇑ » (algebra_map («expr↥ » S₀) A)) ∪ ↑y) ≤ S₁ by exact this hz\n      refine' subring.closure_le.2 (Set.union_subset _ fun t ht => subset_span <| or.inr ht)\n      rw [Set.range_subset_iff]\n      intro y\n      rw [algebra.algebra_map_eq_smul_one]\n      exact smul_mem _ y (subset_span (or.inl rfl))\n  have foo : ∀ z, z ∈ S₁ ↔ z ∈ algebra.adjoin («expr↥ » S₀) (y : set A)\n  simp [this]\n  haveI : is_noetherian_ring («expr↥ » S₀) := is_noetherian_subring_closure _ (finset.finite_to_set _)\n  refine'\n    is_integral_of_submodule_noetherian (algebra.adjoin S₀ ↑y)\n      (is_noetherian_of_fg_of_noetherian _\n        ⟨insert 1 y, by\n          rw [Finset.coe_insert]\n          ext z\n          simp [S₁]\n          convert foo z⟩)\n      _ _\n  rw [← hlx2, finsupp.total_apply, finsupp.sum]\n  refine' subalgebra.sum_mem _ fun r hr => _\n  have : lx r ∈ S₀ := subring.subset_closure (Finset.mem_union_left _ (Finset.mem_image_of_mem _ hr))\n  change «expr • » (⟨_, this⟩ : S₀) r ∈ _\n  rw [finsupp.mem_supported] at hlx1\n  exact subalgebra.smul_mem _ (algebra.subset_adjoin <| hlx1 hr) _\n#align is_integral_of_mem_of_fg is_integral_of_mem_of_fg\n\n",
 "is_integral_of_mem_closure''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_integral_of_mem_closure'' {S : Type _} [CommRing S] {f : «expr →+* » R S} (G : set S)\n    (hG : ∀ x ∈ G, f.is_integral_elem x) : ∀ x ∈ subring.closure G, f.is_integral_elem x := fun x hx =>\n  @is_integral_of_mem_closure' R S _ _ f.to_algebra G hG x hx\n#align is_integral_of_mem_closure'' is_integral_of_mem_closure''\n\n",
 "is_integral_of_mem_closure'":
 "/-- Generalization of `is_integral_of_mem_closure` bootstrapped up from that lemma -/\ntheorem is_integral_of_mem_closure' (G : set A) (hG : ∀ x ∈ G, is_integral R x) :\n    ∀ x ∈ subring.closure G, is_integral R x := fun x hx =>\n  subring.closure_induction hx hG is_integral_zero is_integral_one (fun _ _ => is_integral_add)\n    (fun _ => is_integral_neg) fun _ _ => is_integral_mul\n#align is_integral_of_mem_closure' is_integral_of_mem_closure'\n\n",
 "is_integral_of_mem_closure":
 "theorem is_integral_of_mem_closure {x y z : A} (hx : is_integral R x) (hy : is_integral R y)\n    (hz : z ∈ subring.closure ({x, y} : set A)) : is_integral R z :=\n  (algebra_map R A).is_integral_of_mem_closure hx hy hz\n#align is_integral_of_mem_closure is_integral_of_mem_closure\n\n",
 "is_integral_of_is_scalar_tower":
 "theorem is_integral_of_is_scalar_tower [algebra A B] [IsScalarTower R A B] {x : B} (hx : is_integral R x) :\n    is_integral A x :=\n  let ⟨p, hp, hpx⟩ := hx\n  ⟨p.map <| algebra_map R A, hp.map _, by rw [← aeval_def, aeval_map_algebra_map, aeval_def, hpx]⟩\n#align is_integral_of_is_scalar_tower is_integral_of_is_scalar_tower\n\n",
 "is_integral_of_is_integral_mul_unit":
 "theorem is_integral_of_is_integral_mul_unit {x y : A} {r : R} (hr : algebra_map R A r * y = 1)\n    (hx : is_integral R (x * y)) : is_integral R x :=\n  (algebra_map R A).is_integral_of_is_integral_mul_unit x y r hr hx\n#align is_integral_of_is_integral_mul_unit is_integral_of_is_integral_mul_unit\n\n",
 "is_integral_neg":
 "theorem is_integral_neg {x : A} (hx : is_integral R x) : is_integral R (-x) :=\n  (algebra_map R A).is_integral_neg hx\n#align is_integral_neg is_integral_neg\n\n",
 "is_integral_mul":
 "theorem is_integral_mul {x y : A} (hx : is_integral R x) (hy : is_integral R y) : is_integral R (x * y) :=\n  (algebra_map R A).is_integral_mul hx hy\n#align is_integral_mul is_integral_mul\n\n",
 "is_integral_map_of_comp_eq_of_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_integral_map_of_comp_eq_of_is_integral {R S T U : Type _} [CommRing R] [CommRing S] [CommRing T] [CommRing U]\n    [algebra R S] [algebra T U] (φ : «expr →+* » R T) (ψ : «expr →+* » S U)\n    (h : (algebra_map T U).comp φ = ψ.comp (algebra_map R S)) {a : S} (ha : is_integral R a) : is_integral T (ψ a) :=\n  by\n  rw [is_integral, ring_hom.is_integral_elem] at ha⊢\n  obtain ⟨p, hp⟩ := ha\n  refine' ⟨p.map φ, hp.left.map _, _⟩\n  rw [← eval_map, map_map, h, ← map_map, eval_map, eval₂_at_apply, eval_map, hp.right, RingHom.map_zero]\n#align is_integral_map_of_comp_eq_of_is_integral is_integral_map_of_comp_eq_of_is_integral\n\n",
 "is_integral_map":
 "/-\nCopyright (c) 2019 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem ring_hom.is_integral_map {x : R} : f.is_integral_elem (f x) :=\n  ⟨X - C x, monic_X_sub_C _, by simp⟩\n#align ring_hom.is_integral_map ring_hom.is_integral_map\n\n",
 "is_integral_leading_coeff_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Given a `p : R[X]` and a root `x : S`,\nthen `p.leading_coeff • x : S` is integral over `R`. -/\ntheorem is_integral_leading_coeff_smul [algebra R S] (h : aeval x p = 0) :\n    is_integral R («expr • » p.leading_coeff x) :=\n  by\n  rw [aeval_def] at h\n  rw [algebra.smul_def]\n  exact (algebra_map R S).is_integral_elem_leading_coeff_mul p x h\n#align is_integral_leading_coeff_smul is_integral_leading_coeff_smul\n\n",
 "is_integral_iff_is_integral_closure_finite":
 "theorem is_integral_iff_is_integral_closure_finite {r : A} :\n    is_integral R r ↔ ∃ s : set R, s.finite ∧ is_integral (subring.closure s) r :=\n  by\n  constructor <;> intro hr\n  · rcases hr with ⟨p, hmp, hpr⟩\n    refine' ⟨_, finset.finite_to_set _, p.restriction, monic_restriction.2 hmp, _⟩\n    rw [← aeval_def, ← aeval_map_algebra_map R r p.restriction, map_restriction, aeval_def, hpr]\n  rcases hr with ⟨s, hs, hsr⟩\n  exact is_integral_of_subring _ hsr\n#align is_integral_iff_is_integral_closure_finite is_integral_iff_is_integral_closure_finite\n\n",
 "is_integral_elem_of_is_integral_elem_comp":
 "theorem ring_hom.is_integral_elem_of_is_integral_elem_comp {x : T} (h : (g.comp f).is_integral_elem x) :\n    g.is_integral_elem x :=\n  let ⟨p, ⟨hp, hp'⟩⟩ := h\n  ⟨p.map f, hp.map f, by rwa [← eval₂_map] at hp'⟩\n#align ring_hom.is_integral_elem_of_is_integral_elem_comp ring_hom.is_integral_elem_of_is_integral_elem_comp\n\n",
 "is_integral_elem_leading_coeff_mul":
 "/-- Given a `p : R[X]` and a `x : S` such that `p.eval₂ f x = 0`,\n`f p.leading_coeff * x` is integral. -/\ntheorem ring_hom.is_integral_elem_leading_coeff_mul (h : p.eval₂ f x = 0) :\n    f.is_integral_elem (f p.leading_coeff * x) :=\n  by\n  by_cases h' : 1 ≤ p.nat_degree\n  · use normalize_scale_roots p\n    have : p ≠ 0 := fun h'' => by\n      rw [h'', nat_degree_zero] at h'\n      exact nat.not_succ_le_zero 0 h'\n    use normalize_scale_roots_monic p this\n    rw [normalize_scale_roots_eval₂_leading_coeff_mul p h' f x, h, mul_zero]\n  · by_cases hp : p.map f = 0\n    · apply_fun fun q => coeff q p.nat_degree  at hp\n      rw [coeff_map, coeff_zero, coeff_nat_degree] at hp\n      rw [hp, zero_mul]\n      exact f.is_integral_zero\n    · rw [Nat.one_le_iff_ne_zero, not_not] at h'\n      rw [eq_C_of_nat_degree_eq_zero h', eval₂_C] at h\n      suffices p.map f = 0 by exact (hp this).rec _\n      rw [eq_C_of_nat_degree_eq_zero h', map_C, h, C_eq_zero]\n#align ring_hom.is_integral_elem_leading_coeff_mul ring_hom.is_integral_elem_leading_coeff_mul\n\n",
 "is_integral_algebra_map_iff":
 "theorem is_integral_algebra_map_iff [algebra A B] [IsScalarTower R A B] {x : A}\n    (hAB : function.injective (algebra_map A B)) : is_integral R (algebra_map A B x) ↔ is_integral R x :=\n  is_integral_alg_hom_iff (is_scalar_tower.to_alg_hom R A B) hAB\n#align is_integral_algebra_map_iff is_integral_algebra_map_iff\n\n",
 "is_integral_algebra_map":
 "theorem is_integral_algebra_map {x : R} : is_integral R (algebra_map R A x) :=\n  (algebra_map R A).is_integral_map\n#align is_integral_algebra_map is_integral_algebra_map\n\n",
 "is_integral_algebra":
 "theorem is_integral_algebra [algebra R A] [IsScalarTower R A B] : algebra.is_integral R A := fun x =>\n  is_integral_closure.is_integral R B x\n#align is_integral_algebra is_integral_algebra\n\n",
 "is_integral_alg_hom_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem is_integral_alg_hom_iff {A B : Type _} [Ring A] [Ring B] [algebra R A] [algebra R B] (f : «expr →ₐ[ ] » A R B)\n    (hf : function.injective f) {x : A} : is_integral R (f x) ↔ is_integral R x :=\n  by\n  refine' ⟨_, map_is_integral f⟩\n  rintro ⟨p, hp, hx⟩\n  use p, hp\n  rwa [← f.comp_algebra_map, ← alg_hom.coe_to_ring_hom, ← polynomial.hom_eval₂, alg_hom.coe_to_ring_hom,\n    map_eq_zero_iff f hf] at hx\n#align is_integral_alg_hom_iff is_integral_alg_hom_iff\n\n",
 "is_integral_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem is_integral_alg_equiv {A B : Type _} [Ring A] [Ring B] [algebra R A] [algebra R B] (f : «expr ≃ₐ[ ] » A R B)\n    {x : A} : is_integral R (f x) ↔ is_integral R x :=\n  ⟨fun h => by simpa using map_is_integral f.symm.to_alg_hom h, map_is_integral f.to_alg_hom⟩\n#align is_integral_alg_equiv is_integral_alg_equiv\n\n",
 "is_integral_add":
 "theorem is_integral_add {x y : A} (hx : is_integral R x) (hy : is_integral R y) : is_integral R (x + y) :=\n  (algebra_map R A).is_integral_add hx hy\n#align is_integral_add is_integral_add\n\n",
 "is_integral":
 "protected theorem is_integral [algebra R A] [IsScalarTower R A B] (x : A) : is_integral R x :=\n  (is_integral_algebra_map_iff (algebra_map_injective A R B)).mp <|\n    show is_integral R (algebra_map A B x) from is_integral_iff.mpr ⟨x, rfl⟩\n#align is_integral is_integral\n\n",
 "is_field_of_is_integral_of_is_field'":
 "theorem is_field_of_is_integral_of_is_field' {R S : Type _} [CommRing R] [CommRing S] [IsDomain S] [algebra R S]\n    (H : algebra.is_integral R S) (hR : IsField R) : IsField S :=\n  by\n  letI := hR.to_field\n  refine' ⟨⟨0, 1, zero_ne_one⟩, mul_comm, fun x hx => _⟩\n  let A := algebra.adjoin R ({x} : set S)\n  haveI : is_noetherian R A :=\n    is_noetherian_of_fg_of_noetherian A.to_submodule (fg_adjoin_singleton_of_integral x (H x))\n  haveI : module.finite R A := module.is_noetherian.finite R A\n  obtain ⟨y, hy⟩ :=\n    linear_map.surjective_of_injective\n      (@linear_map.mul_left_injective R A _ _ _ _ ⟨x, subset_adjoin (Set.mem_singleton x)⟩ fun h =>\n        hx (subtype.ext_iff.mp h))\n      1\n  exact ⟨y, subtype.ext_iff.mp hy⟩\n#align is_field_of_is_integral_of_is_field' is_field_of_is_integral_of_is_field'\n\n",
 "is_field_of_is_integral_of_is_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If the integral extension `R → S` is injective, and `S` is a field, then `R` is also a field. -/\ntheorem is_field_of_is_integral_of_is_field {R S : Type _} [CommRing R] [nontrivial R] [CommRing S] [IsDomain S]\n    [algebra R S] (H : is_integral R S) (hRS : function.injective (algebra_map R S)) (hS : IsField S) : IsField R :=\n  by\n  refine' ⟨⟨0, 1, zero_ne_one⟩, mul_comm, fun a ha => _⟩\n  -- Let `a_inv` be the inverse of `algebra_map R S a`,\n  -- then we need to show that `a_inv` is of the form `algebra_map R S b`.\n  obtain ⟨a_inv, ha_inv⟩ := hS.mul_inv_cancel fun h => ha (hRS (trans h (RingHom.map_zero _).symm))\n  -- Let `p : R[X]` be monic with root `a_inv`,\n  -- and `q` be `p` with coefficients reversed (so `q(a) = q'(a) * a + 1`).\n  -- We claim that `q(a) = 0`, so `-q'(a)` is the inverse of `a`.\n  obtain ⟨p, p_monic, hp⟩ := H a_inv\n  use\n    -finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range p.nat_degree) (p.coeff i * a ^ (p.nat_degree - i - 1))\n  -- `q(a) = 0`, because multiplying everything with `a_inv^n` gives `p(a_inv) = 0`.\n  -- TODO: this could be a lemma for `polynomial.reverse`.\n  have hq :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (p.nat_degree + 1)) (p.coeff i * a ^ (p.nat_degree - i)) =\n      0 :=\n    by\n    apply (injective_iff_map_eq_zero (algebra_map R S)).mp hRS\n    have a_inv_ne_zero : a_inv ≠ 0 := right_ne_zero_of_mul (mt ha_inv.symm.trans one_ne_zero)\n    refine' (mul_eq_zero.mp _).resolve_right (pow_ne_zero p.nat_degree a_inv_ne_zero)\n    rw [eval₂_eq_sum_range] at hp\n    rw [ring_hom.map_sum, finset.sum_mul]\n    refine' (finset.sum_congr rfl fun i hi => _).trans hp\n    rw [RingHom.map_mul, mul_assoc]\n    congr\n    have : a_inv ^ p.nat_degree = a_inv ^ (p.nat_degree - i) * a_inv ^ i := by\n      rw [← pow_add a_inv, tsub_add_cancel_of_le (nat.le_of_lt_succ (finset.mem_range.mp hi))]\n    rw [RingHom.map_pow, this, ← mul_assoc, ← mul_pow, ha_inv, one_pow, one_mul]\n  -- Since `q(a) = 0` and `q(a) = q'(a) * a + 1`, we have `a * -q'(a) = 1`.\n  -- TODO: we could use a lemma for `polynomial.div_X` here.\n  rw [finset.sum_range_succ_comm, p_monic.coeff_nat_degree, one_mul, tsub_self, pow_zero, add_eq_zero_iff_eq_neg,\n    eq_comm] at hq\n  rw [mul_comm, neg_mul, finset.sum_mul]\n  convert hq using 2\n  refine' finset.sum_congr rfl fun i hi => _\n  have : 1 ≤ p.nat_degree - i := le_tsub_of_add_le_left (finset.mem_range.mp hi)\n  rw [mul_assoc, ← pow_succ', tsub_add_cancel_of_le this]\n#align is_field_of_is_integral_of_is_field is_field_of_is_integral_of_is_field\n\n",
 "is_field_iff_is_field":
 "theorem algebra.is_integral.is_field_iff_is_field {R S : Type _} [CommRing R] [nontrivial R] [CommRing S] [IsDomain S]\n    [algebra R S] (H : algebra.is_integral R S) (hRS : function.injective (algebra_map R S)) : IsField R ↔ IsField S :=\n  ⟨is_field_of_is_integral_of_is_field' H, is_field_of_is_integral_of_is_field H hRS⟩\n#align algebra.is_integral.is_field_iff_is_field algebra.is_integral.is_field_iff_is_field\n\n",
 "integral_closure_map_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- Mapping an integral closure along an `alg_equiv` gives the integral closure. -/\ntheorem integral_closure_map_alg_equiv (f : «expr ≃ₐ[ ] » A R B) :\n    (integral_closure R A).map (f : «expr →ₐ[ ] » A R B) = integral_closure R B :=\n  by\n  ext y\n  rw [subalgebra.mem_map]\n  constructor\n  · rintro ⟨x, hx, rfl⟩\n    exact map_is_integral f hx\n  · intro hy\n    use f.symm y, map_is_integral (f.symm : «expr →ₐ[ ] » B R A) hy\n    simp\n#align integral_closure_map_alg_equiv integral_closure_map_alg_equiv\n\n",
 "integral_closure_idem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem integral_closure_idem {R : Type _} {A : Type _} [CommRing R] [CommRing A] [algebra R A] :\n    integral_closure (integral_closure R A : set A) A = «expr⊥» :=\n  eq_bot_iff.2 fun x hx =>\n    algebra.mem_bot.2\n      ⟨⟨x, @is_integral_trans _ _ _ _ _ _ _ _ (integral_closure R A).algebra _ integral_closure.is_integral x hx⟩, rfl⟩\n#align integral_closure_idem integral_closure_idem\n\n",
 "finite_iff_is_integral_and_finite_type":
 "/-- finite = integral + finite type -/\ntheorem algebra.finite_iff_is_integral_and_finite_type :\n    module.finite R A ↔ algebra.is_integral R A ∧ algebra.finite_type R A :=\n  ⟨fun h => ⟨algebra.is_integral.of_finite, infer_instance⟩, fun ⟨h, h'⟩ => h.finite⟩\n#align algebra.finite_iff_is_integral_and_finite_type algebra.finite_iff_is_integral_and_finite_type\n\n",
 "finite":
 "theorem algebra.is_integral.finite (h : algebra.is_integral R A) [h' : algebra.finite_type R A] : module.finite R A :=\n  by\n  have :=\n    h.to_finite\n      (by\n        delta ring_hom.finite_type\n        convert h'\n        ext\n        exact (algebra.smul_def _ _).symm)\n  delta ring_hom.finite at this; convert this; ext; exact algebra.smul_def _ _\n#align algebra.is_integral.finite algebra.is_integral.finite\n\n",
 "fg_adjoin_singleton_of_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem fg_adjoin_singleton_of_integral (x : A) (hx : is_integral R x) :\n    (algebra.adjoin R ({x} : set A)).to_submodule.fg :=\n  by\n  rcases hx with ⟨f, hfm, hfx⟩\n  exists Finset.image ((· ^ ·) x) (Finset.range (nat_degree f + 1))\n  apply le_antisymm\n  · rw [span_le]\n    intro s hs\n    rw [Finset.mem_coe] at hs\n    rcases Finset.mem_image.1 hs with ⟨k, hk, rfl⟩\n    clear hk\n    exact (algebra.adjoin R {x}).pow_mem (algebra.subset_adjoin (Set.mem_singleton _)) k\n  intro r hr; change r ∈ algebra.adjoin R ({x} : set A) at hr\n  rw [algebra.adjoin_singleton_eq_range_aeval] at hr\n  rcases(aeval x).mem_range.mp hr with ⟨p, rfl⟩\n  rw [← mod_by_monic_add_div p hfm]\n  rw [← aeval_def] at hfx\n  rw [alg_hom.map_add, alg_hom.map_mul, hfx, zero_mul, add_zero]\n  have : degree («expr %ₘ » p f) ≤ degree f := degree_mod_by_monic_le p hfm\n  generalize «expr %ₘ » p f = q at this⊢\n  rw [← sum_C_mul_X_pow_eq q, aeval_def, eval₂_sum, sum_def]\n  refine' sum_mem fun k hkq => _\n  rw [eval₂_mul, eval₂_C, eval₂_pow, eval₂_X, ← algebra.smul_def]\n  refine' smul_mem _ _ (subset_span _)\n  rw [Finset.mem_coe]; refine' Finset.mem_image.2 ⟨_, _, rfl⟩\n  rw [Finset.mem_range, Nat.lt_succ_iff]; refine' le_of_not_lt fun hk => _\n  rw [degree_le_iff_coeff_zero] at this\n  rw [mem_support_iff] at hkq; apply hkq; apply this\n  exact lt_of_le_of_lt degree_le_nat_degree (WithBot.coe_lt_coe.2 hk)\n#align fg_adjoin_singleton_of_integral fg_adjoin_singleton_of_integral\n\n",
 "fg_adjoin_of_finite":
 "theorem fg_adjoin_of_finite {s : set A} (hfs : s.finite) (his : ∀ x ∈ s, is_integral R x) :\n    (algebra.adjoin R s).to_submodule.fg :=\n  set.finite.induction_on hfs\n    (fun _ =>\n      ⟨{1},\n        submodule.ext fun x =>\n          by\n          erw [algebra.adjoin_empty, Finset.coe_singleton, ← one_eq_span, one_eq_range, linear_map.mem_range,\n            algebra.mem_bot]\n          rfl⟩)\n    (fun a s has hs ih his => by\n      rw [← Set.union_singleton, algebra.adjoin_union_coe_submodule] <;>\n        exact\n          fg.mul (ih fun i hi => his i <| Set.mem_insert_of_mem a hi)\n            (fg_adjoin_singleton_of_integral _ <| his a <| Set.mem_insert a s))\n    his\n#align fg_adjoin_of_finite fg_adjoin_of_finite\n\n",
 "det":
 "theorem is_integral.det {n : Type _} [fintype n] [decidable_eq n] {M : matrix n n A}\n    (h : ∀ i j, is_integral R (M i j)) : is_integral R M.det :=\n  by\n  rw [matrix.det_apply]\n  exact is_integral.sum _ fun σ hσ => is_integral.zsmul (is_integral.prod _ fun i hi => h _ _) _\n#align is_integral.det is_integral.det\n\n",
 "algebra_map_mk'":
 "@[simp]\ntheorem algebra_map_mk' (x : B) (hx : is_integral R x) : algebra_map A B (mk' A x hx) = x :=\n  Classical.choose_spec (is_integral_iff.mp hx)\n#align algebra_map_mk' algebra_map_mk'\n\n",
 "algebra_map_lift":
 "@[simp]\ntheorem algebra_map_lift (x : S) : algebra_map A B (lift A B h x) = algebra_map S B x :=\n  algebra_map_mk' _ _ _\n#align algebra_map_lift algebra_map_lift\n\n",
 "algebra_map_equiv":
 "@[simp]\ntheorem algebra_map_equiv (x : A) : algebra_map A' B (equiv R A B A' x) = algebra_map A B x :=\n  algebra_map_lift _ _ _ _\n#align algebra_map_equiv algebra_map_equiv\n\n",
 "algebra_map":
 "theorem is_integral.algebra_map [algebra A B] [IsScalarTower R A B] {x : A} (h : is_integral R x) :\n    is_integral R (algebra_map A B x) := by\n  rcases h with ⟨f, hf, hx⟩\n  use f, hf\n  rw [is_scalar_tower.algebra_map_eq R A B, ← hom_eval₂, hx, RingHom.map_zero]\n#align is_integral.algebra_map is_integral.algebra_map\n\n",
 "adjoin_le_integral_closure":
 "theorem adjoin_le_integral_closure {x : A} (hx : is_integral R x) : algebra.adjoin R {x} ≤ integral_closure R A :=\n  by\n  rw [algebra.adjoin_le_iff]\n  simp only [SetLike.mem_coe, Set.singleton_subset_iff]\n  exact hx\n#align adjoin_le_integral_closure adjoin_le_integral_closure\n\n"}