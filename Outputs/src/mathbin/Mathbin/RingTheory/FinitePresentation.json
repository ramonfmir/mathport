{"trans":
 "#print trans /-\n/-- If `A` is an `R`-algebra and `S` is an `A`-algebra, both finitely presented, then `S` is\n  finitely presented as `R`-algebra. -/\ntheorem trans [algebra A B] [IsScalarTower R A B] (hfpA : finite_presentation R A) (hfpB : finite_presentation A B) :\n    finite_presentation R B := by\n  obtain ⟨n, I, e, hfg⟩ := iff.1 hfpB\n  exact equiv ((mv_polynomial_of_finite_presentation hfpA _).quotient hfg) (e.restrict_scalars R)\n#align trans trans\n-/\n\n",
 "self":
 "/-- `R` is finitely presented as `R`-algebra. -/\ntheorem self : finite_presentation R R :=\n  equiv (finite_presentation.mv_polynomial R PEmpty) (mv_polynomial.is_empty_alg_equiv R PEmpty)\n#align self self\n\n",
 "quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\nprotected theorem quotient {I : ideal A} (h : I.fg) (hfp : finite_presentation R A) :\n    finite_presentation R («expr ⧸ » A I) := by\n  obtain ⟨n, f, hf⟩ := hfp\n  refine' ⟨n, (ideal.quotient.mkₐ R I).comp f, _, _⟩\n  · exact (ideal.quotient.mkₐ_surjective R I).comp hf.1\n  · refine' ideal.fg_ker_comp _ _ hf.2 _ hf.1\n    simp [h]\n#align quotient quotient\n\n",
 "polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- `R[X]` is finitely presented as `R`-algebra. -/\ntheorem polynomial : finite_presentation R (polynomial R) :=\n  equiv (finite_presentation.mv_polynomial R PUnit) (mv_polynomial.punit_alg_equiv R)\n#align polynomial polynomial\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_surjective (f : «expr →ₐ[ ] » A R B) (hf : surjective f) (hker : f.to_ring_hom.ker.fg) :\n    f.finite_presentation :=\n  ring_hom.finite_presentation.of_surjective f hf hker\n#align of_surjective of_surjective\n\n",
 "of_restrict_scalars_finite_presentation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- We follow the proof of https://stacks.math.columbia.edu/tag/0561\n-- TODO: extract out helper lemmas and tidy proof.\ntheorem of_restrict_scalars_finite_presentation [algebra A B] [IsScalarTower R A B] (hRB : finite_presentation R B)\n    [hRA : finite_type R A] : finite_presentation A B := by\n  classical\n    obtain ⟨n, f, hf, s, hs⟩ := hRB\n    let RX := mv_polynomial (fin n) R\n    let AX := mv_polynomial (fin n) A\n    refine' ⟨n, mv_polynomial.aeval (f ∘ X), _, _⟩\n    · rw [← algebra.range_top_iff_surjective, ← algebra.adjoin_range_eq_range_aeval, Set.range_comp, _root_.eq_top_iff,\n        ← @adjoin_adjoin_of_tower R A B, adjoin_image, adjoin_range_X, algebra.map_top,\n        (algebra.range_top_iff_surjective _).mpr hf]\n      exact subset_adjoin\n    · obtain ⟨t, ht⟩ := hRA.out\n      have := fun i : t => hf (algebra_map A B i)\n      choose t' ht'\n      have ht'' : algebra.adjoin R («expr '' » (algebra_map A AX) t ∪ Set.range (X : _ → AX)) = «expr⊤» :=\n        by\n        rw [adjoin_union_eq_adjoin_adjoin, ← subalgebra.restrict_scalars_top R]\n        congr 1\n        swap\n        · exact subalgebra.is_scalar_tower_mid _\n        rw [adjoin_algebra_map, ht]\n        apply subalgebra.restrict_scalars_injective R\n        rw [← adjoin_restrict_scalars, adjoin_range_X, subalgebra.restrict_scalars_top, subalgebra.restrict_scalars_top]\n      let g : t → AX := fun x => C (x : A) - map (algebra_map R A) (t' x)\n      refine' ⟨s.image (map (algebra_map R A)) ∪ t.attach.image g, _⟩\n      rw [Finset.coe_union, Finset.coe_image, Finset.coe_image, finset.attach_eq_univ, finset.coe_univ, Set.image_univ]\n      let s₀ := _\n      let I := _\n      change ideal.span s₀ = I\n      have leI : ideal.span s₀ ≤ I := by\n        rw [ideal.span_le]\n        rintro _ (⟨x, hx, rfl⟩ | ⟨⟨x, hx⟩, rfl⟩)\n        all_goals dsimp [g]; rw [ring_hom.mem_ker, alg_hom.to_ring_hom_eq_coe, alg_hom.coe_to_ring_hom]\n        · rw [mv_polynomial.aeval_map_algebra_map, ← aeval_unique]\n          have := ideal.subset_span hx\n          rwa [hs] at this\n        · rw [map_sub, mv_polynomial.aeval_map_algebra_map, ← aeval_unique, aeval_C, ht', subtype.coe_mk, sub_self]\n      apply leI.antisymm\n      intro x hx\n      rw [ring_hom.mem_ker, alg_hom.to_ring_hom_eq_coe, alg_hom.coe_to_ring_hom] at hx\n      let s₀ := _\n      change x ∈ ideal.span s₀\n      have :\n        x ∈\n          «expr ⊔ » (map (algebra_map R A) : «expr →+* » _ AX).srange.to_add_submonoid\n            (ideal.span s₀).to_add_submonoid :=\n        by\n        have : x ∈ («expr⊤» : subalgebra R AX) := trivial\n        rw [← ht''] at this\n        apply adjoin_induction this\n        · rintro _ (⟨x, hx, rfl⟩ | ⟨i, rfl⟩)\n          · rw [algebra_map_eq, ← sub_add_cancel (C x) (map (algebra_map R A) (t' ⟨x, hx⟩)), add_comm]\n            apply add_submonoid.add_mem_sup\n            · exact Set.mem_range_self _\n            · apply ideal.subset_span\n              apply Set.mem_union_right\n              exact Set.mem_range_self ⟨x, hx⟩\n          · apply add_submonoid.mem_sup_left\n            exact ⟨X i, map_X _ _⟩\n        · intro r\n          apply add_submonoid.mem_sup_left\n          exact ⟨C r, map_C _ _⟩\n        · intro _ _ h₁ h₂\n          exact add_mem h₁ h₂\n        · intro x₁ x₂ h₁ h₂\n          obtain ⟨_, ⟨p₁, rfl⟩, q₁, hq₁, rfl⟩ := add_submonoid.mem_sup.mp h₁\n          obtain ⟨_, ⟨p₂, rfl⟩, q₂, hq₂, rfl⟩ := add_submonoid.mem_sup.mp h₂\n          rw [add_mul, mul_add, add_assoc, ← map_mul]\n          apply add_submonoid.add_mem_sup\n          · exact Set.mem_range_self _\n          · refine' add_mem (ideal.mul_mem_left _ _ hq₂) (ideal.mul_mem_right _ _ hq₁)\n      obtain ⟨_, ⟨p, rfl⟩, q, hq, rfl⟩ := add_submonoid.mem_sup.mp this\n      rw [map_add, aeval_map_algebra_map, ← aeval_unique, show aeval (f ∘ X) q = 0 from leI hq, add_zero] at hx\n      suffices ideal.span (s : set RX) ≤ (ideal.span s₀).comap (map <| algebra_map R A)\n        by\n        refine' add_mem _ hq\n        rw [hs] at this\n        exact this hx\n      rw [ideal.span_le]\n      intro x hx\n      apply ideal.subset_span\n      apply Set.mem_union_left\n      exact Set.mem_image_of_mem _ hx\n#align of_restrict_scalars_finite_presentation of_restrict_scalars_finite_presentation\n\n",
 "of_finite_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_finite_type [is_noetherian_ring A] {f : «expr →ₐ[ ] » A R B} : f.finite_type ↔ f.finite_presentation :=\n  ring_hom.finite_presentation.of_finite_type\n#align of_finite_type of_finite_type\n\n",
 "of_finite_presentation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_finite_presentation {f : «expr →ₐ[ ] » A R B} (hf : f.finite_presentation) : f.finite_type :=\n  ring_hom.finite_type.of_finite_presentation hf\n#align of_finite_presentation of_finite_presentation\n\n",
 "of_comp_finite_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_comp_finite_type (f : «expr →ₐ[ ] » A R B) {g : «expr →ₐ[ ] » B R C} (h : (g.comp f).finite_presentation)\n    (h' : f.finite_type) : g.finite_presentation :=\n  h.of_comp_finite_type _ h'\n#align of_comp_finite_type of_comp_finite_type\n\n",
 "mv_polynomial_of_finite_presentation":
 "/-- If `A` is a finitely presented `R`-algebra, then `mv_polynomial (fin n) A` is finitely presented\nas `R`-algebra. -/\ntheorem mv_polynomial_of_finite_presentation (hfp : finite_presentation R A) (ι : Type _) [Finite ι] :\n    finite_presentation R (mv_polynomial ι A) :=\n  by\n  rw [iff_quotient_mv_polynomial'] at hfp⊢\n  classical\n    obtain ⟨ι', _, f, hf_surj, hf_ker⟩ := hfp\n    skip\n    let g := (mv_polynomial.map_alg_hom f).comp (mv_polynomial.sum_alg_equiv R ι ι').to_alg_hom\n    cases nonempty_fintype (Sum ι ι')\n    refine'\n      ⟨Sum ι ι', by infer_instance, g,\n        (mv_polynomial.map_surjective f.to_ring_hom hf_surj).comp (alg_equiv.surjective _),\n        ideal.fg_ker_comp _ _ _ _ (alg_equiv.surjective _)⟩\n    · convert submodule.fg_bot\n      exact ring_hom.ker_coe_equiv (mv_polynomial.sum_alg_equiv R ι ι').to_ring_equiv\n    · rw [alg_hom.to_ring_hom_eq_coe, mv_polynomial.map_alg_hom_coe_ring_hom, mv_polynomial.ker_map]\n      exact hf_ker.map mv_polynomial.C\n#align mv_polynomial_of_finite_presentation mv_polynomial_of_finite_presentation\n\n",
 "mv_polynomial":
 "/-- The ring of polynomials in finitely many variables is finitely presented. -/\nprotected theorem mv_polynomial (ι : Type u_2) [Finite ι] : finite_presentation R (mv_polynomial ι R) := by\n  cases nonempty_fintype ι <;>\n    exact\n      let eqv := (mv_polynomial.rename_equiv R <| fintype.equiv_fin ι).symm\n      ⟨fintype.card ι, eqv, eqv.surjective,\n        ((ring_hom.injective_iff_ker_eq_bot _).1 eqv.injective).symm ▸ submodule.fg_bot⟩\n#align mv_polynomial mv_polynomial\n\n",
 "ker_fg_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- If `f : A →ₐ[R] B` is a sujection between finitely-presented `R`-algebras, then the kernel of\n`f` is finitely generated. -/\ntheorem ker_fg_of_surjective (f : «expr →ₐ[ ] » A R B) (hf : function.surjective f) (hRA : finite_presentation R A)\n    (hRB : finite_presentation R B) : f.to_ring_hom.ker.fg :=\n  by\n  obtain ⟨n, g, hg, hg'⟩ := hRA\n  convert (ker_fg_of_mv_polynomial (f.comp g) (hf.comp hg) hRB).map g.to_ring_hom\n  simp_rw [ring_hom.ker_eq_comap_bot, alg_hom.to_ring_hom_eq_coe, alg_hom.comp_to_ring_hom]\n  rw [← ideal.comap_comap, ideal.map_comap_of_surjective (g : «expr →+* » (mv_polynomial (fin n) R) A) hg]\n#align ker_fg_of_surjective ker_fg_of_surjective\n\n",
 "ker_fg_of_mv_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n-- TODO: extract out helper lemmas and tidy proof.\n/-- This is used to prove the strictly stronger `ker_fg_of_surjective`. Use it instead. -/\ntheorem ker_fg_of_mv_polynomial {n : ℕ} (f : «expr →ₐ[ ] » (mv_polynomial (fin n) R) R A) (hf : function.surjective f)\n    (hfp : finite_presentation R A) : f.to_ring_hom.ker.fg := by\n  classical\n    obtain ⟨m, f', hf', s, hs⟩ := hfp\n    let RXn := mv_polynomial (fin n) R\n    let RXm := mv_polynomial (fin m) R\n    have := fun i : fin n => hf' (f <| X i)\n    choose g hg\n    have := fun i : fin m => hf (f' <| X i)\n    choose h hh\n    let aeval_h : «expr →ₐ[ ] » RXm R RXn := aeval h\n    let g' : fin n → RXn := fun i => X i - aeval_h (g i)\n    refine' ⟨finset.univ.image g' ∪ s.image aeval_h, _⟩\n    simp only [Finset.coe_image, Finset.coe_union, finset.coe_univ, Set.image_univ]\n    have hh' : ∀ x, f (aeval_h x) = f' x := by\n      intro x\n      rw [← f.coe_to_ring_hom, map_aeval]\n      simp_rw [alg_hom.coe_to_ring_hom, hh]\n      rw [alg_hom.comp_algebra_map, ← aeval_eq_eval₂_hom, ← aeval_unique]\n    let s' := Set.range g' ∪ «expr '' » aeval_h s\n    have leI : ideal.span s' ≤ f.to_ring_hom.ker := by\n      rw [ideal.span_le]\n      rintro _ (⟨i, rfl⟩ | ⟨x, hx, rfl⟩)\n      · change f (g' i) = 0\n        rw [map_sub, ← hg, hh', sub_self]\n      · change f (aeval_h x) = 0\n        rw [hh']\n        change x ∈ f'.to_ring_hom.ker\n        rw [← hs]\n        exact ideal.subset_span hx\n    apply leI.antisymm\n    intro x hx\n    have : x ∈ «expr ⊔ » aeval_h.range.to_add_submonoid (ideal.span s').to_add_submonoid :=\n      by\n      have : x ∈ adjoin R (Set.range X : set RXn) := by\n        rw [adjoin_range_X]\n        trivial\n      apply adjoin_induction this\n      · rintro _ ⟨i, rfl⟩\n        rw [← sub_add_cancel (X i) (aeval h (g i)), add_comm]\n        apply add_submonoid.add_mem_sup\n        · exact Set.mem_range_self _\n        · apply submodule.subset_span\n          apply Set.mem_union_left\n          exact Set.mem_range_self _\n      · intro r\n        apply add_submonoid.mem_sup_left\n        exact ⟨C r, aeval_C _ _⟩\n      · intro _ _ h₁ h₂\n        exact add_mem h₁ h₂\n      · intro p₁ p₂ h₁ h₂\n        obtain ⟨_, ⟨x₁, rfl⟩, y₁, hy₁, rfl⟩ := add_submonoid.mem_sup.mp h₁\n        obtain ⟨_, ⟨x₂, rfl⟩, y₂, hy₂, rfl⟩ := add_submonoid.mem_sup.mp h₂\n        rw [mul_add, add_mul, add_assoc, ← map_mul]\n        apply add_submonoid.add_mem_sup\n        · exact Set.mem_range_self _\n        · exact add_mem (ideal.mul_mem_right _ _ hy₁) (ideal.mul_mem_left _ _ hy₂)\n    obtain ⟨_, ⟨x, rfl⟩, y, hy, rfl⟩ := add_submonoid.mem_sup.mp this\n    refine' add_mem _ hy\n    simp only [ring_hom.mem_ker, alg_hom.to_ring_hom_eq_coe, alg_hom.coe_to_ring_hom, map_add, show f y = 0 from leI hy,\n      add_zero, hh'] at hx\n    suffices ideal.span (s : set RXm) ≤ (ideal.span s').comap aeval_h\n      by\n      apply this\n      rwa [hs]\n    rw [ideal.span_le]\n    intro x hx\n    apply submodule.subset_span\n    apply Set.mem_union_right\n    exact Set.mem_image_of_mem _ hx\n#align ker_fg_of_mv_polynomial ker_fg_of_mv_polynomial\n\n",
 "iff_quotient_mv_polynomial'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- An algebra is finitely presented if and only if it is a quotient of a polynomial ring whose\nvariables are indexed by a fintype by a finitely generated ideal. -/\ntheorem iff_quotient_mv_polynomial' :\n    finite_presentation R A ↔\n      ∃ (ι : Type u_2)(_ : fintype ι)(f : «expr →ₐ[ ] » (mv_polynomial ι R) R A), surjective f ∧ f.to_ring_hom.ker.fg :=\n  by\n  constructor\n  · rintro ⟨n, f, hfs, hfk⟩\n    set ulift_var := mv_polynomial.rename_equiv R equiv.ulift\n    refine'\n      ⟨ULift (fin n), infer_instance, f.comp ulift_var.to_alg_hom, hfs.comp ulift_var.surjective,\n        ideal.fg_ker_comp _ _ _ hfk ulift_var.surjective⟩\n    convert submodule.fg_bot\n    exact ring_hom.ker_coe_equiv ulift_var.to_ring_equiv\n  · rintro ⟨ι, hfintype, f, hf⟩\n    skip\n    have equiv := mv_polynomial.rename_equiv R (fintype.equiv_fin ι)\n    refine'\n      ⟨fintype.card ι, f.comp equiv.symm, hf.1.comp (alg_equiv.symm equiv).surjective,\n        ideal.fg_ker_comp _ f _ hf.2 equiv.symm.surjective⟩\n    convert submodule.fg_bot\n    exact ring_hom.ker_coe_equiv equiv.symm.to_ring_equiv\n#align iff_quotient_mv_polynomial' iff_quotient_mv_polynomial'\n\n",
 "iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem iff :\n    finite_presentation R A ↔\n      ∃ (n : _)(I : ideal (mv_polynomial (fin n) R))(e : «expr ≃ₐ[ ] » («expr ⧸ » _ I) R A), I.fg :=\n  by\n  constructor\n  · rintro ⟨n, f, hf⟩\n    exact ⟨n, f.to_ring_hom.ker, ideal.quotient_ker_alg_equiv_of_surjective hf.1, hf.2⟩\n  · rintro ⟨n, I, e, hfg⟩\n    exact equiv ((finite_presentation.mv_polynomial R _).quotient hfg) e\n#align iff iff\n\n",
 "id":
 "#print id /-\ntheorem id : finite_presentation (alg_hom.id R A) :=\n  ring_hom.finite_presentation.id A\n#align id id\n-/\n\n",
 "equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/-- If `e : A ≃ₐ[R] B` and `A` is finitely presented, then so is `B`. -/\ntheorem equiv (hfp : finite_presentation R A) (e : «expr ≃ₐ[ ] » A R B) : finite_presentation R B :=\n  by\n  obtain ⟨n, f, hf⟩ := hfp\n  use n, alg_hom.comp (↑e) f\n  constructor\n  · exact function.surjective.comp e.surjective hf.1\n  suffices hker : (alg_hom.comp (↑e) f).to_ring_hom.ker = f.to_ring_hom.ker\n  · rw [hker]\n    exact hf.2\n  · have hco : (alg_hom.comp (↑e) f).to_ring_hom = RingHom.comp (↑e.to_ring_equiv) f.to_ring_hom :=\n      by\n      have h : (alg_hom.comp (↑e) f).to_ring_hom = e.to_alg_hom.to_ring_hom.comp f.to_ring_hom := rfl\n      have h1 : ↑e.to_ring_equiv = e.to_alg_hom.to_ring_hom := rfl\n      rw [h, h1]\n    rw [ring_hom.ker_eq_comap_bot, hco, ← ideal.comap_comap, ← ring_hom.ker_eq_comap_bot,\n      ring_hom.ker_coe_equiv (alg_equiv.to_ring_equiv e), ring_hom.ker_eq_comap_bot]\n#align equiv equiv\n\n",
 "comp_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp_surjective {f : «expr →ₐ[ ] » A R B} {g : «expr →ₐ[ ] » B R C} (hf : f.finite_presentation)\n    (hg : surjective g) (hker : g.to_ring_hom.ker.fg) : (g.comp f).finite_presentation :=\n  ring_hom.finite_presentation.comp_surjective hf hg hker\n#align comp_surjective comp_surjective\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp {g : «expr →ₐ[ ] » B R C} {f : «expr →ₐ[ ] » A R B} (hg : g.finite_presentation)\n    (hf : f.finite_presentation) : (g.comp f).finite_presentation :=\n  ring_hom.finite_presentation.comp hg hf\n#align comp comp\n\n"}