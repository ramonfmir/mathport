{"trans":
 "#print trans /-\n/-- If `A` is an `R`-algebra and `S` is an `A`-algebra, both finitely presented, then `S` is\n  finitely presented as `R`-algebra. -/\ntheorem trans [Algebra A B] [IsScalarTower R A B] (hfpA : finite_presentation R A) (hfpB : finite_presentation A B) :\n    finite_presentation R B := by\n  obtain ⟨n, I, e, hfg⟩ := iff.1 hfpB\n  exact Equiv ((mv_polynomial_of_finite_presentation hfpA _).quotient hfg) (e.restrict_scalars R)\n#align trans trans\n-/\n\n",
 "self":
 "/-- `R` is finitely presented as `R`-algebra. -/\ntheorem self : finite_presentation R R :=\n  equiv (finite_presentation.mv_polynomial R PEmpty) (MvPolynomial.isEmptyAlgEquiv R PEmpty)\n#align self self\n\n",
 "quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\nprotected theorem quotient {I : Ideal A} (h : I.fg) (hfp : finite_presentation R A) :\n    finite_presentation R («expr ⧸ » A I) := by\n  obtain ⟨n, f, hf⟩ := hfp\n  refine' ⟨n, (Ideal.Quotient.mkₐ R I).comp f, _, _⟩\n  · exact (Ideal.Quotient.mkₐ_surjective R I).comp hf.1\n  · refine' Ideal.fg_ker_comp _ _ hf.2 _ hf.1\n    simp [h]\n#align quotient quotient\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_surjective (f : «expr →ₐ[ ] » A R B) (hf : surjective f) (hker : f.to_ring_hom.ker.fg) :\n    f.finite_presentation :=\n  ring_hom.finite_presentation.of_surjective f hf hker\n#align of_surjective of_surjective\n\n",
 "of_restrict_scalars_finite_presentation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- We follow the proof of https://stacks.math.columbia.edu/tag/0561\n-- TODO: extract out helper lemmas and tidy proof.\ntheorem of_restrict_scalars_finite_presentation [Algebra A B] [IsScalarTower R A B] (hRB : finite_presentation R B)\n    [hRA : FiniteType R A] : finite_presentation A B := by\n  classical\n    obtain ⟨n, f, hf, s, hs⟩ := hRB\n    let RX := MvPolynomial (Fin n) R\n    let AX := MvPolynomial (Fin n) A\n    refine' ⟨n, MvPolynomial.aeval (f ∘ X), _, _⟩\n    · rw [← Algebra.range_top_iff_surjective, ← Algebra.adjoin_range_eq_range_aeval, Set.range_comp, _root_.eq_top_iff,\n        ← @adjoin_adjoin_of_tower R A B, adjoin_image, adjoin_range_X, Algebra.map_top,\n        (Algebra.range_top_iff_surjective _).mpr hf]\n      exact subset_adjoin\n    · obtain ⟨t, ht⟩ := hRA.out\n      have := fun i : t => hf (algebraMap A B i)\n      choose t' ht'\n      have ht'' : Algebra.adjoin R («expr '' » (algebraMap A AX) t ∪ Set.range (X : _ → AX)) = «expr⊤» :=\n        by\n        rw [adjoin_union_eq_adjoin_adjoin, ← Subalgebra.restrictScalars_top R]\n        congr 1\n        swap\n        · exact Subalgebra.isScalarTower_mid _\n        rw [adjoin_algebra_map, ht]\n        apply Subalgebra.restrictScalars_injective R\n        rw [← adjoin_restrict_scalars, adjoin_range_X, Subalgebra.restrictScalars_top, Subalgebra.restrictScalars_top]\n      let g : t → AX := fun x => C (x : A) - map (algebraMap R A) (t' x)\n      refine' ⟨s.image (map (algebraMap R A)) ∪ t.attach.image g, _⟩\n      rw [Finset.coe_union, Finset.coe_image, Finset.coe_image, Finset.attach_eq_univ, Finset.coe_univ, Set.image_univ]\n      let s₀ := _\n      let I := _\n      change Ideal.span s₀ = I\n      have leI : Ideal.span s₀ ≤ I := by\n        rw [Ideal.span_le]\n        rintro _ (⟨x, hx, rfl⟩ | ⟨⟨x, hx⟩, rfl⟩)\n        all_goals dsimp [g]; rw [RingHom.mem_ker, AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom]\n        · rw [MvPolynomial.aeval_map_algebraMap, ← aeval_unique]\n          have := Ideal.subset_span hx\n          rwa [hs] at this\n        · rw [map_sub, MvPolynomial.aeval_map_algebraMap, ← aeval_unique, aeval_C, ht', Subtype.coe_mk, sub_self]\n      apply leI.antisymm\n      intro x hx\n      rw [RingHom.mem_ker, AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom] at hx\n      let s₀ := _\n      change x ∈ Ideal.span s₀\n      have :\n        x ∈\n          «expr ⊔ » (map (algebraMap R A) : «expr →+* » _ AX).srange.to_add_submonoid\n            (Ideal.span s₀).to_add_submonoid :=\n        by\n        have : x ∈ («expr⊤» : Subalgebra R AX) := trivial\n        rw [← ht''] at this\n        apply adjoin_induction this\n        · rintro _ (⟨x, hx, rfl⟩ | ⟨i, rfl⟩)\n          · rw [algebra_map_eq, ← sub_add_cancel (C x) (map (algebraMap R A) (t' ⟨x, hx⟩)), add_comm]\n            apply AddSubmonoid.add_mem_sup\n            · exact Set.mem_range_self _\n            · apply Ideal.subset_span\n              apply Set.mem_union_right\n              exact Set.mem_range_self ⟨x, hx⟩\n          · apply AddSubmonoid.mem_sup_left\n            exact ⟨X i, map_X _ _⟩\n        · intro r\n          apply AddSubmonoid.mem_sup_left\n          exact ⟨C r, map_C _ _⟩\n        · intro _ _ h₁ h₂\n          exact add_mem h₁ h₂\n        · intro x₁ x₂ h₁ h₂\n          obtain ⟨_, ⟨p₁, rfl⟩, q₁, hq₁, rfl⟩ := add_submonoid.mem_sup.mp h₁\n          obtain ⟨_, ⟨p₂, rfl⟩, q₂, hq₂, rfl⟩ := add_submonoid.mem_sup.mp h₂\n          rw [add_mul, mul_add, add_assoc, ← map_mul]\n          apply AddSubmonoid.add_mem_sup\n          · exact Set.mem_range_self _\n          · refine' add_mem (Ideal.mul_mem_left _ _ hq₂) (Ideal.mul_mem_right _ _ hq₁)\n      obtain ⟨_, ⟨p, rfl⟩, q, hq, rfl⟩ := add_submonoid.mem_sup.mp this\n      rw [map_add, aeval_map_algebra_map, ← aeval_unique, show aeval (f ∘ X) q = 0 from leI hq, add_zero] at hx\n      suffices Ideal.span (s : Set RX) ≤ (Ideal.span s₀).comap (map <| algebraMap R A)\n        by\n        refine' add_mem _ hq\n        rw [hs] at this\n        exact this hx\n      rw [Ideal.span_le]\n      intro x hx\n      apply Ideal.subset_span\n      apply Set.mem_union_left\n      exact Set.mem_image_of_mem _ hx\n#align of_restrict_scalars_finite_presentation of_restrict_scalars_finite_presentation\n\n",
 "of_finite_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_finite_type [IsNoetherianRing A] {f : «expr →ₐ[ ] » A R B} : f.finite_type ↔ f.finite_presentation :=\n  ring_hom.finite_presentation.of_finite_type\n#align of_finite_type of_finite_type\n\n",
 "of_finite_presentation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_finite_presentation {f : «expr →ₐ[ ] » A R B} (hf : f.finite_presentation) : f.finite_type :=\n  ring_hom.finite_type.of_finite_presentation hf\n#align of_finite_presentation of_finite_presentation\n\n",
 "of_comp_finite_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_comp_finite_type (f : «expr →ₐ[ ] » A R B) {g : «expr →ₐ[ ] » B R C} (h : (g.comp f).finite_presentation)\n    (h' : f.finite_type) : g.finite_presentation :=\n  h.of_comp_finite_type _ h'\n#align of_comp_finite_type of_comp_finite_type\n\n",
 "mv_polynomial_of_finite_presentation":
 "/-- If `A` is a finitely presented `R`-algebra, then `mv_polynomial (fin n) A` is finitely presented\nas `R`-algebra. -/\ntheorem mv_polynomial_of_finite_presentation (hfp : finite_presentation R A) (ι : Type _) [Finite ι] :\n    finite_presentation R (MvPolynomial ι A) :=\n  by\n  rw [iff_quotient_mv_polynomial'] at hfp⊢\n  classical\n    obtain ⟨ι', _, f, hf_surj, hf_ker⟩ := hfp\n    skip\n    let g := (MvPolynomial.mapAlgHom f).comp (MvPolynomial.sumAlgEquiv R ι ι').to_alg_hom\n    cases nonempty_fintype (Sum ι ι')\n    refine'\n      ⟨Sum ι ι', by infer_instance, g, (MvPolynomial.map_surjective f.to_ring_hom hf_surj).comp (AlgEquiv.surjective _),\n        Ideal.fg_ker_comp _ _ _ _ (AlgEquiv.surjective _)⟩\n    · convert Submodule.fg_bot\n      exact RingHom.ker_coe_equiv (MvPolynomial.sumAlgEquiv R ι ι').to_ring_equiv\n    · rw [AlgHom.toRingHom_eq_coe, MvPolynomial.mapAlgHom_coe_ringHom, MvPolynomial.ker_map]\n      exact hf_ker.map MvPolynomial.C\n#align mv_polynomial_of_finite_presentation mv_polynomial_of_finite_presentation\n\n",
 "ker_fg_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- If `f : A →ₐ[R] B` is a sujection between finitely-presented `R`-algebras, then the kernel of\n`f` is finitely generated. -/\ntheorem ker_fg_of_surjective (f : «expr →ₐ[ ] » A R B) (hf : function.surjective f) (hRA : finite_presentation R A)\n    (hRB : finite_presentation R B) : f.to_ring_hom.ker.fg :=\n  by\n  obtain ⟨n, g, hg, hg'⟩ := hRA\n  convert(ker_fg_of_mv_polynomial (f.comp g) (hf.comp hg) hRB).map g.to_ring_hom\n  simp_rw [RingHom.ker_eq_comap_bot, AlgHom.toRingHom_eq_coe, AlgHom.comp_toRingHom]\n  rw [← Ideal.comap_comap, Ideal.map_comap_of_surjective (g : «expr →+* » (MvPolynomial (Fin n) R) A) hg]\n#align ker_fg_of_surjective ker_fg_of_surjective\n\n",
 "ker_fg_of_mv_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n-- TODO: extract out helper lemmas and tidy proof.\n/-- This is used to prove the strictly stronger `ker_fg_of_surjective`. Use it instead. -/\ntheorem ker_fg_of_mv_polynomial {n : ℕ} (f : «expr →ₐ[ ] » (MvPolynomial (Fin n) R) R A) (hf : function.surjective f)\n    (hfp : finite_presentation R A) : f.to_ring_hom.ker.fg := by\n  classical\n    obtain ⟨m, f', hf', s, hs⟩ := hfp\n    let RXn := MvPolynomial (Fin n) R\n    let RXm := MvPolynomial (Fin m) R\n    have := fun i : Fin n => hf' (f <| X i)\n    choose g hg\n    have := fun i : Fin m => hf (f' <| X i)\n    choose h hh\n    let aeval_h : «expr →ₐ[ ] » RXm R RXn := aeval h\n    let g' : Fin n → RXn := fun i => X i - aeval_h (g i)\n    refine' ⟨finset.univ.image g' ∪ s.image aeval_h, _⟩\n    simp only [Finset.coe_image, Finset.coe_union, Finset.coe_univ, Set.image_univ]\n    have hh' : ∀ x, f (aeval_h x) = f' x := by\n      intro x\n      rw [← f.coe_to_ring_hom, map_aeval]\n      simp_rw [AlgHom.coe_toRingHom, hh]\n      rw [AlgHom.comp_algebraMap, ← aeval_eq_eval₂_hom, ← aeval_unique]\n    let s' := Set.range g' ∪ «expr '' » aeval_h s\n    have leI : Ideal.span s' ≤ f.to_ring_hom.ker := by\n      rw [Ideal.span_le]\n      rintro _ (⟨i, rfl⟩ | ⟨x, hx, rfl⟩)\n      · change f (g' i) = 0\n        rw [map_sub, ← hg, hh', sub_self]\n      · change f (aeval_h x) = 0\n        rw [hh']\n        change x ∈ f'.to_ring_hom.ker\n        rw [← hs]\n        exact Ideal.subset_span hx\n    apply leI.antisymm\n    intro x hx\n    have : x ∈ «expr ⊔ » aeval_h.range.to_add_submonoid (Ideal.span s').to_add_submonoid :=\n      by\n      have : x ∈ adjoin R (Set.range X : Set RXn) := by\n        rw [adjoin_range_X]\n        trivial\n      apply adjoin_induction this\n      · rintro _ ⟨i, rfl⟩\n        rw [← sub_add_cancel (X i) (aeval h (g i)), add_comm]\n        apply AddSubmonoid.add_mem_sup\n        · exact Set.mem_range_self _\n        · apply Submodule.subset_span\n          apply Set.mem_union_left\n          exact Set.mem_range_self _\n      · intro r\n        apply AddSubmonoid.mem_sup_left\n        exact ⟨C r, aeval_C _ _⟩\n      · intro _ _ h₁ h₂\n        exact add_mem h₁ h₂\n      · intro p₁ p₂ h₁ h₂\n        obtain ⟨_, ⟨x₁, rfl⟩, y₁, hy₁, rfl⟩ := add_submonoid.mem_sup.mp h₁\n        obtain ⟨_, ⟨x₂, rfl⟩, y₂, hy₂, rfl⟩ := add_submonoid.mem_sup.mp h₂\n        rw [mul_add, add_mul, add_assoc, ← map_mul]\n        apply AddSubmonoid.add_mem_sup\n        · exact Set.mem_range_self _\n        · exact add_mem (Ideal.mul_mem_right _ _ hy₁) (Ideal.mul_mem_left _ _ hy₂)\n    obtain ⟨_, ⟨x, rfl⟩, y, hy, rfl⟩ := add_submonoid.mem_sup.mp this\n    refine' add_mem _ hy\n    simp only [RingHom.mem_ker, AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom, map_add, show f y = 0 from leI hy,\n      add_zero, hh'] at hx\n    suffices Ideal.span (s : Set RXm) ≤ (Ideal.span s').comap aeval_h\n      by\n      apply this\n      rwa [hs]\n    rw [Ideal.span_le]\n    intro x hx\n    apply Submodule.subset_span\n    apply Set.mem_union_right\n    exact Set.mem_image_of_mem _ hx\n#align ker_fg_of_mv_polynomial ker_fg_of_mv_polynomial\n\n",
 "iff_quotient_mv_polynomial'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- An algebra is finitely presented if and only if it is a quotient of a polynomial ring whose\nvariables are indexed by a fintype by a finitely generated ideal. -/\ntheorem iff_quotient_mv_polynomial' :\n    finite_presentation R A ↔\n      ∃ (ι : Type u_2)(_ : Fintype ι)(f : «expr →ₐ[ ] » (MvPolynomial ι R) R A), surjective f ∧ f.to_ring_hom.ker.fg :=\n  by\n  constructor\n  · rintro ⟨n, f, hfs, hfk⟩\n    set ulift_var := MvPolynomial.renameEquiv R Equiv.ulift\n    refine'\n      ⟨ULift (Fin n), inferInstance, f.comp ulift_var.to_alg_hom, hfs.comp ulift_var.surjective,\n        Ideal.fg_ker_comp _ _ _ hfk ulift_var.surjective⟩\n    convert Submodule.fg_bot\n    exact RingHom.ker_coe_equiv ulift_var.to_ring_equiv\n  · rintro ⟨ι, hfintype, f, hf⟩\n    skip\n    have equiv := MvPolynomial.renameEquiv R (Fintype.equivFin ι)\n    refine'\n      ⟨Fintype.card ι, f.comp Equiv.symm, hf.1.comp (AlgEquiv.symm Equiv).surjective,\n        Ideal.fg_ker_comp _ f _ hf.2 equiv.symm.surjective⟩\n    convert Submodule.fg_bot\n    exact RingHom.ker_coe_equiv equiv.symm.to_ring_equiv\n#align iff_quotient_mv_polynomial' iff_quotient_mv_polynomial'\n\n",
 "iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem iff :\n    finite_presentation R A ↔\n      ∃ (n : _)(I : Ideal (MvPolynomial (Fin n) R))(e : «expr ≃ₐ[ ] » («expr ⧸ » _ I) R A), I.fg :=\n  by\n  constructor\n  · rintro ⟨n, f, hf⟩\n    exact ⟨n, f.to_ring_hom.ker, Ideal.quotientKerAlgEquivOfSurjective hf.1, hf.2⟩\n  · rintro ⟨n, I, e, hfg⟩\n    exact Equiv ((finite_presentation.mv_polynomial R _).quotient hfg) e\n#align iff iff\n\n",
 "id":
 "#print id /-\ntheorem id : finite_presentation (AlgHom.id R A) :=\n  ring_hom.finite_presentation.id A\n#align id id\n-/\n\n",
 "comp_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp_surjective {f : «expr →ₐ[ ] » A R B} {g : «expr →ₐ[ ] » B R C} (hf : f.finite_presentation)\n    (hg : surjective g) (hker : g.to_ring_hom.ker.fg) : (g.comp f).finite_presentation :=\n  ring_hom.finite_presentation.comp_surjective hf hg hker\n#align comp_surjective comp_surjective\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp {g : «expr →ₐ[ ] » B R C} {f : «expr →ₐ[ ] » A R B} (hg : g.finite_presentation)\n    (hf : f.finite_presentation) : (g.comp f).finite_presentation :=\n  ring_hom.finite_presentation.comp hg hf\n#align comp comp\n\n",
 "Polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print Polynomial /-\n/-- `R[X]` is finitely presented as `R`-algebra. -/\ntheorem Polynomial : finite_presentation R (polynomial R) :=\n  equiv (finite_presentation.mv_polynomial R PUnit) (MvPolynomial.pUnitAlgEquiv R)\n#align polynomial Polynomial\n-/\n\n",
 "MvPolynomial":
 "#print MvPolynomial /-\n/-- The ring of polynomials in finitely many variables is finitely presented. -/\nprotected theorem MvPolynomial (ι : Type u_2) [Finite ι] : finite_presentation R (MvPolynomial ι R) := by\n  cases nonempty_fintype ι <;>\n    exact\n      let eqv := (MvPolynomial.renameEquiv R <| Fintype.equivFin ι).symm\n      ⟨Fintype.card ι, eqv, eqv.surjective,\n        ((RingHom.injective_iff_ker_eq_bot _).1 eqv.injective).symm ▸ Submodule.fg_bot⟩\n#align mv_polynomial MvPolynomial\n-/\n\n",
 "Equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n#print Equiv /-\n/-- If `e : A ≃ₐ[R] B` and `A` is finitely presented, then so is `B`. -/\ntheorem Equiv (hfp : finite_presentation R A) (e : «expr ≃ₐ[ ] » A R B) : finite_presentation R B :=\n  by\n  obtain ⟨n, f, hf⟩ := hfp\n  use n, AlgHom.comp (↑e) f\n  constructor\n  · exact function.surjective.comp e.surjective hf.1\n  suffices hker : (AlgHom.comp (↑e) f).to_ring_hom.ker = f.to_ring_hom.ker\n  · rw [hker]\n    exact hf.2\n  · have hco : (AlgHom.comp (↑e) f).to_ring_hom = RingHom.comp (↑e.to_ring_equiv) f.to_ring_hom :=\n      by\n      have h : (AlgHom.comp (↑e) f).to_ring_hom = e.to_alg_hom.to_ring_hom.comp f.to_ring_hom := rfl\n      have h1 : ↑e.to_ring_equiv = e.to_alg_hom.to_ring_hom := rfl\n      rw [h, h1]\n    rw [RingHom.ker_eq_comap_bot, hco, ← Ideal.comap_comap, ← RingHom.ker_eq_comap_bot,\n      RingHom.ker_coe_equiv (alg_equiv.to_ring_equiv e), RingHom.ker_eq_comap_bot]\n#align equiv Equiv\n-/\n\n"}