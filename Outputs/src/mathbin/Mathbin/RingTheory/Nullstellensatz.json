{"zero_locus_vanishing_ideal_le":
 "theorem zero_locus_vanishing_ideal_le (V : set (σ → k)) : V ≤ zero_locus (vanishing_ideal V) := fun V hV p hp => hp V hV\n#align zero_locus_vanishing_ideal_le zero_locus_vanishing_ideal_le\n\n",
 "zero_locus_vanishing_ideal_galois_connection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem zero_locus_vanishing_ideal_galois_connection :\n    @GaloisConnection (ideal (mv_polynomial σ k)) («expr ᵒᵈ» (set (σ → k))) _ _ zero_locus vanishing_ideal := fun I V =>\n  ⟨fun h => le_trans (le_vanishing_ideal_zero_locus I) (vanishing_ideal_anti_mono h), fun h =>\n    le_trans (zero_locus_anti_mono h) (zero_locus_vanishing_ideal_le V)⟩\n#align zero_locus_vanishing_ideal_galois_connection zero_locus_vanishing_ideal_galois_connection\n\n",
 "zero_locus_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem zero_locus_top : zero_locus («expr⊤» : ideal (mv_polynomial σ k)) = «expr⊥» :=\n  eq_bot_iff.2 fun x hx => one_ne_zero ((eval x).map_one ▸ hx 1 submodule.mem_top : (1 : k) = 0)\n#align zero_locus_top zero_locus_top\n\n",
 "zero_locus_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem zero_locus_bot : zero_locus («expr⊥» : ideal (mv_polynomial σ k)) = «expr⊤» :=\n  eq_top_iff.2 fun x hx p hp => trans (congr_arg (eval x) (mem_bot.1 hp)) (eval x).map_zero\n#align zero_locus_bot zero_locus_bot\n\n",
 "zero_locus_anti_mono":
 "theorem zero_locus_anti_mono {I J : ideal (mv_polynomial σ k)} (h : I ≤ J) : zero_locus J ≤ zero_locus I :=\n  fun x hx p hp => hx p <| h hp\n#align zero_locus_anti_mono zero_locus_anti_mono\n\n",
 "vanishing_ideal_zero_locus_eq_radical":
 "/-- Main statement of the Nullstellensatz -/\n@[simp]\ntheorem vanishing_ideal_zero_locus_eq_radical (I : ideal (mv_polynomial σ k)) :\n    vanishing_ideal (zero_locus I) = I.radical :=\n  by\n  rw [I.radical_eq_jacobson]\n  refine' le_antisymm (le_infₛ _) fun p hp x hx => _\n  · rintro J ⟨hJI, hJ⟩\n    obtain ⟨x, hx⟩ := (is_maximal_iff_eq_vanishing_ideal_singleton J).1 hJ\n    refine' hx.symm ▸ vanishing_ideal_anti_mono fun y hy p hp => _\n    rw [← mem_vanishing_ideal_singleton_iff, Set.mem_singleton_iff.1 hy, ← hx]\n    refine' hJI hp\n  · rw [← mem_vanishing_ideal_singleton_iff x p]\n    refine'\n      (mem_Inf.mp hp)\n        ⟨le_trans (le_vanishing_ideal_zero_locus I) (vanishing_ideal_anti_mono fun y hy => hy.symm ▸ hx),\n          mv_polynomial.vanishing_ideal_singleton_is_maximal⟩\n#align vanishing_ideal_zero_locus_eq_radical vanishing_ideal_zero_locus_eq_radical\n\n",
 "vanishing_ideal_zero_locus":
 "@[simp]\ntheorem is_prime.vanishing_ideal_zero_locus (P : ideal (mv_polynomial σ k)) [h : P.is_prime] :\n    vanishing_ideal (zero_locus P) = P :=\n  trans (vanishing_ideal_zero_locus_eq_radical P) h.radical\n#align is_prime.vanishing_ideal_zero_locus is_prime.vanishing_ideal_zero_locus\n\n",
 "vanishing_ideal_point_to_point":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem vanishing_ideal_point_to_point (V : set (σ → k)) :\n    prime_spectrum.vanishing_ideal («expr '' » point_to_point V) = mv_polynomial.vanishing_ideal V :=\n  le_antisymm\n    (fun p hp x hx =>\n      (((prime_spectrum.mem_vanishing_ideal _ _).1 hp) ⟨vanishing_ideal {x}, by infer_instance⟩ ⟨x, ⟨hx, rfl⟩⟩) x rfl)\n    fun p hp =>\n    (prime_spectrum.mem_vanishing_ideal _ _).2 fun I hI =>\n      let ⟨x, hx⟩ := hI\n      hx.2 ▸ fun x' hx' => (Set.mem_singleton_iff.1 hx').symm ▸ hp x hx.1\n#align vanishing_ideal_point_to_point vanishing_ideal_point_to_point\n\n",
 "vanishing_ideal_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem vanishing_ideal_empty : vanishing_ideal (∅ : set (σ → k)) = «expr⊤» :=\n  le_antisymm le_top fun p hp x hx => absurd hx (Set.not_mem_empty x)\n#align vanishing_ideal_empty vanishing_ideal_empty\n\n",
 "vanishing_ideal_anti_mono":
 "theorem vanishing_ideal_anti_mono {A B : set (σ → k)} (h : A ≤ B) : vanishing_ideal B ≤ vanishing_ideal A :=\n  fun p hp x hx => hp x <| h hx\n#align vanishing_ideal_anti_mono vanishing_ideal_anti_mono\n\n",
 "radical_le_vanishing_ideal_zero_locus":
 "theorem radical_le_vanishing_ideal_zero_locus (I : ideal (mv_polynomial σ k)) :\n    I.radical ≤ vanishing_ideal (zero_locus I) := by\n  intro p hp x hx\n  rw [← mem_vanishing_ideal_singleton_iff]\n  rw [radical_eq_Inf] at hp\n  refine'\n    (mem_Inf.mp hp)\n      ⟨le_trans (le_vanishing_ideal_zero_locus I) (vanishing_ideal_anti_mono fun y hy => hy.symm ▸ hx),\n        is_maximal.is_prime' _⟩\n#align radical_le_vanishing_ideal_zero_locus radical_le_vanishing_ideal_zero_locus\n\n",
 "point_to_point_zero_locus_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem point_to_point_zero_locus_le (I : ideal (mv_polynomial σ k)) :\n    «expr '' » point_to_point (mv_polynomial.zero_locus I) ≤ prime_spectrum.zero_locus ↑I := fun J hJ =>\n  let ⟨x, hx⟩ := hJ\n  (le_trans (le_vanishing_ideal_zero_locus I) (hx.2 ▸ vanishing_ideal_anti_mono (Set.singleton_subset_iff.2 hx.1)) :\n    I ≤ J.as_ideal)\n#align point_to_point_zero_locus_le point_to_point_zero_locus_le\n\n",
 "mem_zero_locus_iff":
 "/-\nCopyright (c) 2021 Devon Tuma. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Devon Tuma\n-/\n@[simp]\ntheorem mem_zero_locus_iff {I : ideal (mv_polynomial σ k)} {x : σ → k} : x ∈ zero_locus I ↔ ∀ p ∈ I, eval x p = 0 :=\n  iff.rfl\n#align mem_zero_locus_iff mem_zero_locus_iff\n\n",
 "mem_vanishing_ideal_singleton_iff":
 "theorem mem_vanishing_ideal_singleton_iff (x : σ → k) (p : mv_polynomial σ k) :\n    p ∈ (vanishing_ideal {x} : ideal (mv_polynomial σ k)) ↔ eval x p = 0 :=\n  ⟨fun h => h x rfl, fun hpx y hy => hy.symm ▸ hpx⟩\n#align mem_vanishing_ideal_singleton_iff mem_vanishing_ideal_singleton_iff\n\n",
 "mem_vanishing_ideal_iff":
 "@[simp]\ntheorem mem_vanishing_ideal_iff {V : set (σ → k)} {p : mv_polynomial σ k} :\n    p ∈ vanishing_ideal V ↔ ∀ x ∈ V, eval x p = 0 :=\n  iff.rfl\n#align mem_vanishing_ideal_iff mem_vanishing_ideal_iff\n\n",
 "le_vanishing_ideal_zero_locus":
 "theorem le_vanishing_ideal_zero_locus (I : ideal (mv_polynomial σ k)) : I ≤ vanishing_ideal (zero_locus I) :=\n  fun p hp x hx => hx p hp\n#align le_vanishing_ideal_zero_locus le_vanishing_ideal_zero_locus\n\n",
 "is_maximal_iff_eq_vanishing_ideal_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem is_maximal_iff_eq_vanishing_ideal_singleton (I : ideal (mv_polynomial σ k)) :\n    I.is_maximal ↔ ∃ x : σ → k, I = vanishing_ideal {x} :=\n  by\n  cases nonempty_fintype σ\n  refine'\n    ⟨fun hI => _, fun h =>\n      let ⟨x, hx⟩ := h\n      hx.symm ▸ mv_polynomial.vanishing_ideal_singleton_is_maximal⟩\n  letI : I.is_maximal := hI\n  letI : Field («expr ⧸ » (mv_polynomial σ k) I) := quotient.field I\n  let ϕ : «expr →+* » k («expr ⧸ » (mv_polynomial σ k) I) := (ideal.quotient.mk I).comp C\n  have hϕ : function.bijective ϕ :=\n    ⟨quotient_mk_comp_C_injective _ _ I hI.ne_top,\n      is_alg_closed.algebra_map_surjective_of_is_integral' ϕ\n        (mv_polynomial.comp_C_integral_of_surjective_of_jacobson _ quotient.mk_surjective)⟩\n  obtain ⟨φ, hφ⟩ := Function.Surjective.hasRightInverse hϕ.2\n  let x : σ → k := fun s => φ ((ideal.quotient.mk I) (X s))\n  have hx : ∀ s : σ, ϕ (x s) = (ideal.quotient.mk I) (X s) := fun s => hφ ((ideal.quotient.mk I) (X s))\n  refine' ⟨x, (is_maximal.eq_of_le (by infer_instance) hI.ne_top _).symm⟩\n  intro p hp\n  rw [← quotient.eq_zero_iff_mem, map_mv_polynomial_eq_eval₂ (ideal.quotient.mk I) p, eval₂_eq']\n  rw [mem_vanishing_ideal_singleton_iff, eval_eq'] at hp\n  simpa only [ϕ.map_sum, ϕ.map_mul, ϕ.map_prod, ϕ.map_pow, ϕ.map_zero, hx] using congr_arg ϕ hp\n#align is_maximal_iff_eq_vanishing_ideal_singleton is_maximal_iff_eq_vanishing_ideal_singleton\n\n"}