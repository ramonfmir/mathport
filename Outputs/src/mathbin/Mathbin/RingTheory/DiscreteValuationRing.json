{"unit_mul_pow_congr_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem unit_mul_pow_congr_unit {ϖ : R} (hirr : Irreducible ϖ) (u v : «expr ˣ» R) (m n : ℕ)\n    (h : ↑u * ϖ ^ m = v * ϖ ^ n) : u = v :=\n  by\n  obtain rfl : m = n := unit_mul_pow_congr_pow hirr hirr u v m n h\n  rw [← sub_eq_zero] at h\n  rw [← sub_mul, mul_eq_zero] at h\n  cases h\n  · rw [sub_eq_zero] at h\n    exact_mod_cast h\n  · apply (hirr.ne_zero (pow_eq_zero h)).elim\n#align unit_mul_pow_congr_unit unit_mul_pow_congr_unit\n\n",
 "unit_mul_pow_congr_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem unit_mul_pow_congr_pow {p q : R} (hp : Irreducible p) (hq : Irreducible q) (u v : «expr ˣ» R) (m n : ℕ)\n    (h : ↑u * p ^ m = v * q ^ n) : m = n :=\n  by\n  have key : Associated (multiset.replicate m p).prod (multiset.replicate n q).prod :=\n    by\n    rw [Multiset.prod_replicate, Multiset.prod_replicate, Associated]\n    refine' ⟨u * v⁻¹, _⟩\n    simp only [Units.val_mul]\n    rw [mul_left_comm, ← mul_assoc, h, mul_right_comm, Units.mul_inv, one_mul]\n  have := Multiset.card_eq_card_of_rel (unique_factorization_monoid.factors_unique _ _ key)\n  · simpa only [Multiset.card_replicate]\n  all_goals\n    intro x hx\n    obtain rfl := Multiset.eq_of_mem_replicate hx\n    assumption\n#align unit_mul_pow_congr_pow unit_mul_pow_congr_pow\n\n",
 "unique_irreducible":
 "theorem unique_irreducible ⦃p q : R⦄ (hp : Irreducible p) (hq : Irreducible q) : Associated p q :=\n  by\n  rcases hR with ⟨ϖ, hϖ, hR⟩\n  suffices ∀ {p : R} (hp : Irreducible p), Associated p ϖ by apply Associated.trans (this hp) (this hq).symm\n  clear hp hq p q\n  intro p hp\n  obtain ⟨n, hn⟩ := hR hp.ne_zero\n  have : Irreducible (ϖ ^ n) := hn.symm.irreducible hp\n  rcases lt_trichotomy n 1 with (H | rfl | H)\n  · obtain rfl : n = 0 := by\n      clear hn this\n      revert H n\n      exact by decide\n    simpa only [not_irreducible_one, pow_zero] using this\n  · simpa only [pow_one] using hn.symm\n  · obtain ⟨n, rfl⟩ : ∃ k, n = 1 + k + 1 := Nat.exists_eq_add_of_lt H\n    rw [pow_succ] at this\n    rcases this.is_unit_or_is_unit rfl with (H0 | H0)\n    · exact (hϖ.not_unit H0).elim\n    · rw [add_comm, pow_succ] at H0\n      exact (hϖ.not_unit (isUnit_of_mul_isUnit_left H0)).elim\n#align unique_irreducible unique_irreducible\n\n",
 "to_unique_factorization_monoid":
 "/-- An integral domain in which there is an irreducible element `p`\nsuch that every nonzero element is associated to a power of `p` is a unique factorization domain.\nSee `discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization`. -/\ntheorem to_unique_factorization_monoid : unique_factorization_monoid R :=\n  let p := Classical.choose hR\n  let spec := Classical.choose_spec hR\n  unique_factorization_monoid.of_exists_prime_factors fun x hx =>\n    by\n    use multiset.replicate (Classical.choose (spec.2 hx)) p\n    constructor\n    · intro q hq\n      have hpq := Multiset.eq_of_mem_replicate hq\n      rw [hpq]\n      refine' ⟨spec.1.ne_zero, spec.1.not_unit, _⟩\n      intro a b h\n      by_cases ha : a = 0\n      · rw [ha]\n        simp only [true_or_iff, dvd_zero]\n      obtain ⟨m, u, rfl⟩ := spec.2 ha\n      rw [mul_assoc, mul_left_comm, is_unit.dvd_mul_left _ _ _ (Units.isUnit _)] at h\n      rw [is_unit.dvd_mul_right (Units.isUnit _)]\n      by_cases hm : m = 0\n      · simp only [hm, one_mul, pow_zero] at h⊢\n        right\n        exact h\n      left\n      obtain ⟨m, rfl⟩ := nat.exists_eq_succ_of_ne_zero hm\n      rw [pow_succ]\n      apply dvd_mul_of_dvd_left dvd_rfl _\n    · rw [Multiset.prod_replicate]\n      exact Classical.choose_spec (spec.2 hx)\n#align to_unique_factorization_monoid to_unique_factorization_monoid\n\n",
 "of_ufd_of_unique_irreducible":
 "/-- A unique factorization domain with at least one irreducible element\nin which all irreducible elements are associated\nis a discrete valuation ring.\n-/\ntheorem of_ufd_of_unique_irreducible {R : Type u} [CommRing R] [IsDomain R] [unique_factorization_monoid R]\n    (h₁ : ∃ p : R, Irreducible p) (h₂ : ∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q) :\n    discrete_valuation_ring R := by\n  rw [iff_pid_with_one_nonzero_prime]\n  haveI PID : is_principal_ideal_ring R := aux_pid_of_ufd_of_unique_irreducible R h₁ h₂\n  obtain ⟨p, hp⟩ := h₁\n  refine' ⟨PID, ⟨ideal.span {p}, ⟨_, _⟩, _⟩⟩\n  · rw [submodule.ne_bot_iff]\n    refine' ⟨p, ideal.mem_span_singleton.mpr (dvd_refl p), hp.ne_zero⟩\n  · rwa [ideal.span_singleton_prime hp.ne_zero, ← unique_factorization_monoid.irreducible_iff_prime]\n  · intro I\n    rw [← submodule.is_principal.span_singleton_generator I]\n    rintro ⟨I0, hI⟩\n    apply span_singleton_eq_span_singleton.mpr\n    apply h₂ _ hp\n    erw [ne.def, span_singleton_eq_bot] at I0\n    rwa [unique_factorization_monoid.irreducible_iff_prime, ← ideal.span_singleton_prime I0]\n    infer_instance\n#align of_ufd_of_unique_irreducible of_ufd_of_unique_irreducible\n\n",
 "of_has_unit_mul_pow_irreducible_factorization":
 "/-- An integral domain in which there is an irreducible element `p`\nsuch that every nonzero element is associated to a power of `p`\nis a discrete valuation ring.\n-/\ntheorem of_has_unit_mul_pow_irreducible_factorization {R : Type u} [CommRing R] [IsDomain R]\n    (hR : has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R :=\n  by\n  letI : unique_factorization_monoid R := hR.to_unique_factorization_monoid\n  apply of_ufd_of_unique_irreducible _ hR.unique_irreducible\n  obtain ⟨p, hp, H⟩ := hR\n  exact ⟨p, hp⟩\n#align of_has_unit_mul_pow_irreducible_factorization of_has_unit_mul_pow_irreducible_factorization\n\n",
 "not_is_field":
 "/-- A discrete valuation ring `R` is not a field. -/\ntheorem not_is_field : ¬IsField R :=\n  ring.not_is_field_iff_exists_prime.mpr ⟨_, not_a_field R, is_maximal.is_prime' (maximal_ideal R)⟩\n#align not_is_field not_is_field\n\n",
 "not_a_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-\nCopyright (c) 2020 Kevin Buzzard. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard\n-/\ntheorem not_a_field : maximal_ideal R ≠ «expr⊥» :=\n  not_a_field'\n#align not_a_field not_a_field\n\n",
 "maximal_ideal_eq":
 "theorem _root_.irreducible.maximal_ideal_eq {ϖ : R} (h : Irreducible ϖ) : maximal_ideal R = ideal.span {ϖ} :=\n  (irreducible_iff_uniformizer _).mp h\n#align irreducible.maximal_ideal_eq irreducible.maximal_ideal_eq\n\n",
 "irreducible_of_span_eq_maximal_ideal":
 "theorem irreducible_of_span_eq_maximal_ideal {R : Type _} [CommRing R] [local_ring R] [IsDomain R] (ϖ : R) (hϖ : ϖ ≠ 0)\n    (h : maximal_ideal R = ideal.span {ϖ}) : Irreducible ϖ :=\n  by\n  have h2 : ¬is_unit ϖ := show ϖ ∈ maximal_ideal R from h.symm ▸ submodule.mem_span_singleton_self ϖ\n  refine' ⟨h2, _⟩\n  intro a b hab\n  by_contra' h\n  obtain ⟨ha : a ∈ maximal_ideal R, hb : b ∈ maximal_ideal R⟩ := h\n  rw [h, mem_span_singleton'] at ha hb\n  rcases ha with ⟨a, rfl⟩\n  rcases hb with ⟨b, rfl⟩\n  rw [show a * ϖ * (b * ϖ) = ϖ * (ϖ * (a * b)) by ring] at hab\n  apply hϖ\n  apply eq_zero_of_mul_eq_self_right _ hab.symm\n  exact fun hh => h2 (isUnit_of_dvd_one ϖ ⟨_, hh.symm⟩)\n#align irreducible_of_span_eq_maximal_ideal irreducible_of_span_eq_maximal_ideal\n\n",
 "irreducible_iff_uniformizer":
 "/-- An element of a DVR is irreducible iff it is a uniformizer, that is, generates the\n  maximal ideal of R -/\ntheorem irreducible_iff_uniformizer (ϖ : R) : Irreducible ϖ ↔ maximal_ideal R = ideal.span {ϖ} :=\n  ⟨fun hϖ => (eq_maximal_ideal (is_maximal_of_irreducible hϖ)).symm, fun h =>\n    irreducible_of_span_eq_maximal_ideal ϖ (fun e => not_a_field R <| by rwa [h, span_singleton_eq_bot]) h⟩\n#align irreducible_iff_uniformizer irreducible_iff_uniformizer\n\n",
 "iff_pid_with_one_nonzero_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- an integral domain is a DVR iff it's a PID with a unique non-zero prime ideal -/\ntheorem iff_pid_with_one_nonzero_prime (R : Type u) [CommRing R] [IsDomain R] :\n    discrete_valuation_ring R ↔ is_principal_ideal_ring R ∧ ∃! P : ideal R, P ≠ «expr⊥» ∧ is_prime P :=\n  by\n  constructor\n  · intro RDVR\n    rcases id RDVR with ⟨Rlocal⟩\n    constructor\n    assumption\n    skip\n    use local_ring.maximal_ideal R\n    constructor\n    constructor\n    · assumption\n    · infer_instance\n    · rintro Q ⟨hQ1, hQ2⟩\n      obtain ⟨q, rfl⟩ := (is_principal_ideal_ring.principal Q).1\n      have hq : q ≠ 0 := by\n        rintro rfl\n        apply hQ1\n        simp\n      erw [span_singleton_prime hq] at hQ2\n      replace hQ2 := hQ2.irreducible\n      rw [irreducible_iff_uniformizer] at hQ2\n      exact hQ2.symm\n  · rintro ⟨RPID, Punique⟩\n    haveI : local_ring R := local_ring.of_unique_nonzero_prime Punique\n    refine' { not_a_field' := _ }\n    rcases Punique with ⟨P, ⟨hP1, hP2⟩, hP3⟩\n    have hPM : P ≤ maximal_ideal R := le_maximal_ideal hP2.1\n    intro h\n    rw [h, le_bot_iff] at hPM\n    exact hP1 hPM\n#align iff_pid_with_one_nonzero_prime iff_pid_with_one_nonzero_prime\n\n",
 "ideal_eq_span_pow_irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal_eq_span_pow_irreducible {s : ideal R} (hs : s ≠ «expr⊥») {ϖ : R} (hirr : Irreducible ϖ) :\n    ∃ n : ℕ, s = ideal.span {ϖ ^ n} :=\n  by\n  have gen_ne_zero : generator s ≠ 0 :=\n    by\n    rw [ne.def, ← eq_bot_iff_generator_eq_zero]\n    assumption\n  rcases associated_pow_irreducible gen_ne_zero hirr with ⟨n, u, hnu⟩\n  use n\n  have : span _ = _ := span_singleton_generator s\n  rw [← this, ← hnu, span_singleton_eq_span_singleton]\n  use u\n#align ideal_eq_span_pow_irreducible ideal_eq_span_pow_irreducible\n\n",
 "exists_prime":
 "/-- Uniformisers exist in a DVR -/\ntheorem exists_prime : ∃ ϖ : R, Prime ϖ :=\n  (exists_irreducible R).imp fun _ => principal_ideal_ring.irreducible_iff_prime.1\n#align exists_prime exists_prime\n\n",
 "exists_irreducible":
 "/-- Uniformisers exist in a DVR -/\ntheorem exists_irreducible : ∃ ϖ : R, Irreducible ϖ :=\n  by\n  simp_rw [irreducible_iff_uniformizer]\n  exact (is_principal_ideal_ring.principal <| maximal_ideal R).principal\n#align exists_irreducible exists_irreducible\n\n",
 "eq_unit_mul_pow_irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem eq_unit_mul_pow_irreducible {x : R} (hx : x ≠ 0) {ϖ : R} (hirr : Irreducible ϖ) :\n    ∃ (n : ℕ)(u : «expr ˣ» R), x = u * ϖ ^ n :=\n  by\n  obtain ⟨n, hn⟩ := associated_pow_irreducible hx hirr\n  obtain ⟨u, rfl⟩ := hn.symm\n  use n, u\n  apply mul_comm\n#align eq_unit_mul_pow_irreducible eq_unit_mul_pow_irreducible\n\n",
 "aux_pid_of_ufd_of_unique_irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem aux_pid_of_ufd_of_unique_irreducible (R : Type u) [CommRing R] [IsDomain R] [unique_factorization_monoid R]\n    (h₁ : ∃ p : R, Irreducible p) (h₂ : ∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q) :\n    is_principal_ideal_ring R := by\n  constructor\n  intro I\n  by_cases I0 : I = «expr⊥»\n  · rw [I0]\n    use 0\n    simp only [set.singleton_zero, submodule.span_zero]\n  obtain ⟨x, hxI, hx0⟩ : ∃ x ∈ I, x ≠ (0 : R) := I.ne_bot_iff.mp I0\n  obtain ⟨p, hp, H⟩ := has_unit_mul_pow_irreducible_factorization.of_ufd_of_unique_irreducible h₁ h₂\n  have ex : ∃ n : ℕ, p ^ n ∈ I := by\n    obtain ⟨n, u, rfl⟩ := H hx0\n    refine' ⟨n, _⟩\n    simpa only [Units.mul_inv_cancel_right] using I.mul_mem_right (↑u⁻¹) hxI\n  constructor\n  use p ^ nat.find ex\n  show I = ideal.span _\n  apply le_antisymm\n  · intro r hr\n    by_cases hr0 : r = 0\n    · simp only [hr0, submodule.zero_mem]\n    obtain ⟨n, u, rfl⟩ := H hr0\n    simp only [mem_span_singleton, Units.isUnit, is_unit.dvd_mul_right]\n    apply pow_dvd_pow\n    apply nat.find_min'\n    simpa only [Units.mul_inv_cancel_right] using I.mul_mem_right (↑u⁻¹) hr\n  · erw [submodule.span_singleton_le_iff_mem]\n    exact nat.find_spec ex\n#align aux_pid_of_ufd_of_unique_irreducible aux_pid_of_ufd_of_unique_irreducible\n\n",
 "associated_pow_irreducible":
 "theorem associated_pow_irreducible {x : R} (hx : x ≠ 0) {ϖ : R} (hirr : Irreducible ϖ) :\n    ∃ n : ℕ, Associated x (ϖ ^ n) :=\n  by\n  have : wf_dvd_monoid R := is_noetherian_ring.wf_dvd_monoid\n  cases' wf_dvd_monoid.exists_factors x hx with fx hfx\n  use fx.card\n  have H := hfx.2\n  rw [← Associates.mk_eq_mk_iff_associated] at H⊢\n  rw [← H, ← associates.prod_mk, Associates.mk_pow, ← Multiset.prod_replicate]\n  congr 1\n  rw [Multiset.eq_replicate]\n  simp only [true_and_iff, and_imp, Multiset.card_map, eq_self_iff_true, Multiset.mem_map, exists_imp]\n  rintro _ _ _ rfl\n  rw [Associates.mk_eq_mk_iff_associated]\n  refine' associated_of_irreducible _ _ hirr\n  apply hfx.1\n  assumption\n#align associated_pow_irreducible associated_pow_irreducible\n\n",
 "associated_of_irreducible":
 "theorem associated_of_irreducible {a b : R} (ha : Irreducible a) (hb : Irreducible b) : Associated a b :=\n  by\n  rw [irreducible_iff_uniformizer] at ha hb\n  rw [← span_singleton_eq_span_singleton, ← ha, hb]\n#align associated_of_irreducible associated_of_irreducible\n\n",
 "add_val_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem add_val_zero : add_val R 0 = «expr⊤» :=\n  (add_val R).map_zero\n#align add_val_zero add_val_zero\n\n",
 "add_val_uniformizer":
 "@[simp]\ntheorem add_val_uniformizer {ϖ : R} (hϖ : Irreducible ϖ) : add_val R ϖ = 1 := by\n  simpa only [one_mul, eq_self_iff_true, Units.val_one, pow_one, forall_true_left, Nat.cast_one] using\n    add_val_def ϖ 1 hϖ 1\n#align add_val_uniformizer add_val_uniformizer\n\n",
 "add_val_pow":
 "theorem _root_.irreducible.add_val_pow {ϖ : R} (h : Irreducible ϖ) (n : ℕ) : add_val R (ϖ ^ n) = n := by\n  rw [add_val_pow, add_val_uniformizer h, nsmul_one]\n#align irreducible.add_val_pow irreducible.add_val_pow\n\n",
 "add_val_one":
 "@[simp]\ntheorem add_val_one : add_val R 1 = 0 :=\n  (add_val R).map_one\n#align add_val_one add_val_one\n\n",
 "add_val_mul":
 "@[simp]\ntheorem add_val_mul {a b : R} : add_val R (a * b) = add_val R a + add_val R b :=\n  (add_val R).map_mul _ _\n#align add_val_mul add_val_mul\n\n",
 "add_val_le_iff_dvd":
 "theorem add_val_le_iff_dvd {a b : R} : add_val R a ≤ add_val R b ↔ a ∣ b :=\n  by\n  have hp := Classical.choose_spec (exists_prime R)\n  constructor <;> intro h\n  · by_cases ha0 : a = 0\n    · rw [ha0, add_val_zero, top_le_iff, add_val_eq_top_iff] at h\n      rw [h]\n      apply dvd_zero\n    obtain ⟨n, ha⟩ := associated_pow_irreducible ha0 hp.irreducible\n    rw [add_val, add_valuation_apply, add_valuation_apply, multiplicity_le_multiplicity_iff] at h\n    exact ha.dvd.trans (h n ha.symm.dvd)\n  · rw [add_val, add_valuation_apply, add_valuation_apply]\n    exact multiplicity_le_multiplicity_of_dvd_right h\n#align add_val_le_iff_dvd add_val_le_iff_dvd\n\n",
 "add_val_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem add_val_eq_top_iff {a : R} : add_val R a = «expr⊤» ↔ a = 0 :=\n  by\n  have hi := (Classical.choose_spec (exists_prime R)).irreducible\n  constructor\n  · contrapose\n    intro h\n    obtain ⟨n, ha⟩ := associated_pow_irreducible h hi\n    obtain ⟨u, rfl⟩ := ha.symm\n    rw [mul_comm, add_val_def' u hi n]\n    exact part_enat.coe_ne_top _\n  · rintro rfl\n    exact add_val_zero\n#align add_val_eq_top_iff add_val_eq_top_iff\n\n",
 "add_val_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem add_val_def' (u : «expr ˣ» R) {ϖ : R} (hϖ : Irreducible ϖ) (n : ℕ) : add_val R ((u : R) * ϖ ^ n) = n :=\n  add_val_def _ u hϖ n rfl\n#align add_val_def' add_val_def'\n\n",
 "add_val_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem add_val_def (r : R) (u : «expr ˣ» R) {ϖ : R} (hϖ : Irreducible ϖ) (n : ℕ) (hr : r = u * ϖ ^ n) :\n    add_val R r = n := by\n  rw [add_val, add_valuation_apply, hr,\n    eq_of_associated_left (associated_of_irreducible R hϖ (Classical.choose_spec (exists_prime R)).irreducible),\n    eq_of_associated_right (Associated.symm ⟨u, mul_comm _ _⟩),\n    multiplicity_pow_self_of_prime (principal_ideal_ring.irreducible_iff_prime.1 hϖ)]\n#align add_val_def add_val_def\n\n",
 "add_val_add":
 "theorem add_val_add {a b : R} : min (add_val R a) (add_val R b) ≤ add_val R (a + b) :=\n  (add_val R).map_add _ _\n#align add_val_add add_val_add\n\n"}