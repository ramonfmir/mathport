{"trace_trace_of_basis":
 "theorem trace_trace_of_basis [Algebra S T] [IsScalarTower R S T] {ι κ : Type _} [Finite ι] [Finite κ] (b : Basis ι R S)\n    (c : Basis κ S T) (x : T) : trace R S (trace S T x) = trace R T x :=\n  by\n  haveI := Classical.decEq ι\n  haveI := Classical.decEq κ\n  cases nonempty_fintype ι\n  cases nonempty_fintype κ\n  rw [trace_eq_matrix_trace (b.smul c), trace_eq_matrix_trace b, trace_eq_matrix_trace c, Matrix.trace, Matrix.trace,\n    Matrix.trace, ← Finset.univ_product_univ, Finset.sum_product]\n  refine' Finset.sum_congr rfl fun i _ => _\n  simp only [AlgHom.map_sum, smul_left_mul_matrix, Finset.sum_apply,\n    Matrix.diag,-- The unifier is not smart enough to apply this one by itself:\n      Finset.sum_apply\n      i _ fun y => left_mul_matrix b (left_mul_matrix c x y y)]\n#align trace_trace_of_basis trace_trace_of_basis\n\n",
 "trace_trace":
 "@[simp]\ntheorem trace_trace [Algebra K T] [Algebra L T] [IsScalarTower K L T] [FiniteDimensional K L] [FiniteDimensional L T]\n    (x : T) : trace K L (trace L T x) = trace K T x :=\n  trace_trace_of_basis (Basis.ofVectorSpace K L) (Basis.ofVectorSpace L T) x\n#align trace_trace trace_trace\n\n",
 "trace_prod_apply":
 "@[simp]\ntheorem trace_prod_apply [Module.Free R S] [Module.Free R T] [Module.Finite R S] [Module.Finite R T] (x : S × T) :\n    trace R (S × T) x = trace R S x.fst + trace R T x.snd :=\n  by\n  nontriviality R\n  let f := (lmul R S).to_linear_map.prod_map (lmul R T).to_linear_map\n  have : (lmul R (S × T)).to_linear_map = (prod_map_linear R S T S T R).comp f := LinearMap.ext₂ Prod.mul_def\n  simp_rw [trace, this]\n  exact trace_prod_map' _ _\n#align trace_prod_apply trace_prod_apply\n\n",
 "trace_prod":
 "theorem trace_prod [Module.Free R S] [Module.Free R T] [Module.Finite R S] [Module.Finite R T] :\n    trace R (S × T) = (trace R S).coprod (trace R T) :=\n  LinearMap.ext fun p => by rw [coprod_apply, trace_prod_apply]\n#align trace_prod trace_prod\n\n",
 "trace_matrix_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem trace_matrix_reindex {κ' : Type _} (b : Basis κ A B) (f : «expr ≃ » κ κ') :\n    trace_matrix A (b.reindex f) = reindex f f (trace_matrix A b) :=\n  by\n  ext (x y)\n  simp\n#align trace_matrix_reindex trace_matrix_reindex\n\n",
 "trace_matrix_of_matrix_vec_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem trace_matrix_of_matrix_vec_mul [Fintype κ] (b : κ → B) (P : Matrix κ κ A) :\n    trace_matrix A ((P.map (algebraMap A B)).vec_mul b) =\n      matrix.mul (matrix.mul (matrix.transpose P) (trace_matrix A b)) P :=\n  by\n  ext (α β)\n  rw [trace_matrix_apply, vec_mul, dot_product, vec_mul, dot_product, Matrix.mul_apply, bilin_form.sum_left,\n    Fintype.sum_congr _ _ fun i : κ =>\n      @bilin_form.sum_right _ _ _ _ _ _ _ _ (b i * P.map (algebraMap A B) i α) fun y : κ =>\n        b y * P.map (algebraMap A B) y β,\n    sum_comm]\n  congr ; ext x\n  rw [Matrix.mul_apply, sum_mul]\n  congr ; ext y\n  rw [map_apply, trace_form_apply, mul_comm (b y), ← smul_def]\n  simp only [id.smul_eq_mul, RingHom.id_apply, map_apply, transpose_apply, LinearMap.map_smulₛₗ, trace_form_apply,\n    Algebra.smul_mul_assoc]\n  rw [mul_comm (b x), ← smul_def]\n  ring_nf\n  simp [mul_comm]\n#align trace_matrix_of_matrix_vec_mul trace_matrix_of_matrix_vec_mul\n\n",
 "trace_matrix_of_matrix_mul_vec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem trace_matrix_of_matrix_mul_vec [Fintype κ] (b : κ → B) (P : Matrix κ κ A) :\n    trace_matrix A ((P.map (algebraMap A B)).mul_vec b) =\n      matrix.mul (matrix.mul P (trace_matrix A b)) (matrix.transpose P) :=\n  by\n  refine' AddEquiv.injective (transpose_add_equiv _ _ _) _\n  rw [transpose_add_equiv_apply, transpose_add_equiv_apply, ← vec_mul_transpose, ← transpose_map,\n    trace_matrix_of_matrix_vec_mul, transpose_transpose, transpose_mul, transpose_transpose, transpose_mul]\n#align trace_matrix_of_matrix_mul_vec trace_matrix_of_matrix_mul_vec\n\n",
 "trace_matrix_of_basis_mul_vec":
 "theorem trace_matrix_of_basis_mul_vec (b : Basis ι A B) (z : B) :\n    (trace_matrix A b).mul_vec (b.equiv_fun z) = fun i => trace A B (z * b i) :=\n  by\n  ext i\n  rw [← col_apply ((trace_matrix A b).mul_vec (b.equiv_fun z)) i Unit.unit, col_mul_vec, Matrix.mul_apply, trace_matrix]\n  simp only [col_apply, trace_form_apply]\n  conv_lhs =>\n    congr\n    skip\n    ext\n    rw [mul_comm _ (b.equiv_fun z _), ← smul_eq_mul, of_apply, ← LinearMap.map_smul]\n  rw [← LinearMap.map_sum]\n  congr\n  conv_lhs =>\n    congr\n    skip\n    ext\n    rw [← mul_smul_comm]\n  rw [← Finset.mul_sum, mul_comm z]\n  congr\n  rw [b.sum_equiv_fun]\n#align trace_matrix_of_basis_mul_vec trace_matrix_of_basis_mul_vec\n\n",
 "trace_matrix_of_basis":
 "theorem trace_matrix_of_basis [Fintype κ] [DecidableEq κ] (b : Basis κ A B) :\n    trace_matrix A b = bilin_form.to_matrix b (trace_form A B) :=\n  by\n  ext (i j)\n  rw [trace_matrix_apply, trace_form_apply, trace_form_to_matrix]\n#align trace_matrix_of_basis trace_matrix_of_basis\n\n",
 "trace_matrix_eq_embeddings_matrix_reindex_mul_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem trace_matrix_eq_embeddings_matrix_reindex_mul_trans [Fintype κ] (e : «expr ≃ » κ («expr →ₐ[ ] » L K E)) :\n    (trace_matrix K b).map (algebraMap K E) =\n      matrix.mul (embeddings_matrix_reindex K E b e) (matrix.transpose (embeddings_matrix_reindex K E b e)) :=\n  by\n  rw [trace_matrix_eq_embeddings_matrix_mul_trans, embeddings_matrix_reindex, reindex_apply, transpose_submatrix, ←\n    submatrix_mul_transpose_submatrix, ← Equiv.coe_refl, Equiv.refl_symm]\n#align trace_matrix_eq_embeddings_matrix_reindex_mul_trans trace_matrix_eq_embeddings_matrix_reindex_mul_trans\n\n",
 "trace_matrix_eq_embeddings_matrix_mul_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem trace_matrix_eq_embeddings_matrix_mul_trans :\n    (trace_matrix K b).map (algebraMap K E) =\n      matrix.mul (embeddings_matrix K E b) (matrix.transpose (embeddings_matrix K E b)) :=\n  by\n  ext (i j)\n  simp [trace_eq_sum_embeddings, embeddings_matrix, Matrix.mul_apply]\n#align trace_matrix_eq_embeddings_matrix_mul_trans trace_matrix_eq_embeddings_matrix_mul_trans\n\n",
 "trace_matrix_apply":
 "-- TODO: set as an equation lemma for `trace_matrix`, see mathlib4#3024\n@[simp]\ntheorem trace_matrix_apply (b : κ → B) (i j) : trace_matrix A b i j = trace_form A B (b i) (b j) :=\n  rfl\n#align trace_matrix_apply trace_matrix_apply\n\n",
 "trace_gen_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem trace_gen_eq_zero {x : L} (hx : ¬is_integral K x) :\n    algebra.trace K\n        («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n        (adjoin_simple.gen K x) =\n      0 :=\n  by\n  rw [trace_eq_zero_of_not_exists_basis, LinearMap.zero_apply]\n  contrapose! hx\n  obtain ⟨s, ⟨b⟩⟩ := hx\n  refine'\n    is_integral_of_mem_of_fg\n      («expr ⟮ ,⟯» K\n          \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").to_subalgebra\n      _ x _\n  · exact (Submodule.fg_iff_finiteDimensional _).mpr (FiniteDimensional.of_fintype_basis b)\n  · exact subset_adjoin K _ (Set.mem_singleton x)\n#align trace_gen_eq_zero trace_gen_eq_zero\n\n",
 "trace_gen_eq_sum_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem trace_gen_eq_sum_roots (x : L) (hf : (minpoly K x).splits (algebraMap K F)) :\n    algebraMap K F\n        (trace K («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          (adjoin_simple.gen K x)) =\n      ((minpoly K x).map (algebraMap K F)).roots.sum :=\n  by\n  have injKxL :=\n    (algebraMap («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n        L).injective\n  by_cases hx : is_integral K x\n  swap\n  · simp [minpoly.eq_zero hx, trace_gen_eq_zero hx]\n  have hx' : is_integral K (adjoin_simple.gen K x) :=\n    by\n    rwa [← is_integral_algebra_map_iff injKxL, adjoin_simple.algebra_map_gen]\n    infer_instance\n  rw [← adjoin.power_basis_gen hx, (adjoin.power_basis hx).trace_gen_eq_sum_roots] <;>\n      rw [adjoin.power_basis_gen hx, minpoly.eq_of_algebra_map_eq injKxL hx'] <;>\n    try simp only [adjoin_simple.algebra_map_gen _ _]\n  exact hf\n#align trace_gen_eq_sum_roots trace_gen_eq_sum_roots\n\n",
 "trace_gen_eq_next_coeff_minpoly":
 "/-- Given `pb : power_basis K S`, the trace of `pb.gen` is `-(minpoly K pb.gen).next_coeff`. -/\ntheorem power_basis.trace_gen_eq_next_coeff_minpoly [Nontrivial S] (pb : power_basis K S) :\n    algebra.trace K S pb.gen = -(minpoly K pb.gen).next_coeff :=\n  by\n  have d_pos : 0 < pb.dim := power_basis.dim_pos pb\n  have d_pos' : 0 < (minpoly K pb.gen).nat_degree := by simpa\n  haveI : Nonempty (Fin pb.dim) := ⟨⟨0, d_pos⟩⟩\n  rw [trace_eq_matrix_trace pb.basis, trace_eq_neg_charpoly_coeff, charpoly_left_mul_matrix, ← pb.nat_degree_minpoly,\n    Fintype.card_fin, ← next_coeff_of_pos_nat_degree _ d_pos']\n#align power_basis.trace_gen_eq_next_coeff_minpoly power_basis.trace_gen_eq_next_coeff_minpoly\n\n",
 "trace_form_to_matrix_power_basis":
 "theorem trace_form_to_matrix_power_basis (h : power_basis R S) :\n    bilin_form.to_matrix h.basis (trace_form R S) = of fun i j => trace R S (h.gen ^ (↑i + ↑j : ℕ)) :=\n  by\n  ext\n  rw [trace_form_to_matrix, of_apply, pow_add, h.basis_eq_pow, h.basis_eq_pow]\n#align trace_form_to_matrix_power_basis trace_form_to_matrix_power_basis\n\n",
 "trace_form_to_matrix":
 "theorem trace_form_to_matrix [DecidableEq ι] (i j) :\n    bilin_form.to_matrix b (trace_form R S) i j = trace R S (b i * b j) := by\n  rw [bilin_form.to_matrix_apply, trace_form_apply]\n#align trace_form_to_matrix trace_form_to_matrix\n\n",
 "trace_form_nondegenerate":
 "theorem trace_form_nondegenerate [FiniteDimensional K L] [is_separable K L] : (trace_form K L).nondegenerate :=\n  bilin_form.nondegenerate_of_det_ne_zero (trace_form K L) _ (det_trace_form_ne_zero (FiniteDimensional.finBasis K L))\n#align trace_form_nondegenerate trace_form_nondegenerate\n\n",
 "trace_form_is_symm":
 "theorem trace_form_is_symm : (trace_form R S).is_symm := fun x y => congr_arg (trace R S) (mul_comm _ _)\n#align trace_form_is_symm trace_form_is_symm\n\n",
 "trace_form_apply":
 "-- This is a nicer lemma than the one produced by `@[simps] def trace_form`.\n@[simp]\ntheorem trace_form_apply (x y : S) : trace_form R S x y = trace R S (x * y) :=\n  rfl\n#align trace_form_apply trace_form_apply\n\n",
 "trace_eq_zero_of_not_exists_basis":
 "theorem trace_eq_zero_of_not_exists_basis (h : ¬∃ s : Finset S, Nonempty (Basis s R S)) : trace R S = 0 :=\n  by\n  ext s\n  simp [trace_apply, linear_map.trace, h]\n#align trace_eq_zero_of_not_exists_basis trace_eq_zero_of_not_exists_basis\n\n",
 "trace_eq_trace_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem trace_eq_trace_adjoin [FiniteDimensional K L] (x : L) :\n    algebra.trace K L x =\n      «expr • »\n        (finrank («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          L)\n        (trace K («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          (adjoin_simple.gen K x)) :=\n  by\n  rw [←\n    @trace_trace _ _ K\n      («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") _ _ _ _ _ _\n      _ _ x]\n  conv in x => rw [← intermediate_field.adjoin_simple.algebra_map_gen K x]\n  rw [trace_algebra_map, LinearMap.map_smul_of_tower]\n#align trace_eq_trace_adjoin trace_eq_trace_adjoin\n\n",
 "trace_eq_sum_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem trace_eq_sum_roots [FiniteDimensional K L] {x : L} (hF : (minpoly K x).splits (algebraMap K F)) :\n    algebraMap K F (algebra.trace K L x) =\n      «expr • »\n        (finrank («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          L)\n        ((minpoly K x).map (algebraMap K _)).roots.sum :=\n  by\n  rw [trace_eq_trace_adjoin K x, Algebra.smul_def, RingHom.map_mul, ← Algebra.smul_def,\n    intermediate_field.adjoin_simple.trace_gen_eq_sum_roots _ hF, IsScalarTower.algebraMap_smul]\n#align trace_eq_sum_roots trace_eq_sum_roots\n\n",
 "trace_eq_sum_embeddings_gen":
 "theorem trace_eq_sum_embeddings_gen (pb : power_basis K L) (hE : (minpoly K pb.gen).splits (algebraMap K E))\n    (hfx : (minpoly K pb.gen).separable) :\n    algebraMap K E (algebra.trace K L pb.gen) = (@Finset.univ (power_basis.alg_hom.fintype pb)).sum fun σ => σ pb.gen :=\n  by\n  letI := Classical.decEq E\n  rw [pb.trace_gen_eq_sum_roots hE, Fintype.sum_equiv pb.lift_equiv', Finset.sum_mem_multiset,\n    Finset.sum_eq_multiset_sum, Multiset.toFinset_val, multiset.dedup_eq_self.mpr _, Multiset.map_id]\n  · exact nodup_roots ((separable_map _).mpr hfx)\n  · intro x\n    rfl\n  · intro σ\n    rw [power_basis.lift_equiv'_apply_coe, id.def]\n#align trace_eq_sum_embeddings_gen trace_eq_sum_embeddings_gen\n\n",
 "trace_eq_sum_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem trace_eq_sum_embeddings [FiniteDimensional K L] [is_separable K L] {x : L} :\n    algebraMap K E (algebra.trace K L x) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (σ x) :=\n  by\n  have hx := is_separable.is_integral K x\n  rw [trace_eq_trace_adjoin K x, Algebra.smul_def, RingHom.map_mul, ← adjoin.power_basis_gen hx,\n    trace_eq_sum_embeddings_gen E (adjoin.power_basis hx) (is_alg_closed.splits_codomain _), ← Algebra.smul_def,\n    algebraMap_smul]\n  · exact (sum_embeddings_eq_finrank_mul L E (adjoin.power_basis hx)).symm\n  · haveI :=\n      is_separable_tower_bot_of_is_separable K\n        («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") L\n    exact is_separable.separable K _\n#align trace_eq_sum_embeddings trace_eq_sum_embeddings\n\n",
 "trace_eq_sum_automorphisms":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem trace_eq_sum_automorphisms (x : L) [FiniteDimensional K L] [is_galois K L] :\n    algebraMap K L (algebra.trace K L x) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (σ x) :=\n  by\n  apply NoZeroSMulDivisors.algebraMap_injective L (algebraic_closure L)\n  rw [map_sum (algebraMap L (algebraic_closure L))]\n  rw [← Fintype.sum_equiv (normal.alg_hom_equiv_aut K (algebraic_closure L) L)]\n  · rw [← trace_eq_sum_embeddings (algebraic_closure L)]\n    · simp only [algebra_map_eq_smul_one, smul_one_smul]\n    · exact is_galois.to_is_separable\n  · intro σ\n    simp only [normal.alg_hom_equiv_aut, alg_hom.restrict_normal', Equiv.coe_fn_mk, AlgEquiv.coe_ofBijective,\n      alg_hom.restrict_normal_commutes, id.map_eq_id, RingHom.id_apply]\n#align trace_eq_sum_automorphisms trace_eq_sum_automorphisms\n\n",
 "trace_eq_matrix_trace":
 "-- Can't be a `simp` lemma because it depends on a choice of basis\ntheorem trace_eq_matrix_trace [DecidableEq ι] (b : Basis ι R S) (s : S) :\n    trace R S s = Matrix.trace (Algebra.leftMulMatrix b s) :=\n  by\n  rw [trace_apply, linear_map.trace_eq_matrix_trace _ b, ← to_matrix_lmul_eq]\n  rfl\n#align trace_eq_matrix_trace trace_eq_matrix_trace\n\n",
 "trace_comp_trace_of_basis":
 "theorem trace_comp_trace_of_basis [Algebra S T] [IsScalarTower R S T] {ι κ : Type _} [Finite ι] [Fintype κ]\n    (b : Basis ι R S) (c : Basis κ S T) : (trace R S).comp ((trace S T).restrict_scalars R) = trace R T :=\n  by\n  ext\n  rw [LinearMap.comp_apply, LinearMap.restrictScalars_apply, trace_trace_of_basis b c]\n#align trace_comp_trace_of_basis trace_comp_trace_of_basis\n\n",
 "trace_comp_trace":
 "@[simp]\ntheorem trace_comp_trace [Algebra K T] [Algebra L T] [IsScalarTower K L T] [FiniteDimensional K L]\n    [FiniteDimensional L T] : (trace K L).comp ((trace L T).restrict_scalars K) = trace K T :=\n  by\n  ext\n  rw [LinearMap.comp_apply, LinearMap.restrictScalars_apply, trace_trace]\n#align trace_comp_trace trace_comp_trace\n\n",
 "trace_apply":
 "/-\nCopyright (c) 2020 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n-- Not a `simp` lemma since there are more interesting ways to rewrite `trace R S x`,\n-- for example `trace_trace`\ntheorem trace_apply (x) : trace R S x = linear_map.trace R S (lmul R S x) :=\n  rfl\n#align trace_apply trace_apply\n\n",
 "trace_algebra_map_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `x` is in the base field `K`, then the trace is `[L : K] * x`. -/\ntheorem trace_algebra_map_of_basis (x : R) : trace R S (algebraMap R S x) = «expr • » (Fintype.card ι) x :=\n  by\n  haveI := Classical.decEq ι\n  rw [trace_apply, linear_map.trace_eq_matrix_trace R b, Matrix.trace]\n  convert Finset.sum_const _\n  ext i\n  simp [-coe_lmul_eq_mul]\n#align trace_algebra_map_of_basis trace_algebra_map_of_basis\n\n",
 "trace_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `x` is in the base field `K`, then the trace is `[L : K] * x`.\n\n(If `L` is not finite-dimensional over `K`, then `trace` and `finrank` return `0`.)\n-/\n@[simp]\ntheorem trace_algebra_map (x : K) : trace K L (algebraMap K L x) = «expr • » (finrank K L) x :=\n  by\n  by_cases H : ∃ s : Finset L, Nonempty (Basis s K L)\n  · rw [trace_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some]\n  · simp [trace_eq_zero_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis_finset H]\n#align trace_algebra_map trace_algebra_map\n\n",
 "sum_embeddings_eq_finrank_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem sum_embeddings_eq_finrank_mul [FiniteDimensional K F] [is_separable K F] (pb : power_basis K L) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (σ (algebraMap L F pb.gen)) =\n      «expr • » (finrank L F)\n        ((@Finset.univ (power_basis.alg_hom.fintype pb)).sum fun σ : «expr →ₐ[ ] » L K E => σ pb.gen) :=\n  by\n  haveI : FiniteDimensional L F := FiniteDimensional.right K L F\n  haveI : is_separable L F := is_separable_tower_top_of_is_separable K L F\n  letI : Fintype («expr →ₐ[ ] » L K E) := power_basis.alg_hom.fintype pb\n  letI : ∀ f : «expr →ₐ[ ] » L K E, Fintype (@AlgHom L F E _ _ _ _ f.to_ring_hom.to_algebra) := _\n  -- will be solved by unification\n  rw [Fintype.sum_equiv algHomEquivSigma (fun σ : «expr →ₐ[ ] » F K E => _) fun σ => σ.1 pb.gen, ←\n    Finset.univ_sigma_univ, Finset.sum_sigma, ← Finset.sum_nsmul]\n  refine' Finset.sum_congr rfl fun σ _ => _\n  · letI : Algebra L E := σ.to_ring_hom.to_algebra\n    simp only [Finset.sum_const, Finset.card_univ]\n    rw [alg_hom.card L F E]\n  · intro σ\n    simp only [algHomEquivSigma, Equiv.coe_fn_mk, AlgHom.restrictDomain, AlgHom.comp_apply, IsScalarTower.coe_toAlgHom']\n#align sum_embeddings_eq_finrank_mul sum_embeddings_eq_finrank_mul\n\n",
 "is_integral_trace":
 "theorem algebra.is_integral_trace [FiniteDimensional L F] {x : F} (hx : is_integral R x) :\n    is_integral R (algebra.trace L F x) :=\n  by\n  have hx' : is_integral L x := is_integral_of_is_scalar_tower hx\n  rw [← is_integral_algebra_map_iff (algebraMap L (algebraic_closure F)).injective, trace_eq_sum_roots]\n  · refine' (is_integral.multiset_sum _).nsmul _\n    intro y hy\n    rw [mem_roots_map (minpoly.ne_zero hx')] at hy\n    use minpoly R x, minpoly.monic hx\n    rw [← aeval_def] at hy⊢\n    exact minpoly.aeval_of_is_scalar_tower R x y hy\n  · apply is_alg_closed.splits_codomain\n  · infer_instance\n#align algebra.is_integral_trace algebra.is_integral_trace\n\n",
 "embeddings_matrix_reindex_eq_vandermonde":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem embeddings_matrix_reindex_eq_vandermonde (pb : power_basis A B)\n    (e : «expr ≃ » (Fin pb.dim) («expr →ₐ[ ] » B A C)) :\n    embeddings_matrix_reindex A C pb.basis e = matrix.transpose (vandermonde fun i => e i pb.gen) :=\n  by\n  ext (i j)\n  simp [embeddings_matrix_reindex, embeddings_matrix]\n#align embeddings_matrix_reindex_eq_vandermonde embeddings_matrix_reindex_eq_vandermonde\n\n",
 "embeddings_matrix_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n-- TODO: set as an equation lemma for `embeddings_matrix`, see mathlib4#3024\n@[simp]\ntheorem embeddings_matrix_apply (b : κ → B) (i) (σ : «expr →ₐ[ ] » B A C) : embeddings_matrix A C b i σ = σ (b i) :=\n  rfl\n#align embeddings_matrix_apply embeddings_matrix_apply\n\n",
 "det_trace_matrix_ne_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem det_trace_matrix_ne_zero' [is_separable K L] : det (trace_matrix K pb.basis) ≠ 0 :=\n  by\n  suffices algebraMap K (algebraic_closure L) (det (trace_matrix K pb.basis)) ≠ 0\n    by\n    refine' mt (fun ht => _) this\n    rw [ht, RingHom.map_zero]\n  haveI : FiniteDimensional K L := pb.finite_dimensional\n  let e : «expr ≃ » (Fin pb.dim) («expr →ₐ[ ] » L K (algebraic_closure L)) := (Fintype.equivFinOfCardEq _).symm\n  rw [RingHom.map_det, ring_hom.map_matrix_apply, trace_matrix_eq_embeddings_matrix_reindex_mul_trans K _ _ e,\n    embeddings_matrix_reindex_eq_vandermonde, det_mul, det_transpose]\n  refine' mt mul_self_eq_zero.mp _\n  · simp only [det_vandermonde, Finset.prod_eq_zero_iff, not_exists, sub_eq_zero]\n    intro i _ j hij h\n    exact (finset.mem_Ioi.mp hij).ne' (e.injective <| pb.alg_hom_ext h)\n  · rw [alg_hom.card, pb.finrank]\n#align det_trace_matrix_ne_zero' det_trace_matrix_ne_zero'\n\n",
 "det_trace_form_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem det_trace_form_ne_zero [is_separable K L] [DecidableEq ι] (b : Basis ι K L) :\n    det (bilin_form.to_matrix b (trace_form K L)) ≠ 0 :=\n  by\n  haveI : FiniteDimensional K L := FiniteDimensional.of_fintype_basis b\n  let pb : power_basis K L := field.power_basis_of_finite_of_separable _ _\n  rw [← bilin_form.to_matrix_mul_basis_to_matrix pb.basis b, ← det_comm' (pb.basis.to_matrix_mul_to_matrix_flip b) _, ←\n    Matrix.mul_assoc, det_mul]\n  swap; · apply Basis.toMatrix_mul_toMatrix_flip\n  refine'\n    mul_ne_zero\n      (isUnit_of_mul_eq_one _ (matrix.mul (matrix.transpose (b.to_matrix pb.basis)) (b.to_matrix pb.basis)).det\n          _).ne_zero\n      _\n  ·\n    calc\n      (matrix.mul (pb.basis.to_matrix b) (matrix.transpose (pb.basis.to_matrix b))).det *\n            (matrix.mul (matrix.transpose (b.to_matrix pb.basis)) (b.to_matrix pb.basis)).det =\n          (matrix.mul\n              (matrix.mul (pb.basis.to_matrix b)\n                (matrix.transpose (matrix.mul (b.to_matrix pb.basis) (pb.basis.to_matrix b))))\n              (b.to_matrix pb.basis)).det :=\n        by simp only [← det_mul, Matrix.mul_assoc, Matrix.transpose_mul]\n      _ = 1 := by simp only [Basis.toMatrix_mul_toMatrix_flip, Matrix.transpose_one, Matrix.mul_one, Matrix.det_one]\n      \n  simpa only [trace_matrix_of_basis] using det_trace_matrix_ne_zero' pb\n#align det_trace_form_ne_zero det_trace_form_ne_zero\n\n"}