{"mem_lifts_of_monic_of_dvd_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_lifts_of_monic_of_dvd_map {f : polynomial R} (hf : f.monic) {g : polynomial K} (hg : g.monic)\n    (hd : g ∣ f.map (algebra_map R K)) : g ∈ lifts (algebra_map (integral_closure R K) K) :=\n  by\n  haveI : IsScalarTower R K g.splitting_field := splitting_field_aux.is_scalar_tower _ _ _\n  have :=\n    mem_lift_of_splits_of_roots_mem_range (integral_closure R g.splitting_field)\n      ((splits_id_iff_splits _).2 <| splitting_field.splits g) (hg.map _) fun a ha =>\n      (set_like.ext_iff.mp (integral_closure R g.splitting_field).range_algebra_map _).mpr <|\n        roots_mem_integral_closure hf _\n  · rw [lifts_iff_coeff_lifts, ← ring_hom.coe_range, subalgebra.range_algebra_map] at this\n    refine' (lifts_iff_coeff_lifts _).2 fun n => _\n    rw [← ring_hom.coe_range, subalgebra.range_algebra_map]\n    obtain ⟨p, hp, he⟩ := set_like.mem_coe.mp (this n)\n    use p, hp\n    rw [is_scalar_tower.algebra_map_eq R K, coeff_map, ← eval₂_map, eval₂_at_apply] at he\n    rw [eval₂_eq_eval_map]\n    apply (injective_iff_map_eq_zero _).1 _ _ he\n    · apply RingHom.injective\n  rw [is_scalar_tower.algebra_map_eq R K _, ← map_map]\n  refine' Multiset.mem_of_le (roots.le_of_dvd ((hf.map _).map _).ne_zero _) ha\n  · infer_instance\n  · exact map_dvd (algebra_map K g.splitting_field) hd\n  · apply splitting_field_aux.is_scalar_tower\n#align mem_lifts_of_monic_of_dvd_map mem_lifts_of_monic_of_dvd_map\n\n",
 "is_integrally_closed_of_finite_extension":
 "-- Can't be an instance because you need to supply `K`.\ntheorem is_integrally_closed_of_finite_extension [finite_dimensional K L] :\n    is_integrally_closed (integral_closure R L) :=\n  letI : is_fraction_ring (integral_closure R L) L := is_fraction_ring_of_finite_extension K L\n  (integral_closure_eq_bot_iff L).mp integral_closure_idem\n#align is_integrally_closed_of_finite_extension is_integrally_closed_of_finite_extension\n\n",
 "is_integrally_closed_iff_is_integral_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- `R` is integrally closed iff it is the integral closure of itself in its field of fractions. -/\ntheorem is_integrally_closed_iff_is_integral_closure : is_integrally_closed R ↔ is_integral_closure R R K :=\n  (is_integrally_closed_iff K).trans <|\n    by\n    let e : «expr ≃ₐ[ ] » K R (fraction_ring R) := is_localization.alg_equiv (non_zero_divisors R) _ _\n    constructor\n    · intro cl\n      refine' ⟨is_fraction_ring.injective _ _, fun x => ⟨cl, _⟩⟩\n      rintro ⟨y, y_eq⟩\n      rw [← y_eq]\n      exact is_integral_algebra_map\n    · rintro ⟨-, cl⟩ x hx\n      exact cl.mp hx\n#align is_integrally_closed_iff_is_integral_closure is_integrally_closed_iff_is_integral_closure\n\n",
 "is_integrally_closed_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n/-- `R` is integrally closed iff all integral elements of its fraction field `K`\nare also elements of `R`. -/\ntheorem is_integrally_closed_iff : is_integrally_closed R ↔ ∀ {x : K}, is_integral R x → ∃ y, algebra_map R K y = x :=\n  by\n  let e : «expr ≃ₐ[ ] » K R (fraction_ring R) := is_localization.alg_equiv (non_zero_divisors R) _ _\n  constructor\n  · rintro ⟨cl⟩\n    refine' fun x hx => _\n    obtain ⟨y, hy⟩ := cl ((is_integral_alg_equiv e).mpr hx)\n    exact ⟨y, e.algebra_map_eq_apply.mp hy⟩\n  · rintro cl\n    refine' ⟨fun x hx => _⟩\n    obtain ⟨y, hy⟩ := cl ((is_integral_alg_equiv e.symm).mpr hx)\n    exact ⟨y, e.symm.algebra_map_eq_apply.mp hy⟩\n#align is_integrally_closed_iff is_integrally_closed_iff\n\n",
 "is_integral_iff":
 "theorem is_integral_iff {x : K} : is_integral R x ↔ ∃ y : R, algebra_map R K y = x :=\n  is_integral_closure.is_integral_iff\n#align is_integral_iff is_integral_iff\n\n",
 "integral_closure_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem integral_closure_eq_bot_iff : integral_closure R K = «expr⊥» ↔ is_integrally_closed R :=\n  by\n  refine' eq_bot_iff.trans _\n  constructor\n  · rw [is_integrally_closed_iff K]\n    intro h x hx\n    exact set.mem_range.mp (algebra.mem_bot.mp (h hx))\n    assumption\n  · intro h x hx\n    rw [algebra.mem_bot, Set.mem_range]\n    exact is_integral_iff.mp hx\n#align integral_closure_eq_bot_iff integral_closure_eq_bot_iff\n\n",
 "integral_closure_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem integral_closure_eq_bot : integral_closure R K = «expr⊥» :=\n  (integral_closure_eq_bot_iff K).mpr ‹_›\n#align integral_closure_eq_bot integral_closure_eq_bot\n\n",
 "exists_algebra_map_eq_of_pow_mem_subalgebra":
 "theorem exists_algebra_map_eq_of_pow_mem_subalgebra {K : Type _} [Field K] [algebra R K] {S : subalgebra R K}\n    [is_integrally_closed S] [is_fraction_ring S K] {x : K} {n : ℕ} (hn : 0 < n) (hx : x ^ n ∈ S) :\n    ∃ y : S, algebra_map S K y = x :=\n  exists_algebra_map_eq_of_is_integral_pow hn <| is_integral_iff.mpr ⟨⟨x ^ n, hx⟩, rfl⟩\n#align exists_algebra_map_eq_of_pow_mem_subalgebra exists_algebra_map_eq_of_pow_mem_subalgebra\n\n",
 "exists_algebra_map_eq_of_is_integral_pow":
 "theorem exists_algebra_map_eq_of_is_integral_pow {x : K} {n : ℕ} (hn : 0 < n) (hx : is_integral R <| x ^ n) :\n    ∃ y : R, algebra_map R K y = x :=\n  is_integral_iff.mp <| is_integral_of_pow hn hx\n#align exists_algebra_map_eq_of_is_integral_pow exists_algebra_map_eq_of_is_integral_pow\n\n",
 "eq_map_mul_C_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `K = Frac(R)` and `g : K[X]` divides a monic polynomial with coefficients in `R`, then\n    `g * (C g.leading_coeff⁻¹)` has coefficients in `R` -/\ntheorem eq_map_mul_C_of_dvd [is_integrally_closed R] {f : polynomial R} (hf : f.monic) {g : polynomial K}\n    (hg : g ∣ f.map (algebra_map R K)) : ∃ g' : polynomial R, g'.map (algebra_map R K) * (C <| leading_coeff g) = g :=\n  by\n  have g_ne_0 : g ≠ 0 := ne_zero_of_dvd_ne_zero (monic.ne_zero <| hf.map (algebra_map R K)) hg\n  suffices lem : ∃ g' : polynomial R, g'.map (algebra_map R K) = g * C g.leading_coeff⁻¹\n  · obtain ⟨g', hg'⟩ := lem\n    use g'\n    rw [hg', mul_assoc, ← C_mul, inv_mul_cancel (leading_coeff_ne_zero.mpr g_ne_0), C_1, mul_one]\n  have g_mul_dvd : g * C g.leading_coeff⁻¹ ∣ f.map (algebra_map R K) :=\n    by\n    rwa [Associated.dvd_iff_dvd_left (show Associated (g * C g.leading_coeff⁻¹) g from _)]\n    rw [associated_mul_isUnit_left_iff]\n    exact is_unit_C.mpr (inv_ne_zero <| leading_coeff_ne_zero.mpr g_ne_0).is_unit\n  let algeq :=\n    (subalgebra.equiv_of_eq _ _ <| integral_closure_eq_bot R _).trans\n      (algebra.bot_equiv_of_injective <| is_fraction_ring.injective R <| K)\n  have : (algebra_map R _).comp algeq.to_alg_hom.to_ring_hom = (integral_closure R _).to_subring.subtype :=\n    by\n    ext\n    conv_rhs => rw [← algeq.symm_apply_apply x]\n    rfl\n  have H := (mem_lifts _).1 (mem_lifts_of_monic_of_dvd_map K hf (monic_mul_leading_coeff_inv g_ne_0) g_mul_dvd)\n  refine' ⟨map algeq.to_alg_hom.to_ring_hom _, _⟩\n  use Classical.choose H\n  rw [map_map, this]\n  exact Classical.choose_spec H\n#align eq_map_mul_C_of_dvd eq_map_mul_C_of_dvd\n\n"}