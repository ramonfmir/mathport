{"to_principal_ideal_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem to_principal_ideal_eq_iff {I : «expr ˣ» (fractional_ideal (non_zero_divisors R) K)} {x : «expr ˣ» K} :\n    to_principal_ideal R K x = I ↔ span_singleton (non_zero_divisors R) (x : K) = I :=\n  by\n  simp only [to_principal_ideal]\n  exact Units.ext_iff\n#align to_principal_ideal_eq_iff to_principal_ideal_eq_iff\n\n",
 "mk_mk0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem class_group.mk_mk0 [is_dedekind_domain R] (I : non_zero_divisors (Ideal R)) :\n    class_group.mk (fractional_ideal.mk0 K I) = class_group.mk0 I := by\n  rw [class_group.mk0, MonoidHom.comp_apply, ← class_group.mk_canonical_equiv K (FractionRing R),\n    fractional_ideal.map_canonical_equiv_mk0]\n#align class_group.mk_mk0 class_group.mk_mk0\n\n",
 "mk_eq_one_of_coe_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem class_group.mk_eq_one_of_coe_ideal {I : «expr ˣ» (fractional_ideal (non_zero_divisors R) <| FractionRing R)}\n    {I' : Ideal R} (hI : (I : fractional_ideal (non_zero_divisors R) <| FractionRing R) = I') :\n    class_group.mk I = 1 ↔ ∃ x : R, x ≠ 0 ∧ I' = Ideal.span {x} :=\n  by\n  rw [← map_one class_group.mk, class_group.mk_eq_mk_of_coe_ideal hI (_ : _ = ↑(«expr⊤»))]\n  any_goals rfl\n  constructor\n  · rintro ⟨x, y, hx, hy, h⟩\n    rw [Ideal.mul_top] at h\n    rcases ideal.mem_span_singleton_mul.mp ((Ideal.span_singleton_le_iff_mem _).mp h.ge) with ⟨i, hi, rfl⟩\n    rw [← Ideal.span_singleton_mul_span_singleton, Ideal.span_singleton_mul_right_inj hx] at h\n    exact ⟨i, right_ne_zero_of_mul hy, h⟩\n  · rintro ⟨x, hx, rfl⟩\n    exact ⟨1, x, one_ne_zero, hx, by rw [Ideal.span_singleton_one, Ideal.top_mul, Ideal.mul_top]⟩\n#align class_group.mk_eq_one_of_coe_ideal class_group.mk_eq_one_of_coe_ideal\n\n",
 "mk_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem class_group.mk_eq_one_iff {I : «expr ˣ» (fractional_ideal (non_zero_divisors R) K)} :\n    class_group.mk I = 1 ↔ (I : Submodule R K).is_principal :=\n  by\n  simp only [← (class_group.equiv K).injective.eq_iff, _root_.map_one, class_group.equiv_mk, QuotientGroup.mk'_apply,\n    QuotientGroup.eq_one_iff, MonoidHom.mem_range, Units.ext_iff, coe_to_principal_ideal, Units.coe_mapEquiv,\n    fractional_ideal.canonical_equiv_self, coe_coe, RingEquiv.coe_mulEquiv_refl, MulEquiv.refl_apply]\n  refine' ⟨fun ⟨x, hx⟩ => ⟨⟨x, by rw [← hx, coe_span_singleton]⟩⟩, _⟩\n  intro hI\n  obtain ⟨x, hx⟩ := @Submodule.IsPrincipal.principal _ _ _ _ _ _ hI\n  have hx' : (I : fractional_ideal (non_zero_divisors R) K) = span_singleton (non_zero_divisors R) x :=\n    by\n    apply Subtype.coe_injective\n    rw [hx, coe_span_singleton]\n  refine' ⟨Units.mk0 x _, _⟩\n  · intro x_eq\n    apply Units.ne_zero I\n    simp [hx', x_eq]\n  simp [hx']\n#align class_group.mk_eq_one_iff class_group.mk_eq_one_iff\n\n",
 "mk_eq_mk_of_coe_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem class_group.mk_eq_mk_of_coe_ideal {I J : «expr ˣ» (fractional_ideal (non_zero_divisors R) <| FractionRing R)}\n    {I' J' : Ideal R} (hI : (I : fractional_ideal (non_zero_divisors R) <| FractionRing R) = I')\n    (hJ : (J : fractional_ideal (non_zero_divisors R) <| FractionRing R) = J') :\n    class_group.mk I = class_group.mk J ↔ ∃ x y : R, x ≠ 0 ∧ y ≠ 0 ∧ Ideal.span {x} * I' = Ideal.span {y} * J' :=\n  by\n  rw [class_group.mk_eq_mk]\n  constructor\n  · rintro ⟨x, rfl⟩\n    rw [Units.val_mul, hI, coe_to_principal_ideal, mul_comm, span_singleton_mul_coe_ideal_eq_coe_ideal] at hJ\n    exact ⟨_, _, sec_fst_ne_zero le_rfl x.ne_zero, sec_snd_ne_zero le_rfl ↑x, hJ⟩\n  · rintro ⟨x, y, hx, hy, h⟩\n    constructor\n    rw [mul_comm, ← Units.eq_iff, Units.val_mul, coe_to_principal_ideal]\n    convert(mk'_mul_coe_ideal_eq_coe_ideal (FractionRing R) <| mem_nonZeroDivisors_of_ne_zero hy).2 h\n    apply (Ne.isUnit _).unit_spec\n    rwa [ne, mk'_eq_zero_iff_eq_zero]\n#align class_group.mk_eq_mk_of_coe_ideal class_group.mk_eq_mk_of_coe_ideal\n\n",
 "mk_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem class_group.mk_eq_mk {I J : «expr ˣ» (fractional_ideal (non_zero_divisors R) <| FractionRing R)} :\n    class_group.mk I = class_group.mk J ↔\n      ∃ x : «expr ˣ» (FractionRing R), I * to_principal_ideal R (FractionRing R) x = J :=\n  by\n  erw [QuotientGroup.mk'_eq_mk', canonical_equiv_self, Units.map_id, Set.exists_range_iff]\n  rfl\n#align class_group.mk_eq_mk class_group.mk_eq_mk\n\n",
 "mk_canonical_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem class_group.mk_canonical_equiv (K' : Type _) [Field K'] [Algebra R K'] [IsFractionRing R K']\n    (I : «expr ˣ» (fractional_ideal (non_zero_divisors R) K)) :\n    class_group.mk\n        (Units.map (↑(canonical_equiv (non_zero_divisors R) K K')) I :\n          «expr ˣ» (fractional_ideal (non_zero_divisors R) K')) =\n      class_group.mk I :=\n  by\n  rw [class_group.mk, MonoidHom.comp_apply, ← MonoidHom.comp_apply (Units.map _), ← Units.map_comp, ←\n      RingEquiv.coe_monoidHom_trans, fractional_ideal.canonical_equiv_trans_canonical_equiv] <;>\n    rfl\n#align class_group.mk_canonical_equiv class_group.mk_canonical_equiv\n\n",
 "mk0_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem class_group.mk0_surjective [is_dedekind_domain R] :\n    function.surjective (class_group.mk0 : non_zero_divisors (Ideal R) → class_group R) :=\n  by\n  rintro ⟨I⟩\n  obtain ⟨a, a_ne_zero', ha⟩ := I.1.2\n  have a_ne_zero := mem_non_zero_divisors_iff_ne_zero.mp a_ne_zero'\n  have fa_ne_zero : (algebraMap R (FractionRing R)) a ≠ 0 :=\n    IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors a_ne_zero'\n  refine' ⟨⟨{ carrier := { x | (algebraMap R _ a)⁻¹ * algebraMap R _ x ∈ I.1 }.. }, _⟩, _⟩\n  · simp only [RingHom.map_add, Set.mem_setOf_eq, MulZeroClass.mul_zero, RingHom.map_mul, mul_add]\n    exact fun _ _ ha hb => Submodule.add_mem I ha hb\n  · simp only [RingHom.map_zero, Set.mem_setOf_eq, MulZeroClass.mul_zero, RingHom.map_mul]\n    exact Submodule.zero_mem I\n  · intro c _ hb\n    simp only [smul_eq_mul, Set.mem_setOf_eq, MulZeroClass.mul_zero, RingHom.map_mul, mul_add,\n      mul_left_comm ((algebraMap R (FractionRing R)) a)⁻¹]\n    rw [← Algebra.smul_def c]\n    exact Submodule.smul_mem I c hb\n  · rw [mem_nonZeroDivisors_iff_ne_zero, Submodule.zero_eq_bot, Submodule.ne_bot_iff]\n    obtain ⟨x, x_ne, x_mem⟩ := exists_ne_zero_mem_is_integer I.ne_zero\n    refine' ⟨a * x, _, mul_ne_zero a_ne_zero x_ne⟩\n    change ((algebraMap R _) a)⁻¹ * (algebraMap R _) (a * x) ∈ I.1\n    rwa [RingHom.map_mul, ← mul_assoc, inv_mul_cancel fa_ne_zero, one_mul]\n  · symm\n    apply quotient.sound\n    change Setoid.r _ _\n    rw [QuotientGroup.leftRel_apply]\n    refine' ⟨Units.mk0 (algebraMap R _ a) fa_ne_zero, _⟩\n    rw [_root_.eq_inv_mul_iff_mul_eq, eq_comm, mul_comm I]\n    apply Units.ext\n    simp only [fractional_ideal.coe_mk0, fractional_ideal.map_canonical_equiv_mk0, [anonymous], Units.val_mk0,\n      coe_to_principal_ideal, coe_coe, Units.val_mul, fractional_ideal.eq_span_singleton_mul]\n    constructor\n    · intro zJ' hzJ'\n      obtain ⟨zJ, hzJ : (algebraMap R _ a)⁻¹ * algebraMap R _ zJ ∈ ↑I, rfl⟩ :=\n        (mem_coe_ideal (non_zero_divisors R)).mp hzJ'\n      refine' ⟨_, hzJ, _⟩\n      rw [← mul_assoc, mul_inv_cancel fa_ne_zero, one_mul]\n    · intro zI' hzI'\n      obtain ⟨y, hy⟩ := ha zI' hzI'\n      rw [← Algebra.smul_def, mem_coe_ideal]\n      refine' ⟨y, _, hy⟩\n      show (algebraMap R _ a)⁻¹ * algebraMap R _ y ∈ (I : fractional_ideal (non_zero_divisors R) (FractionRing R))\n      rwa [hy, Algebra.smul_def, ← mul_assoc, inv_mul_cancel fa_ne_zero, one_mul]\n#align class_group.mk0_surjective class_group.mk0_surjective\n\n",
 "mk0_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem class_group.mk0_eq_one_iff [is_dedekind_domain R] {I : Ideal R} (hI : I ∈ non_zero_divisors (Ideal R)) :\n    class_group.mk0 ⟨I, hI⟩ = 1 ↔ I.is_principal :=\n  class_group.mk_eq_one_iff.trans (coeSubmodule_isPrincipal R _)\n#align class_group.mk0_eq_one_iff class_group.mk0_eq_one_iff\n\n",
 "mk0_eq_mk0_iff_exists_fraction_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ≠ » (0 : K)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem class_group.mk0_eq_mk0_iff_exists_fraction_ring [is_dedekind_domain R] {I J : non_zero_divisors (Ideal R)} :\n    class_group.mk0 I = class_group.mk0 J ↔\n      ∃ (x : _)(_ : x ≠ (0 : K)), span_singleton (non_zero_divisors R) x * I = J :=\n  by\n  refine' (class_group.equiv K).injective.eq_iff.symm.trans _\n  simp only [class_group.equiv_mk0, QuotientGroup.mk'_eq_mk', mem_principal_ideals_iff, coe_coe, Units.ext_iff,\n    Units.val_mul, fractional_ideal.coe_mk0, exists_prop]\n  constructor\n  · rintro ⟨X, ⟨x, hX⟩, hx⟩\n    refine' ⟨x, _, _⟩\n    · rintro rfl\n      simpa [X.ne_zero.symm] using hX\n    simpa only [hX, mul_comm] using hx\n  · rintro ⟨x, hx, eq_J⟩\n    refine' ⟨Units.mk0 _ (span_singleton_ne_zero_iff.mpr hx), ⟨x, rfl⟩, _⟩\n    simpa only [mul_comm] using eq_J\n#align class_group.mk0_eq_mk0_iff_exists_fraction_ring class_group.mk0_eq_mk0_iff_exists_fraction_ring\n\n",
 "mk0_eq_mk0_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem class_group.mk0_eq_mk0_iff [is_dedekind_domain R] {I J : non_zero_divisors (Ideal R)} :\n    class_group.mk0 I = class_group.mk0 J ↔\n      ∃ (x y : R)(hx : x ≠ 0)(hy : y ≠ 0), Ideal.span {x} * (I : Ideal R) = Ideal.span {y} * J :=\n  by\n  refine' (class_group.mk0_eq_mk0_iff_exists_fraction_ring (FractionRing R)).trans ⟨_, _⟩\n  · rintro ⟨z, hz, h⟩\n    obtain ⟨x, ⟨y, hy⟩, rfl⟩ := IsLocalization.mk'_surjective (non_zero_divisors R) z\n    refine' ⟨x, y, _, mem_non_zero_divisors_iff_ne_zero.mp hy, _⟩\n    · rintro hx\n      apply hz\n      rw [hx, IsFractionRing.mk'_eq_div, _root_.map_zero, zero_div]\n    · exact (fractional_ideal.mk'_mul_coe_ideal_eq_coe_ideal _ hy).mp h\n  · rintro ⟨x, y, hx, hy, h⟩\n    have hy' : y ∈ non_zero_divisors R := mem_non_zero_divisors_iff_ne_zero.mpr hy\n    refine' ⟨IsLocalization.mk' _ x ⟨y, hy'⟩, _, _⟩\n    · contrapose! hx\n      rwa [mk'_eq_iff_eq_mul, MulZeroClass.zero_mul, ← (algebraMap R (FractionRing R)).map_zero,\n        (IsFractionRing.injective R (FractionRing R)).eq_iff] at hx\n    · exact (fractional_ideal.mk'_mul_coe_ideal_eq_coe_ideal _ hy').mpr h\n#align class_group.mk0_eq_mk0_iff class_group.mk0_eq_mk0_iff\n\n",
 "mem_principal_ideals_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mem_principal_ideals_iff {I : «expr ˣ» (fractional_ideal (non_zero_divisors R) K)} :\n    I ∈ (to_principal_ideal R K).range ↔ ∃ x : K, span_singleton (non_zero_divisors R) x = I :=\n  by\n  simp only [MonoidHom.mem_range, to_principal_ideal_eq_iff]\n  constructor <;> rintro ⟨x, hx⟩\n  · exact ⟨x, hx⟩\n  · refine' ⟨Units.mk0 x _, hx⟩\n    rintro rfl\n    simpa [I.ne_zero.symm] using hx\n#align mem_principal_ideals_iff mem_principal_ideals_iff\n\n",
 "map_canonical_equiv_mk0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem fractional_ideal.map_canonical_equiv_mk0 [is_dedekind_domain R] (K' : Type _) [Field K'] [Algebra R K']\n    [IsFractionRing R K'] (I : non_zero_divisors (Ideal R)) :\n    Units.map (↑(fractional_ideal.canonical_equiv (non_zero_divisors R) K K')) (fractional_ideal.mk0 K I) =\n      fractional_ideal.mk0 K' I :=\n  Units.ext (fractional_ideal.canonical_equiv_mk0 K K' I)\n#align fractional_ideal.map_canonical_equiv_mk0 fractional_ideal.map_canonical_equiv_mk0\n\n",
 "induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- Induction principle for the class group: to show something holds for all `x : class_group R`,\nwe can choose a fraction field `K` and show it holds for the equivalence class of each\n`I : fractional_ideal R⁰ K`. -/\n@[elab_as_elim]\ntheorem class_group.induction {P : class_group R → Prop}\n    (h : ∀ I : «expr ˣ» (fractional_ideal (non_zero_divisors R) K), P (class_group.mk I)) (x : class_group R) : P x :=\n  QuotientGroup.induction_on x fun I =>\n    by\n    convert h (Units.mapEquiv (↑(canonical_equiv (non_zero_divisors R) (FractionRing R) K)) I)\n    ext : 1\n    rw [Units.coe_map, Units.coe_mapEquiv]\n    exact (canonical_equiv_flip (non_zero_divisors R) K (FractionRing R) I).symm\n#align class_group.induction class_group.induction\n\n",
 "equiv_mk0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem class_group.equiv_mk0 [is_dedekind_domain R] (I : non_zero_divisors (Ideal R)) :\n    class_group.equiv K (class_group.mk0 I) =\n      QuotientGroup.mk' (to_principal_ideal R K).range (fractional_ideal.mk0 K I) :=\n  by\n  rw [class_group.mk0, MonoidHom.comp_apply, class_group.equiv_mk]\n  congr\n  ext\n  simp\n#align class_group.equiv_mk0 class_group.equiv_mk0\n\n",
 "equiv_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem class_group.equiv_mk (K' : Type _) [Field K'] [Algebra R K'] [IsFractionRing R K']\n    (I : «expr ˣ» (fractional_ideal (non_zero_divisors R) K)) :\n    class_group.equiv K' (class_group.mk I) =\n      QuotientGroup.mk' _ (Units.mapEquiv (↑(fractional_ideal.canonical_equiv (non_zero_divisors R) K K')) I) :=\n  by\n  rw [class_group.equiv, class_group.mk, MonoidHom.comp_apply, QuotientGroup.congr_mk']\n  congr\n  ext : 1\n  rw [Units.coe_mapEquiv, Units.coe_mapEquiv, Units.coe_map]\n  exact fractional_ideal.canonical_equiv_canonical_equiv _ _ _ _ _\n#align class_group.equiv_mk class_group.equiv_mk\n\n",
 "coe_to_principal_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n@[simp]\ntheorem coe_to_principal_ideal (x : «expr ˣ» K) :\n    (to_principal_ideal R K x : fractional_ideal (non_zero_divisors R) K) = span_singleton _ x :=\n  by\n  simp only [to_principal_ideal]\n  rfl\n#align coe_to_principal_ideal coe_to_principal_ideal\n\n",
 "coe_mk0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem fractional_ideal.coe_mk0 [is_dedekind_domain R] (I : non_zero_divisors (Ideal R)) :\n    (fractional_ideal.mk0 K I : fractional_ideal (non_zero_divisors R) K) = I :=\n  rfl\n#align fractional_ideal.coe_mk0 fractional_ideal.coe_mk0\n\n",
 "card_class_group_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/\ntheorem card_class_group_eq_one_iff [is_dedekind_domain R] [Fintype (class_group R)] :\n    Fintype.card (class_group R) = 1 ↔ IsPrincipalIdealRing R :=\n  by\n  constructor; swap;\n  · intros\n    convert card_class_group_eq_one\n    assumption\n  rw [Fintype.card_eq_one_iff]\n  rintro ⟨I, hI⟩\n  have eq_one : ∀ J : class_group R, J = 1 := fun J => trans (hI J) (hI 1).symm\n  refine' ⟨fun I => _⟩\n  by_cases hI : I = «expr⊥»\n  · rw [hI]\n    exact bot_isPrincipal\n  exact (class_group.mk0_eq_one_iff (mem_non_zero_divisors_iff_ne_zero.mpr hI)).mp (eq_one _)\n#align card_class_group_eq_one_iff card_class_group_eq_one_iff\n\n",
 "card_class_group_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- The class number of a principal ideal domain is `1`. -/\ntheorem card_class_group_eq_one [IsPrincipalIdealRing R] : Fintype.card (class_group R) = 1 :=\n  by\n  rw [Fintype.card_eq_one_iff]\n  use 1\n  refine' class_group.induction (FractionRing R) fun I => _\n  exact class_group.mk_eq_one_iff.mpr (I : fractional_ideal (non_zero_divisors R) (FractionRing R)).is_principal\n#align card_class_group_eq_one card_class_group_eq_one\n\n",
 "canonical_equiv_mk0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem fractional_ideal.canonical_equiv_mk0 [is_dedekind_domain R] (K' : Type _) [Field K'] [Algebra R K']\n    [IsFractionRing R K'] (I : non_zero_divisors (Ideal R)) :\n    fractional_ideal.canonical_equiv (non_zero_divisors R) K K' (fractional_ideal.mk0 K I) =\n      fractional_ideal.mk0 K' I :=\n  by simp only [fractional_ideal.coe_mk0, coe_coe, fractional_ideal.canonical_equiv_coe_ideal]\n#align fractional_ideal.canonical_equiv_mk0 fractional_ideal.canonical_equiv_mk0\n\n"}