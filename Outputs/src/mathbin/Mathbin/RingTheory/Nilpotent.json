{"zero_is_radical_iff":
 "theorem zero_is_radical_iff [monoid_with_zero R] : is_radical (0 : R) ↔ is_reduced R :=\n  by\n  simp_rw [is_reduced_iff, is_nilpotent, exists_imp, ← zero_dvd_iff]\n  exact forall_swap\n#align zero_is_radical_iff zero_is_radical_iff\n\n",
 "zero":
 "theorem is_nilpotent.zero [monoid_with_zero R] : is_nilpotent (0 : R) :=\n  ⟨1, pow_one 0⟩\n#align is_nilpotent.zero is_nilpotent.zero\n\n",
 "nilradical_le_prime":
 "theorem nilradical_le_prime (J : ideal R) [H : J.is_prime] : nilradical R ≤ J :=\n  (nilradical_eq_Inf R).symm ▸ infₛ_le H\n#align nilradical_le_prime nilradical_le_prime\n\n",
 "nilradical_eq_zero":
 "@[simp]\ntheorem nilradical_eq_zero (R : Type _) [CommSemiring R] [is_reduced R] : nilradical R = 0 :=\n  ideal.ext fun _ => is_nilpotent_iff_eq_zero\n#align nilradical_eq_zero nilradical_eq_zero\n\n",
 "nilradical_eq_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem nilradical_eq_Inf (R : Type _) [CommSemiring R] : nilradical R = infₛ { J : ideal R | J.is_prime } :=\n  (ideal.radical_eq_Inf («expr⊥»)).trans <| by simp_rw [and_iff_right bot_le]\n#align nilradical_eq_Inf nilradical_eq_Inf\n\n",
 "nilpotent_iff_mem_prime":
 "theorem nilpotent_iff_mem_prime : is_nilpotent x ↔ ∀ J : ideal R, J.is_prime → x ∈ J :=\n  by\n  rw [← mem_nilradical, nilradical_eq_Inf, submodule.mem_Inf]\n  rfl\n#align nilpotent_iff_mem_prime nilpotent_iff_mem_prime\n\n",
 "neg":
 "theorem is_nilpotent.neg [Ring R] (h : is_nilpotent x) : is_nilpotent (-x) :=\n  by\n  obtain ⟨n, hn⟩ := h\n  use n\n  rw [neg_pow, hn, mul_zero]\n#align is_nilpotent.neg is_nilpotent.neg\n\n",
 "mk":
 "/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem is_nilpotent.mk [Zero R] [Pow R ℕ] (x : R) (n : ℕ) (e : x ^ n = 0) : is_nilpotent x :=\n  ⟨n, e⟩\n#align is_nilpotent.mk is_nilpotent.mk\n\n",
 "mem_nilradical":
 "theorem mem_nilradical : x ∈ nilradical R ↔ is_nilpotent x :=\n  iff.rfl\n#align mem_nilradical mem_nilradical\n\n",
 "mapq":
 "theorem is_nilpotent.mapq (hnp : is_nilpotent f) : is_nilpotent (p.mapq p f hp) :=\n  by\n  obtain ⟨k, hk⟩ := hnp\n  use k\n  simp [← p.mapq_pow, hk]\n#align is_nilpotent.mapq is_nilpotent.mapq\n\n",
 "map":
 "theorem is_nilpotent.map [monoid_with_zero R] [monoid_with_zero S] {r : R} {F : Type _} [MonoidWithZeroHomClass F R S]\n    (hr : is_nilpotent r) (f : F) : is_nilpotent (f r) :=\n  by\n  use hr.some\n  rw [← map_pow, hr.some_spec, map_zero]\n#align is_nilpotent.map is_nilpotent.map\n\n",
 "ker_is_radical_iff_reduced_of_surjective":
 "theorem ring_hom.ker_is_radical_iff_reduced_of_surjective {S F} [CommSemiring R] [CommRing S] [RingHomClass F R S]\n    {f : F} (hf : function.surjective f) : (ring_hom.ker f).is_radical ↔ is_reduced S := by\n  simp_rw [is_reduced_iff, hf.forall, is_nilpotent, ← map_pow, ← ring_hom.mem_ker] <;> rfl\n#align ring_hom.ker_is_radical_iff_reduced_of_surjective ring_hom.ker_is_radical_iff_reduced_of_surjective\n\n",
 "is_unit_quotient_mk_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem is_nilpotent.is_unit_quotient_mk_iff {R : Type _} [CommRing R] {I : ideal R} (hI : is_nilpotent I) {x : R} :\n    is_unit (ideal.quotient.mk I x) ↔ is_unit x :=\n  by\n  refine' ⟨_, fun h => h.map I⟩\n  revert x\n  apply ideal.is_nilpotent.induction_on I hI <;> clear hI I\n  swap\n  · introv e h₁ h₂ h₃\n    apply h₁\n    apply h₂\n    exact\n      h₃.map\n        ((double_quot.quot_quot_equiv_quot_sup I J).trans\n              (ideal.quot_equiv_of_eq (sup_eq_right.mpr e))).symm.to_ring_hom\n  · introv e H\n    skip\n    obtain ⟨y, hy⟩ := ideal.quotient.mk_surjective (↑H.unit⁻¹ : «expr ⧸ » S I)\n    have : ideal.quotient.mk I (x * y) = ideal.quotient.mk I 1 := by\n      rw [map_one, _root_.map_mul, hy, IsUnit.mul_val_inv]\n    rw [ideal.quotient.eq] at this\n    have : (x * y - 1) ^ 2 = 0 := by\n      rw [← ideal.mem_bot, ← e]\n      exact ideal.pow_mem_pow this _\n    have : x * (y * (2 - x * y)) = 1 := by\n      rw [eq_comm, ← sub_eq_zero, ← this]\n      ring\n    exact isUnit_of_mul_eq_one _ _ this\n#align is_nilpotent.is_unit_quotient_mk_iff is_nilpotent.is_unit_quotient_mk_iff\n\n",
 "is_reduced_of_injective":
 "theorem is_reduced_of_injective [monoid_with_zero R] [monoid_with_zero S] {F : Type _} [MonoidWithZeroHomClass F R S]\n    (f : F) (hf : function.injective f) [_root_.is_reduced S] : _root_.is_reduced R :=\n  by\n  constructor\n  intro x hx\n  apply hf\n  rw [map_zero]\n  exact (hx.map f).eq_zero\n#align is_reduced_of_injective is_reduced_of_injective\n\n",
 "is_reduced_iff_pow_one_lt":
 "theorem is_reduced_iff_pow_one_lt [monoid_with_zero R] (k : ℕ) (hk : 1 < k) :\n    is_reduced R ↔ ∀ x : R, x ^ k = 0 → x = 0 := by\n  simp_rw [← zero_is_radical_iff, is_radical_iff_pow_one_lt k hk, zero_dvd_iff]\n#align is_reduced_iff_pow_one_lt is_reduced_iff_pow_one_lt\n\n",
 "is_radical_iff_span_singleton":
 "theorem is_radical_iff_span_singleton [CommSemiring R] : is_radical y ↔ (ideal.span ({y} : set R)).is_radical :=\n  by\n  simp_rw [is_radical, ← ideal.mem_span_singleton]\n  exact forall_swap.trans (forall_congr' fun r => exists_imp_distrib.symm)\n#align is_radical_iff_span_singleton is_radical_iff_span_singleton\n\n",
 "is_radical_iff_quotient_reduced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem ideal.is_radical_iff_quotient_reduced [CommRing R] (I : ideal R) : I.is_radical ↔ is_reduced («expr ⧸ » R I) :=\n  by\n  conv_lhs => rw [← @ideal.mk_ker R _ I]\n  exact ring_hom.ker_is_radical_iff_reduced_of_surjective (@ideal.quotient.mk_surjective R _ I)\n#align ideal.is_radical_iff_quotient_reduced ideal.is_radical_iff_quotient_reduced\n\n",
 "is_radical_iff_pow_one_lt":
 "theorem is_radical_iff_pow_one_lt [monoid_with_zero R] (k : ℕ) (hk : 1 < k) : is_radical y ↔ ∀ x, y ∣ x ^ k → y ∣ x :=\n  ⟨fun h x => h k x, fun h =>\n    k.cauchy_induction_mul (fun n h x hd => h x <| (pow_succ' x n).symm ▸ hd.mul_right x) 0 hk\n      (fun x hd => pow_one x ▸ hd) fun n _ hn x hd => h x <| hn _ <| (pow_mul x k n).subst hd⟩\n#align is_radical_iff_pow_one_lt is_radical_iff_pow_one_lt\n\n",
 "is_nilpotent_sub":
 "theorem is_nilpotent_sub (hx : is_nilpotent x) (hy : is_nilpotent y) : is_nilpotent (x - y) :=\n  by\n  rw [← neg_right_iff] at h_comm\n  rw [← is_nilpotent_neg_iff] at hy\n  rw [sub_eq_add_neg]\n  exact h_comm.is_nilpotent_add hx hy\n#align is_nilpotent_sub is_nilpotent_sub\n\n",
 "is_nilpotent_neg_iff":
 "@[simp]\ntheorem is_nilpotent_neg_iff [Ring R] : is_nilpotent (-x) ↔ is_nilpotent x :=\n  ⟨fun h => neg_neg x ▸ h.neg, fun h => h.neg⟩\n#align is_nilpotent_neg_iff is_nilpotent_neg_iff\n\n",
 "is_nilpotent_mul_right_iff":
 "@[simp]\ntheorem is_nilpotent_mul_right_iff (a : A) : is_nilpotent (mul_right R a) ↔ is_nilpotent a := by\n  constructor <;> rintro ⟨n, hn⟩ <;> use n <;> simp only [mul_right_eq_zero_iff, pow_mul_right] at hn⊢ <;> exact hn\n#align is_nilpotent_mul_right_iff is_nilpotent_mul_right_iff\n\n",
 "is_nilpotent_mul_right":
 "theorem is_nilpotent_mul_right (h : is_nilpotent y) : is_nilpotent (x * y) :=\n  by\n  rw [h_comm.eq]\n  exact h_comm.symm.is_nilpotent_mul_left h\n#align is_nilpotent_mul_right is_nilpotent_mul_right\n\n",
 "is_nilpotent_mul_left_iff":
 "@[simp]\ntheorem is_nilpotent_mul_left_iff (a : A) : is_nilpotent (mul_left R a) ↔ is_nilpotent a := by\n  constructor <;> rintro ⟨n, hn⟩ <;> use n <;> simp only [mul_left_eq_zero_iff, pow_mul_left] at hn⊢ <;> exact hn\n#align is_nilpotent_mul_left_iff is_nilpotent_mul_left_iff\n\n",
 "is_nilpotent_mul_left":
 "theorem is_nilpotent_mul_left (h : is_nilpotent x) : is_nilpotent (x * y) :=\n  by\n  obtain ⟨n, hn⟩ := h\n  use n\n  rw [h_comm.mul_pow, hn, zero_mul]\n#align is_nilpotent_mul_left is_nilpotent_mul_left\n\n",
 "is_nilpotent_iff_eq_zero":
 "@[simp]\ntheorem is_nilpotent_iff_eq_zero [monoid_with_zero R] [is_reduced R] : is_nilpotent x ↔ x = 0 :=\n  ⟨fun h => h.eq_zero, fun h => h.symm ▸ is_nilpotent.zero⟩\n#align is_nilpotent_iff_eq_zero is_nilpotent_iff_eq_zero\n\n",
 "is_nilpotent_add":
 "theorem is_nilpotent_add (hx : is_nilpotent x) (hy : is_nilpotent y) : is_nilpotent (x + y) :=\n  by\n  obtain ⟨n, hn⟩ := hx\n  obtain ⟨m, hm⟩ := hy\n  use n + m - 1\n  rw [h_comm.add_pow']\n  apply finset.sum_eq_zero\n  rintro ⟨i, j⟩ hij\n  suffices x ^ i * y ^ j = 0 by simp only [this, nsmul_eq_mul, mul_zero]\n  cases' Nat.le_or_le_of_add_eq_add_pred (finset.nat.mem_antidiagonal.mp hij) with hi hj\n  · rw [pow_eq_zero_of_le hi hn, zero_mul]\n  · rw [pow_eq_zero_of_le hj hm, mul_zero]\n#align is_nilpotent_add is_nilpotent_add\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n  `P I → P (J ⧸ I) → P J`, then `P` holds for all nilpotent ideals. -/\ntheorem ideal.is_nilpotent.induction_on (hI : is_nilpotent I) {P : ∀ ⦃S : Type _⦄ [CommRing S], ∀ I : ideal S, Prop}\n    (h₁ : ∀ ⦃S : Type _⦄ [CommRing S], ∀ I : ideal S, I ^ 2 = «expr⊥» → P I)\n    (h₂ : ∀ ⦃S : Type _⦄ [CommRing S], ∀ I J : ideal S, I ≤ J → P I → P (J.map (ideal.quotient.mk I)) → P J) : P I :=\n  by\n  obtain ⟨n, hI : I ^ n = «expr⊥»⟩ := hI\n  revert S\n  apply nat.strong_induction_on n\n  clear n\n  intro n H S _ I hI\n  by_cases hI' : I = «expr⊥»\n  · subst hI'\n    apply h₁\n    rw [← ideal.zero_eq_bot, zero_pow]\n    exact zero_lt_two\n  cases n\n  · rw [pow_zero, ideal.one_eq_top] at hI\n    haveI := subsingleton_of_bot_eq_top hI.symm\n    exact (hI' (subsingleton.elim _ _)).elim\n  cases n\n  · rw [pow_one] at hI\n    exact (hI' hI).elim\n  apply h₂ (I ^ 2) _ (ideal.pow_le_self two_ne_zero)\n  · apply H n.succ _ (I ^ 2)\n    · rw [← pow_mul, eq_bot_iff, ← hI, nat.succ_eq_add_one, nat.succ_eq_add_one]\n      exact ideal.pow_le_pow (by linarith)\n    · exact le_refl n.succ.succ\n  · apply h₁\n    rw [← ideal.map_pow, ideal.map_quotient_self]\n#align ideal.is_nilpotent.induction_on ideal.is_nilpotent.induction_on\n\n",
 "eq_zero":
 "theorem is_nilpotent.eq_zero [Zero R] [Pow R ℕ] [is_reduced R] (h : is_nilpotent x) : x = 0 :=\n  is_reduced.eq_zero x h\n#align is_nilpotent.eq_zero is_nilpotent.eq_zero\n\n"}