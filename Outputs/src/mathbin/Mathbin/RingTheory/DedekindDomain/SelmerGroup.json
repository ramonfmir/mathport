{"valuation_of_unit_mod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `quot -/\n@[simp]\ntheorem valuation_of_unit_mod_eq (n : ℕ) (x : «expr ˣ» R) :\n    v.valuation_of_ne_zero_mod n (Units.map (algebraMap R K : «expr →* » R K) x : quot K n) = 1 := by\n  rw [valuation_of_ne_zero_mod, MonoidHom.comp_apply, ← QuotientGroup.coe_mk', QuotientGroup.map_mk',\n    valuation_of_unit_eq, QuotientGroup.mk_one, map_one]\n#align valuation_of_unit_mod_eq valuation_of_unit_mod_eq\n\n",
 "valuation_of_unit_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp]\ntheorem valuation_of_unit_eq (x : «expr ˣ» R) :\n    v.valuation_of_ne_zero (Units.map (algebraMap R K : «expr →* » R K) x) = 1 :=\n  by\n  rw [← WithZero.coe_inj, valuation_of_ne_zero_eq, Units.coe_map, eq_iff_le_not_lt]\n  constructor\n  · exact v.valuation_le_one x\n  · cases' x with x _ hx _\n    change ¬v.valuation (algebraMap R K x) < 1\n    apply_fun v.int_valuation  at hx\n    rw [map_one, map_mul] at hx\n    rw [not_lt, ← hx, ← mul_one <| v.valuation _, valuation_of_algebra_map,\n      mul_le_mul_left₀ <| left_ne_zero_of_mul_eq_one hx]\n    exact v.int_valuation_le_one _\n#align valuation_of_unit_eq valuation_of_unit_eq\n\n",
 "valuation_of_ne_zero_to_fun_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `int.multiplicative_zero -/\n/-\nCopyright (c) 2022 David Kurniadi Angdinata. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Kurniadi Angdinata\n-/\n@[simp]\ntheorem valuation_of_ne_zero_to_fun_eq (x : «expr ˣ» K) :\n    (v.valuation_of_ne_zero_to_fun x : int.multiplicative_zero) = v.valuation (x : K) :=\n  by\n  change _ = _ * _\n  rw [Units.val_inv_eq_inv_val]\n  change _ = ite _ _ _ * (ite (coe _ = _) _ _)⁻¹\n  rw [IsLocalization.toLocalizationMap_sec, if_neg <| IsLocalization.sec_fst_ne_zero le_rfl x.ne_zero,\n    if_neg <| nonZeroDivisors.coe_ne_zero _]\n  any_goals exact is_domain.to_nontrivial R\n  rfl\n#align valuation_of_ne_zero_to_fun_eq valuation_of_ne_zero_to_fun_eq\n\n",
 "valuation_of_ne_zero_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `int.multiplicative_zero -/\n@[simp]\ntheorem valuation_of_ne_zero_eq (x : «expr ˣ» K) :\n    (v.valuation_of_ne_zero x : int.multiplicative_zero) = v.valuation (x : K) :=\n  valuation_of_ne_zero_to_fun_eq v x\n#align valuation_of_ne_zero_eq valuation_of_ne_zero_eq\n\n",
 "valuation_ker_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ , ⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ , ⟯» -/\ntheorem valuation_ker_eq :\n    valuation.ker = («expr ⟮ , ⟯» K (∅ : Set <| height_one_spectrum R) n).subgroup_of («expr ⟮ , ⟯» K S n) :=\n  by\n  ext ⟨_, hx⟩\n  constructor\n  · intro hx' v _\n    by_cases hv : v ∈ S\n    · exact congr_fun hx' ⟨v, hv⟩\n    · exact hx v hv\n  · exact fun hx' => funext fun v => hx' v <| Set.not_mem_empty v\n#align valuation_ker_eq valuation_ker_eq\n\n",
 "from_unit_lift_injective":
 "theorem from_unit_lift_injective [Fact <| 0 < n] : function.injective <| @from_unit_lift R _ _ _ K _ _ _ n _ :=\n  function.injective.comp (QuotientGroup.kerLift_injective _) (MulEquiv.injective _)\n#align from_unit_lift_injective from_unit_lift_injective\n\n",
 "from_unit_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem from_unit_ker [hn : Fact <| 0 < n] :\n    (@from_unit R _ _ _ K _ _ _ n).ker = (powMonoidHom n : «expr →* » («expr ˣ» R) («expr ˣ» R)).range :=\n  by\n  ext ⟨_, _, _, _⟩\n  constructor\n  · intro hx\n    rcases(QuotientGroup.eq_one_iff _).mp (subtype.mk.inj hx) with ⟨⟨v, i, vi, iv⟩, hx⟩\n    have hv : ↑(_ ^ n : «expr ˣ» K) = algebraMap R K _ := congr_arg Units.val hx\n    have hi : ↑(_ ^ n : «expr ˣ» K)⁻¹ = algebraMap R K _ := congr_arg Units.inv hx\n    rw [Units.val_pow_eq_pow_val] at hv\n    rw [← inv_pow, Units.inv_mk, Units.val_pow_eq_pow_val] at hi\n    rcases@is_integrally_closed.exists_algebra_map_eq_of_is_integral_pow R _ _ _ _ _ _ _ v _ hn.out\n        (hv.symm ▸ is_integral_algebra_map) with\n      ⟨v', rfl⟩\n    rcases@is_integrally_closed.exists_algebra_map_eq_of_is_integral_pow R _ _ _ _ _ _ _ i _ hn.out\n        (hi.symm ▸ is_integral_algebra_map) with\n      ⟨i', rfl⟩\n    rw [← map_mul, map_eq_one_iff _ <| NoZeroSMulDivisors.algebraMap_injective R K] at vi\n    rw [← map_mul, map_eq_one_iff _ <| NoZeroSMulDivisors.algebraMap_injective R K] at iv\n    rw [Units.val_mk, ← map_pow] at hv\n    exact\n      ⟨⟨v', i', vi, iv⟩, by\n        simpa only [Units.ext_iff, powMonoidHom_apply, Units.val_pow_eq_pow_val] using\n          NoZeroSMulDivisors.algebraMap_injective R K hv⟩\n  · rintro ⟨_, hx⟩\n    rw [← hx]\n    exact subtype.mk_eq_mk.mpr ((QuotientGroup.eq_one_iff _).mpr ⟨_, by simp only [powMonoidHom_apply, map_pow]⟩)\n#align from_unit_ker from_unit_ker\n\n",
 "Monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ , ⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ , ⟯» -/\n#print Monotone /-\ntheorem Monotone (hS : S ≤ S') : «expr ⟮ , ⟯» K S n ≤ «expr ⟮ , ⟯» K S' n := fun _ hx v => hx v ∘ mt (@hS v)\n#align monotone Monotone\n-/\n\n"}