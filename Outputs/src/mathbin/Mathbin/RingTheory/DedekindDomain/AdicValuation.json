{"valued_adic_completion_def":
 "theorem valued_adic_completion_def {x : v.adic_completion K} :\n    valued.v x = @valued.extension K _ _ _ (adic_valued v) x :=\n  rfl\n#align valued_adic_completion_def valued_adic_completion_def\n\n",
 "valuation_uniformizer_ne_zero":
 "/-- Uniformizers are nonzero. -/\ntheorem valuation_uniformizer_ne_zero : Classical.choose (v.valuation_exists_uniformizer K) ≠ 0 :=\n  haveI hu := Classical.choose_spec (v.valuation_exists_uniformizer K)\n  (Valuation.ne_zero_iff _).mp (ne_of_eq_of_ne hu WithZero.coe_ne_zero)\n#align valuation_uniformizer_ne_zero valuation_uniformizer_ne_zero\n\n",
 "valuation_of_mk'":
 "/-- The `v`-adic valuation of `r/s ∈ K` is the valuation of `r` divided by the valuation of `s`. -/\ntheorem valuation_of_mk' {r : R} {s : nonZeroDivisors R} :\n    v.valuation (IsLocalization.mk' K r s) = v.int_valuation r / v.int_valuation s :=\n  by\n  erw [valuation_def, (IsLocalization.toLocalizationMap (nonZeroDivisors R) K).lift_mk', div_eq_mul_inv,\n    mul_eq_mul_left_iff]\n  left\n  rw [Units.val_inv_eq_inv_val, inv_inj]\n  rfl\n#align valuation_of_mk' valuation_of_mk'\n\n",
 "valuation_of_algebra_map":
 "/-- The `v`-adic valuation on `K` extends the `v`-adic valuation on `R`. -/\ntheorem valuation_of_algebra_map (r : R) : v.valuation (algebraMap R K r) = v.int_valuation r := by\n  rw [valuation_def, valuation.extend_to_localization_apply_map_apply]\n#align valuation_of_algebra_map valuation_of_algebra_map\n\n",
 "valuation_lt_one_iff_dvd":
 "/-- The `v`-adic valuation of `r ∈ R` is less than 1 if and only if `v` divides the ideal `(r)`. -/\ntheorem valuation_lt_one_iff_dvd (r : R) : v.valuation (algebraMap R K r) < 1 ↔ v.as_ideal ∣ Ideal.span {r} :=\n  by\n  rw [valuation_of_algebra_map]\n  exact v.int_valuation_lt_one_iff_dvd r\n#align valuation_lt_one_iff_dvd valuation_lt_one_iff_dvd\n\n",
 "valuation_le_one":
 "/-- The `v`-adic valuation on `R` is bounded above by 1. -/\ntheorem valuation_le_one (r : R) : v.valuation (algebraMap R K r) ≤ 1 :=\n  by\n  rw [valuation_of_algebra_map]\n  exact v.int_valuation_le_one r\n#align valuation_le_one valuation_le_one\n\n",
 "valuation_exists_uniformizer":
 "/-- There exists `π ∈ K` with `v`-adic valuation `multiplicative.of_add (-1)`. -/\ntheorem valuation_exists_uniformizer : ∃ π : K, v.valuation π = Multiplicative.ofAdd (-1 : ℤ) :=\n  by\n  obtain ⟨r, hr⟩ := v.int_valuation_exists_uniformizer\n  use algebraMap R K r\n  rw [valuation_def, valuation.extend_to_localization_apply_map_apply]\n  exact hr\n#align valuation_exists_uniformizer valuation_exists_uniformizer\n\n",
 "valuation_def":
 "theorem valuation_def (x : K) :\n    v.valuation x =\n      v.int_valuation.extend_to_localization (fun r hr => Set.mem_compl (v.int_valuation_ne_zero' ⟨r, hr⟩)) K x :=\n  rfl\n#align valuation_def valuation_def\n\n",
 "mem_adic_completion_integers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `int.multiplicative_zero -/\ntheorem mem_adic_completion_integers {x : v.adic_completion K} :\n    x ∈ v.adic_completion_integers K ↔ (valued.v x : int.multiplicative_zero) ≤ 1 :=\n  iff.rfl\n#align mem_adic_completion_integers mem_adic_completion_integers\n\n",
 "map_zero'":
 "/-- The `v`-adic valuation of `0 : R` equals 0. -/\ntheorem int_valuation.map_zero' : v.int_valuation_def 0 = 0 :=\n  v.int_valuation_def_if_pos (Eq.refl 0)\n#align int_valuation.map_zero' int_valuation.map_zero'\n\n",
 "map_one'":
 "/-- The `v`-adic valuation of `1 : R` equals 1. -/\ntheorem int_valuation.map_one' : v.int_valuation_def 1 = 1 := by\n  rw [v.int_valuation_def_if_neg (zero_ne_one.symm : (1 : R) ≠ 0), Ideal.span_singleton_one, ← Ideal.one_eq_top,\n    Associates.mk_one, Associates.factors_one, Associates.count_zero (by apply v.associates_irreducible),\n    Int.ofNat_zero, neg_zero, ofAdd_zero, WithZero.coe_one]\n#align int_valuation.map_one' int_valuation.map_one'\n\n",
 "map_mul'":
 "/-- The `v`-adic valuation of a product equals the product of the valuations. -/\ntheorem int_valuation.map_mul' (x y : R) :\n    v.int_valuation_def (x * y) = v.int_valuation_def x * v.int_valuation_def y :=\n  by\n  simp only [int_valuation_def]\n  by_cases hx : x = 0\n  · rw [hx, MulZeroClass.zero_mul, if_pos (Eq.refl _), MulZeroClass.zero_mul]\n  · by_cases hy : y = 0\n    · rw [hy, MulZeroClass.mul_zero, if_pos (Eq.refl _), MulZeroClass.mul_zero]\n    · rw [if_neg hx, if_neg hy, if_neg (mul_ne_zero hx hy), ← WithZero.coe_mul, WithZero.coe_inj, ← ofAdd_add, ←\n        Ideal.span_singleton_mul_span_singleton, ← Associates.mk_mul_mk, ← neg_add,\n        Associates.count_mul (by apply associates.mk_ne_zero'.mpr hx) (by apply associates.mk_ne_zero'.mpr hy)\n          (by apply v.associates_irreducible)]\n      rfl\n#align int_valuation.map_mul' int_valuation.map_mul'\n\n",
 "map_add_le_max'":
 "/-- The `v`-adic valuation of a sum is bounded above by the maximum of the valuations. -/\ntheorem int_valuation.map_add_le_max' (x y : R) :\n    v.int_valuation_def (x + y) ≤ max (v.int_valuation_def x) (v.int_valuation_def y) :=\n  by\n  by_cases hx : x = 0\n  · rw [hx, zero_add]\n    conv_rhs => rw [int_valuation_def, if_pos (Eq.refl _)]\n    rw [max_eq_right (WithZero.zero_le (v.int_valuation_def y))]\n    exact le_refl _\n  · by_cases hy : y = 0\n    · rw [hy, add_zero]\n      conv_rhs => rw [max_comm, int_valuation_def, if_pos (Eq.refl _)]\n      rw [max_eq_right (WithZero.zero_le (v.int_valuation_def x))]\n      exact le_refl _\n    · by_cases hxy : x + y = 0\n      · rw [int_valuation_def, if_pos hxy]\n        exact zero_le'\n      · rw [v.int_valuation_def_if_neg hxy, v.int_valuation_def_if_neg hx, v.int_valuation_def_if_neg hy, [anonymous],\n          int_valuation.le_max_iff_min_le]\n        set nmin :=\n          min ((Associates.mk v.as_ideal).count (Associates.mk (Ideal.span {x})).factors)\n            ((Associates.mk v.as_ideal).count (Associates.mk (Ideal.span {y})).factors)\n        have h_dvd_x : x ∈ v.as_ideal ^ nmin :=\n          by\n          rw [← associates.le_singleton_iff x nmin _, Associates.prime_pow_dvd_iff_le (associates.mk_ne_zero'.mpr hx) _]\n          exact min_le_left _ _\n          apply v.associates_irreducible\n        have h_dvd_y : y ∈ v.as_ideal ^ nmin :=\n          by\n          rw [← associates.le_singleton_iff y nmin _, Associates.prime_pow_dvd_iff_le (associates.mk_ne_zero'.mpr hy) _]\n          exact min_le_right _ _\n          apply v.associates_irreducible\n        have h_dvd_xy : Associates.mk v.as_ideal ^ nmin ≤ Associates.mk (Ideal.span {x + y}) :=\n          by\n          rw [associates.le_singleton_iff]\n          exact Ideal.add_mem (v.as_ideal ^ nmin) h_dvd_x h_dvd_y\n        rw [Associates.prime_pow_dvd_iff_le (associates.mk_ne_zero'.mpr hxy) _] at h_dvd_xy\n        exact h_dvd_xy\n        apply v.associates_irreducible\n#align int_valuation.map_add_le_max' int_valuation.map_add_le_max'\n\n",
 "le_max_iff_min_le":
 "theorem int_valuation.le_max_iff_min_le {a b c : ℕ} :\n    Multiplicative.ofAdd (-c : ℤ) ≤ max (Multiplicative.ofAdd (-a : ℤ)) (Multiplicative.ofAdd (-b : ℤ)) ↔ min a b ≤ c :=\n  by rw [le_max_iff, of_add_le, of_add_le, neg_le_neg_iff, neg_le_neg_iff, Int.ofNat_le, Int.ofNat_le, ← min_le_iff]\n#align int_valuation.le_max_iff_min_le int_valuation.le_max_iff_min_le\n\n",
 "int_valuation_zero_le":
 "/-- Nonzero divisors have valuation greater than zero. -/\ntheorem int_valuation_zero_le (x : nonZeroDivisors R) : 0 < v.int_valuation_def x :=\n  by\n  rw [v.int_valuation_def_if_neg (nonZeroDivisors.coe_ne_zero x)]\n  exact WithZero.zero_lt_coe _\n#align int_valuation_zero_le int_valuation_zero_le\n\n",
 "int_valuation_ne_zero'":
 "/-- Nonzero divisors have nonzero valuation. -/\ntheorem int_valuation_ne_zero' (x : nonZeroDivisors R) : v.int_valuation_def x ≠ 0 :=\n  v.int_valuation_ne_zero x (nonZeroDivisors.coe_ne_zero x)\n#align int_valuation_ne_zero' int_valuation_ne_zero'\n\n",
 "int_valuation_ne_zero":
 "/-- Nonzero elements have nonzero adic valuation. -/\ntheorem int_valuation_ne_zero (x : R) (hx : x ≠ 0) : v.int_valuation_def x ≠ 0 :=\n  by\n  rw [int_valuation_def, if_neg hx]\n  exact WithZero.coe_ne_zero\n#align int_valuation_ne_zero int_valuation_ne_zero\n\n",
 "int_valuation_lt_one_iff_dvd":
 "/-- The `v`-adic valuation of `r ∈ R` is less than 1 if and only if `v` divides the ideal `(r)`. -/\ntheorem int_valuation_lt_one_iff_dvd (r : R) : v.int_valuation_def r < 1 ↔ v.as_ideal ∣ Ideal.span {r} :=\n  by\n  rw [int_valuation_def]\n  split_ifs with hr\n  · simpa [hr] using WithZero.zero_lt_coe _\n  · rw [← WithZero.coe_one, ← ofAdd_zero, WithZero.coe_lt_coe, of_add_lt, neg_lt_zero, ← Int.ofNat_zero, Int.ofNat_lt,\n      zero_lt_iff]\n    have h : (Ideal.span {r} : Ideal R) ≠ 0 :=\n      by\n      rw [ne.def, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]\n      exact hr\n    apply Associates.count_ne_zero_iff_dvd h (by apply v.irreducible)\n#align int_valuation_lt_one_iff_dvd int_valuation_lt_one_iff_dvd\n\n",
 "int_valuation_le_pow_iff_dvd":
 "/-- The `v`-adic valuation of `r ∈ R` is less than `multiplicative.of_add (-n)` if and only if\n`vⁿ` divides the ideal `(r)`. -/\ntheorem int_valuation_le_pow_iff_dvd (r : R) (n : ℕ) :\n    v.int_valuation_def r ≤ Multiplicative.ofAdd (-(n : ℤ)) ↔ v.as_ideal ^ n ∣ Ideal.span {r} :=\n  by\n  rw [int_valuation_def]\n  split_ifs with hr\n  · simp_rw [hr, ideal.dvd_span_singleton, zero_le', Submodule.zero_mem]\n  ·\n    rw [WithZero.coe_le_coe, of_add_le, neg_le_neg_iff, Int.ofNat_le, ideal.dvd_span_singleton, ←\n      associates.le_singleton_iff,\n      Associates.prime_pow_dvd_iff_le (associates.mk_ne_zero'.mpr hr) (by apply v.associates_irreducible)]\n#align int_valuation_le_pow_iff_dvd int_valuation_le_pow_iff_dvd\n\n",
 "int_valuation_le_one":
 "/-- The `v`-adic valuation on `R` is bounded above by 1. -/\ntheorem int_valuation_le_one (x : R) : v.int_valuation_def x ≤ 1 :=\n  by\n  rw [int_valuation_def]\n  by_cases hx : x = 0\n  · rw [if_pos hx]\n    exact WithZero.zero_le 1\n  · rw [if_neg hx, ← WithZero.coe_one, ← ofAdd_zero, WithZero.coe_le_coe, of_add_le, Right.neg_nonpos_iff]\n    exact Int.coe_nat_nonneg _\n#align int_valuation_le_one int_valuation_le_one\n\n",
 "int_valuation_exists_uniformizer":
 "/-- There exists `π ∈ R` with `v`-adic valuation `multiplicative.of_add (-1)`. -/\ntheorem int_valuation_exists_uniformizer : ∃ π : R, v.int_valuation_def π = Multiplicative.ofAdd (-1 : ℤ) :=\n  by\n  have hv : _root_.irreducible (Associates.mk v.as_ideal) := v.associates_irreducible\n  have hlt : v.as_ideal ^ 2 < v.as_ideal := by\n    rw [← ideal.dvd_not_unit_iff_lt]\n    exact ⟨v.ne_bot, v.as_ideal, (not_congr Ideal.isUnit_iff).mpr (Ideal.IsPrime.ne_top v.is_prime), sq v.as_ideal⟩\n  obtain ⟨π, mem, nmem⟩ := SetLike.exists_of_lt hlt\n  have hπ : Associates.mk (Ideal.span {π}) ≠ 0 :=\n    by\n    rw [Associates.mk_ne_zero']\n    intro h\n    rw [h] at nmem\n    exact nmem (Submodule.zero_mem (v.as_ideal ^ 2))\n  use π\n  rw [int_valuation_def, if_neg (associates.mk_ne_zero'.mp hπ), WithZero.coe_inj]\n  apply congr_arg\n  rw [neg_inj, ← Int.ofNat_one, Int.coe_nat_inj']\n  rw [← ideal.dvd_span_singleton, ← Associates.mk_le_mk_iff_dvd_iff] at mem nmem\n  rw [← pow_one (Associates.mk v.as_ideal), Associates.prime_pow_dvd_iff_le hπ hv] at mem\n  rw [Associates.mk_pow, Associates.prime_pow_dvd_iff_le hπ hv, not_le] at nmem\n  exact Nat.eq_of_le_of_lt_succ mem nmem\n#align int_valuation_exists_uniformizer int_valuation_exists_uniformizer\n\n",
 "int_valuation_def_if_pos":
 "/-\nCopyright (c) 2022 María Inés de Frutos-Fernández. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: María Inés de Frutos-Fernández\n-/\ntheorem int_valuation_def_if_pos {r : R} (hr : r = 0) : v.int_valuation_def r = 0 :=\n  if_pos hr\n#align int_valuation_def_if_pos int_valuation_def_if_pos\n\n",
 "int_valuation_def_if_neg":
 "theorem int_valuation_def_if_neg {r : R} (hr : r ≠ 0) :\n    v.int_valuation_def r =\n      Multiplicative.ofAdd (-(Associates.mk v.as_ideal).count (Associates.mk (Ideal.span {r} : Ideal R)).factors : ℤ) :=\n  if_neg hr\n#align int_valuation_def_if_neg int_valuation_def_if_neg\n\n",
 "coe_smul_adic_completion_integers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul_adic_completion_integers (r : R) (x : v.adic_completion_integers K) :\n    (↑(«expr • » r x) : v.adic_completion K) = «expr • » r (x : v.adic_completion K) :=\n  rfl\n#align coe_smul_adic_completion_integers coe_smul_adic_completion_integers\n\n",
 "coe_smul_adic_completion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul_adic_completion (r : R) (x : K) :\n    (↑(«expr • » r x) : v.adic_completion K) = «expr • » r (↑x : v.adic_completion K) :=\n  @UniformSpace.Completion.coe_smul R K v.adic_valued.to_uniform_space _ _ r x\n#align coe_smul_adic_completion coe_smul_adic_completion\n\n",
 "algebra_map_adic_completion'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem algebra_map_adic_completion' : «expr⇑ » (algebraMap R <| v.adic_completion K) = coe ∘ algebraMap R K :=\n  rfl\n#align algebra_map_adic_completion' algebra_map_adic_completion'\n\n",
 "algebra_map_adic_completion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem algebra_map_adic_completion : «expr⇑ » (algebraMap K <| v.adic_completion K) = coe :=\n  rfl\n#align algebra_map_adic_completion algebra_map_adic_completion\n\n",
 "adic_valued_apply":
 "theorem adic_valued_apply {x : K} : (v.adic_valued.v : _) x = v.valuation x :=\n  rfl\n#align adic_valued_apply adic_valued_apply\n\n"}