{"not_is_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_localization.at_prime.not_is_field {P : Ideal A} (hP : P ≠ «expr⊥») [pP : P.is_prime] (Aₘ : Type _)\n    [CommRing Aₘ] [Algebra A Aₘ] [is_localization.at_prime Aₘ P] : ¬IsField Aₘ :=\n  by\n  intro h\n  letI := h.to_field\n  obtain ⟨x, x_mem, x_ne⟩ := P.ne_bot_iff.mp hP\n  exact\n    (local_ring.maximal_ideal.is_maximal _).ne_top\n      (Ideal.eq_top_of_isUnit_mem _ ((is_localization.at_prime.to_map_mem_maximal_iff Aₘ P _).mpr x_mem)\n        (is_unit_iff_ne_zero.mpr\n          ((map_ne_zero_iff (algebraMap A Aₘ) (IsLocalization.injective Aₘ P.prime_compl_le_non_zero_divisors)).mpr\n            x_ne)))\n#align is_localization.at_prime.not_is_field is_localization.at_prime.not_is_field\n\n",
 "localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-\nCopyright (c) 2020 Kenji Nakagawa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenji Nakagawa, Anne Baanen, Filippo A. E. Nuccio\n-/\n/-- Localizing a domain of Krull dimension `≤ 1` gives another ring of Krull dimension `≤ 1`.\n\nNote that the same proof can/should be generalized to preserving any Krull dimension,\nonce we have a suitable definition.\n-/\ntheorem ring.dimension_le_one.localization {R : Type _} (Rₘ : Type _) [CommRing R] [IsDomain R] [CommRing Rₘ]\n    [Algebra R Rₘ] {M : Submonoid R} [IsLocalization M Rₘ] (hM : M ≤ non_zero_divisors R)\n    (h : ring.dimension_le_one R) : ring.dimension_le_one Rₘ :=\n  by\n  intro p hp0 hpp\n  refine' ideal.is_maximal_def.mpr ⟨hpp.ne_top, Ideal.maximal_of_no_maximal fun P hpP hPm => _⟩\n  have hpP' : (⟨p, hpp⟩ : { p : Ideal Rₘ // p.is_prime }) < ⟨P, hPm.is_prime⟩ := hpP\n  rw [← (IsLocalization.orderIsoOfPrime M Rₘ).lt_iff_lt] at hpP'\n  haveI : Ideal.IsPrime (Ideal.comap (algebraMap R Rₘ) p) := ((IsLocalization.orderIsoOfPrime M Rₘ) ⟨p, hpp⟩).2.1\n  haveI : Ideal.IsPrime (Ideal.comap (algebraMap R Rₘ) P) :=\n    ((IsLocalization.orderIsoOfPrime M Rₘ) ⟨P, hPm.is_prime⟩).2.1\n  have hlt : Ideal.comap (algebraMap R Rₘ) p < Ideal.comap (algebraMap R Rₘ) P := hpP'\n  refine' h.not_lt_lt («expr⊥») (Ideal.comap _ _) (Ideal.comap _ _) ⟨_, hpP'⟩\n  exact IsLocalization.bot_lt_comap_prime _ _ hM _ hp0\n#align ring.dimension_le_one.localization ring.dimension_le_one.localization\n\n",
 "is_dedekind_domain_dvr":
 "/-- Dedekind domains, in the sense of Noetherian integrally closed domains of Krull dimension ≤ 1,\nare also Dedekind domains in the sense of Noetherian domains where the localization at every\nnonzero prime ideal is a DVR. -/\ntheorem is_dedekind_domain.is_dedekind_domain_dvr [is_dedekind_domain A] : is_dedekind_domain_dvr A :=\n  { is_noetherian_ring := is_dedekind_domain.is_noetherian_ring\n    is_dvr_at_nonzero_prime := fun P hP pP =>\n      is_localization.at_prime.discrete_valuation_ring_of_dedekind_domain A hP _ }\n#align is_dedekind_domain.is_dedekind_domain_dvr is_dedekind_domain.is_dedekind_domain_dvr\n\n",
 "is_dedekind_domain":
 "/-- The localization of a Dedekind domain at every nonzero prime ideal is a Dedekind domain. -/\ntheorem is_localization.at_prime.is_dedekind_domain [is_dedekind_domain A] (P : Ideal A) [P.is_prime] (Aₘ : Type _)\n    [CommRing Aₘ] [IsDomain Aₘ] [Algebra A Aₘ] [is_localization.at_prime Aₘ P] : is_dedekind_domain Aₘ :=\n  is_localization.is_dedekind_domain A P.prime_compl_le_non_zero_divisors Aₘ\n#align is_localization.at_prime.is_dedekind_domain is_localization.at_prime.is_dedekind_domain\n\n",
 "discrete_valuation_ring_of_dedekind_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- In a Dedekind domain, the localization at every nonzero prime ideal is a DVR. -/\ntheorem is_localization.at_prime.discrete_valuation_ring_of_dedekind_domain [is_dedekind_domain A] {P : Ideal A}\n    (hP : P ≠ «expr⊥») [pP : P.is_prime] (Aₘ : Type _) [CommRing Aₘ] [IsDomain Aₘ] [Algebra A Aₘ]\n    [is_localization.at_prime Aₘ P] : discrete_valuation_ring Aₘ := by\n  classical\n    letI : IsNoetherianRing Aₘ := IsLocalization.isNoetherianRing P.prime_compl _ is_dedekind_domain.is_noetherian_ring\n    letI : local_ring Aₘ := is_localization.at_prime.local_ring Aₘ P\n    have hnf := is_localization.at_prime.not_is_field A hP Aₘ\n    exact ((discrete_valuation_ring.tfae Aₘ hnf).out 0 2).mpr (is_localization.at_prime.is_dedekind_domain A P _)\n#align is_localization.at_prime.discrete_valuation_ring_of_dedekind_domain is_localization.at_prime.discrete_valuation_ring_of_dedekind_domain\n\n"}