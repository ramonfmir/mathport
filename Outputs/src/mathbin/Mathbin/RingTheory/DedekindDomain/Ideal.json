{"sup_mul_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem sup_mul_inf (I J : ideal A) : «expr ⊔ » I J * «expr ⊓ » I J = I * J :=\n  by\n  letI := classical.dec_eq (ideal A)\n  letI := classical.dec_eq (Associates (ideal A))\n  letI := unique_factorization_monoid.to_normalized_gcd_monoid (ideal A)\n  have hgcd : gcd I J = «expr ⊔ » I J := by\n    rw [gcd_eq_normalize _ _, normalize_eq]\n    · rw [dvd_iff_le, sup_le_iff, ← dvd_iff_le, ← dvd_iff_le]\n      exact ⟨gcd_dvd_left _ _, gcd_dvd_right _ _⟩\n    · rw [dvd_gcd_iff, dvd_iff_le, dvd_iff_le]\n      simp\n  have hlcm : lcm I J = «expr ⊓ » I J := by\n    rw [lcm_eq_normalize _ _, normalize_eq]\n    · rw [lcm_dvd_iff, dvd_iff_le, dvd_iff_le]\n      simp\n    · rw [dvd_iff_le, le_inf_iff, ← dvd_iff_le, ← dvd_iff_le]\n      exact ⟨dvd_lcm_left _ _, dvd_lcm_right _ _⟩\n  rw [← hgcd, ← hlcm, associated_iff_eq.mp (gcd_mul_lcm _ _)]\n  infer_instance\n#align sup_mul_inf sup_mul_inf\n\n",
 "sup_eq_prod_inf_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_eq_prod_inf_factors (hI : I ≠ «expr⊥») (hJ : J ≠ «expr⊥») :\n    «expr ⊔ » I J = (normalized_factors I ∩ normalized_factors J).prod :=\n  by\n  have H :\n    normalized_factors (normalized_factors I ∩ normalized_factors J).prod =\n      normalized_factors I ∩ normalized_factors J :=\n    by\n    apply normalized_factors_prod_of_prime\n    intro p hp\n    rw [mem_inter] at hp\n    exact prime_of_normalized_factor p hp.left\n  have :=\n    multiset.prod_ne_zero_of_prime (normalized_factors I ∩ normalized_factors J) fun _ h =>\n      prime_of_normalized_factor _ (Multiset.mem_inter.1 h).1\n  apply le_antisymm\n  · rw [sup_le_iff, ← dvd_iff_le, ← dvd_iff_le]\n    constructor\n    · rw [dvd_iff_normalized_factors_le_normalized_factors this hI, H]\n      exact inf_le_left\n    · rw [dvd_iff_normalized_factors_le_normalized_factors this hJ, H]\n      exact inf_le_right\n  · rw [← dvd_iff_le, dvd_iff_normalized_factors_le_normalized_factors, normalized_factors_prod_of_prime, le_iff_count]\n    · intro a\n      rw [Multiset.count_inter]\n      exact le_min (count_le_of_ideal_ge le_sup_left hI a) (count_le_of_ideal_ge le_sup_right hJ a)\n    · intro p hp\n      rw [mem_inter] at hp\n      exact prime_of_normalized_factor p hp.left\n    · exact ne_bot_of_le_ne_bot hI le_sup_left\n    · exact this\n#align sup_eq_prod_inf_factors sup_eq_prod_inf_factors\n\n",
 "strict_anti_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ideal.strict_anti_pow (I : ideal A) (hI0 : I ≠ «expr⊥») (hI1 : I ≠ «expr⊤») :\n    strict_anti ((· ^ ·) I : ℕ → ideal A) :=\n  strict_anti_nat_of_succ_lt fun e =>\n    ideal.dvd_not_unit_iff_lt.mp ⟨pow_ne_zero _ hI0, I, mt is_unit_iff.mp hI1, pow_succ' I e⟩\n#align ideal.strict_anti_pow ideal.strict_anti_pow\n\n",
 "span_singleton_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem span_singleton_mul_inv {x : K} (hx : x ≠ 0) :\n    span_singleton (non_zero_divisors R₁) x * (span_singleton (non_zero_divisors R₁) x)⁻¹ = 1 := by\n  rw [span_singleton_inv, span_singleton_mul_span_singleton, mul_inv_cancel hx, span_singleton_one]\n#align span_singleton_mul_inv span_singleton_mul_inv\n\n",
 "span_singleton_inv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem span_singleton_inv_mul {x : K} (hx : x ≠ 0) :\n    (span_singleton (non_zero_divisors R₁) x)⁻¹ * span_singleton (non_zero_divisors R₁) x = 1 := by\n  rw [mul_comm, span_singleton_mul_inv K hx]\n#align span_singleton_inv_mul span_singleton_inv_mul\n\n",
 "span_singleton_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem span_singleton_inv (x : K) : (span_singleton (non_zero_divisors R₁) x)⁻¹ = span_singleton _ x⁻¹ :=\n  one_div_span_singleton x\n#align span_singleton_inv span_singleton_inv\n\n",
 "span_singleton_dvd_span_singleton_iff_dvd":
 "theorem span_singleton_dvd_span_singleton_iff_dvd {a b : R} : ideal.span {a} ∣ ideal.span ({b} : set R) ↔ a ∣ b :=\n  ⟨fun h => mem_span_singleton.mp (dvd_iff_le.mp h (mem_span_singleton.mpr (dvd_refl b))), fun h =>\n    dvd_iff_le.mpr fun d hd => mem_span_singleton.mpr (dvd_trans h (mem_span_singleton.mp hd))⟩\n#align span_singleton_dvd_span_singleton_iff_dvd span_singleton_dvd_span_singleton_iff_dvd\n\n",
 "span_singleton_div_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n@[simp]\ntheorem span_singleton_div_span_singleton (x y : K) :\n    span_singleton (non_zero_divisors R₁) x / span_singleton (non_zero_divisors R₁) y =\n      span_singleton (non_zero_divisors R₁) (x / y) :=\n  by rw [div_span_singleton, mul_comm, span_singleton_mul_span_singleton, div_eq_mul_inv]\n#align span_singleton_div_span_singleton span_singleton_div_span_singleton\n\n",
 "span_singleton_div_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem span_singleton_div_self {x : K} (hx : x ≠ 0) :\n    span_singleton (non_zero_divisors R₁) x / span_singleton (non_zero_divisors R₁) x = 1 := by\n  rw [span_singleton_div_span_singleton, div_self hx, span_singleton_one]\n#align span_singleton_div_self span_singleton_div_self\n\n",
 "singleton_span_mem_normalized_factors_of_mem_normalized_factors":
 "theorem singleton_span_mem_normalized_factors_of_mem_normalized_factors [NormalizationMonoid R] [decidable_eq R]\n    [decidable_eq (ideal R)] {a b : R} (ha : a ∈ normalized_factors b) :\n    ideal.span ({a} : set R) ∈ normalized_factors (ideal.span ({b} : set R)) :=\n  by\n  by_cases hb : b = 0\n  · rw [ideal.span_singleton_eq_bot.mpr hb, bot_eq_zero, normalized_factors_zero]\n    rw [hb, normalized_factors_zero] at ha\n    simpa only [Multiset.not_mem_zero]\n  · suffices Prime (ideal.span ({a} : set R))\n      by\n      obtain ⟨c, hc, hc'⟩ :=\n        exists_mem_normalized_factors_of_dvd _ this.irreducible\n          (dvd_iff_le.mpr (span_singleton_le_span_singleton.mpr (dvd_of_mem_normalized_factors ha)))\n      rwa [associated_iff_eq.mp hc']\n      · by_contra\n        exact hb (span_singleton_eq_bot.mp h)\n    rw [prime_iff_is_prime]\n    exact (span_singleton_prime (prime_of_normalized_factor a ha).ne_zero).mpr (prime_of_normalized_factor a ha)\n    by_contra\n    exact (prime_of_normalized_factor a ha).ne_zero (span_singleton_eq_bot.mp h)\n#align\n  singleton_span_mem_normalized_factors_of_mem_normalized_factors singleton_span_mem_normalized_factors_of_mem_normalized_factors\n\n",
 "right_inverse_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- `I⁻¹` is the inverse of `I` if `I` has an inverse. -/\ntheorem right_inverse_eq (I J : fractional_ideal (non_zero_divisors R₁) K) (h : I * J = 1) : J = I⁻¹ :=\n  by\n  have hI : I ≠ 0 := ne_zero_of_mul_eq_one I J h\n  suffices h' : I * (1 / I) = 1\n  · exact congr_arg Units.inv <| @Units.ext _ _ (units.mk_of_mul_eq_one _ _ h) (units.mk_of_mul_eq_one _ _ h') rfl\n  apply le_antisymm\n  · apply mul_le.mpr _\n    intro x hx y hy\n    rw [mul_comm]\n    exact (mem_div_iff_of_nonzero hI).mp hy x hx\n  rw [← h]\n  apply mul_left_mono I\n  apply (le_div_iff_of_nonzero hI).mpr _\n  intro y hy x hx\n  rw [mul_comm]\n  exact mul_mem_mul hx hy\n#align right_inverse_eq right_inverse_eq\n\n",
 "quotient_equiv_pi_factors_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem is_dedekind_domain.quotient_equiv_pi_factors_mk {I : ideal R} (hI : I ≠ «expr⊥») (x : R) :\n    is_dedekind_domain.quotient_equiv_pi_factors hI (ideal.quotient.mk I x) = fun P => ideal.quotient.mk _ x :=\n  rfl\n#align is_dedekind_domain.quotient_equiv_pi_factors_mk is_dedekind_domain.quotient_equiv_pi_factors_mk\n\n",
 "prod_normalized_factors_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem prod_normalized_factors_eq_self (hI : I ≠ «expr⊥») : (normalized_factors I).prod = I :=\n  associated_iff_eq.1 (normalized_factors_prod hI)\n#align prod_normalized_factors_eq_self prod_normalized_factors_eq_self\n\n",
 "prod_le_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem ideal.prod_le_prime {ι : Type _} {s : Finset ι} {f : ι → ideal R} {P : ideal R} [hP : P.is_prime] :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) ≤ P ↔\n      ∃ i ∈ s, f i ≤ P :=\n  by\n  by_cases hP0 : P = «expr⊥»\n  · simp only [hP0, le_bot_iff]\n    rw [← ideal.zero_eq_bot, finset.prod_eq_zero_iff]\n  simp only [← ideal.dvd_iff_le]\n  exact ((ideal.prime_iff_is_prime hP0).mpr hP).dvd_finset_prod_iff _\n#align ideal.prod_le_prime ideal.prod_le_prime\n\n",
 "prime_of_is_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal.prime_of_is_prime {P : ideal A} (hP : P ≠ «expr⊥») (h : is_prime P) : Prime P :=\n  by\n  refine' ⟨hP, mt ideal.is_unit_iff.mp h.ne_top, fun I J hIJ => _⟩\n  simpa only [ideal.dvd_iff_le] using h.mul_le.mp (ideal.le_of_dvd hIJ)\n#align ideal.prime_of_is_prime ideal.prime_of_is_prime\n\n",
 "prime_le_prime_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ring.dimension_le_one.prime_le_prime_iff_eq (h : ring.dimension_le_one R) {P Q : ideal R} [hP : P.is_prime]\n    [hQ : Q.is_prime] (hP0 : P ≠ «expr⊥») : P ≤ Q ↔ P = Q :=\n  ⟨(h P hP0 hP).eq_of_le hQ.ne_top, eq.le⟩\n#align ring.dimension_le_one.prime_le_prime_iff_eq ring.dimension_le_one.prime_le_prime_iff_eq\n\n",
 "prime_iff_is_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- In a Dedekind domain, the (nonzero) prime elements of the monoid with zero `ideal A`\nare exactly the prime ideals. -/\ntheorem ideal.prime_iff_is_prime {P : ideal A} (hP : P ≠ «expr⊥») : Prime P ↔ is_prime P :=\n  ⟨ideal.is_prime_of_prime, ideal.prime_of_is_prime hP⟩\n#align ideal.prime_iff_is_prime ideal.prime_iff_is_prime\n\n",
 "pow_succ_lt_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal.pow_succ_lt_pow {P : ideal A} [P_prime : P.is_prime] (hP : P ≠ «expr⊥») (i : ℕ) : P ^ (i + 1) < P ^ i :=\n  lt_of_le_of_ne (ideal.pow_le_pow (nat.le_succ _))\n    (mt (pow_eq_pow_iff hP (mt ideal.is_unit_iff.mp P_prime.ne_top)).mp i.succ_ne_self)\n#align ideal.pow_succ_lt_pow ideal.pow_succ_lt_pow\n\n",
 "pow_lt_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ideal.pow_lt_self (I : ideal A) (hI0 : I ≠ «expr⊥») (hI1 : I ≠ «expr⊤») (e : ℕ) (he : 2 ≤ e) : I ^ e < I := by\n  convert I.strict_anti_pow hI0 hI1 he <;> rw [pow_one]\n#align ideal.pow_lt_self ideal.pow_lt_self\n\n",
 "pow_le_prime_iff":
 "theorem ideal.pow_le_prime_iff {I P : ideal R} [hP : P.is_prime] {n : ℕ} (hn : n ≠ 0) : I ^ n ≤ P ↔ I ≤ P :=\n  ⟨ideal.le_of_pow_le_prime, fun h => trans (ideal.pow_le_self hn) h⟩\n#align ideal.pow_le_prime_iff ideal.pow_le_prime_iff\n\n",
 "one_mem_inv_coe_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem one_mem_inv_coe_ideal {I : ideal A} (hI : I ≠ «expr⊥») :\n    (1 : K) ∈ (I : fractional_ideal (non_zero_divisors A) K)⁻¹ :=\n  by\n  rw [mem_inv_iff (coe_ideal_ne_zero.mpr hI)]\n  intro y hy\n  rw [one_mul]\n  exact coe_ideal_le_one hy\n  assumption\n#align one_mem_inv_coe_ideal one_mem_inv_coe_ideal\n\n",
 "normalized_factors_equiv_of_quot_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem normalized_factors_equiv_of_quot_equiv_symm (hI : I ≠ «expr⊥») (hJ : J ≠ «expr⊥») :\n    (normalized_factors_equiv_of_quot_equiv f hI hJ).symm = normalized_factors_equiv_of_quot_equiv f.symm hJ hI :=\n  rfl\n#align normalized_factors_equiv_of_quot_equiv_symm normalized_factors_equiv_of_quot_equiv_symm\n\n",
 "normalized_factors_equiv_of_quot_equiv_multiplicity_eq_multiplicity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The map `normalized_factors_equiv_of_quot_equiv` preserves multiplicities. -/\ntheorem normalized_factors_equiv_of_quot_equiv_multiplicity_eq_multiplicity (hI : I ≠ «expr⊥») (hJ : J ≠ «expr⊥»)\n    (L : ideal R) (hL : L ∈ normalized_factors I) :\n    multiplicity (↑(normalized_factors_equiv_of_quot_equiv f hI hJ ⟨L, hL⟩)) J = multiplicity L I :=\n  by\n  rw [normalized_factors_equiv_of_quot_equiv, equiv.coe_fn_mk, subtype.coe_mk]\n  exact\n    multiplicity_factor_dvd_iso_eq_multiplicity_of_mem_normalized_factor hI hJ hL fun ⟨l, hl⟩ ⟨l', hl'⟩ =>\n      ideal_factors_equiv_of_quot_equiv_is_dvd_iso f hl hl'\n#align\n  normalized_factors_equiv_of_quot_equiv_multiplicity_eq_multiplicity normalized_factors_equiv_of_quot_equiv_multiplicity_eq_multiplicity\n\n",
 "multiplicity_normalized_factors_equiv_span_normalized_factors_symm_eq_multiplicity":
 "/-- The bijection `normalized_factors_equiv_span_normalized_factors.symm` between the set of prime\n    factors of the ideal `⟨r⟩` and the set of prime factors of `r` preserves multiplicities. -/\ntheorem multiplicity_normalized_factors_equiv_span_normalized_factors_symm_eq_multiplicity {r : R} (hr : r ≠ 0)\n    (I : { I : ideal R | I ∈ normalized_factors (ideal.span ({r} : set R)) }) :\n    multiplicity ((normalized_factors_equiv_span_normalized_factors hr).symm I : R) r =\n      multiplicity (I : ideal R) (ideal.span {r}) :=\n  by\n  obtain ⟨x, hx⟩ := (normalized_factors_equiv_span_normalized_factors hr).surjective I\n  obtain ⟨a, ha⟩ := x\n  rw [hx.symm, equiv.symm_apply_apply, subtype.coe_mk,\n    multiplicity_normalized_factors_equiv_span_normalized_factors_eq_multiplicity hr ha, hx]\n#align\n  multiplicity_normalized_factors_equiv_span_normalized_factors_symm_eq_multiplicity multiplicity_normalized_factors_equiv_span_normalized_factors_symm_eq_multiplicity\n\n",
 "multiplicity_normalized_factors_equiv_span_normalized_factors_eq_multiplicity":
 "/-- The bijection `normalized_factors_equiv_span_normalized_factors` between the set of prime\n    factors of `r` and the set of prime factors of the ideal `⟨r⟩` preserves multiplicities. -/\ntheorem multiplicity_normalized_factors_equiv_span_normalized_factors_eq_multiplicity {r d : R} (hr : r ≠ 0)\n    (hd : d ∈ normalized_factors r) :\n    multiplicity d r =\n      multiplicity (normalized_factors_equiv_span_normalized_factors hr ⟨d, hd⟩ : ideal R) (ideal.span {r}) :=\n  by\n  simp only [normalized_factors_equiv_span_normalized_factors, multiplicity_eq_multiplicity_span, subtype.coe_mk,\n    equiv.of_bijective_apply]\n#align\n  multiplicity_normalized_factors_equiv_span_normalized_factors_eq_multiplicity multiplicity_normalized_factors_equiv_span_normalized_factors_eq_multiplicity\n\n",
 "multiplicity_eq_multiplicity_span":
 "theorem multiplicity_eq_multiplicity_span [decidable_rel ((· ∣ ·) : R → R → Prop)]\n    [decidable_rel ((· ∣ ·) : ideal R → ideal R → Prop)] {a b : R} :\n    multiplicity (ideal.span {a}) (ideal.span ({b} : set R)) = multiplicity a b :=\n  by\n  by_cases h : Finite a b\n  · rw [← part_enat.coe_get (finite_iff_dom.mp h)]\n    refine' (multiplicity.unique (show ideal.span {a} ^ (multiplicity a b).get h ∣ ideal.span {b} from _) _).symm <;>\n      rw [ideal.span_singleton_pow, span_singleton_dvd_span_singleton_iff_dvd]\n    exact pow_multiplicity_dvd h\n    ·\n      exact\n        multiplicity.is_greatest\n          ((part_enat.lt_coe_iff _ _).mpr (exists.intro (finite_iff_dom.mp h) (nat.lt_succ_self _)))\n  · suffices ¬Finite (ideal.span ({a} : set R)) (ideal.span ({b} : set R))\n      by\n      rw [finite_iff_dom, part_enat.not_dom_iff_eq_top] at h this\n      rw [h, this]\n    refine'\n      not_finite_iff_forall.mpr fun n =>\n        by\n        rw [ideal.span_singleton_pow, span_singleton_dvd_span_singleton_iff_dvd]\n        exact not_finite_iff_forall.mp h n\n#align multiplicity_eq_multiplicity_span multiplicity_eq_multiplicity_span\n\n",
 "mul_right_strict_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mul_right_strict_mono [is_dedekind_domain A] {I : fractional_ideal (non_zero_divisors A) K} (hI : I ≠ 0) :\n    strict_mono (· * I) :=\n  strictMono_of_le_iff_le fun _ _ => (mul_right_le_iff hI).symm\n#align mul_right_strict_mono mul_right_strict_mono\n\n",
 "mul_right_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mul_right_le_iff [is_dedekind_domain A] {J : fractional_ideal (non_zero_divisors A) K} (hJ : J ≠ 0) :\n    ∀ {I I'}, I * J ≤ I' * J ↔ I ≤ I' := by\n  intro I I'\n  constructor\n  · intro h\n    convert mul_right_mono J⁻¹ h <;> rw [mul_assoc, fractional_ideal.mul_inv_cancel hJ, mul_one]\n  · exact fun h => mul_right_mono J h\n#align mul_right_le_iff mul_right_le_iff\n\n",
 "mul_mem_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal.is_prime.mul_mem_pow (I : ideal R) [hI : I.is_prime] {a b : R} {n : ℕ} (h : a * b ∈ I ^ n) :\n    a ∈ I ∨ b ∈ I ^ n := by\n  cases n; · simp\n  by_cases hI0 : I = «expr⊥»; · simpa [pow_succ, hI0] using h\n  simp only [← submodule.span_singleton_le_iff_mem, ideal.submodule_span_eq, ← ideal.dvd_iff_le, ←\n    ideal.span_singleton_mul_span_singleton] at h⊢\n  by_cases ha : I ∣ span {a}\n  · exact or.inl ha\n  rw [mul_comm] at h\n  exact or.inr (Prime.pow_dvd_of_dvd_mul_right ((ideal.prime_iff_is_prime hI0).mpr hI) _ ha h)\n#align ideal.is_prime.mul_mem_pow ideal.is_prime.mul_mem_pow\n\n",
 "mul_left_strict_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mul_left_strict_mono [is_dedekind_domain A] {I : fractional_ideal (non_zero_divisors A) K} (hI : I ≠ 0) :\n    strict_mono ((· * ·) I) :=\n  strictMono_of_le_iff_le fun _ _ => (mul_left_le_iff hI).symm\n#align mul_left_strict_mono mul_left_strict_mono\n\n",
 "mul_left_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mul_left_le_iff [is_dedekind_domain A] {J : fractional_ideal (non_zero_divisors A) K} (hJ : J ≠ 0) {I I'} :\n    J * I ≤ J * I' ↔ I ≤ I' := by convert mul_right_le_iff hJ using 1 <;> simp only [mul_comm]\n#align mul_left_le_iff mul_left_le_iff\n\n",
 "mul_inv_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n#print mul_inv_eq_one /-\ntheorem mul_inv_eq_one {I : fractional_ideal (non_zero_divisors A) K} (hI : I ≠ 0) : I * I⁻¹ = 1 :=\n  is_dedekind_domain_inv_iff.mp h I hI\n#align mul_inv_eq_one mul_inv_eq_one\n-/\n\n",
 "mul_inv_cancel_of_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mul_inv_cancel_of_le_one [h : is_dedekind_domain A] {I : ideal A} (hI0 : I ≠ «expr⊥»)\n    (hI : ((I * I⁻¹)⁻¹ : fractional_ideal (non_zero_divisors A) K) ≤ 1) :\n    (I * I⁻¹ : fractional_ideal (non_zero_divisors A) K) = 1 :=\n  by\n  -- Handle a few trivial cases.\n  by_cases hI1 : I = «expr⊤»\n  · rw [hI1, coe_ideal_top, one_mul, inv_one]\n  by_cases hNF : IsField A\n  · letI := hNF.to_field\n    rcases hI1 (I.eq_bot_or_top.resolve_left hI0) with ⟨⟩\n  -- We'll show a contradiction with `exists_not_mem_one_of_ne_bot`:\n  -- `J⁻¹ = (I * I⁻¹)⁻¹` cannot have an element `x ∉ 1`, so it must equal `1`.\n  obtain ⟨J, hJ⟩ : ∃ J : ideal A, (J : fractional_ideal (non_zero_divisors A) K) = I * I⁻¹ :=\n    le_one_iff_exists_coe_ideal.mp mul_one_div_le_one\n  by_cases hJ0 : J = «expr⊥»\n  · subst hJ0\n    refine' absurd _ hI0\n    rw [eq_bot_iff, ← coe_ideal_le_coe_ideal K, hJ]\n    exact coe_ideal_le_self_mul_inv K I\n    infer_instance\n  by_cases hJ1 : J = «expr⊤»\n  · rw [← hJ, hJ1, coe_ideal_top]\n  obtain ⟨x, hx, hx1⟩ :\n    ∃ x : K,\n      x ∈ (J : fractional_ideal (non_zero_divisors A) K)⁻¹ ∧ x ∉ (1 : fractional_ideal (non_zero_divisors A) K) :=\n    exists_not_mem_one_of_ne_bot hNF hJ0 hJ1\n  contrapose! hx1 with h_abs\n  rw [hJ] at hx\n  exact hI hx\n#align mul_inv_cancel_of_le_one mul_inv_cancel_of_le_one\n\n",
 "mul_inv_cancel_iff_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mul_inv_cancel_iff_is_unit {I : fractional_ideal (non_zero_divisors R₁) K} : I * I⁻¹ = 1 ↔ is_unit I :=\n  (mul_inv_cancel_iff K).trans isUnit_iff_exists_inv.symm\n#align mul_inv_cancel_iff_is_unit mul_inv_cancel_iff_is_unit\n\n",
 "mul_inv_cancel_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mul_inv_cancel_iff {I : fractional_ideal (non_zero_divisors R₁) K} : I * I⁻¹ = 1 ↔ ∃ J, I * J = 1 :=\n  ⟨fun h => ⟨I⁻¹, h⟩, fun ⟨J, hJ⟩ => by rwa [← right_inverse_eq K I J hJ]⟩\n#align mul_inv_cancel_iff mul_inv_cancel_iff\n\n",
 "mul_inv_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n#print mul_inv_cancel /-\n/-- Nonzero fractional ideals in a Dedekind domain are units.\n\nThis is also available as `_root_.mul_inv_cancel`, using the\n`comm_group_with_zero` instance defined below.\n-/\nprotected theorem mul_inv_cancel [is_dedekind_domain A] {I : fractional_ideal (non_zero_divisors A) K} (hne : I ≠ 0) :\n    I * I⁻¹ = 1 :=\n  by\n  obtain ⟨a, J, ha, hJ⟩ :\n    ∃ (a : A)(aI : ideal A), a ≠ 0 ∧ I = span_singleton (non_zero_divisors A) (algebra_map _ _ a)⁻¹ * aI :=\n    exists_eq_span_singleton_mul I\n  suffices h₂ : I * (span_singleton (non_zero_divisors A) (algebra_map _ _ a) * J⁻¹) = 1\n  · rw [mul_inv_cancel_iff]\n    exact ⟨span_singleton (non_zero_divisors A) (algebra_map _ _ a) * J⁻¹, h₂⟩\n  subst hJ\n  rw [mul_assoc, mul_left_comm (J : fractional_ideal (non_zero_divisors A) K), coe_ideal_mul_inv, mul_one,\n    span_singleton_mul_span_singleton, inv_mul_cancel, span_singleton_one]\n  · exact mt ((injective_iff_map_eq_zero (algebra_map A K)).mp (is_fraction_ring.injective A K) _) ha\n  · exact coe_ideal_ne_zero.mp (right_ne_zero_of_mul hne)\n#align mul_inv_cancel mul_inv_cancel\n-/\n\n",
 "mul_generator_self_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mul_generator_self_inv {R₁ : Type _} [CommRing R₁] [algebra R₁ K] [is_localization (non_zero_divisors R₁) K]\n    (I : fractional_ideal (non_zero_divisors R₁) K) [submodule.is_principal (I : submodule R₁ K)] (h : I ≠ 0) :\n    I * span_singleton _ (generator (I : submodule R₁ K))⁻¹ = 1 :=\n  by\n  -- Rewrite only the `I` that appears alone.\n  conv_lhs =>\n    congr\n    rw [eq_span_singleton_of_principal I]\n  rw [span_singleton_mul_span_singleton, mul_inv_cancel, span_singleton_one]\n  intro generator_I_eq_zero\n  apply h\n  rw [eq_span_singleton_of_principal I, generator_I_eq_zero, span_singleton_zero]\n#align mul_generator_self_inv mul_generator_self_inv\n\n",
 "mem_inv_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem mem_inv_iff (hI : I ≠ 0) {x : K} : x ∈ I⁻¹ ↔ ∀ y ∈ I, x * y ∈ (1 : fractional_ideal (non_zero_divisors R₁) K) :=\n  mem_div_iff_of_nonzero hI\n#align mem_inv_iff mem_inv_iff\n\n",
 "map_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n#print map_inv /-\n@[simp]\ntheorem map_inv (I : fractional_ideal (non_zero_divisors R₁) K) (h : «expr ≃ₐ[ ] » K R₁ K') :\n    I⁻¹.map (h : «expr →ₐ[ ] » K R₁ K') = (I.map h)⁻¹ := by rw [inv_eq, map_div, map_one, inv_eq]\n#align map_inv map_inv\n-/\n\n",
 "le_singleton_iff":
 "theorem associates.le_singleton_iff (x : A) (n : ℕ) (I : ideal A) :\n    Associates.mk I ^ n ≤ Associates.mk (ideal.span {x}) ↔ x ∈ I ^ n := by\n  rw [← Associates.dvd_eq_le, ← Associates.mk_pow, Associates.mk_dvd_mk, ideal.dvd_span_singleton]\n#align associates.le_singleton_iff associates.le_singleton_iff\n\n",
 "le_self_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem le_self_mul_inv {I : fractional_ideal (non_zero_divisors R₁) K}\n    (hI : I ≤ (1 : fractional_ideal (non_zero_divisors R₁) K)) : I ≤ I * I⁻¹ :=\n  le_self_mul_one_div hI\n#align le_self_mul_inv le_self_mul_inv\n\n",
 "le_of_pow_le_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal.le_of_pow_le_prime {I P : ideal R} [hP : P.is_prime] {n : ℕ} (h : I ^ n ≤ P) : I ≤ P :=\n  by\n  by_cases hP0 : P = «expr⊥»\n  · simp only [hP0, le_bot_iff] at h⊢\n    exact pow_eq_zero h\n  rw [← ideal.dvd_iff_le] at h⊢\n  exact ((ideal.prime_iff_is_prime hP0).mpr hP).dvd_of_dvd_pow h\n#align ideal.le_of_pow_le_prime ideal.le_of_pow_le_prime\n\n",
 "le_mul_of_no_prime_factors":
 "/- Warning: even though a pure term-mode proof typechecks (the `by convert` can simply be\n  removed), it's slower to the point of a possible timeout. -/\ntheorem ideal.le_mul_of_no_prime_factors {I J K : ideal R} (coprime : ∀ P, J ≤ P → K ≤ P → ¬is_prime P) (hJ : I ≤ J)\n    (hK : I ≤ K) : I ≤ J * K := by\n  simp only [← ideal.dvd_iff_le] at coprime hJ hK⊢\n  by_cases hJ0 : J = 0\n  · simpa only [hJ0, zero_mul] using hJ\n  obtain ⟨I', rfl⟩ := hK\n  rw [mul_comm]\n  exact\n    mul_dvd_mul_left K\n      (unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors hJ0\n        (fun P hPJ hPK => mt ideal.is_prime_of_prime (coprime P hPJ hPK)) hJ)\n#align ideal.le_mul_of_no_prime_factors ideal.le_mul_of_no_prime_factors\n\n",
 "lcm_eq_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem lcm_eq_inf (I J : ideal A) : lcm I J = «expr ⊓ » I J :=\n  rfl\n#align lcm_eq_inf lcm_eq_inf\n\n",
 "is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\nprotected theorem is_unit {I : fractional_ideal (non_zero_divisors A) K} (hI : I ≠ 0) : is_unit I :=\n  isUnit_of_mul_eq_one _ _ (h.mul_inv_eq_one hI)\n#align is_unit is_unit\n\n",
 "is_principal_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem is_principal_inv (I : fractional_ideal (non_zero_divisors R₁) K) [submodule.is_principal (I : submodule R₁ K)]\n    (h : I ≠ 0) : submodule.is_principal I⁻¹.1 :=\n  by\n  rw [val_eq_coe, is_principal_iff]\n  use (generator (I : submodule R₁ K))⁻¹\n  have hI : I * span_singleton _ (generator (I : submodule R₁ K))⁻¹ = 1\n  apply mul_generator_self_inv _ I h\n  exact (right_inverse_eq _ I (span_singleton _ (generator (I : submodule R₁ K))⁻¹) hI).symm\n#align is_principal_inv is_principal_inv\n\n",
 "is_prime_of_prime":
 "theorem ideal.is_prime_of_prime {P : ideal A} (h : Prime P) : is_prime P :=\n  by\n  refine' ⟨_, fun x y hxy => _⟩\n  · rintro rfl\n    rw [← ideal.one_eq_top] at h\n    exact h.not_unit isUnit_one\n  · simp only [← ideal.dvd_span_singleton, ← ideal.span_singleton_mul_span_singleton] at hxy⊢\n    exact h.dvd_or_dvd hxy\n#align ideal.is_prime_of_prime ideal.is_prime_of_prime\n\n",
 "is_prime_iff_bot_or_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- In a Dedekind domain, the the prime ideals are the zero ideal together with the prime elements\nof the monoid with zero `ideal A`. -/\ntheorem ideal.is_prime_iff_bot_or_prime {P : ideal A} : is_prime P ↔ P = «expr⊥» ∨ Prime P :=\n  ⟨fun hp => (eq_or_ne P («expr⊥»)).imp_right fun hp0 => ideal.prime_of_is_prime hp0 hp, fun hp =>\n    hp.elim (fun h => h.symm ▸ ideal.bot_prime) ideal.is_prime_of_prime⟩\n#align ideal.is_prime_iff_bot_or_prime ideal.is_prime_iff_bot_or_prime\n\n",
 "is_noetherian_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem is_noetherian_ring : is_noetherian_ring A :=\n  by\n  refine' is_noetherian_ring_iff.mpr ⟨fun I : ideal A => _⟩\n  by_cases hI : I = «expr⊥»\n  · rw [hI]\n    apply submodule.fg_bot\n  have hI : (I : fractional_ideal (non_zero_divisors A) (fraction_ring A)) ≠ 0 := coe_ideal_ne_zero.mpr hI\n  exact I.fg_of_is_unit (is_fraction_ring.injective A (fraction_ring A)) (h.is_unit hI)\n#align is_noetherian_ring is_noetherian_ring\n\n",
 "is_dedekind_domain_inv_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (I «expr ≠ » («expr⊥»() : fractional_ideal[fractional_ideal] non_zero_divisors(A) K)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem is_dedekind_domain_inv_iff [algebra A K] [is_fraction_ring A K] :\n    is_dedekind_domain_inv A ↔ ∀ (I) (_ : I ≠ («expr⊥» : fractional_ideal (non_zero_divisors A) K)), I * I⁻¹ = 1 :=\n  by\n  let h := map_equiv (fraction_ring.alg_equiv A K)\n  refine' h.to_equiv.forall_congr fun I => _\n  rw [← h.to_equiv.apply_eq_iff_eq]\n  simp [is_dedekind_domain_inv, show «expr⇑ » h.to_equiv = h from rfl]\n#align is_dedekind_domain_inv_iff is_dedekind_domain_inv_iff\n\n",
 "is_dedekind_domain_iff_is_dedekind_domain_inv":
 "/-- `is_dedekind_domain` and `is_dedekind_domain_inv` are equivalent ways\nto express that an integral domain is a Dedekind domain. -/\ntheorem is_dedekind_domain_iff_is_dedekind_domain_inv : is_dedekind_domain A ↔ is_dedekind_domain_inv A :=\n  ⟨fun h I hI => fractional_ideal.mul_inv_cancel hI, fun h => h.is_dedekind_domain⟩\n#align is_dedekind_domain_iff_is_dedekind_domain_inv is_dedekind_domain_iff_is_dedekind_domain_inv\n\n",
 "is_dedekind_domain":
 "/-- Showing one side of the equivalence between the definitions\n`is_dedekind_domain_inv` and `is_dedekind_domain` of Dedekind domains. -/\ntheorem is_dedekind_domain : is_dedekind_domain A :=\n  ⟨h.is_noetherian_ring, h.dimension_le_one, h.integrally_closed⟩\n#align is_dedekind_domain is_dedekind_domain\n\n",
 "irreducible_pow_sup_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem irreducible_pow_sup_of_le (hJ : Irreducible J) (n : ℕ) (hn : ↑n ≤ multiplicity J I) :\n    «expr ⊔ » (J ^ n) I = J ^ n := by\n  by_cases hI : I = «expr⊥»\n  · simp_all\n  rw [irreducible_pow_sup hI hJ, min_eq_right]\n  rwa [multiplicity_eq_count_normalized_factors hJ hI, part_enat.coe_le_coe, normalize_eq J] at hn\n#align irreducible_pow_sup_of_le irreducible_pow_sup_of_le\n\n",
 "irreducible_pow_sup_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem irreducible_pow_sup_of_ge (hI : I ≠ «expr⊥») (hJ : Irreducible J) (n : ℕ) (hn : multiplicity J I ≤ n) :\n    «expr ⊔ » (J ^ n) I = J ^ (multiplicity J I).get (part_enat.dom_of_le_coe hn) :=\n  by\n  rw [irreducible_pow_sup hI hJ, min_eq_left]\n  congr\n  · rw [← part_enat.coe_inj, part_enat.coe_get, multiplicity_eq_count_normalized_factors hJ hI, normalize_eq J]\n  · rwa [multiplicity_eq_count_normalized_factors hJ hI, part_enat.coe_le_coe, normalize_eq J] at hn\n#align irreducible_pow_sup_of_ge irreducible_pow_sup_of_ge\n\n",
 "irreducible_pow_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem irreducible_pow_sup (hI : I ≠ «expr⊥») (hJ : Irreducible J) (n : ℕ) :\n    «expr ⊔ » (J ^ n) I = J ^ min ((normalized_factors I).count J) n := by\n  rw [sup_eq_prod_inf_factors (pow_ne_zero n hJ.ne_zero) hI, min_comm, normalized_factors_of_irreducible_pow hJ,\n    normalize_eq J, replicate_inter, prod_replicate]\n#align irreducible_pow_sup irreducible_pow_sup\n\n",
 "invertible_of_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem invertible_of_principal (I : fractional_ideal (non_zero_divisors R₁) K)\n    [submodule.is_principal (I : submodule R₁ K)] (h : I ≠ 0) : I * I⁻¹ = 1 :=\n  mul_div_self_cancel_iff.mpr ⟨span_singleton _ (generator (I : submodule R₁ K))⁻¹, mul_generator_self_inv _ I h⟩\n#align invertible_of_principal invertible_of_principal\n\n",
 "invertible_iff_generator_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem invertible_iff_generator_nonzero (I : fractional_ideal (non_zero_divisors R₁) K)\n    [submodule.is_principal (I : submodule R₁ K)] : I * I⁻¹ = 1 ↔ generator (I : submodule R₁ K) ≠ 0 :=\n  by\n  constructor\n  · intro hI hg\n    apply ne_zero_of_mul_eq_one _ _ hI\n    rw [eq_span_singleton_of_principal I, hg, span_singleton_zero]\n  · intro hg\n    apply invertible_of_principal\n    rw [eq_span_singleton_of_principal I]\n    intro hI\n    have := mem_span_singleton_self _ (generator (I : submodule R₁ K))\n    rw [hI, mem_zero_iff] at this\n    contradiction\n#align invertible_iff_generator_nonzero invertible_iff_generator_nonzero\n\n",
 "inv_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem inv_zero' : (0 : fractional_ideal (non_zero_divisors R₁) K)⁻¹ = 0 :=\n  div_zero\n#align inv_zero' inv_zero'\n\n",
 "inv_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem inv_nonzero {J : fractional_ideal (non_zero_divisors R₁) K} (h : J ≠ 0) :\n    J⁻¹ = ⟨(1 : fractional_ideal (non_zero_divisors R₁) K) / J, fractional_div_of_nonzero h⟩ :=\n  div_nonzero _\n#align inv_nonzero inv_nonzero\n\n",
 "inv_mul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n#print inv_mul_eq_one /-\ntheorem inv_mul_eq_one {I : fractional_ideal (non_zero_divisors A) K} (hI : I ≠ 0) : I⁻¹ * I = 1 :=\n  (mul_comm _ _).trans (h.mul_inv_eq_one hI)\n#align inv_mul_eq_one inv_mul_eq_one\n-/\n\n",
 "inv_eq":
 "/-\nCopyright (c) 2020 Kenji Nakagawa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenji Nakagawa, Anne Baanen, Filippo A. E. Nuccio\n-/\ntheorem inv_eq : I⁻¹ = 1 / I :=\n  rfl\n#align inv_eq inv_eq\n\n",
 "inv_anti_mono":
 "theorem inv_anti_mono (hI : I ≠ 0) (hJ : J ≠ 0) (hIJ : I ≤ J) : J⁻¹ ≤ I⁻¹ := fun x =>\n  by\n  simp only [mem_inv_iff hI, mem_inv_iff hJ]\n  exact fun h y hy => h y (hIJ hy)\n#align inv_anti_mono inv_anti_mono\n\n",
 "integrally_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem integrally_closed : is_integrally_closed A :=\n  by\n  -- It suffices to show that for integral `x`,\n  -- `A[x]` (which is a fractional ideal) is in fact equal to `A`.\n  refine' ⟨fun x hx => _⟩\n  rw [← Set.mem_range, ← algebra.mem_bot, ← subalgebra.mem_to_submodule, algebra.to_submodule_bot, ←\n    coe_span_singleton (non_zero_divisors A) (1 : fraction_ring A), span_singleton_one, ←\n    fractional_ideal.adjoin_integral_eq_one_of_is_unit x hx (h.is_unit _)]\n  · exact mem_adjoin_integral_self (non_zero_divisors A) x hx\n  · exact fun h => one_ne_zero (eq_zero_iff.mp h 1 (subalgebra.one_mem _))\n#align integrally_closed integrally_closed\n\n",
 "infi_localization_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A Dedekind domain is equal to the intersection of its localizations at all its height one\nnon-zero prime ideals viewed as subalgebras of its field of fractions. -/\ntheorem infi_localization_eq_bot [algebra R K] [hK : is_fraction_ring R K] :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (localization.subalgebra.of_field K _ v.as_ideal.prime_compl_le_non_zero_divisors) =\n      «expr⊥» :=\n  by\n  ext x\n  rw [algebra.mem_infi]\n  constructor\n  by_cases hR : IsField R\n  · rcases function.bijective_iff_has_inverse.mp\n        (is_field.localization_map_bijective (flip non_zero_divisors.ne_zero rfl : 0 ∉ non_zero_divisors R) hR) with\n      ⟨algebra_map_inv, _, algebra_map_right_inv⟩\n    exact fun _ => algebra.mem_bot.mpr ⟨algebra_map_inv x, algebra_map_right_inv x⟩\n    exact hK\n  all_goals rw [← maximal_spectrum.infi_localization_eq_bot, algebra.mem_infi]\n  · exact fun hx ⟨v, hv⟩ => hx ((equiv_maximal_spectrum hR).symm ⟨v, hv⟩)\n  · exact fun hx ⟨v, hv, hbot⟩ => hx ⟨v, dimension_le_one v hbot hv⟩\n#align infi_localization_eq_bot infi_localization_eq_bot\n\n",
 "inf_prime_pow_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (i j «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The intersection of distinct prime powers in a Dedekind domain is the product of these\nprime powers. -/\ntheorem is_dedekind_domain.inf_prime_pow_eq_prod {ι : Type _} (s : Finset ι) (f : ι → ideal R) (e : ι → ℕ)\n    (prime : ∀ i ∈ s, Prime (f i)) (coprime : ∀ (i) (_ : i ∈ s) (j) (_ : j ∈ s), i ≠ j → f i ≠ f j) :\n    (s.inf fun i => f i ^ e i) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i ^ e i) :=\n  by\n  letI := classical.dec_eq ι\n  revert prime coprime\n  refine' s.induction _ _\n  · simp\n  intro a s ha ih prime coprime\n  specialize\n    ih (fun i hi => Prime i (Finset.mem_insert_of_mem hi)) fun i hi j hj =>\n      coprime i (Finset.mem_insert_of_mem hi) j (Finset.mem_insert_of_mem hj)\n  rw [finset.inf_insert, finset.prod_insert ha, ih]\n  refine' le_antisymm (ideal.le_mul_of_no_prime_factors _ inf_le_left inf_le_right) ideal.mul_le_inf\n  intro P hPa hPs hPp\n  haveI := hPp\n  obtain ⟨b, hb, hPb⟩ := ideal.prod_le_prime.mp hPs\n  haveI := ideal.is_prime_of_prime (Prime a (Finset.mem_insert_self a s))\n  haveI := ideal.is_prime_of_prime (Prime b (Finset.mem_insert_of_mem hb))\n  refine'\n    coprime a (Finset.mem_insert_self a s) b (Finset.mem_insert_of_mem hb) _\n      (((is_dedekind_domain.dimension_le_one.prime_le_prime_iff_eq _).mp (ideal.le_of_pow_le_prime hPa)).trans\n        ((is_dedekind_domain.dimension_le_one.prime_le_prime_iff_eq _).mp (ideal.le_of_pow_le_prime hPb)).symm)\n  · rintro rfl\n    contradiction\n  · exact (Prime a (Finset.mem_insert_self a s)).ne_zero\n  · exact (Prime b (Finset.mem_insert_of_mem hb)).ne_zero\n#align is_dedekind_domain.inf_prime_pow_eq_prod is_dedekind_domain.inf_prime_pow_eq_prod\n\n",
 "inf_eq_mul_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_eq_mul_of_coprime {I J : ideal A} (coprime : «expr ⊔ » I J = «expr⊤») : «expr ⊓ » I J = I * J := by\n  rw [← associated_iff_eq.mp (gcd_mul_lcm I J), lcm_eq_inf I J, gcd_eq_sup, coprime, top_mul]\n#align inf_eq_mul_of_coprime inf_eq_mul_of_coprime\n\n",
 "ideal_factors_fun_of_quot_hom_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp]\ntheorem ideal_factors_fun_of_quot_hom_id :\n    ideal_factors_fun_of_quot_hom (RingHom.id («expr ⧸ » A J)).is_surjective = OrderHom.id :=\n  OrderHom.ext _ _\n    (funext fun X => by\n      simp only [ideal_factors_fun_of_quot_hom, map_id, OrderHom.coe_fun_mk, order_hom.id_coe, id.def,\n        comap_map_of_surjective J quotient.mk_surjective, ← ring_hom.ker_eq_comap_bot J, mk_ker,\n        sup_eq_left.mpr (dvd_iff_le.mp X.prop), subtype.coe_eta])\n#align ideal_factors_fun_of_quot_hom_id ideal_factors_fun_of_quot_hom_id\n\n",
 "ideal_factors_fun_of_quot_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem ideal_factors_fun_of_quot_hom_comp {f : «expr →+* » («expr ⧸ » R I) («expr ⧸ » A J)}\n    {g : «expr →+* » («expr ⧸ » A J) («expr ⧸ » B L)} (hf : function.surjective f) (hg : function.surjective g) :\n    (ideal_factors_fun_of_quot_hom hg).comp (ideal_factors_fun_of_quot_hom hf) =\n      ideal_factors_fun_of_quot_hom (show function.surjective (g.comp f) from hg.comp hf) :=\n  by\n  refine' OrderHom.ext _ _ (funext fun x => _)\n  rw [ideal_factors_fun_of_quot_hom, ideal_factors_fun_of_quot_hom, order_hom.comp_coe, OrderHom.coe_fun_mk,\n    OrderHom.coe_fun_mk, Function.comp_apply, ideal_factors_fun_of_quot_hom, OrderHom.coe_fun_mk, subtype.mk_eq_mk,\n    subtype.coe_mk, map_comap_of_surjective J quotient.mk_surjective, map_map]\n#align ideal_factors_fun_of_quot_hom_comp ideal_factors_fun_of_quot_hom_comp\n\n",
 "ideal_factors_equiv_of_quot_equiv_symm":
 "theorem ideal_factors_equiv_of_quot_equiv_symm :\n    (ideal_factors_equiv_of_quot_equiv f).symm = ideal_factors_equiv_of_quot_equiv f.symm :=\n  rfl\n#align ideal_factors_equiv_of_quot_equiv_symm ideal_factors_equiv_of_quot_equiv_symm\n\n",
 "ideal_factors_equiv_of_quot_equiv_mem_normalized_factors_of_mem_normalized_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal_factors_equiv_of_quot_equiv_mem_normalized_factors_of_mem_normalized_factors (hJ : J ≠ «expr⊥»)\n    {L : ideal R} (hL : L ∈ normalized_factors I) :\n    ↑(ideal_factors_equiv_of_quot_equiv f ⟨L, dvd_of_mem_normalized_factors hL⟩) ∈ normalized_factors J :=\n  by\n  by_cases hI : I = «expr⊥»\n  · exfalso\n    rw [hI, bot_eq_zero, normalized_factors_zero, ← Multiset.empty_eq_zero] at hL\n    exact hL\n  · apply mem_normalized_factors_factor_dvd_iso_of_mem_normalized_factors hI hJ hL _\n    rintro ⟨l, hl⟩ ⟨l', hl'⟩\n    rw [subtype.coe_mk, subtype.coe_mk]\n    apply ideal_factors_equiv_of_quot_equiv_is_dvd_iso f\n#align\n  ideal_factors_equiv_of_quot_equiv_mem_normalized_factors_of_mem_normalized_factors ideal_factors_equiv_of_quot_equiv_mem_normalized_factors_of_mem_normalized_factors\n\n",
 "ideal_factors_equiv_of_quot_equiv_is_dvd_iso":
 "theorem ideal_factors_equiv_of_quot_equiv_is_dvd_iso {L M : ideal R} (hL : L ∣ I) (hM : M ∣ I) :\n    (ideal_factors_equiv_of_quot_equiv f ⟨L, hL⟩ : ideal A) ∣ ideal_factors_equiv_of_quot_equiv f ⟨M, hM⟩ ↔ L ∣ M :=\n  by\n  suffices\n    ideal_factors_equiv_of_quot_equiv f ⟨M, hM⟩ ≤ ideal_factors_equiv_of_quot_equiv f ⟨L, hL⟩ ↔\n      (⟨M, hM⟩ : { p : ideal R | p ∣ I }) ≤ ⟨L, hL⟩\n    by rw [dvd_iff_le, dvd_iff_le, Subtype.coe_le_coe, this, Subtype.mk_le_mk]\n  exact (ideal_factors_equiv_of_quot_equiv f).le_iff_le\n#align ideal_factors_equiv_of_quot_equiv_is_dvd_iso ideal_factors_equiv_of_quot_equiv_is_dvd_iso\n\n",
 "gcd_eq_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n-- In fact, any lawful gcd and lcm would equal sup and inf respectively.\n@[simp]\ntheorem gcd_eq_sup (I J : ideal A) : gcd I J = «expr ⊔ » I J :=\n  rfl\n#align gcd_eq_sup gcd_eq_sup\n\n",
 "exists_not_mem_one_of_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem exists_not_mem_one_of_ne_bot [is_dedekind_domain A] (hNF : ¬IsField A) {I : ideal A} (hI0 : I ≠ «expr⊥»)\n    (hI1 : I ≠ «expr⊤») :\n    ∃ x : K,\n      x ∈ (I⁻¹ : fractional_ideal (non_zero_divisors A) K) ∧ x ∉ (1 : fractional_ideal (non_zero_divisors A) K) :=\n  by\n  -- WLOG, let `I` be maximal.\n  suffices\n    ∀ {M : ideal A} (hM : M.is_maximal),\n      ∃ x : K, x ∈ (M⁻¹ : fractional_ideal (non_zero_divisors A) K) ∧ x ∉ (1 : fractional_ideal (non_zero_divisors A) K)\n    by\n    obtain ⟨M, hM, hIM⟩ : ∃ M : ideal A, is_maximal M ∧ I ≤ M := ideal.exists_le_maximal I hI1\n    skip\n    have hM0 := (M.bot_lt_of_maximal hNF).ne'\n    obtain ⟨x, hxM, hx1⟩ := this hM\n    refine' ⟨x, inv_anti_mono _ _ ((coe_ideal_le_coe_ideal _).mpr hIM) hxM, hx1⟩ <;> rw [coe_ideal_ne_zero] <;>\n      assumption\n  -- Let `a` be a nonzero element of `M` and `J` the ideal generated by `a`.\n  intro M hM\n  skip\n  obtain ⟨⟨a, haM⟩, ha0⟩ := submodule.nonzero_mem_of_bot_lt (M.bot_lt_of_maximal hNF)\n  replace ha0 : a ≠ 0 := subtype.coe_injective.ne ha0\n  let J : ideal A := ideal.span {a}\n  have hJ0 : J ≠ «expr⊥» := mt ideal.span_singleton_eq_bot.mp ha0\n  have hJM : J ≤ M := ideal.span_le.mpr (set.singleton_subset_iff.mpr haM)\n  have hM0 : «expr⊥» < M := M.bot_lt_of_maximal hNF\n  -- Then we can find a product of prime (hence maximal) ideals contained in `J`,\n  -- such that removing element `M` from the product is not contained in `J`.\n  obtain ⟨Z, hle, hnle⟩ := exists_multiset_prod_cons_le_and_prod_not_le hNF hJ0 hJM\n  -- Choose an element `b` of the product that is not in `J`.\n  obtain ⟨b, hbZ, hbJ⟩ := set_like.not_le_iff_exists.mp hnle\n  have hnz_fa : algebra_map A K a ≠ 0 := mt ((injective_iff_map_eq_zero _).mp (is_fraction_ring.injective A K) a) ha0\n  have hb0 : algebra_map A K b ≠ 0 :=\n    mt ((injective_iff_map_eq_zero _).mp (is_fraction_ring.injective A K) b) fun h => hbJ <| h.symm ▸ J.zero_mem\n  -- Then `b a⁻¹ : K` is in `M⁻¹` but not in `1`.\n  refine' ⟨algebra_map A K b * (algebra_map A K a)⁻¹, (mem_inv_iff _).mpr _, _⟩\n  · exact coe_ideal_ne_zero.mpr hM0.ne'\n  · rintro y₀ hy₀\n    obtain ⟨y, h_Iy, rfl⟩ := (mem_coe_ideal _).mp hy₀\n    rw [mul_comm, ← mul_assoc, ← RingHom.map_mul]\n    have h_yb : y * b ∈ J := by\n      apply hle\n      rw [Multiset.prod_cons]\n      exact submodule.smul_mem_smul h_Iy hbZ\n    rw [ideal.mem_span_singleton'] at h_yb\n    rcases h_yb with ⟨c, hc⟩\n    rw [← hc, RingHom.map_mul, mul_assoc, mul_inv_cancel hnz_fa, mul_one]\n    apply coe_mem_one\n  · refine' mt (mem_one_iff _).mp _\n    rintro ⟨x', h₂_abs⟩\n    rw [← div_eq_mul_inv, eq_div_iff_mul_eq hnz_fa, ← RingHom.map_mul] at h₂_abs\n    have := ideal.mem_span_singleton'.mpr ⟨x', is_fraction_ring.injective A K h₂_abs⟩\n    contradiction\n#align exists_not_mem_one_of_ne_bot exists_not_mem_one_of_ne_bot\n\n",
 "exists_multiset_prod_cons_le_and_prod_not_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/-- Specialization of `exists_prime_spectrum_prod_le_and_ne_bot_of_domain` to Dedekind domains:\nLet `I : ideal A` be a nonzero ideal, where `A` is a Dedekind domain that is not a field.\nThen `exists_prime_spectrum_prod_le_and_ne_bot_of_domain` states we can find a product of prime\nideals that is contained within `I`. This lemma extends that result by making the product minimal:\nlet `M` be a maximal ideal that contains `I`, then the product including `M` is contained within `I`\nand the product excluding `M` is not contained within `I`. -/\ntheorem exists_multiset_prod_cons_le_and_prod_not_le [is_dedekind_domain A] (hNF : ¬IsField A) {I M : ideal A}\n    (hI0 : I ≠ «expr⊥») (hIM : I ≤ M) [hM : M.is_maximal] :\n    ∃ Z : Multiset (prime_spectrum A),\n      («expr ::ₘ » M (Z.map prime_spectrum.as_ideal)).prod ≤ I ∧ ¬Multiset.prod (Z.map prime_spectrum.as_ideal) ≤ I :=\n  by\n  -- Let `Z` be a minimal set of prime ideals such that their product is contained in `J`.\n  obtain ⟨Z₀, hZ₀⟩ := prime_spectrum.exists_prime_spectrum_prod_le_and_ne_bot_of_domain hNF hI0\n  obtain ⟨Z, ⟨hZI, hprodZ⟩, h_eraseZ⟩ :=\n    multiset.well_founded_lt.has_min\n      (fun Z => (Z.map prime_spectrum.as_ideal).prod ≤ I ∧ (Z.map prime_spectrum.as_ideal).prod ≠ «expr⊥») ⟨Z₀, hZ₀⟩\n  have hZM : Multiset.prod (Z.map prime_spectrum.as_ideal) ≤ M := le_trans hZI hIM\n  have hZ0 : Z ≠ 0 := by\n    rintro rfl\n    simpa [hM.ne_top] using hZM\n  obtain ⟨_, hPZ', hPM⟩ := (hM.is_prime.multiset_prod_le (mt multiset.map_eq_zero.mp hZ0)).mp hZM\n  -- Then in fact there is a `P ∈ Z` with `P ≤ M`.\n  obtain ⟨P, hPZ, rfl⟩ := multiset.mem_map.mp hPZ'\n  classical\n    have := Multiset.map_erase prime_spectrum.as_ideal prime_spectrum.ext P Z\n    obtain ⟨hP0, hZP0⟩ : P.as_ideal ≠ «expr⊥» ∧ ((Z.erase P).map prime_spectrum.as_ideal).prod ≠ «expr⊥» := by\n      rwa [ne.def, ← Multiset.cons_erase hPZ', Multiset.prod_cons, ideal.mul_eq_bot, not_or, ← this] at hprodZ\n    -- By maximality of `P` and `M`, we have that `P ≤ M` implies `P = M`.\n    have hPM' := (is_dedekind_domain.dimension_le_one _ hP0 P.is_prime).eq_of_le hM.ne_top hPM\n    subst hPM'\n    -- By minimality of `Z`, erasing `P` from `Z` is exactly what we need.\n    refine' ⟨Z.erase P, _, _⟩\n    · convert hZI\n      rw [this, Multiset.cons_erase hPZ']\n    · refine' fun h => h_eraseZ (Z.erase P) ⟨h, _⟩ (multiset.erase_lt.mpr hPZ)\n      exact hZP0\n#align exists_multiset_prod_cons_le_and_prod_not_le exists_multiset_prod_cons_le_and_prod_not_le\n\n",
 "exists_mem_pow_not_mem_pow_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ideal.exists_mem_pow_not_mem_pow_succ (I : ideal A) (hI0 : I ≠ «expr⊥») (hI1 : I ≠ «expr⊤») (e : ℕ) :\n    ∃ x ∈ I ^ e, x ∉ I ^ (e + 1) :=\n  SetLike.exists_of_lt (I.strict_anti_pow hI0 hI1 e.lt_succ_self)\n#align ideal.exists_mem_pow_not_mem_pow_succ ideal.exists_mem_pow_not_mem_pow_succ\n\n",
 "exist_integer_multiples_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- Strengthening of `is_localization.exist_integer_multiples`:\nLet `J ≠ ⊤` be an ideal in a Dedekind domain `A`, and `f ≠ 0` a finite collection\nof elements of `K = Frac(A)`, then we can multiply the elements of `f` by some `a : K`\nto find a collection of elements of `A` that is not completely contained in `J`. -/\ntheorem ideal.exist_integer_multiples_not_mem {J : ideal A} (hJ : J ≠ «expr⊤») {ι : Type _} (s : Finset ι) (f : ι → K)\n    {j} (hjs : j ∈ s) (hjf : f j ≠ 0) :\n    ∃ a : K,\n      (∀ i ∈ s, is_localization.is_integer A (a * f i)) ∧\n        ∃ i ∈ s, a * f i ∉ (J : fractional_ideal (non_zero_divisors A) K) :=\n  by\n  -- Consider the fractional ideal `I` spanned by the `f`s.\n  let I : fractional_ideal (non_zero_divisors A) K := span_finset A s f\n  have hI0 : I ≠ 0 := span_finset_ne_zero.mpr ⟨j, hjs, hjf⟩\n  -- We claim the multiplier `a` we're looking for is in `I⁻¹ \\ (J / I)`.\n  suffices ↑J / I < I⁻¹ by\n    obtain ⟨_, a, hI, hpI⟩ := set_like.lt_iff_le_and_exists.mp this\n    rw [mem_inv_iff hI0] at hI\n    refine' ⟨a, fun i hi => _, _⟩\n    -- By definition, `a ∈ I⁻¹` multiplies elements of `I` into elements of `1`,\n    -- in other words, `a * f i` is an integer.\n    · exact (mem_one_iff _).mp (hI (f i) (submodule.subset_span (Set.mem_image_of_mem f hi)))\n    · contrapose! hpI\n      -- And if all `a`-multiples of `I` are an element of `J`,\n      -- then `a` is actually an element of `J / I`, contradiction.\n      refine' (mem_div_iff_of_nonzero hI0).mpr fun y hy => submodule.span_induction hy _ _ _ _\n      · rintro _ ⟨i, hi, rfl⟩\n        exact hpI i hi\n      · rw [mul_zero]\n        exact submodule.zero_mem _\n      · intro x y hx hy\n        rw [mul_add]\n        exact submodule.add_mem _ hx hy\n      · intro b x hx\n        rw [mul_smul_comm]\n        exact submodule.smul_mem _ b hx\n  -- To show the inclusion of `J / I` into `I⁻¹ = 1 / I`, note that `J < I`.\n  calc\n    ↑J / I = ↑J * I⁻¹ := div_eq_mul_inv (↑J) I\n    _ < 1 * I⁻¹ := mul_right_strict_mono (inv_ne_zero hI0) _\n    _ = I⁻¹ := one_mul _\n    \n  · rw [← coe_ideal_top]\n    -- And multiplying by `I⁻¹` is indeed strictly monotone.\n    exact strictMono_of_le_iff_le (fun _ _ => (coe_ideal_le_coe_ideal K).symm) (lt_top_iff_ne_top.mpr hJ)\n#align ideal.exist_integer_multiples_not_mem ideal.exist_integer_multiples_not_mem\n\n",
 "eq_prime_pow_of_succ_lt_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal.eq_prime_pow_of_succ_lt_of_le {P I : ideal A} [P_prime : P.is_prime] (hP : P ≠ «expr⊥») {i : ℕ}\n    (hlt : P ^ (i + 1) < I) (hle : I ≤ P ^ i) : I = P ^ i :=\n  by\n  letI := classical.dec_eq (ideal A)\n  refine' le_antisymm hle _\n  have P_prime' := ideal.prime_of_is_prime hP P_prime\n  have : I ≠ «expr⊥» := (lt_of_le_of_lt bot_le hlt).ne'\n  have := pow_ne_zero i hP\n  have := pow_ne_zero (i + 1) hP\n  rw [← ideal.dvd_not_unit_iff_lt, dvd_not_unit_iff_normalized_factors_lt_normalized_factors, normalized_factors_pow,\n    normalized_factors_irreducible P_prime'.irreducible, Multiset.nsmul_singleton, Multiset.lt_replicate_succ] at hlt\n  rw [← ideal.dvd_iff_le, dvd_iff_normalized_factors_le_normalized_factors, normalized_factors_pow,\n    normalized_factors_irreducible P_prime'.irreducible, Multiset.nsmul_singleton]\n  all_goals assumption\n#align ideal.eq_prime_pow_of_succ_lt_of_le ideal.eq_prime_pow_of_succ_lt_of_le\n\n",
 "dvd_span_singleton":
 "@[simp]\ntheorem ideal.dvd_span_singleton {I : ideal A} {x : A} : I ∣ ideal.span {x} ↔ x ∈ I :=\n  ideal.dvd_iff_le.trans (ideal.span_le.trans Set.singleton_subset_iff)\n#align ideal.dvd_span_singleton ideal.dvd_span_singleton\n\n",
 "dvd_not_unit_iff_lt":
 "theorem ideal.dvd_not_unit_iff_lt {I J : ideal A} : DvdNotUnit I J ↔ J < I :=\n  ⟨fun ⟨hI, H, hunit, hmul⟩ =>\n    lt_of_le_of_ne (ideal.dvd_iff_le.mp ⟨H, hmul⟩)\n      (mt\n        (fun h =>\n          have : H = 1 := mul_left_cancel₀ hI (by rw [← hmul, h, mul_one])\n          show is_unit H from this.symm ▸ isUnit_one)\n        hunit),\n    fun h => dvdNotUnit_of_dvd_of_not_dvd (ideal.dvd_iff_le.mpr (le_of_lt h)) (mt ideal.dvd_iff_le.mp (not_le_of_lt h))⟩\n#align ideal.dvd_not_unit_iff_lt ideal.dvd_not_unit_iff_lt\n\n",
 "dvd_iff_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n-- Project out the computable fields first.\n/-- For ideals in a Dedekind domain, to divide is to contain. -/\ntheorem ideal.dvd_iff_le {I J : ideal A} : I ∣ J ↔ J ≤ I :=\n  ⟨ideal.le_of_dvd, fun h => by\n    by_cases hI : I = «expr⊥»\n    · have hJ : J = «expr⊥» := by rwa [hI, ← eq_bot_iff] at h\n      rw [hI, hJ]\n    have hI' : (I : fractional_ideal (non_zero_divisors A) (fraction_ring A)) ≠ 0 := coe_ideal_ne_zero.mpr hI\n    have : (I : fractional_ideal (non_zero_divisors A) (fraction_ring A))⁻¹ * J ≤ 1 :=\n      le_trans (mul_left_mono (↑I)⁻¹ ((coe_ideal_le_coe_ideal _).mpr h)) (le_of_eq (inv_mul_cancel hI'))\n    obtain ⟨H, hH⟩ := le_one_iff_exists_coe_ideal.mp this\n    use H\n    refine' coe_ideal_injective (show (J : fractional_ideal (non_zero_divisors A) (fraction_ring A)) = ↑(I * H) from _)\n    rw [coe_ideal_mul, hH, ← mul_assoc, mul_inv_cancel hI', one_mul]⟩\n#align ideal.dvd_iff_le ideal.dvd_iff_le\n\n",
 "div_eq_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n#print div_eq_mul_inv /-\n/-- This is also available as `_root_.div_eq_mul_inv`, using the\n`comm_group_with_zero` instance defined below.\n-/\nprotected theorem div_eq_mul_inv [is_dedekind_domain A] (I J : fractional_ideal (non_zero_divisors A) K) :\n    I / J = I * J⁻¹ := by\n  by_cases hJ : J = 0\n  · rw [hJ, div_zero, inv_zero', mul_zero]\n  refine' le_antisymm ((mul_right_le_iff hJ).mp _) ((le_div_iff_mul_le hJ).mpr _)\n  · rw [mul_assoc, mul_comm J⁻¹, fractional_ideal.mul_inv_cancel hJ, mul_one, mul_le]\n    intro x hx y hy\n    rw [mem_div_iff_of_nonzero hJ] at hx\n    exact hx y hy\n  rw [mul_assoc, mul_comm J⁻¹, fractional_ideal.mul_inv_cancel hJ, mul_one]\n  exact le_refl I\n#align div_eq_mul_inv div_eq_mul_inv\n-/\n\n",
 "dimension_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem dimension_le_one : dimension_le_one A :=\n  by\n  -- We're going to show that `P` is maximal because any (maximal) ideal `M`\n  -- that is strictly larger would be `⊤`.\n  rintro P P_ne hP\n  refine' ideal.is_maximal_def.mpr ⟨hP.ne_top, fun M hM => _⟩\n  -- We may assume `P` and `M` (as fractional ideals) are nonzero.\n  have P'_ne : (P : fractional_ideal (non_zero_divisors A) (fraction_ring A)) ≠ 0 := coe_ideal_ne_zero.mpr P_ne\n  have M'_ne : (M : fractional_ideal (non_zero_divisors A) (fraction_ring A)) ≠ 0 :=\n    coe_ideal_ne_zero.mpr (lt_of_le_of_lt bot_le hM).ne'\n  -- In particular, we'll show `M⁻¹ * P ≤ P`\n  suffices (M⁻¹ * P : fractional_ideal (non_zero_divisors A) (fraction_ring A)) ≤ P\n    by\n    rw [eq_top_iff, ← coe_ideal_le_coe_ideal (fraction_ring A), coe_ideal_top]\n    calc\n      (1 : fractional_ideal (non_zero_divisors A) (fraction_ring A)) = _ * _ * _ := _\n      _ ≤ _ * _ := mul_right_mono (P⁻¹ * M : fractional_ideal (non_zero_divisors A) (fraction_ring A)) this\n      _ = M := _\n      \n    · rw [mul_assoc, ← mul_assoc ↑P, h.mul_inv_eq_one P'_ne, one_mul, h.inv_mul_eq_one M'_ne]\n    · rw [← mul_assoc ↑P, h.mul_inv_eq_one P'_ne, one_mul]\n    · infer_instance\n  -- Suppose we have `x ∈ M⁻¹ * P`, then in fact `x = algebra_map _ _ y` for some `y`.\n  intro x hx\n  have le_one : (M⁻¹ * P : fractional_ideal (non_zero_divisors A) (fraction_ring A)) ≤ 1 :=\n    by\n    rw [← h.inv_mul_eq_one M'_ne]\n    exact mul_left_mono _ ((coe_ideal_le_coe_ideal (fraction_ring A)).mpr hM.le)\n  obtain ⟨y, hy, rfl⟩ := (mem_coe_ideal _).mp (le_one hx)\n  -- Since `M` is strictly greater than `P`, let `z ∈ M \\ P`.\n  obtain ⟨z, hzM, hzp⟩ := SetLike.exists_of_lt hM\n  -- We have `z * y ∈ M * (M⁻¹ * P) = P`.\n  have zy_mem := mul_mem_mul (mem_coe_ideal_of_mem (non_zero_divisors A) hzM) hx\n  rw [← RingHom.map_mul, ← mul_assoc, h.mul_inv_eq_one M'_ne, one_mul] at zy_mem\n  obtain ⟨zy, hzy, zy_eq⟩ := (mem_coe_ideal (non_zero_divisors A)).mp zy_mem\n  rw [is_fraction_ring.injective A (fraction_ring A) zy_eq] at hzy\n  -- But `P` is a prime ideal, so `z ∉ P` implies `y ∈ P`, as desired.\n  exact mem_coe_ideal_of_mem (non_zero_divisors A) (or.resolve_left (hP.mem_or_mem hzy) hzp)\n#align dimension_le_one dimension_le_one\n\n",
 "count_normalized_factors_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem ideal.count_normalized_factors_eq {p x : ideal R} [hp : p.is_prime] {n : ℕ} (hle : x ≤ p ^ n)\n    (hlt : ¬x ≤ p ^ (n + 1)) : (normalized_factors x).count p = n :=\n  count_normalized_factors_eq' ((ideal.is_prime_iff_bot_or_prime.mp hp).imp_right Prime.irreducible)\n    (by\n      haveI : unique («expr ˣ» (ideal R)) := ideal.unique_units\n      apply normalize_eq)\n    (by convert ideal.dvd_iff_le.mpr hle) (by convert mt ideal.le_of_dvd hlt)\n#align ideal.count_normalized_factors_eq ideal.count_normalized_factors_eq\n\n",
 "count_le_of_ideal_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem count_le_of_ideal_ge {I J : ideal T} (h : I ≤ J) (hI : I ≠ «expr⊥») (K : ideal T) :\n    count K (normalized_factors J) ≤ count K (normalized_factors I) :=\n  le_iff_count.1 ((dvd_iff_normalized_factors_le_normalized_factors (ne_bot_of_le_ne_bot hI h) hI).1 (dvd_iff_le.2 h)) _\n#align count_le_of_ideal_ge count_le_of_ideal_ge\n\n",
 "coprime_of_no_prime_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ideal.coprime_of_no_prime_ge {I J : ideal R} (h : ∀ P, I ≤ P → J ≤ P → ¬is_prime P) : «expr ⊔ » I J = «expr⊤» :=\n  by\n  by_contra hIJ\n  obtain ⟨P, hP, hIJ⟩ := ideal.exists_le_maximal _ hIJ\n  exact h P (le_trans le_sup_left hIJ) (le_trans le_sup_right hIJ) hP.is_prime\n#align ideal.coprime_of_no_prime_ge ideal.coprime_of_no_prime_ge\n\n",
 "coe_inv_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem coe_inv_of_nonzero {J : fractional_ideal (non_zero_divisors R₁) K} (h : J ≠ 0) :\n    (↑J⁻¹ : submodule R₁ K) = is_localization.coe_submodule K («expr⊤») / J :=\n  by\n  rwa [inv_nonzero _]\n  rfl\n  assumption\n#align coe_inv_of_nonzero coe_inv_of_nonzero\n\n",
 "coe_ideal_span_singleton_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem coe_ideal_span_singleton_mul_inv {x : R₁} (hx : x ≠ 0) :\n    (ideal.span ({x} : set R₁) : fractional_ideal (non_zero_divisors R₁) K) * (ideal.span ({x} : set R₁))⁻¹ = 1 := by\n  rw [coe_ideal_span_singleton,\n    span_singleton_mul_inv K <| (map_ne_zero_iff _ <| no_zero_smul_divisors.algebra_map_injective R₁ K).mpr hx]\n#align coe_ideal_span_singleton_mul_inv coe_ideal_span_singleton_mul_inv\n\n",
 "coe_ideal_span_singleton_inv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem coe_ideal_span_singleton_inv_mul {x : R₁} (hx : x ≠ 0) :\n    (ideal.span ({x} : set R₁) : fractional_ideal (non_zero_divisors R₁) K)⁻¹ * ideal.span ({x} : set R₁) = 1 := by\n  rw [mul_comm, coe_ideal_span_singleton_mul_inv K hx]\n#align coe_ideal_span_singleton_inv_mul coe_ideal_span_singleton_inv_mul\n\n",
 "coe_ideal_span_singleton_div_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem coe_ideal_span_singleton_div_self {x : R₁} (hx : x ≠ 0) :\n    (ideal.span ({x} : set R₁) : fractional_ideal (non_zero_divisors R₁) K) / ideal.span ({x} : set R₁) = 1 := by\n  rw [coe_ideal_span_singleton,\n    span_singleton_div_self K <| (map_ne_zero_iff _ <| no_zero_smul_divisors.algebra_map_injective R₁ K).mpr hx]\n#align coe_ideal_span_singleton_div_self coe_ideal_span_singleton_div_self\n\n",
 "coe_ideal_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- Nonzero integral ideals in a Dedekind domain are invertible.\n\nWe will use this to show that nonzero fractional ideals are invertible,\nand finally conclude that fractional ideals in a Dedekind domain form a group with zero.\n-/\ntheorem coe_ideal_mul_inv [h : is_dedekind_domain A] (I : ideal A) (hI0 : I ≠ «expr⊥») :\n    (I * I⁻¹ : fractional_ideal (non_zero_divisors A) K) = 1 :=\n  by\n  -- We'll show `1 ≤ J⁻¹ = (I * I⁻¹)⁻¹ ≤ 1`.\n  apply mul_inv_cancel_of_le_one hI0\n  by_cases hJ0 : (I * I⁻¹ : fractional_ideal (non_zero_divisors A) K) = 0\n  · rw [hJ0, inv_zero']\n    exact zero_le _\n  intro x hx\n  -- In particular, we'll show all `x ∈ J⁻¹` are integral.\n  suffices x ∈ integral_closure A K by\n    rwa [is_integrally_closed.integral_closure_eq_bot, algebra.mem_bot, Set.mem_range, ← mem_one_iff] at this <;>\n      assumption\n  -- For that, we'll find a subalgebra that is f.g. as a module and contains `x`.\n  -- `A` is a noetherian ring, so we just need to find a subalgebra between `{x}` and `I⁻¹`.\n  rw [mem_integral_closure_iff_mem_fg]\n  have x_mul_mem :\n    ∀ b ∈ (I⁻¹ : fractional_ideal (non_zero_divisors A) K), x * b ∈ (I⁻¹ : fractional_ideal (non_zero_divisors A) K) :=\n    by\n    intro b hb\n    rw [mem_inv_iff] at hx⊢\n    swap\n    · exact coe_ideal_ne_zero.mpr hI0\n    swap\n    · exact hJ0\n    simp only [mul_assoc, mul_comm b] at hx⊢\n    intro y hy\n    exact hx _ (mul_mem_mul hy hb)\n  -- It turns out the subalgebra consisting of all `p(x)` for `p : A[X]` works.\n  refine'\n    ⟨alg_hom.range (polynomial.aeval x : «expr →ₐ[ ] » (polynomial A) A K),\n      is_noetherian_submodule.mp (is_noetherian I⁻¹) _ fun y hy => _, ⟨polynomial.X, polynomial.aeval_X x⟩⟩\n  obtain ⟨p, rfl⟩ := (alg_hom.mem_range _).mp hy\n  rw [polynomial.aeval_eq_sum_range]\n  refine' submodule.sum_mem _ fun i hi => submodule.smul_mem _ _ _\n  clear hi\n  induction' i with i ih\n  · rw [pow_zero]\n    exact one_mem_inv_coe_ideal hI0\n  · show x ^ i.succ ∈ (I⁻¹ : fractional_ideal (non_zero_divisors A) K)\n    rw [pow_succ]\n    exact x_mul_mem _ ih\n#align coe_ideal_mul_inv coe_ideal_mul_inv\n\n",
 "coe_ideal_le_self_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem coe_ideal_le_self_mul_inv (I : ideal R₁) : (I : fractional_ideal (non_zero_divisors R₁) K) ≤ I * I⁻¹ :=\n  le_self_mul_inv coe_ideal_le_one\n#align coe_ideal_le_self_mul_inv coe_ideal_le_self_mul_inv\n\n",
 "associates_irreducible":
 "theorem associates_irreducible : _root_.irreducible <| Associates.mk v.as_ideal :=\n  (Associates.irreducible_mk _).mpr v.irreducible\n#align associates_irreducible associates_irreducible\n\n",
 "adjoin_integral_eq_one_of_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem fractional_ideal.adjoin_integral_eq_one_of_is_unit [algebra A K] [is_fraction_ring A K] (x : K)\n    (hx : is_integral A x) (hI : is_unit (adjoin_integral (non_zero_divisors A) x hx)) :\n    adjoin_integral (non_zero_divisors A) x hx = 1 :=\n  by\n  set I := adjoin_integral (non_zero_divisors A) x hx\n  have mul_self : I * I = I := by\n    apply coe_to_submodule_injective\n    simp\n  convert congr_arg (· * I⁻¹) mul_self <;> simp only [(mul_inv_cancel_iff_is_unit K).mpr hI, mul_assoc, mul_one]\n#align fractional_ideal.adjoin_integral_eq_one_of_is_unit fractional_ideal.adjoin_integral_eq_one_of_is_unit\n\n",
 "Prime":
 "#print Prime /-\ntheorem Prime : Prime v.as_ideal :=\n  ideal.prime_of_is_prime v.ne_bot v.is_prime\n#align prime Prime\n-/\n\n",
 "Irreducible":
 "#print Irreducible /-\ntheorem Irreducible : Irreducible v.as_ideal :=\n  unique_factorization_monoid.irreducible_iff_prime.mpr v.prime\n#align irreducible Irreducible\n-/\n\n"}