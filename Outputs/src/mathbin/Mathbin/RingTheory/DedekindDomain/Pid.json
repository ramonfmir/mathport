{"of_finite_primes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A Dedekind domain is a PID if its set of primes is finite. -/\ntheorem is_principal_ideal_ring.of_finite_primes [IsDomain R] [is_dedekind_domain R]\n    (h : { I : Ideal R | I.is_prime }.finite) : IsPrincipalIdealRing R :=\n  ⟨fun I => by\n    obtain rfl | hI := eq_or_ne I («expr⊥»)\n    · exact bot_isPrincipal\n    apply ideal.is_principal.of_finite_maximals_of_is_unit\n    · apply h.subset\n      exact @Ideal.IsMaximal.isPrime _ _\n    · exact isUnit_of_mul_eq_one _ _ (fractional_ideal.coe_ideal_mul_inv I hI)⟩\n#align is_principal_ideal_ring.of_finite_primes is_principal_ideal_ring.of_finite_primes\n\n",
 "of_finite_maximals_of_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem ideal.is_principal.of_finite_maximals_of_is_unit (hf : { I : Ideal R | I.is_maximal }.finite) {I : Ideal R}\n    (hI : IsUnit (I : fractional_ideal (non_zero_divisors R) (FractionRing R))) : I.is_principal :=\n  (IsLocalization.coeSubmodule_isPrincipal _ le_rfl).mp\n    (fractional_ideal.is_principal.of_finite_maximals_of_inv le_rfl hf I\n      (↑hI.unit⁻¹ : fractional_ideal (non_zero_divisors R) (FractionRing R)) hI.unit.mul_inv)\n#align ideal.is_principal.of_finite_maximals_of_is_unit ideal.is_principal.of_finite_maximals_of_is_unit\n\n",
 "of_finite_maximals_of_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem fractional_ideal.is_principal.of_finite_maximals_of_inv {A : Type _} [CommRing A] [Algebra R A]\n    {S : Submonoid R} [IsLocalization S A] (hS : S ≤ non_zero_divisors R) (hf : { I : Ideal R | I.is_maximal }.finite)\n    (I I' : fractional_ideal S A) (hinv : I * I' = 1) : Submodule.IsPrincipal (I : Submodule R A) :=\n  by\n  have hinv' := hinv\n  rw [Subtype.ext_iff, fractional_ideal.coe_mul] at hinv\n  let s := hf.to_finset\n  haveI := Classical.decEq (Ideal R)\n  have coprime : ∀ M ∈ s, ∀ M' ∈ s.erase M, «expr ⊔ » M M' = «expr⊤» :=\n    by\n    simp_rw [Finset.mem_erase, hf.mem_to_finset]\n    rintro M hM M' ⟨hne, hM'⟩\n    exact Ideal.IsMaximal.coprime_of_ne hM hM' hne.symm\n  have nle :\n    ∀ M ∈ s, ¬«expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" M' ≤ M :=\n    fun M hM =>\n    left_lt_sup.1 ((hf.mem_to_finset.1 hM).ne_top.lt_top.trans_eq (Ideal.sup_infᵢ_eq_top <| coprime M hM).symm)\n  have : ∀ M ∈ s, ∃ a ∈ I, ∃ b ∈ I', a * b ∉ IsLocalization.coeSubmodule A M :=\n    by\n    intro M hM\n    by_contra' h\n    obtain ⟨x, hx, hxM⟩ :=\n      SetLike.exists_of_lt\n        ((IsLocalization.coeSubmodule_strictMono hS (hf.mem_to_finset.1 hM).ne_top.lt_top).trans_eq hinv.symm)\n    refine' hxM (Submodule.map₂_le.2 _ hx)\n    exact h\n  choose! a ha b hb hm using this\n  choose! u hu hum using fun M hM => SetLike.not_le_iff_exists.1 (nle M hM)\n  let v :=\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n      («expr • » (u M) (b M))\n  have hv : v ∈ I' := Submodule.sum_mem _ fun M hM => Submodule.smul_mem _ _ <| hb M hM\n  refine'\n    fractional_ideal.is_principal_of_unit_of_comap_mul_span_singleton_eq_top (Units.mkOfMulEqOne I I' hinv') hv\n      (of_not_not fun h => _)\n  obtain ⟨M, hM, hJM⟩ := Ideal.exists_le_maximal _ h\n  replace hM := hf.mem_to_finset.2 hM\n  have : ∀ a ∈ I, ∀ b ∈ I', ∃ c, algebraMap R _ c = a * b :=\n    by\n    intro a ha b hb\n    have hi := hinv.le\n    obtain ⟨c, -, hc⟩ := hi (Submodule.mul_mem_mul ha hb)\n    exact ⟨c, hc⟩\n  have hmem : a M * v ∈ IsLocalization.coeSubmodule A M :=\n    by\n    obtain ⟨c, hc⟩ := this _ (ha M hM) v hv\n    refine' IsLocalization.coeSubmodule_mono _ hJM ⟨c, _, hc⟩\n    have := Submodule.mul_mem_mul (ha M hM) (Submodule.mem_span_singleton_self v)\n    rwa [← hc] at this\n  simp_rw [Finset.mul_sum, mul_smul_comm] at hmem\n  rw [← s.add_sum_erase _ hM, Submodule.add_mem_iff_left] at hmem\n  · refine' hm M hM _\n    obtain ⟨c, hc : algebraMap R A c = a M * b M⟩ := this _ (ha M hM) _ (hb M hM)\n    rw [← hc] at hmem⊢\n    rw [Algebra.smul_def, ← _root_.map_mul] at hmem\n    obtain ⟨d, hdM, he⟩ := hmem\n    rw [IsLocalization.injective _ hS he] at hdM\n    exact Submodule.mem_map_of_mem (((hf.mem_to_finset.1 hM).is_prime.mem_or_mem hdM).resolve_left <| hum M hM)\n  · refine' Submodule.sum_mem _ fun M' hM' => _\n    rw [Finset.mem_erase] at hM'\n    obtain ⟨c, hc⟩ := this _ (ha M hM) _ (hb M' hM'.2)\n    rw [← hc, Algebra.smul_def, ← _root_.map_mul]\n    specialize hu M' hM'.2\n    simp_rw [Ideal.mem_infᵢ, Finset.mem_erase] at hu\n    exact Submodule.mem_map_of_mem (M.mul_mem_right _ <| hu M ⟨hM'.1.symm, hM⟩)\n#align fractional_ideal.is_principal.of_finite_maximals_of_inv fractional_ideal.is_principal.of_finite_maximals_of_inv\n\n",
 "mem_normalized_factors_of_is_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- The first hypothesis below follows from properties of the localization but is needed for the\nsecond, so we leave it to the user to provide (automatically). -/\n/-- If `p` is a prime in the Dedekind domain `R`, `S` an extension of `R` and `Sₚ` the localization\nof `S` at `p`, then all primes in `Sₚ` are factors of the image of `p` in `Sₚ`. -/\ntheorem is_localization.over_prime.mem_normalized_factors_of_is_prime [DecidableEq (Ideal Sₚ)] {P : Ideal Sₚ}\n    (hP : IsPrime P) (hP0 : P ≠ «expr⊥») : P ∈ normalizedFactors (Ideal.map (algebraMap R Sₚ) p) :=\n  by\n  have non_zero_div : Algebra.algebraMapSubmonoid S p.prime_compl ≤ non_zero_divisors S :=\n    map_le_nonZeroDivisors_of_injective _ (NoZeroSMulDivisors.algebraMap_injective _ _)\n      p.prime_compl_le_non_zero_divisors\n  letI : Algebra (localization.at_prime p) Sₚ := localizationAlgebra p.prime_compl S\n  haveI : IsScalarTower R (localization.at_prime p) Sₚ :=\n    IsScalarTower.of_algebraMap_eq fun x => by erw [IsLocalization.map_eq, IsScalarTower.algebraMap_apply R S]\n  obtain ⟨pid, p', ⟨hp'0, hp'p⟩, hpu⟩ :=\n    (discrete_valuation_ring.iff_pid_with_one_nonzero_prime (localization.at_prime p)).mp\n      (is_localization.at_prime.discrete_valuation_ring_of_dedekind_domain R hp0 _)\n  have : local_ring.maximal_ideal (localization.at_prime p) ≠ «expr⊥» :=\n    by\n    rw [Submodule.ne_bot_iff] at hp0⊢\n    obtain ⟨x, x_mem, x_ne⟩ := hp0\n    exact\n      ⟨algebraMap _ _ x, (is_localization.at_prime.to_map_mem_maximal_iff _ _ _).mpr x_mem,\n        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors _ p.prime_compl_le_non_zero_divisors\n          (mem_nonZeroDivisors_of_ne_zero x_ne)⟩\n  rw [← Multiset.singleton_le, ← normalize_eq P, ←\n    normalized_factors_irreducible (ideal.prime_of_is_prime hP0 hP).irreducible, ←\n    dvd_iff_normalized_factors_le_normalized_factors hP0, dvd_iff_le,\n    IsScalarTower.algebraMap_eq R (localization.at_prime p) Sₚ, ← Ideal.map_map,\n    localization.at_prime.map_eq_maximal_ideal, Ideal.map_le_iff_le_comap, hpu (local_ring.maximal_ideal _) ⟨this, _⟩,\n    hpu (comap _ _) ⟨_, _⟩]\n  · exact le_rfl\n  · have hRS : algebra.is_integral R S :=\n      is_integral_of_noetherian (isNoetherian_of_fg_of_noetherian' module.finite.out)\n    exact mt (ideal.eq_bot_of_comap_eq_bot (is_integral_localization hRS)) hP0\n  · exact Ideal.comap_isPrime (algebraMap (localization.at_prime p) Sₚ) P\n  · exact (local_ring.maximal_ideal.is_maximal _).is_prime\n  · rw [ne.def, zero_eq_bot, Ideal.map_eq_bot_iff_of_injective]\n    · assumption\n    rw [IsScalarTower.algebraMap_eq R S Sₚ]\n    exact (IsLocalization.injective Sₚ non_zero_div).comp (NoZeroSMulDivisors.algebraMap_injective _ _)\n#align is_localization.over_prime.mem_normalized_factors_of_is_prime is_localization.over_prime.mem_normalized_factors_of_is_prime\n\n",
 "is_principal_of_unit_of_comap_mul_span_singleton_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem fractional_ideal.is_principal_of_unit_of_comap_mul_span_singleton_eq_top {R A : Type _} [CommRing R]\n    [CommRing A] [Algebra R A] {S : Submonoid R} [IsLocalization S A] (I : «expr ˣ» (fractional_ideal S A)) {v : A}\n    (hv : v ∈ (↑I⁻¹ : fractional_ideal S A))\n    (h : Submodule.comap (Algebra.linearMap R A) (I * Submodule.span R {v}) = «expr⊤») :\n    Submodule.IsPrincipal (I : Submodule R A) :=\n  by\n  have hinv := I.mul_inv\n  set J := Submodule.comap (Algebra.linearMap R A) (I * Submodule.span R {v})\n  have hJ : IsLocalization.coeSubmodule A J = I * Submodule.span R {v} :=\n    by\n    rw [Subtype.ext_iff, fractional_ideal.coe_mul, fractional_ideal.coe_one] at hinv\n    apply Submodule.map_comap_eq_self\n    rw [← Submodule.one_eq_range, ← hinv]\n    exact Submodule.mul_le_mul_right ((Submodule.span_singleton_le_iff_mem _ _).2 hv)\n  have : (1 : A) ∈ ↑I * Submodule.span R {v} :=\n    by\n    rw [← hJ, h, IsLocalization.coeSubmodule_top, Submodule.mem_one]\n    exact ⟨1, (algebraMap R _).map_one⟩\n  obtain ⟨w, hw, hvw⟩ := Submodule.mem_mul_span_singleton.1 this\n  refine' ⟨⟨w, _⟩⟩\n  rw [← fractional_ideal.coe_span_singleton S, ← inv_inv I, eq_comm, coe_coe]\n  refine' congr_arg coe (Units.eq_inv_of_mul_eq_one_left (le_antisymm _ _))\n  · infer_instance\n  · conv_rhs => rw [← hinv, mul_comm]\n    apply fractional_ideal.mul_le_mul_left (fractional_ideal.span_singleton_le_iff_mem.mpr hw)\n  · rw [fractional_ideal.one_le, ← hvw, mul_comm]\n    exact fractional_ideal.mul_mem_mul hv (fractional_ideal.mem_span_singleton_self _ _)\n#align fractional_ideal.is_principal_of_unit_of_comap_mul_span_singleton_eq_top fractional_ideal.is_principal_of_unit_of_comap_mul_span_singleton_eq_top\n\n",
 "is_principal_ideal_ring_localization_over_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- Let `p` be a prime in the Dedekind domain `R` and `S` be an integral extension of `R`,\nthen the localization `Sₚ` of `S` at `p` is a PID. -/\ntheorem is_dedekind_domain.is_principal_ideal_ring_localization_over_prime : IsPrincipalIdealRing Sₚ :=\n  by\n  letI := Classical.decEq (Ideal Sₚ)\n  letI := Classical.decPred fun P : Ideal Sₚ => P.is_prime\n  refine'\n    is_principal_ideal_ring.of_finite_primes\n      (Set.Finite.ofFinset\n        (Finset.filter (fun P => P.is_prime)\n          ({«expr⊥»} ∪ (normalized_factors (Ideal.map (algebraMap R Sₚ) p)).to_finset))\n        fun P => _)\n  rw [Finset.mem_filter, Finset.mem_union, Finset.mem_singleton, Set.mem_setOf, Multiset.mem_toFinset]\n  exact\n    and_iff_right_of_imp fun hP =>\n      or_iff_not_imp_left.mpr (is_localization.over_prime.mem_normalized_factors_of_is_prime S p hp0 hP)\n#align is_dedekind_domain.is_principal_ideal_ring_localization_over_prime is_dedekind_domain.is_principal_ideal_ring_localization_over_prime\n\n",
 "eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-\nCopyright (c) 2023 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n/-- Let `P` be a prime ideal, `x ∈ P \\ P²` and `x ∉ Q` for all prime ideals `Q ≠ P`.\nThen `P` is generated by `x`. -/\ntheorem ideal.eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne {P : Ideal R} (hP : P.is_prime) [IsDomain R]\n    [is_dedekind_domain R] {x : R} (x_mem : x ∈ P) (hxP2 : x ∉ P ^ 2) (hxQ : ∀ Q : Ideal R, IsPrime Q → Q ≠ P → x ∉ Q) :\n    P = Ideal.span {x} := by\n  letI := Classical.decEq (Ideal R)\n  have hx0 : x ≠ 0 := by\n    rintro rfl\n    exact hxP2 (zero_mem _)\n  by_cases hP0 : P = «expr⊥»\n  · subst hP0\n    simpa using hxP2\n  have hspan0 : span ({x} : Set R) ≠ «expr⊥» := mt ideal.span_singleton_eq_bot.mp hx0\n  have span_le := (Ideal.span_singleton_le_iff_mem _).mpr x_mem\n  refine'\n    associated_iff_eq.mp\n      ((associated_iff_normalized_factors_eq_normalized_factors hP0 hspan0).mpr\n        (le_antisymm ((dvd_iff_normalized_factors_le_normalized_factors hP0 hspan0).mp _) _))\n  · rwa [ideal.dvd_iff_le, Ideal.span_singleton_le_iff_mem]\n  simp only [normalized_factors_irreducible (ideal.prime_of_is_prime hP0 hP).irreducible, normalize_eq,\n    Multiset.le_iff_count, Multiset.count_singleton]\n  intro Q\n  split_ifs with hQ\n  · subst hQ\n    refine' (ideal.count_normalized_factors_eq _ _).le <;> simp only [Ideal.span_singleton_le_iff_mem, pow_one] <;>\n      assumption\n  by_cases hQp : is_prime Q\n  · skip\n    refine' (ideal.count_normalized_factors_eq _ _).le <;>\n      simp only [Ideal.span_singleton_le_iff_mem, pow_one, pow_zero, one_eq_top, Submodule.mem_top]\n    exact hxQ _ hQp hQ\n  ·\n    exact\n      (multiset.count_eq_zero.mpr fun hQi =>\n          hQp (is_prime_of_prime (irreducible_iff_prime.mp (irreducible_of_normalized_factor _ hQi)))).le\n#align ideal.eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne ideal.eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne\n\n"}