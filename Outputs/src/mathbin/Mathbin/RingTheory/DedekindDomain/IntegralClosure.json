{"rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is a principal ring\nand `L` has no zero smul divisors by `A`, the `A`-rank of the integral closure `C` of `A` in `L`\nis equal to the `K`-rank of `L`. -/\ntheorem is_integral_closure.rank [IsPrincipalIdealRing A] [NoZeroSMulDivisors A L] :\n    FiniteDimensional.finrank A C = FiniteDimensional.finrank K L :=\n  by\n  haveI : Module.Free A C := is_integral_closure.module_free A K L C\n  haveI : IsNoetherian A C := is_integral_closure.is_noetherian A K L C\n  haveI : IsLocalization (Algebra.algebraMapSubmonoid C (non_zero_divisors A)) L :=\n    is_integral_closure.is_localization A K L C\n  let b := Basis.localizationLocalization K (non_zero_divisors A) L (Module.Free.chooseBasis A C)\n  rw [FiniteDimensional.finrank_eq_card_chooseBasisIndex, FiniteDimensional.finrank_eq_card_basis b]\n#align is_integral_closure.rank is_integral_closure.rank\n\n",
 "range_le_span_dual_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_integral_closure.range_le_span_dual_basis [is_separable K L] {ι : Type _} [Fintype ι] [DecidableEq ι]\n    (b : Basis ι K L) (hb_int : ∀ i, is_integral A (b i)) [is_integrally_closed A] :\n    ((Algebra.linearMap C L).restrict_scalars A).range ≤\n      Submodule.span A (Set.range <| (trace_form K L).dual_basis (trace_form_nondegenerate K L) b) :=\n  by\n  let db := (trace_form K L).dual_basis (trace_form_nondegenerate K L) b\n  rintro _ ⟨x, rfl⟩\n  simp only [LinearMap.coe_restrictScalars, Algebra.linearMap_apply]\n  have hx : is_integral A (algebraMap C L x) := (is_integral_closure.is_integral A L x).algebra_map\n  rsuffices ⟨c, x_eq⟩ :\n    ∃ c : ι → A,\n      algebraMap C L x =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » (c i) (db i))\n  · rw [x_eq]\n    refine' Submodule.sum_mem _ fun i _ => Submodule.smul_mem _ _ (Submodule.subset_span _)\n    rw [Set.mem_range]\n    exact ⟨i, rfl⟩\n  suffices\n    ∃ c : ι → K,\n      (∀ i, is_integral A (c i)) ∧\n        algebraMap C L x =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (c i) (db i))\n    by\n    obtain ⟨c, hc, hx⟩ := this\n    have hc' : ∀ i, IsLocalization.IsInteger A (c i) := fun i => is_integrally_closed.is_integral_iff.mp (hc i)\n    use fun i => Classical.choose (hc' i)\n    refine' hx.trans (Finset.sum_congr rfl fun i _ => _)\n    conv_lhs => rw [← Classical.choose_spec (hc' i)]\n    rw [← IsScalarTower.algebraMap_smul K (Classical.choose (hc' i)) (db i)]\n  refine' ⟨fun i => db.repr (algebraMap C L x) i, fun i => _, (db.sum_repr _).symm⟩\n  rw [bilin_form.dual_basis_repr_apply]\n  exact is_integral_trace (is_integral_mul hx (hb_int i))\n#align is_integral_closure.range_le_span_dual_basis is_integral_closure.range_le_span_dual_basis\n\n",
 "module_free":
 "/- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is a principal ring\nand `L` has no zero smul divisors by `A`, the integral closure `C` of `A` in `L` is\na free `A`-module. -/\ntheorem is_integral_closure.module_free [NoZeroSMulDivisors A L] [IsPrincipalIdealRing A] : Module.Free A C :=\n  by\n  haveI : NoZeroSMulDivisors A C := is_integral_closure.no_zero_smul_divisors A L\n  haveI : IsNoetherian A C := is_integral_closure.is_noetherian A K L _\n  exact Module.free_of_finite_type_torsion_free'\n#align is_integral_closure.module_free is_integral_closure.module_free\n\n",
 "is_noetherian_ring":
 "/- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is\nintegrally closed and Noetherian, the integral closure of `A` in `L` is\nNoetherian. -/\ntheorem integral_closure.is_noetherian_ring [is_integrally_closed A] [IsNoetherianRing A] :\n    IsNoetherianRing (integral_closure A L) :=\n  is_integral_closure.is_noetherian_ring A K L (integral_closure A L)\n#align integral_closure.is_noetherian_ring integral_closure.is_noetherian_ring\n\n",
 "is_noetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is\nintegrally closed and Noetherian, the integral closure `C` of `A` in `L` is\nNoetherian over `A`. -/\ntheorem is_integral_closure.is_noetherian [is_integrally_closed A] [IsNoetherianRing A] : IsNoetherian A C :=\n  by\n  haveI := Classical.decEq L\n  obtain ⟨s, b, hb_int⟩ := finite_dimensional.exists_is_basis_integral A K L\n  let b' := (trace_form K L).dual_basis (trace_form_nondegenerate K L) b\n  letI := isNoetherian_span_of_finite A (Set.finite_range b')\n  let f : «expr →ₗ[ ] » C A (Submodule.span A (Set.range b')) :=\n    (Submodule.ofLe (is_integral_closure.range_le_span_dual_basis C b hb_int)).comp\n      ((Algebra.linearMap C L).restrict_scalars A).range_restrict\n  refine' isNoetherian_of_ker_bot f _\n  rw [LinearMap.ker_comp, Submodule.ker_ofLe, Submodule.comap_bot, LinearMap.ker_codRestrict]\n  exact LinearMap.ker_eq_bot_of_injective (is_integral_closure.algebra_map_injective C A L)\n#align is_integral_closure.is_noetherian is_integral_closure.is_noetherian\n\n",
 "is_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-\nCopyright (c) 2020 Kenji Nakagawa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenji Nakagawa, Anne Baanen, Filippo A. E. Nuccio\n-/\n/- If `L` is a separable extension of `K = Frac(A)` and `L` has no zero smul divisors by `A`,\nthen `L` is the localization of the integral closure `C` of `A` in `L` at `A⁰`. -/\ntheorem is_integral_closure.is_localization [is_separable K L] [NoZeroSMulDivisors A L] :\n    IsLocalization (Algebra.algebraMapSubmonoid C (non_zero_divisors A)) L :=\n  by\n  haveI : IsDomain C :=\n    (is_integral_closure.equiv A C L (integral_closure A L)).to_ring_equiv.is_domain (integral_closure A L)\n  haveI : NoZeroSMulDivisors A C := is_integral_closure.no_zero_smul_divisors A L\n  refine' ⟨_, fun z => _, fun x y => ⟨fun h => ⟨1, _⟩, _⟩⟩\n  · rintro ⟨_, x, hx, rfl⟩\n    rw [isUnit_iff_ne_zero, map_ne_zero_iff _ (is_integral_closure.algebra_map_injective C A L), Subtype.coe_mk,\n      map_ne_zero_iff _ (NoZeroSMulDivisors.algebraMap_injective A C)]\n    exact mem_non_zero_divisors_iff_ne_zero.mp hx\n  · obtain ⟨m, hm⟩ :=\n      is_integral.exists_multiple_integral_of_is_localization (non_zero_divisors A) z (is_separable.is_integral K z)\n    obtain ⟨x, hx⟩ : ∃ x, algebraMap C L x = «expr • » m z := is_integral_closure.is_integral_iff.mp hm\n    refine' ⟨⟨x, algebraMap A C m, m, SetLike.coe_mem m, rfl⟩, _⟩\n    rw [Subtype.coe_mk, ← IsScalarTower.algebraMap_apply, hx, mul_comm, Submonoid.smul_def, smul_def]\n  · simp only [is_integral_closure.algebra_map_injective C A L h]\n  · rintro ⟨⟨_, m, hm, rfl⟩, h⟩\n    refine' congr_arg (algebraMap C L) ((mul_right_inj' _).mp h)\n    rw [Subtype.coe_mk, map_ne_zero_iff _ (NoZeroSMulDivisors.algebraMap_injective A C)]\n    exact mem_non_zero_divisors_iff_ne_zero.mp hm\n#align is_integral_closure.is_localization is_integral_closure.is_localization\n\n",
 "is_dedekind_domain":
 "/- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is a Dedekind domain,\nthe integral closure of `A` in `L` is a Dedekind domain.\n\nCan't be an instance since `K` can't be inferred. See also the instance\n`integral_closure.is_dedekind_domain_fraction_ring` where `K := fraction_ring A`.\n-/\ntheorem integral_closure.is_dedekind_domain [h : is_dedekind_domain A] : is_dedekind_domain (integral_closure A L) :=\n  is_integral_closure.is_dedekind_domain A K L (integral_closure A L)\n#align integral_closure.is_dedekind_domain integral_closure.is_dedekind_domain\n\n",
 "integral_closure_le_span_dual_basis":
 "theorem integral_closure_le_span_dual_basis [is_separable K L] {ι : Type _} [Fintype ι] [DecidableEq ι]\n    (b : Basis ι K L) (hb_int : ∀ i, is_integral A (b i)) [is_integrally_closed A] :\n    (integral_closure A L).to_submodule ≤\n      Submodule.span A (Set.range <| (trace_form K L).dual_basis (trace_form_nondegenerate K L) b) :=\n  by\n  refine' le_trans _ (is_integral_closure.range_le_span_dual_basis (integral_closure A L) b hb_int)\n  intro x hx\n  exact ⟨⟨x, hx⟩, rfl⟩\n#align integral_closure_le_span_dual_basis integral_closure_le_span_dual_basis\n\n",
 "exists_is_basis_integral":
 "/-- If `L` is a finite extension of `K = Frac(A)`,\nthen `L` has a basis over `A` consisting of integral elements. -/\ntheorem finite_dimensional.exists_is_basis_integral : ∃ (s : Finset L)(b : Basis s K L), ∀ x, is_integral A (b x) :=\n  by\n  letI := Classical.decEq L\n  letI : IsNoetherian K L := IsNoetherian.iff_fg.2 inferInstance\n  let s' := IsNoetherian.finsetBasisIndex K L\n  let bs' := IsNoetherian.finsetBasis K L\n  obtain ⟨y, hy, his'⟩ := exists_integral_multiples A K (finset.univ.image bs')\n  have hy' : algebraMap A L y ≠ 0 :=\n    by\n    refine' mt ((injective_iff_map_eq_zero (algebraMap A L)).mp _ _) hy\n    rw [IsScalarTower.algebraMap_eq A K L]\n    exact (algebraMap K L).injective.comp (IsFractionRing.injective A K)\n  refine'\n    ⟨s',\n      bs'.map\n        {\n          Algebra.lmul _ _ (algebraMap A L\n              y) with\n          to_fun := fun x => algebraMap A L y * x\n          inv_fun := fun x => (algebraMap A L y)⁻¹ * x\n          left_inv := _\n          right_inv := _ },\n      _⟩\n  · intro x\n    simp only [inv_mul_cancel_left₀ hy']\n  · intro x\n    simp only [mul_inv_cancel_left₀ hy']\n  · rintro ⟨x', hx'⟩\n    simp only [Algebra.smul_def, Finset.mem_image, exists_prop, Finset.mem_univ, true_and_iff] at his'\n    simp only [Basis.map_apply, LinearEquiv.coe_mk]\n    exact his' _ ⟨_, rfl⟩\n#align finite_dimensional.exists_is_basis_integral finite_dimensional.exists_is_basis_integral\n\n",
 "exists_integral_multiples":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (y «expr ≠ » (0 : A)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Send a set of `x`'es in a finite extension `L` of the fraction field of `R`\nto `(y : R) • x ∈ integral_closure R L`. -/\ntheorem exists_integral_multiples (s : Finset L) : ∃ (y : _)(_ : y ≠ (0 : A)), ∀ x ∈ s, is_integral A («expr • » y x) :=\n  by\n  haveI := Classical.decEq L\n  refine' s.induction _ _\n  · use 1, one_ne_zero\n    rintro x ⟨⟩\n  · rintro x s hx ⟨y, hy, hs⟩\n    obtain ⟨x', y', hy', hx'⟩ :=\n      exists_integral_multiple ((is_fraction_ring.is_algebraic_iff A K L).mpr (is_algebraic_of_finite _ _ x))\n        ((injective_iff_map_eq_zero (algebraMap A L)).mp _)\n    refine' ⟨y * y', mul_ne_zero hy hy', fun x'' hx'' => _⟩\n    rcases finset.mem_insert.mp hx'' with (rfl | hx'')\n    · rw [mul_smul, Algebra.smul_def, Algebra.smul_def, mul_comm _ x'', hx']\n      exact is_integral_mul is_integral_algebra_map x'.2\n    · rw [mul_comm, mul_smul, Algebra.smul_def]\n      exact is_integral_mul is_integral_algebra_map (hs _ hx'')\n    · rw [IsScalarTower.algebraMap_eq A K L]\n      apply (algebraMap K L).injective.comp\n      exact IsFractionRing.injective _ _\n#align exists_integral_multiples exists_integral_multiples\n\n"}