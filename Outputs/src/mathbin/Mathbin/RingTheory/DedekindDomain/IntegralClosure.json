{"range_le_span_dual_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2020 Kenji Nakagawa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenji Nakagawa, Anne Baanen, Filippo A. E. Nuccio\n-/\ntheorem is_integral_closure.range_le_span_dual_basis [is_separable K L] {ι : Type _} [fintype ι] [decidable_eq ι]\n    (b : basis ι K L) (hb_int : ∀ i, is_integral A (b i)) [is_integrally_closed A] :\n    ((algebra.linear_map C L).restrict_scalars A).range ≤\n      submodule.span A (Set.range <| (trace_form K L).dual_basis (trace_form_nondegenerate K L) b) :=\n  by\n  let db := (trace_form K L).dual_basis (trace_form_nondegenerate K L) b\n  rintro _ ⟨x, rfl⟩\n  simp only [linear_map.coe_restrict_scalars_eq_coe, algebra.linear_map_apply]\n  have hx : is_integral A (algebra_map C L x) := (is_integral_closure.is_integral A L x).algebra_map\n  rsuffices ⟨c, x_eq⟩ :\n    ∃ c : ι → A,\n      algebra_map C L x =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » (c i) (db i))\n  · rw [x_eq]\n    refine' submodule.sum_mem _ fun i _ => submodule.smul_mem _ _ (submodule.subset_span _)\n    rw [Set.mem_range]\n    exact ⟨i, rfl⟩\n  suffices\n    ∃ c : ι → K,\n      (∀ i, is_integral A (c i)) ∧\n        algebra_map C L x =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (c i) (db i))\n    by\n    obtain ⟨c, hc, hx⟩ := this\n    have hc' : ∀ i, is_localization.is_integer A (c i) := fun i => is_integrally_closed.is_integral_iff.mp (hc i)\n    use fun i => Classical.choose (hc' i)\n    refine' hx.trans (finset.sum_congr rfl fun i _ => _)\n    conv_lhs => rw [← Classical.choose_spec (hc' i)]\n    rw [← is_scalar_tower.algebra_map_smul K (Classical.choose (hc' i)) (db i)]\n  refine' ⟨fun i => db.repr (algebra_map C L x) i, fun i => _, (db.sum_repr _).symm⟩\n  rw [bilin_form.dual_basis_repr_apply]\n  exact is_integral_trace (is_integral_mul hx (hb_int i))\n#align is_integral_closure.range_le_span_dual_basis is_integral_closure.range_le_span_dual_basis\n\n",
 "is_noetherian_ring":
 "/- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is\nintegrally closed and Noetherian, the integral closure of `A` in `L` is\nNoetherian. -/\ntheorem integral_closure.is_noetherian_ring [is_integrally_closed A] [is_noetherian_ring A] :\n    is_noetherian_ring (integral_closure A L) :=\n  is_integral_closure.is_noetherian_ring A K L (integral_closure A L)\n#align integral_closure.is_noetherian_ring integral_closure.is_noetherian_ring\n\n",
 "is_noetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is\nintegrally closed and Noetherian, the integral closure `C` of `A` in `L` is\nNoetherian over `A`. -/\ntheorem is_integral_closure.is_noetherian [is_integrally_closed A] [is_noetherian_ring A] : is_noetherian A C :=\n  by\n  haveI := classical.dec_eq L\n  obtain ⟨s, b, hb_int⟩ := finite_dimensional.exists_is_basis_integral A K L\n  let b' := (trace_form K L).dual_basis (trace_form_nondegenerate K L) b\n  letI := is_noetherian_span_of_finite A (set.finite_range b')\n  let f : «expr →ₗ[ ] » C A (submodule.span A (Set.range b')) :=\n    (submodule.of_le (is_integral_closure.range_le_span_dual_basis C b hb_int)).comp\n      ((algebra.linear_map C L).restrict_scalars A).range_restrict\n  refine' is_noetherian_of_ker_bot f _\n  rw [linear_map.ker_comp, submodule.ker_of_le, submodule.comap_bot, linear_map.ker_cod_restrict]\n  exact linear_map.ker_eq_bot_of_injective (is_integral_closure.algebra_map_injective C A L)\n#align is_integral_closure.is_noetherian is_integral_closure.is_noetherian\n\n",
 "is_dedekind_domain":
 "/- If `L` is a finite separable extension of `K = Frac(A)`, where `A` is a Dedekind domain,\nthe integral closure of `A` in `L` is a Dedekind domain.\n\nCan't be an instance since `K` can't be inferred. See also the instance\n`integral_closure.is_dedekind_domain_fraction_ring` where `K := fraction_ring A`.\n-/\ntheorem integral_closure.is_dedekind_domain [h : is_dedekind_domain A] : is_dedekind_domain (integral_closure A L) :=\n  is_integral_closure.is_dedekind_domain A K L (integral_closure A L)\n#align integral_closure.is_dedekind_domain integral_closure.is_dedekind_domain\n\n",
 "integral_closure_le_span_dual_basis":
 "theorem integral_closure_le_span_dual_basis [is_separable K L] {ι : Type _} [fintype ι] [decidable_eq ι]\n    (b : basis ι K L) (hb_int : ∀ i, is_integral A (b i)) [is_integrally_closed A] :\n    (integral_closure A L).to_submodule ≤\n      submodule.span A (Set.range <| (trace_form K L).dual_basis (trace_form_nondegenerate K L) b) :=\n  by\n  refine' le_trans _ (is_integral_closure.range_le_span_dual_basis (integral_closure A L) b hb_int)\n  intro x hx\n  exact ⟨⟨x, hx⟩, rfl⟩\n#align integral_closure_le_span_dual_basis integral_closure_le_span_dual_basis\n\n",
 "exists_is_basis_integral":
 "/-- If `L` is a finite extension of `K = Frac(A)`,\nthen `L` has a basis over `A` consisting of integral elements. -/\ntheorem finite_dimensional.exists_is_basis_integral : ∃ (s : Finset L)(b : basis s K L), ∀ x, is_integral A (b x) :=\n  by\n  letI := classical.dec_eq L\n  letI : is_noetherian K L := is_noetherian.iff_fg.2 infer_instance\n  let s' := is_noetherian.finset_basis_index K L\n  let bs' := is_noetherian.finset_basis K L\n  obtain ⟨y, hy, his'⟩ := exists_integral_multiples A K (finset.univ.image bs')\n  have hy' : algebra_map A L y ≠ 0 :=\n    by\n    refine' mt ((injective_iff_map_eq_zero (algebra_map A L)).mp _ _) hy\n    rw [is_scalar_tower.algebra_map_eq A K L]\n    exact (algebra_map K L).injective.comp (is_fraction_ring.injective A K)\n  refine'\n    ⟨s',\n      bs'.map\n        {\n          algebra.lmul _ _ (algebra_map A L\n              y) with\n          to_fun := fun x => algebra_map A L y * x\n          inv_fun := fun x => (algebra_map A L y)⁻¹ * x\n          left_inv := _\n          right_inv := _ },\n      _⟩\n  · intro x\n    simp only [inv_mul_cancel_left₀ hy']\n  · intro x\n    simp only [mul_inv_cancel_left₀ hy']\n  · rintro ⟨x', hx'⟩\n    simp only [algebra.smul_def, Finset.mem_image, exists_prop, finset.mem_univ, true_and_iff] at his'\n    simp only [basis.map_apply, linear_equiv.coe_mk]\n    exact his' _ ⟨_, rfl⟩\n#align finite_dimensional.exists_is_basis_integral finite_dimensional.exists_is_basis_integral\n\n",
 "exists_integral_multiples":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y «expr ≠ » (0 : A)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Send a set of `x`'es in a finite extension `L` of the fraction field of `R`\nto `(y : R) • x ∈ integral_closure R L`. -/\ntheorem exists_integral_multiples (s : Finset L) : ∃ (y : _)(_ : y ≠ (0 : A)), ∀ x ∈ s, is_integral A («expr • » y x) :=\n  by\n  haveI := classical.dec_eq L\n  refine' s.induction _ _\n  · use 1, one_ne_zero\n    rintro x ⟨⟩\n  · rintro x s hx ⟨y, hy, hs⟩\n    obtain ⟨x', y', hy', hx'⟩ :=\n      exists_integral_multiple ((is_fraction_ring.is_algebraic_iff A K L).mpr (is_algebraic_of_finite _ _ x))\n        ((injective_iff_map_eq_zero (algebra_map A L)).mp _)\n    refine' ⟨y * y', mul_ne_zero hy hy', fun x'' hx'' => _⟩\n    rcases finset.mem_insert.mp hx'' with (rfl | hx'')\n    · rw [mul_smul, algebra.smul_def, algebra.smul_def, mul_comm _ x'', hx']\n      exact is_integral_mul is_integral_algebra_map x'.2\n    · rw [mul_comm, mul_smul, algebra.smul_def]\n      exact is_integral_mul is_integral_algebra_map (hs _ hx'')\n    · rw [is_scalar_tower.algebra_map_eq A K L]\n      apply (algebra_map K L).injective.comp\n      exact is_fraction_ring.injective _ _\n#align exists_integral_multiples exists_integral_multiples\n\n"}