{"tfae":
 "/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae [])\n      (Command.declSig\n       [(Term.instBinder \"[\" [] (Term.app `is_bezout [`R]) \"]\") (Term.instBinder \"[\" [] (Term.app `IsDomain [`R]) \"]\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `is_noetherian_ring [`R])\n            \",\"\n            (Term.app `is_principal_ideal_ring [`R])\n            \",\"\n            (Term.app `unique_factorization_monoid [`R])\n            \",\"\n            (Term.app `wf_dvd_monoid [`R])]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Mathlib.Tactic.tacticClassical_\n            \"classical\"\n            (Tactic.tacticSeq\n             (Tactic.tacticSeq1Indented\n              [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.intro \"intro\" [`H])\n                 []\n                 (Tactic.exact\n                  \"exact\"\n                  (Term.anonymousCtor\n                   \"⟨\"\n                   [(Term.fun\n                     \"fun\"\n                     (Term.basicFun\n                      [`I]\n                      []\n                      \"=>\"\n                      (Term.app\n                       `is_principal_of_fg\n                       [(Term.hole \"_\") (Term.app `is_noetherian.noetherian [(Term.hole \"_\")])])))]\n                   \"⟩\"))])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.intro \"intro\" []) [] (Tactic.tacticInfer_instance \"infer_instance\")])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.intro \"intro\" []) [] (Tactic.tacticInfer_instance \"infer_instance\")])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Std.Tactic.rintro\n                  \"rintro\"\n                  [(Std.Tactic.RCases.rintroPat.one\n                    (Std.Tactic.RCases.rcasesPat.tuple\n                     \"⟨\"\n                     [(Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)])\n                       [])]\n                     \"⟩\"))]\n                  [])\n                 []\n                 (Tactic.rwSeq\n                  \"rw\"\n                  []\n                  (Tactic.rwRuleSeq\n                   \"[\"\n                   [(Tactic.rwRule [] `is_noetherian_ring_iff)\n                    \",\"\n                    (Tactic.rwRule [] `is_noetherian_iff_fg_well_founded)]\n                   \"]\")\n                  [])\n                 []\n                 (Tactic.apply \"apply\" (Term.app `RelEmbedding.wellFounded [(Term.hole \"_\") `h]))\n                 []\n                 (Tactic.tacticHave_\n                  \"have\"\n                  (Term.haveDecl\n                   (Term.haveIdDecl\n                    []\n                    [(Term.typeSpec\n                      \":\"\n                      (Term.forall\n                       \"∀\"\n                       [`I]\n                       [(Term.typeSpec\n                         \":\"\n                         («term{_:_//_}» \"{\" `J [\":\" (Term.app `ideal [`R])] \"//\" (Term.proj `J \".\" `fg) \"}\"))]\n                       \",\"\n                       («term∃_,_»\n                        \"∃\"\n                        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] [\":\" `R]))\n                        \",\"\n                        («term_=_»\n                         (Term.typeAscription \"(\" `I \":\" [(Term.app `ideal [`R])] \")\")\n                         \"=\"\n                         (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])))))]\n                    \":=\"\n                    (Term.fun\n                     \"fun\"\n                     (Term.basicFun\n                      [(Term.anonymousCtor \"⟨\" [`I \",\" `hI] \"⟩\")]\n                      []\n                      \"=>\"\n                      (Term.proj (Term.app `is_bezout.is_principal_of_fg [`I `hI]) \".\" (fieldIdx \"1\")))))))\n                 []\n                 (Mathlib.Tactic.Choose.choose \"choose\" [] [(Lean.binderIdent `f) (Lean.binderIdent `hf)] [])\n                 []\n                 (Tactic.exact\n                  \"exact\"\n                  (Term.structInst\n                   \"{\"\n                   []\n                   [(Term.structInstField (Term.structInstLVal `to_fun []) \":=\" `f)\n                    []\n                    (Term.structInstField\n                     (Term.structInstLVal `inj' [])\n                     \":=\"\n                     (Term.fun\n                      \"fun\"\n                      (Term.basicFun\n                       [`x `y `e]\n                       []\n                       \"=>\"\n                       (Term.byTactic\n                        \"by\"\n                        (Tactic.tacticSeq\n                         (Tactic.tacticSeq1Indented\n                          [(Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n                           []\n                           (Tactic.rwSeq\n                            \"rw\"\n                            []\n                            (Tactic.rwRuleSeq\n                             \"[\"\n                             [(Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `e)]\n                             \"]\")\n                            [])]))))))\n                    []\n                    (Term.structInstField\n                     (Term.structInstLVal `map_rel_iff' [])\n                     \":=\"\n                     (Term.fun\n                      \"fun\"\n                      (Term.basicFun\n                       [`x `y]\n                       []\n                       \"=>\"\n                       (Term.byTactic\n                        \"by\"\n                        (Tactic.tacticSeq\n                         (Tactic.tacticSeq1Indented\n                          [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                           []\n                           (Tactic.rwSeq\n                            \"rw\"\n                            []\n                            (Tactic.rwRuleSeq\n                             \"[\"\n                             [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.span_singleton_lt_span_singleton)\n                              \",\"\n                              (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)\n                              \",\"\n                              (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)]\n                             \"]\")\n                            [])\n                           []\n                           (Tactic.tacticRfl \"rfl\")]))))))]\n                   (Term.optEllipsis [])\n                   []\n                   \"}\"))])\n               []\n               (Tactic.tfaeFinish \"tfae_finish\")])))])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Mathlib.Tactic.tacticClassical_\n           \"classical\"\n           (Tactic.tacticSeq\n            (Tactic.tacticSeq1Indented\n             [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.intro \"intro\" [`H])\n                []\n                (Tactic.exact\n                 \"exact\"\n                 (Term.anonymousCtor\n                  \"⟨\"\n                  [(Term.fun\n                    \"fun\"\n                    (Term.basicFun\n                     [`I]\n                     []\n                     \"=>\"\n                     (Term.app\n                      `is_principal_of_fg\n                      [(Term.hole \"_\") (Term.app `is_noetherian.noetherian [(Term.hole \"_\")])])))]\n                  \"⟩\"))])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.intro \"intro\" []) [] (Tactic.tacticInfer_instance \"infer_instance\")])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.intro \"intro\" []) [] (Tactic.tacticInfer_instance \"infer_instance\")])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Std.Tactic.rintro\n                 \"rintro\"\n                 [(Std.Tactic.RCases.rintroPat.one\n                   (Std.Tactic.RCases.rcasesPat.tuple\n                    \"⟨\"\n                    [(Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)])\n                      [])]\n                    \"⟩\"))]\n                 [])\n                []\n                (Tactic.rwSeq\n                 \"rw\"\n                 []\n                 (Tactic.rwRuleSeq\n                  \"[\"\n                  [(Tactic.rwRule [] `is_noetherian_ring_iff) \",\" (Tactic.rwRule [] `is_noetherian_iff_fg_well_founded)]\n                  \"]\")\n                 [])\n                []\n                (Tactic.apply \"apply\" (Term.app `RelEmbedding.wellFounded [(Term.hole \"_\") `h]))\n                []\n                (Tactic.tacticHave_\n                 \"have\"\n                 (Term.haveDecl\n                  (Term.haveIdDecl\n                   []\n                   [(Term.typeSpec\n                     \":\"\n                     (Term.forall\n                      \"∀\"\n                      [`I]\n                      [(Term.typeSpec\n                        \":\"\n                        («term{_:_//_}» \"{\" `J [\":\" (Term.app `ideal [`R])] \"//\" (Term.proj `J \".\" `fg) \"}\"))]\n                      \",\"\n                      («term∃_,_»\n                       \"∃\"\n                       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] [\":\" `R]))\n                       \",\"\n                       («term_=_»\n                        (Term.typeAscription \"(\" `I \":\" [(Term.app `ideal [`R])] \")\")\n                        \"=\"\n                        (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])))))]\n                   \":=\"\n                   (Term.fun\n                    \"fun\"\n                    (Term.basicFun\n                     [(Term.anonymousCtor \"⟨\" [`I \",\" `hI] \"⟩\")]\n                     []\n                     \"=>\"\n                     (Term.proj (Term.app `is_bezout.is_principal_of_fg [`I `hI]) \".\" (fieldIdx \"1\")))))))\n                []\n                (Mathlib.Tactic.Choose.choose \"choose\" [] [(Lean.binderIdent `f) (Lean.binderIdent `hf)] [])\n                []\n                (Tactic.exact\n                 \"exact\"\n                 (Term.structInst\n                  \"{\"\n                  []\n                  [(Term.structInstField (Term.structInstLVal `to_fun []) \":=\" `f)\n                   []\n                   (Term.structInstField\n                    (Term.structInstLVal `inj' [])\n                    \":=\"\n                    (Term.fun\n                     \"fun\"\n                     (Term.basicFun\n                      [`x `y `e]\n                      []\n                      \"=>\"\n                      (Term.byTactic\n                       \"by\"\n                       (Tactic.tacticSeq\n                        (Tactic.tacticSeq1Indented\n                         [(Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n                          []\n                          (Tactic.rwSeq\n                           \"rw\"\n                           []\n                           (Tactic.rwRuleSeq\n                            \"[\"\n                            [(Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `e)]\n                            \"]\")\n                           [])]))))))\n                   []\n                   (Term.structInstField\n                    (Term.structInstLVal `map_rel_iff' [])\n                    \":=\"\n                    (Term.fun\n                     \"fun\"\n                     (Term.basicFun\n                      [`x `y]\n                      []\n                      \"=>\"\n                      (Term.byTactic\n                       \"by\"\n                       (Tactic.tacticSeq\n                        (Tactic.tacticSeq1Indented\n                         [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                          []\n                          (Tactic.rwSeq\n                           \"rw\"\n                           []\n                           (Tactic.rwRuleSeq\n                            \"[\"\n                            [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.span_singleton_lt_span_singleton)\n                             \",\"\n                             (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)\n                             \",\"\n                             (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)]\n                            \"]\")\n                           [])\n                          []\n                          (Tactic.tacticRfl \"rfl\")]))))))]\n                  (Term.optEllipsis [])\n                  []\n                  \"}\"))])\n              []\n              (Tactic.tfaeFinish \"tfae_finish\")])))])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Mathlib.Tactic.tacticClassical_\n       \"classical\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [(Term.fun\n                \"fun\"\n                (Term.basicFun\n                 [`I]\n                 []\n                 \"=>\"\n                 (Term.app\n                  `is_principal_of_fg\n                  [(Term.hole \"_\") (Term.app `is_noetherian.noetherian [(Term.hole \"_\")])])))]\n              \"⟩\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" []) [] (Tactic.tacticInfer_instance \"infer_instance\")])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" []) [] (Tactic.tacticInfer_instance \"infer_instance\")])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [] `is_noetherian_ring_iff) \",\" (Tactic.rwRule [] `is_noetherian_iff_fg_well_founded)]\n              \"]\")\n             [])\n            []\n            (Tactic.apply \"apply\" (Term.app `RelEmbedding.wellFounded [(Term.hole \"_\") `h]))\n            []\n            (Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               []\n               [(Term.typeSpec\n                 \":\"\n                 (Term.forall\n                  \"∀\"\n                  [`I]\n                  [(Term.typeSpec\n                    \":\"\n                    («term{_:_//_}» \"{\" `J [\":\" (Term.app `ideal [`R])] \"//\" (Term.proj `J \".\" `fg) \"}\"))]\n                  \",\"\n                  («term∃_,_»\n                   \"∃\"\n                   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] [\":\" `R]))\n                   \",\"\n                   («term_=_»\n                    (Term.typeAscription \"(\" `I \":\" [(Term.app `ideal [`R])] \")\")\n                    \"=\"\n                    (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])))))]\n               \":=\"\n               (Term.fun\n                \"fun\"\n                (Term.basicFun\n                 [(Term.anonymousCtor \"⟨\" [`I \",\" `hI] \"⟩\")]\n                 []\n                 \"=>\"\n                 (Term.proj (Term.app `is_bezout.is_principal_of_fg [`I `hI]) \".\" (fieldIdx \"1\")))))))\n            []\n            (Mathlib.Tactic.Choose.choose \"choose\" [] [(Lean.binderIdent `f) (Lean.binderIdent `hf)] [])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.structInst\n              \"{\"\n              []\n              [(Term.structInstField (Term.structInstLVal `to_fun []) \":=\" `f)\n               []\n               (Term.structInstField\n                (Term.structInstLVal `inj' [])\n                \":=\"\n                (Term.fun\n                 \"fun\"\n                 (Term.basicFun\n                  [`x `y `e]\n                  []\n                  \"=>\"\n                  (Term.byTactic\n                   \"by\"\n                   (Tactic.tacticSeq\n                    (Tactic.tacticSeq1Indented\n                     [(Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n                      []\n                      (Tactic.rwSeq\n                       \"rw\"\n                       []\n                       (Tactic.rwRuleSeq\n                        \"[\"\n                        [(Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `e)]\n                        \"]\")\n                       [])]))))))\n               []\n               (Term.structInstField\n                (Term.structInstLVal `map_rel_iff' [])\n                \":=\"\n                (Term.fun\n                 \"fun\"\n                 (Term.basicFun\n                  [`x `y]\n                  []\n                  \"=>\"\n                  (Term.byTactic\n                   \"by\"\n                   (Tactic.tacticSeq\n                    (Tactic.tacticSeq1Indented\n                     [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                      []\n                      (Tactic.rwSeq\n                       \"rw\"\n                       []\n                       (Tactic.rwRuleSeq\n                        \"[\"\n                        [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.span_singleton_lt_span_singleton)\n                         \",\"\n                         (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)\n                         \",\"\n                         (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)]\n                        \"]\")\n                       [])\n                      []\n                      (Tactic.tacticRfl \"rfl\")]))))))]\n              (Term.optEllipsis [])\n              []\n              \"}\"))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)]) [])]\n            \"⟩\"))]\n         [])\n        []\n        (Tactic.rwSeq\n         \"rw\"\n         []\n         (Tactic.rwRuleSeq\n          \"[\"\n          [(Tactic.rwRule [] `is_noetherian_ring_iff) \",\" (Tactic.rwRule [] `is_noetherian_iff_fg_well_founded)]\n          \"]\")\n         [])\n        []\n        (Tactic.apply \"apply\" (Term.app `RelEmbedding.wellFounded [(Term.hole \"_\") `h]))\n        []\n        (Tactic.tacticHave_\n         \"have\"\n         (Term.haveDecl\n          (Term.haveIdDecl\n           []\n           [(Term.typeSpec\n             \":\"\n             (Term.forall\n              \"∀\"\n              [`I]\n              [(Term.typeSpec \":\" («term{_:_//_}» \"{\" `J [\":\" (Term.app `ideal [`R])] \"//\" (Term.proj `J \".\" `fg) \"}\"))]\n              \",\"\n              («term∃_,_»\n               \"∃\"\n               (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] [\":\" `R]))\n               \",\"\n               («term_=_»\n                (Term.typeAscription \"(\" `I \":\" [(Term.app `ideal [`R])] \")\")\n                \"=\"\n                (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])))))]\n           \":=\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [(Term.anonymousCtor \"⟨\" [`I \",\" `hI] \"⟩\")]\n             []\n             \"=>\"\n             (Term.proj (Term.app `is_bezout.is_principal_of_fg [`I `hI]) \".\" (fieldIdx \"1\")))))))\n        []\n        (Mathlib.Tactic.Choose.choose \"choose\" [] [(Lean.binderIdent `f) (Lean.binderIdent `hf)] [])\n        []\n        (Tactic.exact\n         \"exact\"\n         (Term.structInst\n          \"{\"\n          []\n          [(Term.structInstField (Term.structInstLVal `to_fun []) \":=\" `f)\n           []\n           (Term.structInstField\n            (Term.structInstLVal `inj' [])\n            \":=\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`x `y `e]\n              []\n              \"=>\"\n              (Term.byTactic\n               \"by\"\n               (Tactic.tacticSeq\n                (Tactic.tacticSeq1Indented\n                 [(Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n                  []\n                  (Tactic.rwSeq\n                   \"rw\"\n                   []\n                   (Tactic.rwRuleSeq\n                    \"[\"\n                    [(Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `e)]\n                    \"]\")\n                   [])]))))))\n           []\n           (Term.structInstField\n            (Term.structInstLVal `map_rel_iff' [])\n            \":=\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`x `y]\n              []\n              \"=>\"\n              (Term.byTactic\n               \"by\"\n               (Tactic.tacticSeq\n                (Tactic.tacticSeq1Indented\n                 [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                  []\n                  (Tactic.rwSeq\n                   \"rw\"\n                   []\n                   (Tactic.rwRuleSeq\n                    \"[\"\n                    [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.span_singleton_lt_span_singleton)\n                     \",\"\n                     (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)\n                     \",\"\n                     (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)]\n                    \"]\")\n                   [])\n                  []\n                  (Tactic.tacticRfl \"rfl\")]))))))]\n          (Term.optEllipsis [])\n          []\n          \"}\"))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.structInst\n        \"{\"\n        []\n        [(Term.structInstField (Term.structInstLVal `to_fun []) \":=\" `f)\n         []\n         (Term.structInstField\n          (Term.structInstLVal `inj' [])\n          \":=\"\n          (Term.fun\n           \"fun\"\n           (Term.basicFun\n            [`x `y `e]\n            []\n            \"=>\"\n            (Term.byTactic\n             \"by\"\n             (Tactic.tacticSeq\n              (Tactic.tacticSeq1Indented\n               [(Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n                []\n                (Tactic.rwSeq\n                 \"rw\"\n                 []\n                 (Tactic.rwRuleSeq\n                  \"[\"\n                  [(Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `e)]\n                  \"]\")\n                 [])]))))))\n         []\n         (Term.structInstField\n          (Term.structInstLVal `map_rel_iff' [])\n          \":=\"\n          (Term.fun\n           \"fun\"\n           (Term.basicFun\n            [`x `y]\n            []\n            \"=>\"\n            (Term.byTactic\n             \"by\"\n             (Tactic.tacticSeq\n              (Tactic.tacticSeq1Indented\n               [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                []\n                (Tactic.rwSeq\n                 \"rw\"\n                 []\n                 (Tactic.rwRuleSeq\n                  \"[\"\n                  [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.span_singleton_lt_span_singleton)\n                   \",\"\n                   (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)\n                   \",\"\n                   (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)]\n                  \"]\")\n                 [])\n                []\n                (Tactic.tacticRfl \"rfl\")]))))))]\n        (Term.optEllipsis [])\n        []\n        \"}\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.structInst\n       \"{\"\n       []\n       [(Term.structInstField (Term.structInstLVal `to_fun []) \":=\" `f)\n        []\n        (Term.structInstField\n         (Term.structInstLVal `inj' [])\n         \":=\"\n         (Term.fun\n          \"fun\"\n          (Term.basicFun\n           [`x `y `e]\n           []\n           \"=>\"\n           (Term.byTactic\n            \"by\"\n            (Tactic.tacticSeq\n             (Tactic.tacticSeq1Indented\n              [(Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n               []\n               (Tactic.rwSeq\n                \"rw\"\n                []\n                (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `e)] \"]\")\n                [])]))))))\n        []\n        (Term.structInstField\n         (Term.structInstLVal `map_rel_iff' [])\n         \":=\"\n         (Term.fun\n          \"fun\"\n          (Term.basicFun\n           [`x `y]\n           []\n           \"=>\"\n           (Term.byTactic\n            \"by\"\n            (Tactic.tacticSeq\n             (Tactic.tacticSeq1Indented\n              [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n               []\n               (Tactic.rwSeq\n                \"rw\"\n                []\n                (Tactic.rwRuleSeq\n                 \"[\"\n                 [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.span_singleton_lt_span_singleton)\n                  \",\"\n                  (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)\n                  \",\"\n                  (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)]\n                 \"]\")\n                [])\n               []\n               (Tactic.tacticRfl \"rfl\")]))))))]\n       (Term.optEllipsis [])\n       []\n       \"}\")\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [`x `y]\n        []\n        \"=>\"\n        (Term.byTactic\n         \"by\"\n         (Tactic.tacticSeq\n          (Tactic.tacticSeq1Indented\n           [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.span_singleton_lt_span_singleton)\n               \",\"\n               (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)\n               \",\"\n               (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)]\n              \"]\")\n             [])\n            []\n            (Tactic.tacticRfl \"rfl\")])))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n          []\n          (Tactic.rwSeq\n           \"rw\"\n           []\n           (Tactic.rwRuleSeq\n            \"[\"\n            [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.span_singleton_lt_span_singleton)\n             \",\"\n             (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)\n             \",\"\n             (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)]\n            \"]\")\n           [])\n          []\n          (Tactic.tacticRfl \"rfl\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticRfl \"rfl\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq\n       \"rw\"\n       []\n       (Tactic.rwRuleSeq\n        \"[\"\n        [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.span_singleton_lt_span_singleton)\n         \",\"\n         (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)\n         \",\"\n         (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `hf)]\n        \"]\")\n       [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hf\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hf\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `ideal.span_singleton_lt_span_singleton\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `y\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [`x `y `e]\n        []\n        \"=>\"\n        (Term.byTactic\n         \"by\"\n         (Tactic.tacticSeq\n          (Tactic.tacticSeq1Indented\n           [(Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `e)] \"]\")\n             [])])))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n          []\n          (Tactic.rwSeq\n           \"rw\"\n           []\n           (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `e)] \"]\")\n           [])])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq\n       \"rw\"\n       []\n       (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `hf) \",\" (Tactic.rwRule [] `e)] \"]\")\n       [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `e\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hf\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hf\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `e\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `y\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Mathlib.Tactic.Choose.choose \"choose\" [] [(Lean.binderIdent `f) (Lean.binderIdent `hf)] [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticHave_\n       \"have\"\n       (Term.haveDecl\n        (Term.haveIdDecl\n         []\n         [(Term.typeSpec\n           \":\"\n           (Term.forall\n            \"∀\"\n            [`I]\n            [(Term.typeSpec \":\" («term{_:_//_}» \"{\" `J [\":\" (Term.app `ideal [`R])] \"//\" (Term.proj `J \".\" `fg) \"}\"))]\n            \",\"\n            («term∃_,_»\n             \"∃\"\n             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] [\":\" `R]))\n             \",\"\n             («term_=_»\n              (Term.typeAscription \"(\" `I \":\" [(Term.app `ideal [`R])] \")\")\n              \"=\"\n              (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])))))]\n         \":=\"\n         (Term.fun\n          \"fun\"\n          (Term.basicFun\n           [(Term.anonymousCtor \"⟨\" [`I \",\" `hI] \"⟩\")]\n           []\n           \"=>\"\n           (Term.proj (Term.app `is_bezout.is_principal_of_fg [`I `hI]) \".\" (fieldIdx \"1\")))))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [(Term.anonymousCtor \"⟨\" [`I \",\" `hI] \"⟩\")]\n        []\n        \"=>\"\n        (Term.proj (Term.app `is_bezout.is_principal_of_fg [`I `hI]) \".\" (fieldIdx \"1\"))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj (Term.app `is_bezout.is_principal_of_fg [`I `hI]) \".\" (fieldIdx \"1\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `is_bezout.is_principal_of_fg [`I `hI])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hI\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `I\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `is_bezout.is_principal_of_fg\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `is_bezout.is_principal_of_fg [`I `hI]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"⟨\" [`I \",\" `hI] \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hI\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `I\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.forall\n       \"∀\"\n       [`I]\n       [(Term.typeSpec \":\" («term{_:_//_}» \"{\" `J [\":\" (Term.app `ideal [`R])] \"//\" (Term.proj `J \".\" `fg) \"}\"))]\n       \",\"\n       («term∃_,_»\n        \"∃\"\n        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] [\":\" `R]))\n        \",\"\n        («term_=_»\n         (Term.typeAscription \"(\" `I \":\" [(Term.app `ideal [`R])] \")\")\n         \"=\"\n         (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")]))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      («term∃_,_»\n       \"∃\"\n       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] [\":\" `R]))\n       \",\"\n       («term_=_»\n        (Term.typeAscription \"(\" `I \":\" [(Term.app `ideal [`R])] \")\")\n        \"=\"\n        (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      («term_=_»\n       (Term.typeAscription \"(\" `I \":\" [(Term.app `ideal [`R])] \")\")\n       \"=\"\n       (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term{_}»', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term{_}»', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      («term{_}» \"{\" [`x] \"}\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `ideal.span\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))\n      (Term.typeAscription \"(\" `I \":\" [(Term.app `ideal [`R])] \")\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `ideal [`R])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `R\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `ideal\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `I\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'null', expected 'Lean.bracketedExplicitBinders'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `R\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      («term{_:_//_}» \"{\" `J [\":\" (Term.app `ideal [`R])] \"//\" (Term.proj `J \".\" `fg) \"}\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj `J \".\" `fg)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `J\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `ideal [`R])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `R\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `ideal\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.apply \"apply\" (Term.app `RelEmbedding.wellFounded [(Term.hole \"_\") `h]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `RelEmbedding.wellFounded [(Term.hole \"_\") `h])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `RelEmbedding.wellFounded\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq\n       \"rw\"\n       []\n       (Tactic.rwRuleSeq\n        \"[\"\n        [(Tactic.rwRule [] `is_noetherian_ring_iff) \",\" (Tactic.rwRule [] `is_noetherian_iff_fg_well_founded)]\n        \"]\")\n       [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `is_noetherian_iff_fg_well_founded\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `is_noetherian_ring_iff\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"⟨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)]) [])]\n          \"⟩\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  tfae\n  [ is_bezout R ] [ IsDomain R ]\n    : TFAE [ is_noetherian_ring R , is_principal_ideal_ring R , unique_factorization_monoid R , wf_dvd_monoid R ]\n  :=\n    by\n      classical\n        tfae_have 1 → 2\n          · intro H exact ⟨ fun I => is_principal_of_fg _ is_noetherian.noetherian _ ⟩\n          tfae_have 2 → 3\n          · intro infer_instance\n          tfae_have 3 → 4\n          · intro infer_instance\n          tfae_have 4 → 1\n          ·\n            rintro ⟨ h ⟩\n              rw [ is_noetherian_ring_iff , is_noetherian_iff_fg_well_founded ]\n              apply RelEmbedding.wellFounded _ h\n              have\n                : ∀ I : { J : ideal R // J . fg } , ∃ x : R , ( I : ideal R ) = ideal.span { x }\n                  :=\n                  fun ⟨ I , hI ⟩ => is_bezout.is_principal_of_fg I hI . 1\n              choose f hf\n              exact\n                {\n                  to_fun := f\n                    inj' := fun x y e => by ext1 rw [ hf , hf , e ]\n                    map_rel_iff'\n                      :=\n                      fun x y => by dsimp rw [ ← ideal.span_singleton_lt_span_singleton , ← hf , ← hf ] rfl\n                  }\n          tfae_finish\n#align tfae tfae\n\n",
 "span_gcd":
 "theorem span_gcd (x y : R) : (ideal.span {gcd x y} : ideal R) = ideal.span {x, y} :=\n  ideal.span_singleton_generator _\n#align span_gcd span_gcd\n\n",
 "is_bezout":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n-- Note that the proof, despite being `infer_instance`, depends on the `local attribute [instance]`\n-- lemma above, and is thus necessary to be restated.\ntheorem _root_.function.surjective.is_bezout {S : Type v} [CommRing S] (f : «expr →+* » R S)\n    (hf : function.surjective f) [is_bezout R] : is_bezout S :=\n  by\n  rw [iff_span_pair_is_principal]\n  intro x y\n  obtain ⟨⟨x, rfl⟩, ⟨y, rfl⟩⟩ := hf x, hf y\n  use f (gcd x y)\n  trans ideal.map f (ideal.span {gcd x y})\n  · rw [span_gcd, ideal.map_span, Set.image_insert_eq, Set.image_singleton]\n  · rw [ideal.map_span, Set.image_singleton]\n    rfl\n#align function.surjective.is_bezout function.surjective.is_bezout\n\n",
 "iff_span_pair_is_principal":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem iff_span_pair_is_principal : is_bezout R ↔ ∀ x y : R, (ideal.span {x, y} : ideal R).is_principal := by\n  classical\n    constructor\n    · intro H x y\n      infer_instance\n    · intro H\n      constructor\n      apply submodule.fg_induction\n      · exact fun _ => ⟨⟨_, rfl⟩⟩\n      · rintro _ _ ⟨⟨x, rfl⟩⟩ ⟨⟨y, rfl⟩⟩\n        rw [← submodule.span_insert]\n        exact H _ _\n#align iff_span_pair_is_principal iff_span_pair_is_principal\n\n",
 "gcd_eq_sum":
 "theorem gcd_eq_sum (x y : R) : ∃ a b : R, a * x + b * y = gcd x y :=\n  ideal.mem_span_pair.mp\n    (by\n      rw [← span_gcd]\n      apply ideal.subset_span\n      simp)\n#align gcd_eq_sum gcd_eq_sum\n\n",
 "gcd_dvd_right":
 "theorem gcd_dvd_right (x y : R) : gcd x y ∣ y :=\n  (submodule.is_principal.mem_iff_generator_dvd _).mp (ideal.subset_span (by simp))\n#align gcd_dvd_right gcd_dvd_right\n\n",
 "gcd_dvd_left":
 "theorem gcd_dvd_left (x y : R) : gcd x y ∣ x :=\n  (submodule.is_principal.mem_iff_generator_dvd _).mp (ideal.subset_span (by simp))\n#align gcd_dvd_left gcd_dvd_left\n\n",
 "dvd_gcd":
 "theorem dvd_gcd {x y z : R} (hx : z ∣ x) (hy : z ∣ y) : z ∣ gcd x y :=\n  by\n  rw [← ideal.span_singleton_le_span_singleton] at hx hy⊢\n  rw [span_gcd, ideal.span_insert, sup_le_iff]\n  exact ⟨hx, hy⟩\n#align dvd_gcd dvd_gcd\n\n"}