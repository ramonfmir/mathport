{"tfae":
 "theorem tfae [is_bezout R] [IsDomain R] :\n    TFAE [IsNoetherianRing R, IsPrincipalIdealRing R, UniqueFactorizationMonoid R, WfDvdMonoid R] := by\n  classical\n    tfae_have 1 → 2\n    · intro H\n      exact ⟨fun I => is_principal_of_fg _ (is_noetherian.noetherian _)⟩\n    tfae_have 2 → 3\n    · intro\n      infer_instance\n    tfae_have 3 → 4\n    · intro\n      infer_instance\n    tfae_have 4 → 1\n    · rintro ⟨h⟩\n      rw [isNoetherianRing_iff, isNoetherian_iff_fg_wellFounded]\n      apply RelEmbedding.wellFounded _ h\n      have : ∀ I : { J : Ideal R // J.fg }, ∃ x : R, (I : Ideal R) = Ideal.span {x} := fun ⟨I, hI⟩ =>\n        (is_bezout.is_principal_of_fg I hI).1\n      choose f hf\n      exact\n        { to_fun := f\n          inj' := fun x y e => by\n            ext1\n            rw [hf, hf, e]\n          map_rel_iff' := fun x y => by\n            dsimp\n            rw [← Ideal.span_singleton_lt_span_singleton, ← hf, ← hf]\n            rfl }\n    tfae_finish\n#align tfae tfae\n\n",
 "span_gcd":
 "#print span_gcd /-\ntheorem span_gcd (x y : R) : (Ideal.span {gcd x y} : Ideal R) = Ideal.span {x, y} :=\n  Ideal.span_singleton_generator _\n#align span_gcd span_gcd\n-/\n\n",
 "is_bezout":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n-- Note that the proof, despite being `infer_instance`, depends on the `local attribute [instance]`\n-- lemma above, and is thus necessary to be restated.\ntheorem _root_.function.surjective.is_bezout {S : Type v} [CommRing S] (f : «expr →+* » R S)\n    (hf : function.surjective f) [is_bezout R] : is_bezout S :=\n  by\n  rw [iff_span_pair_is_principal]\n  intro x y\n  obtain ⟨⟨x, rfl⟩, ⟨y, rfl⟩⟩ := hf x, hf y\n  use f (gcd x y)\n  trans Ideal.map f (Ideal.span {gcd x y})\n  · rw [span_gcd, Ideal.map_span, Set.image_insert_eq, Set.image_singleton]\n  · rw [Ideal.map_span, Set.image_singleton]\n    rfl\n#align function.surjective.is_bezout function.surjective.is_bezout\n\n",
 "iff_span_pair_is_principal":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem iff_span_pair_is_principal : is_bezout R ↔ ∀ x y : R, (Ideal.span {x, y} : Ideal R).is_principal := by\n  classical\n    constructor\n    · intro H x y\n      infer_instance\n    · intro H\n      constructor\n      apply Submodule.fg_induction\n      · exact fun _ => ⟨⟨_, rfl⟩⟩\n      · rintro _ _ ⟨⟨x, rfl⟩⟩ ⟨⟨y, rfl⟩⟩\n        rw [← Submodule.span_insert]\n        exact H _ _\n#align iff_span_pair_is_principal iff_span_pair_is_principal\n\n",
 "gcd_eq_sum":
 "theorem gcd_eq_sum (x y : R) : ∃ a b : R, a * x + b * y = gcd x y :=\n  Ideal.mem_span_pair.mp\n    (by\n      rw [← span_gcd]\n      apply Ideal.subset_span\n      simp)\n#align gcd_eq_sum gcd_eq_sum\n\n",
 "gcd_dvd_right":
 "theorem gcd_dvd_right (x y : R) : gcd x y ∣ y :=\n  (Submodule.IsPrincipal.mem_iff_generator_dvd _).mp (Ideal.subset_span (by simp))\n#align gcd_dvd_right gcd_dvd_right\n\n",
 "gcd_dvd_left":
 "theorem gcd_dvd_left (x y : R) : gcd x y ∣ x :=\n  (Submodule.IsPrincipal.mem_iff_generator_dvd _).mp (Ideal.subset_span (by simp))\n#align gcd_dvd_left gcd_dvd_left\n\n",
 "dvd_gcd":
 "theorem dvd_gcd {x y z : R} (hx : z ∣ x) (hy : z ∣ y) : z ∣ gcd x y :=\n  by\n  rw [← Ideal.span_singleton_le_span_singleton] at hx hy⊢\n  rw [span_gcd, Ideal.span_insert, sup_le_iff]\n  exact ⟨hx, hy⟩\n#align dvd_gcd dvd_gcd\n\n"}