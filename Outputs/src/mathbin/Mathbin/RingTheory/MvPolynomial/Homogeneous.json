{"total_degree":
 "theorem total_degree (hφ : is_homogeneous φ n) (h : φ ≠ 0) : totalDegree φ = n :=\n  by\n  rw [total_degree]\n  apply le_antisymm\n  · apply Finset.sup_le\n    intro d hd\n    rw [mem_support_iff] at hd\n    rw [Finsupp.sum, hφ hd]\n  · obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero h\n    simp only [← hφ hd, Finsupp.sum]\n    replace hd := finsupp.mem_support_iff.mpr hd\n    exact Finset.le_sup hd\n#align total_degree total_degree\n\n",
 "sum_homogeneous_component":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_homogeneous_component :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (range (φ.total_degree + 1)) (homogeneous_component i φ) =\n      φ :=\n  by\n  ext1 d\n  suffices φ.total_degree < d.support.sum d → 0 = coeff d φ by simpa [coeff_sum, coeff_homogeneous_component]\n  exact fun h => (coeff_eq_zero_of_total_degree_lt h).symm\n#align sum_homogeneous_component sum_homogeneous_component\n\n",
 "mul":
 "theorem mul (hφ : is_homogeneous φ m) (hψ : is_homogeneous ψ n) : is_homogeneous (φ * ψ) (m + n) :=\n  homogeneous_submodule_mul m n <| Submodule.mul_mem_mul hφ hψ\n#align mul mul\n\n",
 "mem_homogeneous_submodule":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Eric Wieser\n-/\n/-\nTODO\n* create definition for `∑ i in d.support, d i`\n* show that `mv_polynomial σ R ≃ₐ[R] ⨁ i, homogeneous_submodule σ R i`\n-/\n@[simp]\ntheorem mem_homogeneous_submodule [CommSemiring R] (n : ℕ) (p : MvPolynomial σ R) :\n    p ∈ homogeneous_submodule σ R n ↔ p.is_homogeneous n :=\n  iff.rfl\n#align mem_homogeneous_submodule mem_homogeneous_submodule\n\n",
 "is_homogeneous_zero":
 "theorem is_homogeneous_zero (n : ℕ) : is_homogeneous (0 : MvPolynomial σ R) n :=\n  (homogeneous_submodule σ R n).zero_mem\n#align is_homogeneous_zero is_homogeneous_zero\n\n",
 "is_homogeneous_one":
 "theorem is_homogeneous_one : is_homogeneous (1 : MvPolynomial σ R) 0 :=\n  is_homogeneous_C _ _\n#align is_homogeneous_one is_homogeneous_one\n\n",
 "is_homogeneous_of_total_degree_zero":
 "theorem is_homogeneous_of_total_degree_zero {p : MvPolynomial σ R} (hp : p.total_degree = 0) : is_homogeneous p 0 :=\n  by\n  erw [total_degree, Finset.sup_eq_bot_iff] at hp\n  -- we have to do this in two steps to stop simp changing bot to zero\n  simp_rw [mem_support_iff] at hp\n  exact hp\n#align is_homogeneous_of_total_degree_zero is_homogeneous_of_total_degree_zero\n\n",
 "is_homogeneous_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem is_homogeneous_monomial (d : «expr →₀ » σ ℕ) (r : R) (n : ℕ)\n    (hn :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.support (d i) =\n        n) :\n    is_homogeneous (monomial d r) n := by\n  intro c hc\n  classical\n    rw [coeff_monomial] at hc\n    split_ifs  at hc with h\n    · subst c\n      exact hn\n    · contradiction\n#align is_homogeneous_monomial is_homogeneous_monomial\n\n",
 "is_homogeneous_X":
 "theorem is_homogeneous_X (i : σ) : is_homogeneous (X i : MvPolynomial σ R) 1 :=\n  by\n  apply is_homogeneous_monomial\n  simp only [Finsupp.support_single_ne_zero _ one_ne_zero, Finset.sum_singleton]\n  exact Finsupp.single_eq_same\n#align is_homogeneous_X is_homogeneous_X\n\n",
 "is_homogeneous_C":
 "theorem is_homogeneous_C (r : R) : is_homogeneous (C r : MvPolynomial σ R) 0 :=\n  by\n  apply is_homogeneous_monomial\n  simp only [Finsupp.zero_apply, Finset.sum_const_zero]\n#align is_homogeneous_C is_homogeneous_C\n\n",
 "inj_right":
 "theorem inj_right (hm : is_homogeneous φ m) (hn : is_homogeneous φ n) (hφ : φ ≠ 0) : m = n :=\n  by\n  obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero hφ\n  rw [← hm hd, ← hn hd]\n#align inj_right inj_right\n\n",
 "homogeneous_submodule_mul":
 "theorem homogeneous_submodule_mul [CommSemiring R] (m n : ℕ) :\n    homogeneous_submodule σ R m * homogeneous_submodule σ R n ≤ homogeneous_submodule σ R (m + n) :=\n  by\n  rw [Submodule.mul_le]\n  intro φ hφ ψ hψ c hc\n  rw [coeff_mul] at hc\n  obtain ⟨⟨d, e⟩, hde, H⟩ := Finset.exists_ne_zero_of_sum_ne_zero hc\n  have aux : coeff d φ ≠ 0 ∧ coeff e ψ ≠ 0 := by\n    contrapose! H\n    by_cases h : coeff d φ = 0 <;> simp_all only [ne.def, not_false_iff, MulZeroClass.zero_mul, MulZeroClass.mul_zero]\n  specialize hφ aux.1\n  specialize hψ aux.2\n  rw [Finsupp.mem_antidiagonal] at hde\n  classical\n    have hd' : d.support ⊆ d.support ∪ e.support := Finset.subset_union_left _ _\n    have he' : e.support ⊆ d.support ∪ e.support := Finset.subset_union_right _ _\n    rw [← hde, ← hφ, ← hψ, Finset.sum_subset Finsupp.support_add, Finset.sum_subset hd', Finset.sum_subset he', ←\n      Finset.sum_add_distrib]\n    · congr\n    all_goals intro i hi; apply finsupp.not_mem_support_iff.mp\n#align homogeneous_submodule_mul homogeneous_submodule_mul\n\n",
 "homogeneous_submodule_eq_finsupp_supported":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- While equal, the former has a convenient definitional reduction. -/\ntheorem homogeneous_submodule_eq_finsupp_supported [CommSemiring R] (n : ℕ) :\n    homogeneous_submodule σ R n =\n      Finsupp.supported _ R\n        { d |\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.support\n              (d i) =\n            n } :=\n  by\n  ext\n  rw [Finsupp.mem_supported, Set.subset_def]\n  simp only [Finsupp.mem_support_iff, Finset.mem_coe]\n  rfl\n#align homogeneous_submodule_eq_finsupp_supported homogeneous_submodule_eq_finsupp_supported\n\n",
 "homogeneous_component_zero":
 "@[simp]\ntheorem homogeneous_component_zero : homogeneous_component 0 φ = C (coeff 0 φ) :=\n  by\n  ext1 d\n  rcases em (d = 0) with (rfl | hd)\n  ·\n    simp only [coeff_homogeneous_component, sum_eq_zero_iff, Finsupp.zero_apply, if_true, coeff_C, eq_self_iff_true,\n      forall_true_iff]\n  · rw [coeff_homogeneous_component, if_neg, coeff_C, if_neg (ne.symm hd)]\n    simp only [Finsupp.ext_iff, Finsupp.zero_apply] at hd\n    simp [hd]\n#align homogeneous_component_zero homogeneous_component_zero\n\n",
 "homogeneous_component_is_homogeneous":
 "theorem homogeneous_component_is_homogeneous : (homogeneous_component n φ).is_homogeneous n :=\n  by\n  intro d hd\n  contrapose! hd\n  rw [coeff_homogeneous_component, if_neg hd]\n#align homogeneous_component_is_homogeneous homogeneous_component_is_homogeneous\n\n",
 "homogeneous_component_homogeneous_polynomial":
 "theorem homogeneous_component_homogeneous_polynomial (m n : ℕ) (p : MvPolynomial σ R)\n    (h : p ∈ homogeneous_submodule σ R n) : homogeneous_component m p = if m = n then p else 0 :=\n  by\n  simp only [mem_homogeneous_submodule] at h\n  ext x\n  rw [coeff_homogeneous_component]\n  by_cases zero_coeff : coeff x p = 0\n  · split_ifs\n    all_goals simp only [zero_coeff, coeff_zero]\n  · rw [h zero_coeff]\n    simp only [show n = m ↔ m = n from eq_comm]\n    split_ifs with h1\n    · rfl\n    · simp only [coeff_zero]\n#align homogeneous_component_homogeneous_polynomial homogeneous_component_homogeneous_polynomial\n\n",
 "homogeneous_component_eq_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem homogeneous_component_eq_zero'\n    (h :\n      ∀ d : «expr →₀ » σ ℕ,\n        d ∈ φ.support →\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.support\n              (d i) ≠\n            n) :\n    homogeneous_component n φ = 0 := by\n  rw [homogeneous_component_apply, sum_eq_zero]\n  intro d hd; rw [mem_filter] at hd\n  exfalso; exact h _ hd.1 hd.2\n#align homogeneous_component_eq_zero' homogeneous_component_eq_zero'\n\n",
 "homogeneous_component_eq_zero":
 "theorem homogeneous_component_eq_zero (h : φ.total_degree < n) : homogeneous_component n φ = 0 :=\n  by\n  apply homogeneous_component_eq_zero'\n  rw [total_degree, Finset.sup_lt_iff] at h\n  · intro d hd\n    exact ne_of_lt (h d hd)\n  · exact lt_of_le_of_lt (nat.zero_le _) h\n#align homogeneous_component_eq_zero homogeneous_component_eq_zero\n\n",
 "homogeneous_component_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem homogeneous_component_apply :\n    homogeneous_component n φ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (φ.support.filter fun d =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.support\n              (d i) =\n            n)\n        (monomial d (coeff d φ)) :=\n  by\n  convert Finsupp.filter_eq_sum\n      (fun d : «expr →₀ » σ ℕ =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.support\n            (d i) =\n          n)\n      φ\n#align homogeneous_component_apply homogeneous_component_apply\n\n",
 "homogeneous_component_C_mul":
 "@[simp]\ntheorem homogeneous_component_C_mul (n : ℕ) (r : R) :\n    homogeneous_component n (C r * φ) = C r * homogeneous_component n φ := by simp only [C_mul', LinearMap.map_smul]\n#align homogeneous_component_C_mul homogeneous_component_C_mul\n\n",
 "coeff_homogeneous_component":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem coeff_homogeneous_component (d : «expr →₀ » σ ℕ) :\n    coeff d (homogeneous_component n φ) =\n      if\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.support\n              (d i) =\n            n then\n        coeff d φ\n      else 0 :=\n  by\n  convert Finsupp.filter_apply\n      (fun d : «expr →₀ » σ ℕ =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.support\n            (d i) =\n          n)\n      φ d\n#align coeff_homogeneous_component coeff_homogeneous_component\n\n",
 "coeff_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem coeff_eq_zero (hφ : is_homogeneous φ n) (d : «expr →₀ » σ ℕ)\n    (hd :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.support (d i) ≠\n        n) :\n    coeff d φ = 0 := by\n  have aux := mt (@hφ d) hd\n  classical rwa [Classical.not_not] at aux\n#align coeff_eq_zero coeff_eq_zero\n\n",
 "add":
 "theorem add (hφ : is_homogeneous φ n) (hψ : is_homogeneous ψ n) : is_homogeneous (φ + ψ) n :=\n  (homogeneous_submodule σ R n).add_mem hφ hψ\n#align add add\n\n",
 "Sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print Sum /-\ntheorem Sum {ι : Type _} (s : Finset ι) (φ : ι → MvPolynomial σ R) (n : ℕ) (h : ∀ i ∈ s, is_homogeneous (φ i) n) :\n    is_homogeneous\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (φ i)) n :=\n  (homogeneous_submodule σ R n).sum_mem h\n#align sum Sum\n-/\n\n",
 "Prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print Prod /-\ntheorem Prod {ι : Type _} (s : Finset ι) (φ : ι → MvPolynomial σ R) (n : ι → ℕ)\n    (h : ∀ i ∈ s, is_homogeneous (φ i) (n i)) :\n    is_homogeneous\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (φ i))\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (n i)) :=\n  by\n  classical\n    revert h\n    apply Finset.induction_on s\n    · intro\n      simp only [is_homogeneous_one, Finset.sum_empty, Finset.prod_empty]\n    · intro i s his IH h\n      simp only [his, Finset.prod_insert, Finset.sum_insert, not_false_iff]\n      apply (h i (Finset.mem_insert_self _ _)).mul (IH _)\n      intro j hjs\n      exact h j (Finset.mem_insert_of_mem hjs)\n#align prod Prod\n-/\n\n"}