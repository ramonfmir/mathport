{"tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (I «expr ≠ » «expr⊥»()) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `discrete_valuation_ring.tfae [])\n      (Command.declSig\n       [(Term.instBinder \"[\" [] (Term.app `is_noetherian_ring [`R]) \"]\")\n        (Term.instBinder \"[\" [] (Term.app `local_ring [`R]) \"]\")\n        (Term.instBinder \"[\" [] (Term.app `IsDomain [`R]) \"]\")\n        (Term.explicitBinder \"(\" [`h] [\":\" («term¬_» \"¬\" (Term.app `IsField [`R]))] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `discrete_valuation_ring [`R])\n            \",\"\n            (Term.app `valuation_ring [`R])\n            \",\"\n            (Term.app `is_dedekind_domain [`R])\n            \",\"\n            («term_∧_»\n             (Term.app `is_integrally_closed [`R])\n             \"∧\"\n             («term∃!_,_»\n              \"∃!\"\n              (Lean.explicitBinders\n               (Lean.unbracketedExplicitBinders [(Lean.binderIdent `P)] [\":\" (Term.app `ideal [`R])]))\n              \",\"\n              («term_∧_» («term_≠_» `P \"≠\" (Term.app `«expr⊥» [])) \"∧\" (Term.proj `P \".\" `is_prime))))\n            \",\"\n            (Term.proj (Term.app `maximal_ideal [`R]) \".\" `is_principal)\n            \",\"\n            («term_=_»\n             (Term.app `finite_dimensional.finrank [(Term.app `residue_field [`R]) (Term.app `cotangent_space [`R])])\n             \"=\"\n             (num \"1\"))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder \"(\" [`I] [] [] \")\")\n              (Term.explicitBinder \"(\" [(Term.hole \"_\")] [\":\" («term_≠_» `I \"≠\" (Term.app `«expr⊥» []))] [] \")\")]\n             []\n             \",\"\n             («term∃_,_»\n              \"∃\"\n              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `n)] [\":\" (termℕ \"ℕ\")]))\n              \",\"\n              («term_=_» `I \"=\" («term_^_» (Term.app `maximal_ideal [`R]) \"^\" `n))))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tacticHave_\n            \"have\"\n            (Term.haveDecl\n             (Term.haveIdDecl\n              [`ne_bot []]\n              []\n              \":=\"\n              (Term.app `ring.ne_bot_of_is_maximal_of_not_is_field [(Term.app `maximal_ideal.is_maximal [`R]) `h]))))\n           []\n           (Mathlib.Tactic.tacticClassical_\n            \"classical\"\n            (Tactic.tacticSeq\n             (Tactic.tacticSeq1Indented\n              [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `finrank_eq_one_iff')] \"]\") [])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.intro \"intro\" []) [] (Tactic.tacticInfer_instance \"infer_instance\")])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.intro \"intro\" [])\n                 []\n                 (Std.Tactic.tacticHaveI_\n                  \"haveI\"\n                  (Term.haveDecl (Term.haveIdDecl [] [] \":=\" (Term.app `is_bezout.to_gcd_domain [`R]))))\n                 []\n                 (Std.Tactic.tacticHaveI_\n                  \"haveI\"\n                  (Term.haveDecl\n                   (Term.haveIdDecl\n                    []\n                    [(Term.typeSpec \":\" (Term.app `unique_factorization_monoid [`R]))]\n                    \":=\"\n                    `ufm_of_gcd_of_wf_dvd_monoid)))\n                 []\n                 (Tactic.apply \"apply\" `discrete_valuation_ring.of_ufd_of_unique_irreducible)\n                 []\n                 (tactic__\n                  (cdotTk (patternIgnore (token.«· » \"·\")))\n                  [(Std.Tactic.obtain\n                    \"obtain\"\n                    [(Std.Tactic.RCases.rcasesPatMed\n                      [(Std.Tactic.RCases.rcasesPat.tuple\n                        \"⟨\"\n                        [(Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `x)])\n                          [])\n                         \",\"\n                         (Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx₁)])\n                          [])\n                         \",\"\n                         (Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx₂)])\n                          [])]\n                        \"⟩\")])]\n                    []\n                    [\":=\" [(Term.app `ring.exists_not_is_unit_of_not_is_field [`h])]])\n                   []\n                   (Std.Tactic.obtain\n                    \"obtain\"\n                    [(Std.Tactic.RCases.rcasesPatMed\n                      [(Std.Tactic.RCases.rcasesPat.tuple\n                        \"⟨\"\n                        [(Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])\n                          [])\n                         \",\"\n                         (Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp₁)])\n                          [])\n                         \",\"\n                         (Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp₂)])\n                          [])]\n                        \"⟩\")])]\n                    []\n                    [\":=\" [(Term.app `wf_dvd_monoid.exists_irreducible_factor [`hx₂ `hx₁])]])\n                   []\n                   (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`p \",\" `hp₁] \"⟩\"))])\n                 []\n                 (tactic__\n                  (cdotTk (patternIgnore (token.«· » \"·\")))\n                  [(Tactic.exact \"exact\" `valuation_ring.unique_irreducible)])])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.intro \"intro\" [`H])\n                 []\n                 (Tactic.exact\n                  \"exact\"\n                  (Term.anonymousCtor\n                   \"⟨\"\n                   [`infer_instance\n                    \",\"\n                    (Term.proj\n                     (Term.app\n                      (Term.proj (Term.app `discrete_valuation_ring.iff_pid_with_one_nonzero_prime [`R]) \".\" `mp)\n                      [`H])\n                     \".\"\n                     (fieldIdx \"2\"))]\n                   \"⟩\"))])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Std.Tactic.rintro\n                  \"rintro\"\n                  [(Std.Tactic.RCases.rintroPat.one\n                    (Std.Tactic.RCases.rcasesPat.tuple\n                     \"⟨\"\n                     [(Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h₁)])\n                       [])\n                      \",\"\n                      (Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h₂)])\n                       [])]\n                     \"⟩\"))]\n                  [])\n                 []\n                 (Tactic.exact\n                  \"exact\"\n                  (Term.anonymousCtor\n                   \"⟨\"\n                   [`infer_instance\n                    \",\"\n                    (Term.fun\n                     \"fun\"\n                     (Term.basicFun\n                      [`I `hI `hI']\n                      []\n                      \"=>\"\n                      (Term.subst\n                       (Term.app\n                        `ExistsUnique.unique\n                        [`h₂\n                         (Term.anonymousCtor \"⟨\" [`ne_bot \",\" `infer_instance] \"⟩\")\n                         (Term.anonymousCtor \"⟨\" [`hI \",\" `hI'] \"⟩\")])\n                       \"▸\"\n                       [(Term.app `maximal_ideal.is_maximal [`R])])))\n                    \",\"\n                    `h₁]\n                   \"⟩\"))])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"5\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.intro \"intro\" [`h])\n                 []\n                 (Tactic.exact \"exact\" (Term.app `maximal_ideal_is_principal_of_is_dedekind_domain [`R]))])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"6\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Std.Tactic.rintro\n                  \"rintro\"\n                  [(Std.Tactic.RCases.rintroPat.one\n                    (Std.Tactic.RCases.rcasesPat.tuple\n                     \"⟨\"\n                     [(Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `x)])\n                       [])\n                      \",\"\n                      (Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])\n                       [])]\n                     \"⟩\"))]\n                  [])\n                 []\n                 (Tactic.tacticHave_\n                  \"have\"\n                  (Term.haveDecl\n                   (Term.haveIdDecl\n                    []\n                    [(Term.typeSpec \":\" («term_∈_» `x \"∈\" (Term.app `maximal_ideal [`R])))]\n                    \":=\"\n                    (Term.byTactic\n                     \"by\"\n                     (Tactic.tacticSeq\n                      (Tactic.tacticSeq1Indented\n                       [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hx)] \"]\") [])\n                        []\n                        (Tactic.exact\n                         \"exact\"\n                         (Term.app `submodule.subset_span [(Term.app `Set.mem_singleton [`x])]))]))))))\n                 []\n                 (Tactic.tacticLet_\n                  \"let\"\n                  (Term.letDecl\n                   (Term.letIdDecl\n                    `x'\n                    []\n                    [(Term.typeSpec \":\" (Term.app `maximal_ideal [`R]))]\n                    \":=\"\n                    (Term.anonymousCtor \"⟨\" [`x \",\" `this] \"⟩\"))))\n                 []\n                 (Mathlib.Tactic.«tacticUse_,,» \"use\" [(Term.app `submodule.quotient.mk [`x'])])\n                 []\n                 (Tactic.constructor \"constructor\")\n                 []\n                 (tactic__\n                  (cdotTk (patternIgnore (token.«· » \"·\")))\n                  [(Tactic.intro \"intro\" [`e])\n                   []\n                   (Tactic.rwSeq\n                    \"rw\"\n                    []\n                    (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.quotient.mk_eq_zero)] \"]\")\n                    [(Tactic.location \"at\" (Tactic.locationHyp [`e] []))])\n                   []\n                   (Tactic.apply\n                    \"apply\"\n                    (Term.app\n                     `ring.ne_bot_of_is_maximal_of_not_is_field\n                     [(Term.app `maximal_ideal.is_maximal [`R]) `h]))\n                   []\n                   (Tactic.apply\n                    \"apply\"\n                    (Term.app `submodule.eq_bot_of_le_smul_of_le_jacobson_bot [(Term.app `maximal_ideal [`R])]))\n                   []\n                   (tactic__\n                    (cdotTk (patternIgnore (token.«· » \"·\")))\n                    [(Tactic.exact\n                      \"exact\"\n                      (Term.anonymousCtor\n                       \"⟨\"\n                       [(«term{_}» \"{\" [`x] \"}\")\n                        \",\"\n                        (Term.subst (Term.proj (Term.app `Finset.coe_singleton [`x]) \".\" `symm) \"▸\" [`hx.symm])]\n                       \"⟩\"))])\n                   []\n                   (tactic__\n                    (cdotTk (patternIgnore (token.«· » \"·\")))\n                    [(Mathlib.Tactic.Conv.convLHS\n                      \"conv_lhs\"\n                      []\n                      []\n                      \"=>\"\n                      (Tactic.Conv.convSeq\n                       (Tactic.Conv.convSeq1Indented\n                        [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hx)] \"]\"))])))\n                     []\n                     (Tactic.rwSeq\n                      \"rw\"\n                      []\n                      (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.mem_smul_top_iff)] \"]\")\n                      [(Tactic.location \"at\" (Tactic.locationHyp [`e] []))])\n                     []\n                     (Std.Tactic.tacticRwa__\n                      \"rwa\"\n                      (Tactic.rwRuleSeq\n                       \"[\"\n                       [(Tactic.rwRule [] `submodule.span_le) \",\" (Tactic.rwRule [] `Set.singleton_subset_iff)]\n                       \"]\")\n                      [])])\n                   []\n                   (tactic__\n                    (cdotTk (patternIgnore (token.«· » \"·\")))\n                    [(Tactic.rwSeq\n                      \"rw\"\n                      []\n                      (Tactic.rwRuleSeq\n                       \"[\"\n                       [(Tactic.rwRule\n                         []\n                         (Term.app\n                          `local_ring.jacobson_eq_maximal_ideal\n                          [(Term.typeAscription \"(\" (Term.app `«expr⊥» []) \":\" [(Term.app `ideal [`R])] \")\")\n                           `bot_ne_top]))]\n                       \"]\")\n                      [])\n                     []\n                     (Tactic.exact \"exact\" (Term.app `le_refl [(Term.hole \"_\")]))])])\n                 []\n                 (tactic__\n                  (cdotTk (patternIgnore (token.«· » \"·\")))\n                  [(Tactic.refine'\n                    \"refine'\"\n                    (Term.fun\n                     \"fun\"\n                     (Term.basicFun\n                      [`w]\n                      []\n                      \"=>\"\n                      (Term.app\n                       `Quotient.inductionOn'\n                       [`w (Term.fun \"fun\" (Term.basicFun [`y] [] \"=>\" (Term.hole \"_\")))]))))\n                   []\n                   (Std.Tactic.obtain\n                    \"obtain\"\n                    [(Std.Tactic.RCases.rcasesPatMed\n                      [(Std.Tactic.RCases.rcasesPat.tuple\n                        \"⟨\"\n                        [(Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `y)])\n                          [])\n                         \",\"\n                         (Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])\n                          [])]\n                        \"⟩\")])]\n                    []\n                    [\":=\" [`y]])\n                   []\n                   (Tactic.rwSeq\n                    \"rw\"\n                    []\n                    (Tactic.rwRuleSeq\n                     \"[\"\n                     [(Tactic.rwRule [] `hx) \",\" (Tactic.rwRule [] `submodule.mem_span_singleton)]\n                     \"]\")\n                    [(Tactic.location \"at\" (Tactic.locationHyp [`hy] []))])\n                   []\n                   (Std.Tactic.obtain\n                    \"obtain\"\n                    [(Std.Tactic.RCases.rcasesPatMed\n                      [(Std.Tactic.RCases.rcasesPat.tuple\n                        \"⟨\"\n                        [(Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                          [])\n                         \",\"\n                         (Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                          [])]\n                        \"⟩\")])]\n                    []\n                    [\":=\" [`hy]])\n                   []\n                   (Tactic.exact\n                    \"exact\"\n                    (Term.anonymousCtor \"⟨\" [(Term.app `ideal.quotient.mk [(Term.hole \"_\") `a]) \",\" `rfl] \"⟩\"))])])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"5\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Std.Tactic.rintro\n                  \"rintro\"\n                  [(Std.Tactic.RCases.rintroPat.one\n                    (Std.Tactic.RCases.rcasesPat.tuple\n                     \"⟨\"\n                     [(Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `x)])\n                       [])\n                      \",\"\n                      (Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])\n                       [])\n                      \",\"\n                      (Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx')])\n                       [])]\n                     \"⟩\"))]\n                  [])\n                 []\n                 (Tactic.induction \"induction\" [`x] [\"using\" `Quotient.inductionOn'] [] [])\n                 []\n                 (Mathlib.Tactic.«tacticUse_,,» \"use\" [`x])\n                 []\n                 (Tactic.apply \"apply\" `le_antisymm)\n                 []\n                 (Mathlib.Tactic.tacticSwap \"swap\")\n                 []\n                 (tactic__\n                  (cdotTk (patternIgnore (token.«· » \"·\")))\n                  [(Tactic.rwSeq\n                    \"rw\"\n                    []\n                    (Tactic.rwRuleSeq\n                     \"[\"\n                     [(Tactic.rwRule [] `submodule.span_le) \",\" (Tactic.rwRule [] `Set.singleton_subset_iff)]\n                     \"]\")\n                    [])\n                   []\n                   (Tactic.exact \"exact\" `x.prop)])\n                 []\n                 (Tactic.tacticHave_\n                  \"have\"\n                  (Term.haveDecl\n                   (Term.haveIdDecl\n                    [`h₁ []]\n                    [(Term.typeSpec\n                      \":\"\n                      («term_≤_»\n                       (Term.app\n                        `«expr ⊔ »\n                        [(Term.typeAscription\n                          \"(\"\n                          (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])\n                          \":\"\n                          [(Term.app `ideal [`R])]\n                          \")\")\n                         (Term.app `maximal_ideal [`R])])\n                       \"≤\"\n                       (Term.app\n                        `«expr ⊔ »\n                        [(Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])\n                         (Term.app `«expr • » [(Term.app `maximal_ideal [`R]) (Term.app `maximal_ideal [`R])])])))]\n                    \":=\"\n                    (Term.byTactic\n                     \"by\"\n                     (Tactic.tacticSeq\n                      (Tactic.tacticSeq1Indented\n                       [(Tactic.refine' \"refine'\" (Term.app `sup_le [`le_sup_left (Term.hole \"_\")]))\n                        []\n                        (Std.Tactic.rintro\n                         \"rintro\"\n                         [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `m))\n                          (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hm))]\n                         [])\n                        []\n                        (Std.Tactic.obtain\n                         \"obtain\"\n                         [(Std.Tactic.RCases.rcasesPatMed\n                           [(Std.Tactic.RCases.rcasesPat.tuple\n                             \"⟨\"\n                             [(Std.Tactic.RCases.rcasesPatLo\n                               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `c)])\n                               [])\n                              \",\"\n                              (Std.Tactic.RCases.rcasesPatLo\n                               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hc)])\n                               [])]\n                             \"⟩\")])]\n                         []\n                         [\":=\"\n                          [(Term.app\n                            `hx'\n                            [(Term.app `submodule.quotient.mk [(Term.anonymousCtor \"⟨\" [`m \",\" `hm] \"⟩\")])])]])\n                        []\n                        (Tactic.induction \"induction\" [`c] [\"using\" `Quotient.inductionOn'] [] [])\n                        []\n                        (Tactic.rwSeq\n                         \"rw\"\n                         []\n                         (Tactic.rwRuleSeq\n                          \"[\"\n                          [(Tactic.rwRule\n                            [(patternIgnore (token.«← » \"←\"))]\n                            (Term.app `sub_sub_cancel [(«term_*_» `c \"*\" `x) `m]))]\n                          \"]\")\n                         [])\n                        []\n                        (Tactic.apply \"apply\" (Term.app `sub_mem [(Term.hole \"_\") (Term.hole \"_\")]))\n                        []\n                        (tactic__\n                         (cdotTk (patternIgnore (token.«· » \"·\")))\n                         [(Tactic.tacticInfer_instance \"infer_instance\")])\n                        []\n                        (tactic__\n                         (cdotTk (patternIgnore (token.«· » \"·\")))\n                         [(Tactic.refine'\n                           \"refine'\"\n                           (Term.app\n                            `ideal.mem_sup_left\n                            [(Term.app `ideal.mem_span_singleton'.mpr [(Term.anonymousCtor \"⟨\" [`c \",\" `rfl] \"⟩\")])]))])\n                        []\n                        (tactic__\n                         (cdotTk (patternIgnore (token.«· » \"·\")))\n                         [(Tactic.tacticHave_\n                           \"have\"\n                           (Term.haveDecl\n                            (Term.haveIdDecl\n                             []\n                             []\n                             \":=\"\n                             (Term.app (Term.proj (Term.app `submodule.quotient.eq [(Term.hole \"_\")]) \".\" `mp) [`hc]))))\n                          []\n                          (Tactic.rwSeq\n                           \"rw\"\n                           []\n                           (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.mem_smul_top_iff)] \"]\")\n                           [(Tactic.location \"at\" (Tactic.locationHyp [`this] []))])\n                          []\n                          (Tactic.exact \"exact\" (Term.app `ideal.mem_sup_right [`this]))])]))))))\n                 []\n                 (Tactic.tacticHave_\n                  \"have\"\n                  (Term.haveDecl\n                   (Term.haveIdDecl\n                    [`h₂ []]\n                    [(Term.typeSpec\n                      \":\"\n                      («term_≤_»\n                       (Term.app `maximal_ideal [`R])\n                       \"≤\"\n                       (Term.proj\n                        (Term.typeAscription \"(\" (Term.app `«expr⊥» []) \":\" [(Term.app `ideal [`R])] \")\")\n                        \".\"\n                        `jacobson)))]\n                    \":=\"\n                    (Term.byTactic\n                     \"by\"\n                     (Tactic.tacticSeq\n                      (Tactic.tacticSeq1Indented\n                       [(Tactic.rwSeq\n                         \"rw\"\n                         []\n                         (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `local_ring.jacobson_eq_maximal_ideal)] \"]\")\n                         [])\n                        []\n                        (Std.Tactic.exacts\n                         \"exacts\"\n                         \"[\"\n                         [(Term.app `le_refl [(Term.hole \"_\")]) \",\" `bot_ne_top]\n                         \"]\")]))))))\n                 []\n                 (Tactic.tacticHave_\n                  \"have\"\n                  (Term.haveDecl\n                   (Term.haveIdDecl\n                    []\n                    []\n                    \":=\"\n                    (Term.app\n                     `submodule.smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson\n                     [(Term.app `is_noetherian.noetherian [(Term.hole \"_\")]) `h₂ `h₁]))))\n                 []\n                 (Tactic.rwSeq\n                  \"rw\"\n                  []\n                  (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.bot_smul) \",\" (Tactic.rwRule [] `sup_bot_eq)] \"]\")\n                  [(Tactic.location \"at\" (Tactic.locationHyp [`this] []))])\n                 []\n                 (Tactic.rwSeq\n                  \"rw\"\n                  []\n                  (Tactic.rwRuleSeq\n                   \"[\"\n                   [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `sup_eq_left) \",\" (Tactic.rwRule [] `eq_comm)]\n                   \"]\")\n                  [])\n                 []\n                 (Tactic.exact\n                  \"exact\"\n                  (Term.app `le_sup_left.antisymm [(«term_<|_» `h₁.trans \"<|\" (Term.app `le_of_eq [`this]))]))])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"7\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.exact \"exact\" (Term.app `exists_maximal_ideal_pow_eq_of_principal [`R `h]))])\n               []\n               (Tactic.tfaeHave \"tfae_have\" [] (num \"7\") \"→\" (num \"2\"))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.rwSeq\n                  \"rw\"\n                  []\n                  (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `valuation_ring.iff_ideal_total)] \"]\")\n                  [])\n                 []\n                 (Tactic.intro \"intro\" [`H])\n                 []\n                 (Tactic.constructor \"constructor\")\n                 []\n                 (Tactic.intro \"intro\" [`I `J])\n                 []\n                 (Classical.«tacticBy_cases_:_» \"by_cases\" [`hI \":\"] («term_=_» `I \"=\" (Term.app `«expr⊥» [])))\n                 []\n                 (tactic__\n                  (cdotTk (patternIgnore (token.«· » \"·\")))\n                  [(Tactic.subst \"subst\" [`hI])\n                   []\n                   (Mathlib.Tactic.tacticLeft \"left\")\n                   []\n                   (Tactic.exact \"exact\" `bot_le)])\n                 []\n                 (Classical.«tacticBy_cases_:_» \"by_cases\" [`hJ \":\"] («term_=_» `J \"=\" (Term.app `«expr⊥» [])))\n                 []\n                 (tactic__\n                  (cdotTk (patternIgnore (token.«· » \"·\")))\n                  [(Tactic.subst \"subst\" [`hJ])\n                   []\n                   (Mathlib.Tactic.tacticRight \"right\")\n                   []\n                   (Tactic.exact \"exact\" `bot_le)])\n                 []\n                 (Std.Tactic.obtain\n                  \"obtain\"\n                  [(Std.Tactic.RCases.rcasesPatMed\n                    [(Std.Tactic.RCases.rcasesPat.tuple\n                      \"⟨\"\n                      [(Std.Tactic.RCases.rcasesPatLo\n                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `n)])\n                        [])\n                       \",\"\n                       (Std.Tactic.RCases.rcasesPatLo\n                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                        [])]\n                      \"⟩\")])]\n                  []\n                  [\":=\" [(Term.app `H [`I `hI])]])\n                 []\n                 (Std.Tactic.obtain\n                  \"obtain\"\n                  [(Std.Tactic.RCases.rcasesPatMed\n                    [(Std.Tactic.RCases.rcasesPat.tuple\n                      \"⟨\"\n                      [(Std.Tactic.RCases.rcasesPatLo\n                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `m)])\n                        [])\n                       \",\"\n                       (Std.Tactic.RCases.rcasesPatLo\n                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                        [])]\n                      \"⟩\")])]\n                  []\n                  [\":=\" [(Term.app `H [`J `hJ])]])\n                 []\n                 (Tactic.cases'\n                  \"cases'\"\n                  [(Tactic.casesTarget [] (Term.app `le_total [`m `n]))]\n                  []\n                  [\"with\" [(Lean.binderIdent `h') (Lean.binderIdent `h')]])\n                 []\n                 (tactic__\n                  (cdotTk (patternIgnore (token.«· » \"·\")))\n                  [(Mathlib.Tactic.tacticLeft \"left\") [] (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))])\n                 []\n                 (tactic__\n                  (cdotTk (patternIgnore (token.«· » \"·\")))\n                  [(Mathlib.Tactic.tacticRight \"right\") [] (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))])])\n               []\n               (Tactic.tfaeFinish \"tfae_finish\")])))])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tacticHave_\n           \"have\"\n           (Term.haveDecl\n            (Term.haveIdDecl\n             [`ne_bot []]\n             []\n             \":=\"\n             (Term.app `ring.ne_bot_of_is_maximal_of_not_is_field [(Term.app `maximal_ideal.is_maximal [`R]) `h]))))\n          []\n          (Mathlib.Tactic.tacticClassical_\n           \"classical\"\n           (Tactic.tacticSeq\n            (Tactic.tacticSeq1Indented\n             [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `finrank_eq_one_iff')] \"]\") [])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.intro \"intro\" []) [] (Tactic.tacticInfer_instance \"infer_instance\")])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.intro \"intro\" [])\n                []\n                (Std.Tactic.tacticHaveI_\n                 \"haveI\"\n                 (Term.haveDecl (Term.haveIdDecl [] [] \":=\" (Term.app `is_bezout.to_gcd_domain [`R]))))\n                []\n                (Std.Tactic.tacticHaveI_\n                 \"haveI\"\n                 (Term.haveDecl\n                  (Term.haveIdDecl\n                   []\n                   [(Term.typeSpec \":\" (Term.app `unique_factorization_monoid [`R]))]\n                   \":=\"\n                   `ufm_of_gcd_of_wf_dvd_monoid)))\n                []\n                (Tactic.apply \"apply\" `discrete_valuation_ring.of_ufd_of_unique_irreducible)\n                []\n                (tactic__\n                 (cdotTk (patternIgnore (token.«· » \"·\")))\n                 [(Std.Tactic.obtain\n                   \"obtain\"\n                   [(Std.Tactic.RCases.rcasesPatMed\n                     [(Std.Tactic.RCases.rcasesPat.tuple\n                       \"⟨\"\n                       [(Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `x)])\n                         [])\n                        \",\"\n                        (Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx₁)])\n                         [])\n                        \",\"\n                        (Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx₂)])\n                         [])]\n                       \"⟩\")])]\n                   []\n                   [\":=\" [(Term.app `ring.exists_not_is_unit_of_not_is_field [`h])]])\n                  []\n                  (Std.Tactic.obtain\n                   \"obtain\"\n                   [(Std.Tactic.RCases.rcasesPatMed\n                     [(Std.Tactic.RCases.rcasesPat.tuple\n                       \"⟨\"\n                       [(Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])\n                         [])\n                        \",\"\n                        (Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp₁)])\n                         [])\n                        \",\"\n                        (Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp₂)])\n                         [])]\n                       \"⟩\")])]\n                   []\n                   [\":=\" [(Term.app `wf_dvd_monoid.exists_irreducible_factor [`hx₂ `hx₁])]])\n                  []\n                  (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`p \",\" `hp₁] \"⟩\"))])\n                []\n                (tactic__\n                 (cdotTk (patternIgnore (token.«· » \"·\")))\n                 [(Tactic.exact \"exact\" `valuation_ring.unique_irreducible)])])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.intro \"intro\" [`H])\n                []\n                (Tactic.exact\n                 \"exact\"\n                 (Term.anonymousCtor\n                  \"⟨\"\n                  [`infer_instance\n                   \",\"\n                   (Term.proj\n                    (Term.app\n                     (Term.proj (Term.app `discrete_valuation_ring.iff_pid_with_one_nonzero_prime [`R]) \".\" `mp)\n                     [`H])\n                    \".\"\n                    (fieldIdx \"2\"))]\n                  \"⟩\"))])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Std.Tactic.rintro\n                 \"rintro\"\n                 [(Std.Tactic.RCases.rintroPat.one\n                   (Std.Tactic.RCases.rcasesPat.tuple\n                    \"⟨\"\n                    [(Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h₁)])\n                      [])\n                     \",\"\n                     (Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h₂)])\n                      [])]\n                    \"⟩\"))]\n                 [])\n                []\n                (Tactic.exact\n                 \"exact\"\n                 (Term.anonymousCtor\n                  \"⟨\"\n                  [`infer_instance\n                   \",\"\n                   (Term.fun\n                    \"fun\"\n                    (Term.basicFun\n                     [`I `hI `hI']\n                     []\n                     \"=>\"\n                     (Term.subst\n                      (Term.app\n                       `ExistsUnique.unique\n                       [`h₂\n                        (Term.anonymousCtor \"⟨\" [`ne_bot \",\" `infer_instance] \"⟩\")\n                        (Term.anonymousCtor \"⟨\" [`hI \",\" `hI'] \"⟩\")])\n                      \"▸\"\n                      [(Term.app `maximal_ideal.is_maximal [`R])])))\n                   \",\"\n                   `h₁]\n                  \"⟩\"))])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"5\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.intro \"intro\" [`h])\n                []\n                (Tactic.exact \"exact\" (Term.app `maximal_ideal_is_principal_of_is_dedekind_domain [`R]))])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"6\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Std.Tactic.rintro\n                 \"rintro\"\n                 [(Std.Tactic.RCases.rintroPat.one\n                   (Std.Tactic.RCases.rcasesPat.tuple\n                    \"⟨\"\n                    [(Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `x)])\n                      [])\n                     \",\"\n                     (Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])\n                      [])]\n                    \"⟩\"))]\n                 [])\n                []\n                (Tactic.tacticHave_\n                 \"have\"\n                 (Term.haveDecl\n                  (Term.haveIdDecl\n                   []\n                   [(Term.typeSpec \":\" («term_∈_» `x \"∈\" (Term.app `maximal_ideal [`R])))]\n                   \":=\"\n                   (Term.byTactic\n                    \"by\"\n                    (Tactic.tacticSeq\n                     (Tactic.tacticSeq1Indented\n                      [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hx)] \"]\") [])\n                       []\n                       (Tactic.exact\n                        \"exact\"\n                        (Term.app `submodule.subset_span [(Term.app `Set.mem_singleton [`x])]))]))))))\n                []\n                (Tactic.tacticLet_\n                 \"let\"\n                 (Term.letDecl\n                  (Term.letIdDecl\n                   `x'\n                   []\n                   [(Term.typeSpec \":\" (Term.app `maximal_ideal [`R]))]\n                   \":=\"\n                   (Term.anonymousCtor \"⟨\" [`x \",\" `this] \"⟩\"))))\n                []\n                (Mathlib.Tactic.«tacticUse_,,» \"use\" [(Term.app `submodule.quotient.mk [`x'])])\n                []\n                (Tactic.constructor \"constructor\")\n                []\n                (tactic__\n                 (cdotTk (patternIgnore (token.«· » \"·\")))\n                 [(Tactic.intro \"intro\" [`e])\n                  []\n                  (Tactic.rwSeq\n                   \"rw\"\n                   []\n                   (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.quotient.mk_eq_zero)] \"]\")\n                   [(Tactic.location \"at\" (Tactic.locationHyp [`e] []))])\n                  []\n                  (Tactic.apply\n                   \"apply\"\n                   (Term.app `ring.ne_bot_of_is_maximal_of_not_is_field [(Term.app `maximal_ideal.is_maximal [`R]) `h]))\n                  []\n                  (Tactic.apply\n                   \"apply\"\n                   (Term.app `submodule.eq_bot_of_le_smul_of_le_jacobson_bot [(Term.app `maximal_ideal [`R])]))\n                  []\n                  (tactic__\n                   (cdotTk (patternIgnore (token.«· » \"·\")))\n                   [(Tactic.exact\n                     \"exact\"\n                     (Term.anonymousCtor\n                      \"⟨\"\n                      [(«term{_}» \"{\" [`x] \"}\")\n                       \",\"\n                       (Term.subst (Term.proj (Term.app `Finset.coe_singleton [`x]) \".\" `symm) \"▸\" [`hx.symm])]\n                      \"⟩\"))])\n                  []\n                  (tactic__\n                   (cdotTk (patternIgnore (token.«· » \"·\")))\n                   [(Mathlib.Tactic.Conv.convLHS\n                     \"conv_lhs\"\n                     []\n                     []\n                     \"=>\"\n                     (Tactic.Conv.convSeq\n                      (Tactic.Conv.convSeq1Indented\n                       [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hx)] \"]\"))])))\n                    []\n                    (Tactic.rwSeq\n                     \"rw\"\n                     []\n                     (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.mem_smul_top_iff)] \"]\")\n                     [(Tactic.location \"at\" (Tactic.locationHyp [`e] []))])\n                    []\n                    (Std.Tactic.tacticRwa__\n                     \"rwa\"\n                     (Tactic.rwRuleSeq\n                      \"[\"\n                      [(Tactic.rwRule [] `submodule.span_le) \",\" (Tactic.rwRule [] `Set.singleton_subset_iff)]\n                      \"]\")\n                     [])])\n                  []\n                  (tactic__\n                   (cdotTk (patternIgnore (token.«· » \"·\")))\n                   [(Tactic.rwSeq\n                     \"rw\"\n                     []\n                     (Tactic.rwRuleSeq\n                      \"[\"\n                      [(Tactic.rwRule\n                        []\n                        (Term.app\n                         `local_ring.jacobson_eq_maximal_ideal\n                         [(Term.typeAscription \"(\" (Term.app `«expr⊥» []) \":\" [(Term.app `ideal [`R])] \")\")\n                          `bot_ne_top]))]\n                      \"]\")\n                     [])\n                    []\n                    (Tactic.exact \"exact\" (Term.app `le_refl [(Term.hole \"_\")]))])])\n                []\n                (tactic__\n                 (cdotTk (patternIgnore (token.«· » \"·\")))\n                 [(Tactic.refine'\n                   \"refine'\"\n                   (Term.fun\n                    \"fun\"\n                    (Term.basicFun\n                     [`w]\n                     []\n                     \"=>\"\n                     (Term.app\n                      `Quotient.inductionOn'\n                      [`w (Term.fun \"fun\" (Term.basicFun [`y] [] \"=>\" (Term.hole \"_\")))]))))\n                  []\n                  (Std.Tactic.obtain\n                   \"obtain\"\n                   [(Std.Tactic.RCases.rcasesPatMed\n                     [(Std.Tactic.RCases.rcasesPat.tuple\n                       \"⟨\"\n                       [(Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `y)])\n                         [])\n                        \",\"\n                        (Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])\n                         [])]\n                       \"⟩\")])]\n                   []\n                   [\":=\" [`y]])\n                  []\n                  (Tactic.rwSeq\n                   \"rw\"\n                   []\n                   (Tactic.rwRuleSeq\n                    \"[\"\n                    [(Tactic.rwRule [] `hx) \",\" (Tactic.rwRule [] `submodule.mem_span_singleton)]\n                    \"]\")\n                   [(Tactic.location \"at\" (Tactic.locationHyp [`hy] []))])\n                  []\n                  (Std.Tactic.obtain\n                   \"obtain\"\n                   [(Std.Tactic.RCases.rcasesPatMed\n                     [(Std.Tactic.RCases.rcasesPat.tuple\n                       \"⟨\"\n                       [(Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                         [])\n                        \",\"\n                        (Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                         [])]\n                       \"⟩\")])]\n                   []\n                   [\":=\" [`hy]])\n                  []\n                  (Tactic.exact\n                   \"exact\"\n                   (Term.anonymousCtor \"⟨\" [(Term.app `ideal.quotient.mk [(Term.hole \"_\") `a]) \",\" `rfl] \"⟩\"))])])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"5\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Std.Tactic.rintro\n                 \"rintro\"\n                 [(Std.Tactic.RCases.rintroPat.one\n                   (Std.Tactic.RCases.rcasesPat.tuple\n                    \"⟨\"\n                    [(Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `x)])\n                      [])\n                     \",\"\n                     (Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])\n                      [])\n                     \",\"\n                     (Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx')])\n                      [])]\n                    \"⟩\"))]\n                 [])\n                []\n                (Tactic.induction \"induction\" [`x] [\"using\" `Quotient.inductionOn'] [] [])\n                []\n                (Mathlib.Tactic.«tacticUse_,,» \"use\" [`x])\n                []\n                (Tactic.apply \"apply\" `le_antisymm)\n                []\n                (Mathlib.Tactic.tacticSwap \"swap\")\n                []\n                (tactic__\n                 (cdotTk (patternIgnore (token.«· » \"·\")))\n                 [(Tactic.rwSeq\n                   \"rw\"\n                   []\n                   (Tactic.rwRuleSeq\n                    \"[\"\n                    [(Tactic.rwRule [] `submodule.span_le) \",\" (Tactic.rwRule [] `Set.singleton_subset_iff)]\n                    \"]\")\n                   [])\n                  []\n                  (Tactic.exact \"exact\" `x.prop)])\n                []\n                (Tactic.tacticHave_\n                 \"have\"\n                 (Term.haveDecl\n                  (Term.haveIdDecl\n                   [`h₁ []]\n                   [(Term.typeSpec\n                     \":\"\n                     («term_≤_»\n                      (Term.app\n                       `«expr ⊔ »\n                       [(Term.typeAscription\n                         \"(\"\n                         (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])\n                         \":\"\n                         [(Term.app `ideal [`R])]\n                         \")\")\n                        (Term.app `maximal_ideal [`R])])\n                      \"≤\"\n                      (Term.app\n                       `«expr ⊔ »\n                       [(Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])\n                        (Term.app `«expr • » [(Term.app `maximal_ideal [`R]) (Term.app `maximal_ideal [`R])])])))]\n                   \":=\"\n                   (Term.byTactic\n                    \"by\"\n                    (Tactic.tacticSeq\n                     (Tactic.tacticSeq1Indented\n                      [(Tactic.refine' \"refine'\" (Term.app `sup_le [`le_sup_left (Term.hole \"_\")]))\n                       []\n                       (Std.Tactic.rintro\n                        \"rintro\"\n                        [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `m))\n                         (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hm))]\n                        [])\n                       []\n                       (Std.Tactic.obtain\n                        \"obtain\"\n                        [(Std.Tactic.RCases.rcasesPatMed\n                          [(Std.Tactic.RCases.rcasesPat.tuple\n                            \"⟨\"\n                            [(Std.Tactic.RCases.rcasesPatLo\n                              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `c)])\n                              [])\n                             \",\"\n                             (Std.Tactic.RCases.rcasesPatLo\n                              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hc)])\n                              [])]\n                            \"⟩\")])]\n                        []\n                        [\":=\"\n                         [(Term.app\n                           `hx'\n                           [(Term.app `submodule.quotient.mk [(Term.anonymousCtor \"⟨\" [`m \",\" `hm] \"⟩\")])])]])\n                       []\n                       (Tactic.induction \"induction\" [`c] [\"using\" `Quotient.inductionOn'] [] [])\n                       []\n                       (Tactic.rwSeq\n                        \"rw\"\n                        []\n                        (Tactic.rwRuleSeq\n                         \"[\"\n                         [(Tactic.rwRule\n                           [(patternIgnore (token.«← » \"←\"))]\n                           (Term.app `sub_sub_cancel [(«term_*_» `c \"*\" `x) `m]))]\n                         \"]\")\n                        [])\n                       []\n                       (Tactic.apply \"apply\" (Term.app `sub_mem [(Term.hole \"_\") (Term.hole \"_\")]))\n                       []\n                       (tactic__\n                        (cdotTk (patternIgnore (token.«· » \"·\")))\n                        [(Tactic.tacticInfer_instance \"infer_instance\")])\n                       []\n                       (tactic__\n                        (cdotTk (patternIgnore (token.«· » \"·\")))\n                        [(Tactic.refine'\n                          \"refine'\"\n                          (Term.app\n                           `ideal.mem_sup_left\n                           [(Term.app `ideal.mem_span_singleton'.mpr [(Term.anonymousCtor \"⟨\" [`c \",\" `rfl] \"⟩\")])]))])\n                       []\n                       (tactic__\n                        (cdotTk (patternIgnore (token.«· » \"·\")))\n                        [(Tactic.tacticHave_\n                          \"have\"\n                          (Term.haveDecl\n                           (Term.haveIdDecl\n                            []\n                            []\n                            \":=\"\n                            (Term.app (Term.proj (Term.app `submodule.quotient.eq [(Term.hole \"_\")]) \".\" `mp) [`hc]))))\n                         []\n                         (Tactic.rwSeq\n                          \"rw\"\n                          []\n                          (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.mem_smul_top_iff)] \"]\")\n                          [(Tactic.location \"at\" (Tactic.locationHyp [`this] []))])\n                         []\n                         (Tactic.exact \"exact\" (Term.app `ideal.mem_sup_right [`this]))])]))))))\n                []\n                (Tactic.tacticHave_\n                 \"have\"\n                 (Term.haveDecl\n                  (Term.haveIdDecl\n                   [`h₂ []]\n                   [(Term.typeSpec\n                     \":\"\n                     («term_≤_»\n                      (Term.app `maximal_ideal [`R])\n                      \"≤\"\n                      (Term.proj\n                       (Term.typeAscription \"(\" (Term.app `«expr⊥» []) \":\" [(Term.app `ideal [`R])] \")\")\n                       \".\"\n                       `jacobson)))]\n                   \":=\"\n                   (Term.byTactic\n                    \"by\"\n                    (Tactic.tacticSeq\n                     (Tactic.tacticSeq1Indented\n                      [(Tactic.rwSeq\n                        \"rw\"\n                        []\n                        (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `local_ring.jacobson_eq_maximal_ideal)] \"]\")\n                        [])\n                       []\n                       (Std.Tactic.exacts\n                        \"exacts\"\n                        \"[\"\n                        [(Term.app `le_refl [(Term.hole \"_\")]) \",\" `bot_ne_top]\n                        \"]\")]))))))\n                []\n                (Tactic.tacticHave_\n                 \"have\"\n                 (Term.haveDecl\n                  (Term.haveIdDecl\n                   []\n                   []\n                   \":=\"\n                   (Term.app\n                    `submodule.smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson\n                    [(Term.app `is_noetherian.noetherian [(Term.hole \"_\")]) `h₂ `h₁]))))\n                []\n                (Tactic.rwSeq\n                 \"rw\"\n                 []\n                 (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.bot_smul) \",\" (Tactic.rwRule [] `sup_bot_eq)] \"]\")\n                 [(Tactic.location \"at\" (Tactic.locationHyp [`this] []))])\n                []\n                (Tactic.rwSeq\n                 \"rw\"\n                 []\n                 (Tactic.rwRuleSeq\n                  \"[\"\n                  [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `sup_eq_left) \",\" (Tactic.rwRule [] `eq_comm)]\n                  \"]\")\n                 [])\n                []\n                (Tactic.exact\n                 \"exact\"\n                 (Term.app `le_sup_left.antisymm [(«term_<|_» `h₁.trans \"<|\" (Term.app `le_of_eq [`this]))]))])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"7\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.exact \"exact\" (Term.app `exists_maximal_ideal_pow_eq_of_principal [`R `h]))])\n              []\n              (Tactic.tfaeHave \"tfae_have\" [] (num \"7\") \"→\" (num \"2\"))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.rwSeq\n                 \"rw\"\n                 []\n                 (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `valuation_ring.iff_ideal_total)] \"]\")\n                 [])\n                []\n                (Tactic.intro \"intro\" [`H])\n                []\n                (Tactic.constructor \"constructor\")\n                []\n                (Tactic.intro \"intro\" [`I `J])\n                []\n                (Classical.«tacticBy_cases_:_» \"by_cases\" [`hI \":\"] («term_=_» `I \"=\" (Term.app `«expr⊥» [])))\n                []\n                (tactic__\n                 (cdotTk (patternIgnore (token.«· » \"·\")))\n                 [(Tactic.subst \"subst\" [`hI]) [] (Mathlib.Tactic.tacticLeft \"left\") [] (Tactic.exact \"exact\" `bot_le)])\n                []\n                (Classical.«tacticBy_cases_:_» \"by_cases\" [`hJ \":\"] («term_=_» `J \"=\" (Term.app `«expr⊥» [])))\n                []\n                (tactic__\n                 (cdotTk (patternIgnore (token.«· » \"·\")))\n                 [(Tactic.subst \"subst\" [`hJ])\n                  []\n                  (Mathlib.Tactic.tacticRight \"right\")\n                  []\n                  (Tactic.exact \"exact\" `bot_le)])\n                []\n                (Std.Tactic.obtain\n                 \"obtain\"\n                 [(Std.Tactic.RCases.rcasesPatMed\n                   [(Std.Tactic.RCases.rcasesPat.tuple\n                     \"⟨\"\n                     [(Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `n)])\n                       [])\n                      \",\"\n                      (Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                       [])]\n                     \"⟩\")])]\n                 []\n                 [\":=\" [(Term.app `H [`I `hI])]])\n                []\n                (Std.Tactic.obtain\n                 \"obtain\"\n                 [(Std.Tactic.RCases.rcasesPatMed\n                   [(Std.Tactic.RCases.rcasesPat.tuple\n                     \"⟨\"\n                     [(Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `m)])\n                       [])\n                      \",\"\n                      (Std.Tactic.RCases.rcasesPatLo\n                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                       [])]\n                     \"⟩\")])]\n                 []\n                 [\":=\" [(Term.app `H [`J `hJ])]])\n                []\n                (Tactic.cases'\n                 \"cases'\"\n                 [(Tactic.casesTarget [] (Term.app `le_total [`m `n]))]\n                 []\n                 [\"with\" [(Lean.binderIdent `h') (Lean.binderIdent `h')]])\n                []\n                (tactic__\n                 (cdotTk (patternIgnore (token.«· » \"·\")))\n                 [(Mathlib.Tactic.tacticLeft \"left\") [] (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))])\n                []\n                (tactic__\n                 (cdotTk (patternIgnore (token.«· » \"·\")))\n                 [(Mathlib.Tactic.tacticRight \"right\") [] (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))])])\n              []\n              (Tactic.tfaeFinish \"tfae_finish\")])))])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Mathlib.Tactic.tacticClassical_\n       \"classical\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `finrank_eq_one_iff')] \"]\") [])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" []) [] (Tactic.tacticInfer_instance \"infer_instance\")])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [])\n            []\n            (Std.Tactic.tacticHaveI_\n             \"haveI\"\n             (Term.haveDecl (Term.haveIdDecl [] [] \":=\" (Term.app `is_bezout.to_gcd_domain [`R]))))\n            []\n            (Std.Tactic.tacticHaveI_\n             \"haveI\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               []\n               [(Term.typeSpec \":\" (Term.app `unique_factorization_monoid [`R]))]\n               \":=\"\n               `ufm_of_gcd_of_wf_dvd_monoid)))\n            []\n            (Tactic.apply \"apply\" `discrete_valuation_ring.of_ufd_of_unique_irreducible)\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Std.Tactic.obtain\n               \"obtain\"\n               [(Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `x)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx₁)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx₂)])\n                     [])]\n                   \"⟩\")])]\n               []\n               [\":=\" [(Term.app `ring.exists_not_is_unit_of_not_is_field [`h])]])\n              []\n              (Std.Tactic.obtain\n               \"obtain\"\n               [(Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp₁)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp₂)])\n                     [])]\n                   \"⟩\")])]\n               []\n               [\":=\" [(Term.app `wf_dvd_monoid.exists_irreducible_factor [`hx₂ `hx₁])]])\n              []\n              (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`p \",\" `hp₁] \"⟩\"))])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Tactic.exact \"exact\" `valuation_ring.unique_irreducible)])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`infer_instance\n               \",\"\n               (Term.proj\n                (Term.app\n                 (Term.proj (Term.app `discrete_valuation_ring.iff_pid_with_one_nonzero_prime [`R]) \".\" `mp)\n                 [`H])\n                \".\"\n                (fieldIdx \"2\"))]\n              \"⟩\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h₁)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h₂)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`infer_instance\n               \",\"\n               (Term.fun\n                \"fun\"\n                (Term.basicFun\n                 [`I `hI `hI']\n                 []\n                 \"=>\"\n                 (Term.subst\n                  (Term.app\n                   `ExistsUnique.unique\n                   [`h₂\n                    (Term.anonymousCtor \"⟨\" [`ne_bot \",\" `infer_instance] \"⟩\")\n                    (Term.anonymousCtor \"⟨\" [`hI \",\" `hI'] \"⟩\")])\n                  \"▸\"\n                  [(Term.app `maximal_ideal.is_maximal [`R])])))\n               \",\"\n               `h₁]\n              \"⟩\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"5\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`h])\n            []\n            (Tactic.exact \"exact\" (Term.app `maximal_ideal_is_principal_of_is_dedekind_domain [`R]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"6\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `x)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               []\n               [(Term.typeSpec \":\" («term_∈_» `x \"∈\" (Term.app `maximal_ideal [`R])))]\n               \":=\"\n               (Term.byTactic\n                \"by\"\n                (Tactic.tacticSeq\n                 (Tactic.tacticSeq1Indented\n                  [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hx)] \"]\") [])\n                   []\n                   (Tactic.exact \"exact\" (Term.app `submodule.subset_span [(Term.app `Set.mem_singleton [`x])]))]))))))\n            []\n            (Tactic.tacticLet_\n             \"let\"\n             (Term.letDecl\n              (Term.letIdDecl\n               `x'\n               []\n               [(Term.typeSpec \":\" (Term.app `maximal_ideal [`R]))]\n               \":=\"\n               (Term.anonymousCtor \"⟨\" [`x \",\" `this] \"⟩\"))))\n            []\n            (Mathlib.Tactic.«tacticUse_,,» \"use\" [(Term.app `submodule.quotient.mk [`x'])])\n            []\n            (Tactic.constructor \"constructor\")\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Tactic.intro \"intro\" [`e])\n              []\n              (Tactic.rwSeq\n               \"rw\"\n               []\n               (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.quotient.mk_eq_zero)] \"]\")\n               [(Tactic.location \"at\" (Tactic.locationHyp [`e] []))])\n              []\n              (Tactic.apply\n               \"apply\"\n               (Term.app `ring.ne_bot_of_is_maximal_of_not_is_field [(Term.app `maximal_ideal.is_maximal [`R]) `h]))\n              []\n              (Tactic.apply\n               \"apply\"\n               (Term.app `submodule.eq_bot_of_le_smul_of_le_jacobson_bot [(Term.app `maximal_ideal [`R])]))\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.exact\n                 \"exact\"\n                 (Term.anonymousCtor\n                  \"⟨\"\n                  [(«term{_}» \"{\" [`x] \"}\")\n                   \",\"\n                   (Term.subst (Term.proj (Term.app `Finset.coe_singleton [`x]) \".\" `symm) \"▸\" [`hx.symm])]\n                  \"⟩\"))])\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Mathlib.Tactic.Conv.convLHS\n                 \"conv_lhs\"\n                 []\n                 []\n                 \"=>\"\n                 (Tactic.Conv.convSeq\n                  (Tactic.Conv.convSeq1Indented\n                   [(Tactic.Conv.convRw__ \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hx)] \"]\"))])))\n                []\n                (Tactic.rwSeq\n                 \"rw\"\n                 []\n                 (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.mem_smul_top_iff)] \"]\")\n                 [(Tactic.location \"at\" (Tactic.locationHyp [`e] []))])\n                []\n                (Std.Tactic.tacticRwa__\n                 \"rwa\"\n                 (Tactic.rwRuleSeq\n                  \"[\"\n                  [(Tactic.rwRule [] `submodule.span_le) \",\" (Tactic.rwRule [] `Set.singleton_subset_iff)]\n                  \"]\")\n                 [])])\n              []\n              (tactic__\n               (cdotTk (patternIgnore (token.«· » \"·\")))\n               [(Tactic.rwSeq\n                 \"rw\"\n                 []\n                 (Tactic.rwRuleSeq\n                  \"[\"\n                  [(Tactic.rwRule\n                    []\n                    (Term.app\n                     `local_ring.jacobson_eq_maximal_ideal\n                     [(Term.typeAscription \"(\" (Term.app `«expr⊥» []) \":\" [(Term.app `ideal [`R])] \")\") `bot_ne_top]))]\n                  \"]\")\n                 [])\n                []\n                (Tactic.exact \"exact\" (Term.app `le_refl [(Term.hole \"_\")]))])])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Tactic.refine'\n               \"refine'\"\n               (Term.fun\n                \"fun\"\n                (Term.basicFun\n                 [`w]\n                 []\n                 \"=>\"\n                 (Term.app `Quotient.inductionOn' [`w (Term.fun \"fun\" (Term.basicFun [`y] [] \"=>\" (Term.hole \"_\")))]))))\n              []\n              (Std.Tactic.obtain\n               \"obtain\"\n               [(Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `y)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])\n                     [])]\n                   \"⟩\")])]\n               []\n               [\":=\" [`y]])\n              []\n              (Tactic.rwSeq\n               \"rw\"\n               []\n               (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `hx) \",\" (Tactic.rwRule [] `submodule.mem_span_singleton)] \"]\")\n               [(Tactic.location \"at\" (Tactic.locationHyp [`hy] []))])\n              []\n              (Std.Tactic.obtain\n               \"obtain\"\n               [(Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                     [])]\n                   \"⟩\")])]\n               []\n               [\":=\" [`hy]])\n              []\n              (Tactic.exact\n               \"exact\"\n               (Term.anonymousCtor \"⟨\" [(Term.app `ideal.quotient.mk [(Term.hole \"_\") `a]) \",\" `rfl] \"⟩\"))])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"5\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `x)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx')])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.induction \"induction\" [`x] [\"using\" `Quotient.inductionOn'] [] [])\n            []\n            (Mathlib.Tactic.«tacticUse_,,» \"use\" [`x])\n            []\n            (Tactic.apply \"apply\" `le_antisymm)\n            []\n            (Mathlib.Tactic.tacticSwap \"swap\")\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Tactic.rwSeq\n               \"rw\"\n               []\n               (Tactic.rwRuleSeq\n                \"[\"\n                [(Tactic.rwRule [] `submodule.span_le) \",\" (Tactic.rwRule [] `Set.singleton_subset_iff)]\n                \"]\")\n               [])\n              []\n              (Tactic.exact \"exact\" `x.prop)])\n            []\n            (Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               [`h₁ []]\n               [(Term.typeSpec\n                 \":\"\n                 («term_≤_»\n                  (Term.app\n                   `«expr ⊔ »\n                   [(Term.typeAscription\n                     \"(\"\n                     (Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])\n                     \":\"\n                     [(Term.app `ideal [`R])]\n                     \")\")\n                    (Term.app `maximal_ideal [`R])])\n                  \"≤\"\n                  (Term.app\n                   `«expr ⊔ »\n                   [(Term.app `ideal.span [(«term{_}» \"{\" [`x] \"}\")])\n                    (Term.app `«expr • » [(Term.app `maximal_ideal [`R]) (Term.app `maximal_ideal [`R])])])))]\n               \":=\"\n               (Term.byTactic\n                \"by\"\n                (Tactic.tacticSeq\n                 (Tactic.tacticSeq1Indented\n                  [(Tactic.refine' \"refine'\" (Term.app `sup_le [`le_sup_left (Term.hole \"_\")]))\n                   []\n                   (Std.Tactic.rintro\n                    \"rintro\"\n                    [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `m))\n                     (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hm))]\n                    [])\n                   []\n                   (Std.Tactic.obtain\n                    \"obtain\"\n                    [(Std.Tactic.RCases.rcasesPatMed\n                      [(Std.Tactic.RCases.rcasesPat.tuple\n                        \"⟨\"\n                        [(Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `c)])\n                          [])\n                         \",\"\n                         (Std.Tactic.RCases.rcasesPatLo\n                          (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hc)])\n                          [])]\n                        \"⟩\")])]\n                    []\n                    [\":=\"\n                     [(Term.app `hx' [(Term.app `submodule.quotient.mk [(Term.anonymousCtor \"⟨\" [`m \",\" `hm] \"⟩\")])])]])\n                   []\n                   (Tactic.induction \"induction\" [`c] [\"using\" `Quotient.inductionOn'] [] [])\n                   []\n                   (Tactic.rwSeq\n                    \"rw\"\n                    []\n                    (Tactic.rwRuleSeq\n                     \"[\"\n                     [(Tactic.rwRule\n                       [(patternIgnore (token.«← » \"←\"))]\n                       (Term.app `sub_sub_cancel [(«term_*_» `c \"*\" `x) `m]))]\n                     \"]\")\n                    [])\n                   []\n                   (Tactic.apply \"apply\" (Term.app `sub_mem [(Term.hole \"_\") (Term.hole \"_\")]))\n                   []\n                   (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.tacticInfer_instance \"infer_instance\")])\n                   []\n                   (tactic__\n                    (cdotTk (patternIgnore (token.«· » \"·\")))\n                    [(Tactic.refine'\n                      \"refine'\"\n                      (Term.app\n                       `ideal.mem_sup_left\n                       [(Term.app `ideal.mem_span_singleton'.mpr [(Term.anonymousCtor \"⟨\" [`c \",\" `rfl] \"⟩\")])]))])\n                   []\n                   (tactic__\n                    (cdotTk (patternIgnore (token.«· » \"·\")))\n                    [(Tactic.tacticHave_\n                      \"have\"\n                      (Term.haveDecl\n                       (Term.haveIdDecl\n                        []\n                        []\n                        \":=\"\n                        (Term.app (Term.proj (Term.app `submodule.quotient.eq [(Term.hole \"_\")]) \".\" `mp) [`hc]))))\n                     []\n                     (Tactic.rwSeq\n                      \"rw\"\n                      []\n                      (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.mem_smul_top_iff)] \"]\")\n                      [(Tactic.location \"at\" (Tactic.locationHyp [`this] []))])\n                     []\n                     (Tactic.exact \"exact\" (Term.app `ideal.mem_sup_right [`this]))])]))))))\n            []\n            (Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               [`h₂ []]\n               [(Term.typeSpec\n                 \":\"\n                 («term_≤_»\n                  (Term.app `maximal_ideal [`R])\n                  \"≤\"\n                  (Term.proj\n                   (Term.typeAscription \"(\" (Term.app `«expr⊥» []) \":\" [(Term.app `ideal [`R])] \")\")\n                   \".\"\n                   `jacobson)))]\n               \":=\"\n               (Term.byTactic\n                \"by\"\n                (Tactic.tacticSeq\n                 (Tactic.tacticSeq1Indented\n                  [(Tactic.rwSeq\n                    \"rw\"\n                    []\n                    (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `local_ring.jacobson_eq_maximal_ideal)] \"]\")\n                    [])\n                   []\n                   (Std.Tactic.exacts \"exacts\" \"[\" [(Term.app `le_refl [(Term.hole \"_\")]) \",\" `bot_ne_top] \"]\")]))))))\n            []\n            (Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               []\n               []\n               \":=\"\n               (Term.app\n                `submodule.smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson\n                [(Term.app `is_noetherian.noetherian [(Term.hole \"_\")]) `h₂ `h₁]))))\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `submodule.bot_smul) \",\" (Tactic.rwRule [] `sup_bot_eq)] \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`this] []))])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `sup_eq_left) \",\" (Tactic.rwRule [] `eq_comm)]\n              \"]\")\n             [])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.app `le_sup_left.antisymm [(«term_<|_» `h₁.trans \"<|\" (Term.app `le_of_eq [`this]))]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"7\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `exists_maximal_ideal_pow_eq_of_principal [`R `h]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"7\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `valuation_ring.iff_ideal_total)] \"]\") [])\n            []\n            (Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.constructor \"constructor\")\n            []\n            (Tactic.intro \"intro\" [`I `J])\n            []\n            (Classical.«tacticBy_cases_:_» \"by_cases\" [`hI \":\"] («term_=_» `I \"=\" (Term.app `«expr⊥» [])))\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Tactic.subst \"subst\" [`hI]) [] (Mathlib.Tactic.tacticLeft \"left\") [] (Tactic.exact \"exact\" `bot_le)])\n            []\n            (Classical.«tacticBy_cases_:_» \"by_cases\" [`hJ \":\"] («term_=_» `J \"=\" (Term.app `«expr⊥» [])))\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Tactic.subst \"subst\" [`hJ]) [] (Mathlib.Tactic.tacticRight \"right\") [] (Tactic.exact \"exact\" `bot_le)])\n            []\n            (Std.Tactic.obtain\n             \"obtain\"\n             [(Std.Tactic.RCases.rcasesPatMed\n               [(Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `n)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                   [])]\n                 \"⟩\")])]\n             []\n             [\":=\" [(Term.app `H [`I `hI])]])\n            []\n            (Std.Tactic.obtain\n             \"obtain\"\n             [(Std.Tactic.RCases.rcasesPatMed\n               [(Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `m)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                   [])]\n                 \"⟩\")])]\n             []\n             [\":=\" [(Term.app `H [`J `hJ])]])\n            []\n            (Tactic.cases'\n             \"cases'\"\n             [(Tactic.casesTarget [] (Term.app `le_total [`m `n]))]\n             []\n             [\"with\" [(Lean.binderIdent `h') (Lean.binderIdent `h')]])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Mathlib.Tactic.tacticLeft \"left\") [] (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Mathlib.Tactic.tacticRight \"right\") [] (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))])])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `valuation_ring.iff_ideal_total)] \"]\") [])\n        []\n        (Tactic.intro \"intro\" [`H])\n        []\n        (Tactic.constructor \"constructor\")\n        []\n        (Tactic.intro \"intro\" [`I `J])\n        []\n        (Classical.«tacticBy_cases_:_» \"by_cases\" [`hI \":\"] («term_=_» `I \"=\" (Term.app `«expr⊥» [])))\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.«· » \"·\")))\n         [(Tactic.subst \"subst\" [`hI]) [] (Mathlib.Tactic.tacticLeft \"left\") [] (Tactic.exact \"exact\" `bot_le)])\n        []\n        (Classical.«tacticBy_cases_:_» \"by_cases\" [`hJ \":\"] («term_=_» `J \"=\" (Term.app `«expr⊥» [])))\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.«· » \"·\")))\n         [(Tactic.subst \"subst\" [`hJ]) [] (Mathlib.Tactic.tacticRight \"right\") [] (Tactic.exact \"exact\" `bot_le)])\n        []\n        (Std.Tactic.obtain\n         \"obtain\"\n         [(Std.Tactic.RCases.rcasesPatMed\n           [(Std.Tactic.RCases.rcasesPat.tuple\n             \"⟨\"\n             [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `n)]) [])\n              \",\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n               [])]\n             \"⟩\")])]\n         []\n         [\":=\" [(Term.app `H [`I `hI])]])\n        []\n        (Std.Tactic.obtain\n         \"obtain\"\n         [(Std.Tactic.RCases.rcasesPatMed\n           [(Std.Tactic.RCases.rcasesPat.tuple\n             \"⟨\"\n             [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `m)]) [])\n              \",\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n               [])]\n             \"⟩\")])]\n         []\n         [\":=\" [(Term.app `H [`J `hJ])]])\n        []\n        (Tactic.cases'\n         \"cases'\"\n         [(Tactic.casesTarget [] (Term.app `le_total [`m `n]))]\n         []\n         [\"with\" [(Lean.binderIdent `h') (Lean.binderIdent `h')]])\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.«· » \"·\")))\n         [(Mathlib.Tactic.tacticLeft \"left\") [] (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))])\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.«· » \"·\")))\n         [(Mathlib.Tactic.tacticRight \"right\") [] (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Mathlib.Tactic.tacticRight \"right\") [] (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `ideal.pow_le_pow [`h'])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h'\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `ideal.pow_le_pow\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Mathlib.Tactic.tacticRight \"right\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Mathlib.Tactic.tacticLeft \"left\") [] (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `ideal.pow_le_pow [`h']))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `ideal.pow_le_pow [`h'])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h'\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `ideal.pow_le_pow\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Mathlib.Tactic.tacticLeft \"left\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.cases'\n       \"cases'\"\n       [(Tactic.casesTarget [] (Term.app `le_total [`m `n]))]\n       []\n       [\"with\" [(Lean.binderIdent `h') (Lean.binderIdent `h')]])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `le_total [`m `n])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `n\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `m\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `le_total\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.obtain\n       \"obtain\"\n       [(Std.Tactic.RCases.rcasesPatMed\n         [(Std.Tactic.RCases.rcasesPat.tuple\n           \"⟨\"\n           [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `m)]) [])\n            \",\"\n            (Std.Tactic.RCases.rcasesPatLo\n             (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n             [])]\n           \"⟩\")])]\n       []\n       [\":=\" [(Term.app `H [`J `hJ])]])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `H [`J `hJ])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hJ\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `J\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.obtain\n       \"obtain\"\n       [(Std.Tactic.RCases.rcasesPatMed\n         [(Std.Tactic.RCases.rcasesPat.tuple\n           \"⟨\"\n           [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `n)]) [])\n            \",\"\n            (Std.Tactic.RCases.rcasesPatLo\n             (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n             [])]\n           \"⟩\")])]\n       []\n       [\":=\" [(Term.app `H [`I `hI])]])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `H [`I `hI])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hI\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `I\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.subst \"subst\" [`hJ]) [] (Mathlib.Tactic.tacticRight \"right\") [] (Tactic.exact \"exact\" `bot_le)])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" `bot_le)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `bot_le\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Mathlib.Tactic.tacticRight \"right\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.subst \"subst\" [`hJ])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hJ\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Classical.«tacticBy_cases_:_» \"by_cases\" [`hJ \":\"] («term_=_» `J \"=\" (Term.app `«expr⊥» [])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      («term_=_» `J \"=\" (Term.app `«expr⊥» []))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `«expr⊥» [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `«expr⊥»\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1024, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))\n      `J\n[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.subst \"subst\" [`hI]) [] (Mathlib.Tactic.tacticLeft \"left\") [] (Tactic.exact \"exact\" `bot_le)])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" `bot_le)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `bot_le\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Mathlib.Tactic.tacticLeft \"left\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.subst \"subst\" [`hI])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hI\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Classical.«tacticBy_cases_:_» \"by_cases\" [`hI \":\"] («term_=_» `I \"=\" (Term.app `«expr⊥» [])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      («term_=_» `I \"=\" (Term.app `«expr⊥» []))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `«expr⊥» [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `«expr⊥»\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1024, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))\n      `I\n[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`I `J])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `J\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `I\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.constructor \"constructor\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`H])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `valuation_ring.iff_ideal_total)] \"]\") [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `valuation_ring.iff_ideal_total\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"7\") \"→\" (num \"2\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  discrete_valuation_ring.tfae\n  [ is_noetherian_ring R ] [ local_ring R ] [ IsDomain R ] ( h : ¬ IsField R )\n    :\n      TFAE\n        [\n          discrete_valuation_ring R\n            ,\n            valuation_ring R\n            ,\n            is_dedekind_domain R\n            ,\n            is_integrally_closed R ∧ ∃! P : ideal R , P ≠ «expr⊥» ∧ P . is_prime\n            ,\n            maximal_ideal R . is_principal\n            ,\n            finite_dimensional.finrank residue_field R cotangent_space R = 1\n            ,\n            ∀ ( I ) ( _ : I ≠ «expr⊥» ) , ∃ n : ℕ , I = maximal_ideal R ^ n\n          ]\n  :=\n    by\n      have ne_bot := ring.ne_bot_of_is_maximal_of_not_is_field maximal_ideal.is_maximal R h\n        classical\n          rw [ finrank_eq_one_iff' ]\n            tfae_have 1 → 2\n            · intro infer_instance\n            tfae_have 2 → 1\n            ·\n              intro\n                haveI := is_bezout.to_gcd_domain R\n                haveI : unique_factorization_monoid R := ufm_of_gcd_of_wf_dvd_monoid\n                apply discrete_valuation_ring.of_ufd_of_unique_irreducible\n                ·\n                  obtain ⟨ x , hx₁ , hx₂ ⟩ := ring.exists_not_is_unit_of_not_is_field h\n                    obtain ⟨ p , hp₁ , hp₂ ⟩ := wf_dvd_monoid.exists_irreducible_factor hx₂ hx₁\n                    exact ⟨ p , hp₁ ⟩\n                · exact valuation_ring.unique_irreducible\n            tfae_have 1 → 4\n            · intro H exact ⟨ infer_instance , discrete_valuation_ring.iff_pid_with_one_nonzero_prime R . mp H . 2 ⟩\n            tfae_have 4 → 3\n            ·\n              rintro ⟨ h₁ , h₂ ⟩\n                exact\n                  ⟨\n                    infer_instance\n                      ,\n                      fun\n                        I hI hI'\n                          =>\n                          ExistsUnique.unique h₂ ⟨ ne_bot , infer_instance ⟩ ⟨ hI , hI' ⟩ ▸ maximal_ideal.is_maximal R\n                      ,\n                      h₁\n                    ⟩\n            tfae_have 3 → 5\n            · intro h exact maximal_ideal_is_principal_of_is_dedekind_domain R\n            tfae_have 5 → 6\n            ·\n              rintro ⟨ x , hx ⟩\n                have : x ∈ maximal_ideal R := by rw [ hx ] exact submodule.subset_span Set.mem_singleton x\n                let x' : maximal_ideal R := ⟨ x , this ⟩\n                use submodule.quotient.mk x'\n                constructor\n                ·\n                  intro e\n                    rw [ submodule.quotient.mk_eq_zero ] at e\n                    apply ring.ne_bot_of_is_maximal_of_not_is_field maximal_ideal.is_maximal R h\n                    apply submodule.eq_bot_of_le_smul_of_le_jacobson_bot maximal_ideal R\n                    · exact ⟨ { x } , Finset.coe_singleton x . symm ▸ hx.symm ⟩\n                    ·\n                      conv_lhs => rw [ hx ]\n                        rw [ submodule.mem_smul_top_iff ] at e\n                        rwa [ submodule.span_le , Set.singleton_subset_iff ]\n                    · rw [ local_ring.jacobson_eq_maximal_ideal ( «expr⊥» : ideal R ) bot_ne_top ] exact le_refl _\n                ·\n                  refine' fun w => Quotient.inductionOn' w fun y => _\n                    obtain ⟨ y , hy ⟩ := y\n                    rw [ hx , submodule.mem_span_singleton ] at hy\n                    obtain ⟨ a , rfl ⟩ := hy\n                    exact ⟨ ideal.quotient.mk _ a , rfl ⟩\n            tfae_have 6 → 5\n            ·\n              rintro ⟨ x , hx , hx' ⟩\n                induction x using Quotient.inductionOn'\n                use x\n                apply le_antisymm\n                swap\n                · rw [ submodule.span_le , Set.singleton_subset_iff ] exact x.prop\n                have\n                  h₁\n                    :\n                      «expr ⊔ » ( ideal.span { x } : ideal R ) maximal_ideal R\n                        ≤\n                        «expr ⊔ » ideal.span { x } «expr • » maximal_ideal R maximal_ideal R\n                    :=\n                    by\n                      refine' sup_le le_sup_left _\n                        rintro m hm\n                        obtain ⟨ c , hc ⟩ := hx' submodule.quotient.mk ⟨ m , hm ⟩\n                        induction c using Quotient.inductionOn'\n                        rw [ ← sub_sub_cancel c * x m ]\n                        apply sub_mem _ _\n                        · infer_instance\n                        · refine' ideal.mem_sup_left ideal.mem_span_singleton'.mpr ⟨ c , rfl ⟩\n                        ·\n                          have := submodule.quotient.eq _ . mp hc\n                            rw [ submodule.mem_smul_top_iff ] at this\n                            exact ideal.mem_sup_right this\n                have\n                  h₂\n                    : maximal_ideal R ≤ ( «expr⊥» : ideal R ) . jacobson\n                    :=\n                    by rw [ local_ring.jacobson_eq_maximal_ideal ] exacts [ le_refl _ , bot_ne_top ]\n                have := submodule.smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson is_noetherian.noetherian _ h₂ h₁\n                rw [ submodule.bot_smul , sup_bot_eq ] at this\n                rw [ ← sup_eq_left , eq_comm ]\n                exact le_sup_left.antisymm h₁.trans <| le_of_eq this\n            tfae_have 5 → 7\n            · exact exists_maximal_ideal_pow_eq_of_principal R h\n            tfae_have 7 → 2\n            ·\n              rw [ valuation_ring.iff_ideal_total ]\n                intro H\n                constructor\n                intro I J\n                by_cases hI : I = «expr⊥»\n                · subst hI left exact bot_le\n                by_cases hJ : J = «expr⊥»\n                · subst hJ right exact bot_le\n                obtain ⟨ n , rfl ⟩ := H I hI\n                obtain ⟨ m , rfl ⟩ := H J hJ\n                cases' le_total m n with h' h'\n                · left exact ideal.pow_le_pow h'\n                · right exact ideal.pow_le_pow h'\n            tfae_finish\n#align discrete_valuation_ring.tfae discrete_valuation_ring.tfae\n\n",
 "maximal_ideal_is_principal_of_is_dedekind_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem maximal_ideal_is_principal_of_is_dedekind_domain [local_ring R] [IsDomain R] [is_dedekind_domain R] :\n    (maximal_ideal R).is_principal := by\n  classical\n    by_cases ne_bot : maximal_ideal R = «expr⊥»\n    · rw [ne_bot]\n      infer_instance\n    obtain ⟨a, ha₁, ha₂⟩ : ∃ a ∈ maximal_ideal R, a ≠ (0 : R) :=\n      by\n      by_contra h'\n      push_neg  at h'\n      apply ne_bot\n      rwa [eq_bot_iff]\n    have hle : ideal.span {a} ≤ maximal_ideal R := by rwa [ideal.span_le, Set.singleton_subset_iff]\n    have : (ideal.span {a}).radical = maximal_ideal R :=\n      by\n      rw [ideal.radical_eq_Inf]\n      apply le_antisymm\n      · exact infₛ_le ⟨hle, infer_instance⟩\n      · refine' le_infₛ fun I hI => (eq_maximal_ideal <| is_dedekind_domain.dimension_le_one _ (fun e => ha₂ _) hI.2).ge\n        rw [← ideal.span_singleton_eq_bot, eq_bot_iff, ← e]\n        exact hI.1\n    have : ∃ n, maximal_ideal R ^ n ≤ ideal.span {a} := by\n      rw [← this]\n      apply ideal.exists_radical_pow_le_of_fg\n      exact is_noetherian.noetherian _\n    cases hn : nat.find this\n    · have := nat.find_spec this\n      rw [hn, pow_zero, ideal.one_eq_top] at this\n      exact (ideal.is_maximal.ne_top infer_instance (eq_top_iff.mpr <| this.trans hle)).elim\n    obtain ⟨b, hb₁, hb₂⟩ : ∃ b ∈ maximal_ideal R ^ n, ¬b ∈ ideal.span {a} :=\n      by\n      by_contra h'\n      push_neg  at h'\n      rw [Nat.find_eq_iff] at hn\n      exact hn.2 n n.lt_succ_self fun x hx => not_not.mp (h' x hx)\n    have hb₃ : ∀ m ∈ maximal_ideal R, ∃ k : R, k * a = b * m :=\n      by\n      intro m hm\n      rw [← ideal.mem_span_singleton']\n      apply nat.find_spec this\n      rw [hn, pow_succ']\n      exact ideal.mul_mem_mul hb₁ hm\n    have hb₄ : b ≠ 0 := by\n      rintro rfl\n      apply hb₂\n      exact zero_mem _\n    let K := fraction_ring R\n    let x : K := algebra_map R K b / algebra_map R K a\n    let M := submodule.map (algebra.of_id R K).to_linear_map (maximal_ideal R)\n    have ha₃ : algebra_map R K a ≠ 0 := is_fraction_ring.to_map_eq_zero_iff.not.mpr ha₂\n    by_cases hx : ∀ y ∈ M, x * y ∈ M\n    · have := is_integral_of_smul_mem_submodule M _ _ x hx\n      · obtain ⟨y, e⟩ := is_integrally_closed.algebra_map_eq_of_integral this\n        refine' (hb₂ (ideal.mem_span_singleton'.mpr ⟨y, _⟩)).elim\n        apply is_fraction_ring.injective R K\n        rw [map_mul, e, div_mul_cancel _ ha₃]\n      · rw [submodule.ne_bot_iff]\n        refine' ⟨_, ⟨a, ha₁, rfl⟩, _⟩\n        exact is_fraction_ring.to_map_eq_zero_iff.not.mpr ha₂\n      · apply submodule.fg.map\n        exact is_noetherian.noetherian _\n    · have : (M.map (distrib_mul_action.to_linear_map R K x)).comap (algebra.of_id R K).to_linear_map = «expr⊤» :=\n        by\n        by_contra h\n        apply hx\n        rintro m' ⟨m, hm, rfl : algebra_map R K m = m'⟩\n        obtain ⟨k, hk⟩ := hb₃ m hm\n        have hk' : x * algebra_map R K m = algebra_map R K k := by\n          rw [← mul_div_right_comm, ← map_mul, ← hk, map_mul, mul_div_cancel _ ha₃]\n        exact ⟨k, le_maximal_ideal h ⟨_, ⟨_, hm, rfl⟩, hk'⟩, hk'.symm⟩\n      obtain ⟨y, hy₁, hy₂⟩ : ∃ y ∈ maximal_ideal R, b * y = a :=\n        by\n        rw [ideal.eq_top_iff_one, submodule.mem_comap] at this\n        obtain ⟨_, ⟨y, hy, rfl⟩, hy' : x * algebra_map R K y = algebra_map R K 1⟩ := this\n        rw [map_one, ← mul_div_right_comm, div_eq_one_iff_eq ha₃, ← map_mul] at hy'\n        exact ⟨y, hy, is_fraction_ring.injective R K hy'⟩\n      refine' ⟨⟨y, _⟩⟩\n      apply le_antisymm\n      · intro m hm\n        obtain ⟨k, hk⟩ := hb₃ m hm\n        rw [← hy₂, mul_comm, mul_assoc] at hk\n        rw [← mul_left_cancel₀ hb₄ hk, mul_comm]\n        exact ideal.mem_span_singleton'.mpr ⟨_, rfl⟩\n      · rwa [submodule.span_le, Set.singleton_subset_iff]\n#align maximal_ideal_is_principal_of_is_dedekind_domain maximal_ideal_is_principal_of_is_dedekind_domain\n\n",
 "exists_maximal_ideal_pow_eq_of_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem exists_maximal_ideal_pow_eq_of_principal [is_noetherian_ring R] [local_ring R] [IsDomain R] (h : ¬IsField R)\n    (h' : (maximal_ideal R).is_principal) (I : ideal R) (hI : I ≠ «expr⊥») : ∃ n : ℕ, I = maximal_ideal R ^ n := by\n  classical\n    obtain ⟨x, hx : _ = ideal.span _⟩ := h'\n    by_cases hI' : I = «expr⊤»\n    · use 0\n      rw [pow_zero, hI', ideal.one_eq_top]\n    have H : ∀ r : R, ¬is_unit r ↔ x ∣ r := fun r => (set_like.ext_iff.mp hx r).trans ideal.mem_span_singleton\n    have : x ≠ 0 := by\n      rintro rfl\n      apply ring.ne_bot_of_is_maximal_of_not_is_field (maximal_ideal.is_maximal R) h\n      simp [hx]\n    have hx' := discrete_valuation_ring.irreducible_of_span_eq_maximal_ideal x this hx\n    have H' : ∀ r : R, r ≠ 0 → r ∈ nonunits R → ∃ n : ℕ, Associated (x ^ n) r :=\n      by\n      intro r hr₁ hr₂\n      obtain ⟨f, hf₁, rfl, hf₂⟩ := (wf_dvd_monoid.not_unit_iff_exists_factors_eq r hr₁).mp hr₂\n      have : ∀ b ∈ f, Associated x b := by\n        intro b hb\n        exact Irreducible.associated_of_dvd hx' (hf₁ b hb) ((H b).mp (hf₁ b hb).1)\n      clear hr₁ hr₂ hf₁\n      induction' f using Multiset.induction with fa fs fh\n      · exact (hf₂ rfl).elim\n      rcases eq_or_ne fs ∅ with (rfl | hf')\n      · use 1\n        rw [pow_one, Multiset.prod_cons, Multiset.empty_eq_zero, Multiset.prod_zero, mul_one]\n        exact this _ (Multiset.mem_cons_self _ _)\n      · obtain ⟨n, hn⟩ := fh hf' fun b hb => this _ (Multiset.mem_cons_of_mem hb)\n        use n + 1\n        rw [pow_add, Multiset.prod_cons, mul_comm, pow_one]\n        exact Associated.mul_mul (this _ (Multiset.mem_cons_self _ _)) hn\n    have : ∃ n : ℕ, x ^ n ∈ I :=\n      by\n      obtain ⟨r, hr₁, hr₂⟩ : ∃ r : R, r ∈ I ∧ r ≠ 0 := by\n        by_contra h\n        push_neg  at h\n        apply hI\n        rw [eq_bot_iff]\n        exact h\n      obtain ⟨n, u, rfl⟩ := H' r hr₂ (le_maximal_ideal hI' hr₁)\n      use n\n      rwa [← I.unit_mul_mem_iff_mem u.is_unit, mul_comm]\n    use nat.find this\n    apply le_antisymm\n    · change ∀ s ∈ I, s ∈ _\n      by_contra hI''\n      push_neg  at hI''\n      obtain ⟨s, hs₁, hs₂⟩ := hI''\n      apply hs₂\n      by_cases hs₃ : s = 0\n      · rw [hs₃]\n        exact zero_mem _\n      obtain ⟨n, u, rfl⟩ := H' s hs₃ (le_maximal_ideal hI' hs₁)\n      rw [mul_comm, ideal.unit_mul_mem_iff_mem _ u.is_unit] at hs₁⊢\n      apply ideal.pow_le_pow (nat.find_min' this hs₁)\n      apply ideal.pow_mem_pow\n      exact (H _).mpr (dvd_refl _)\n    · rw [hx, ideal.span_singleton_pow, ideal.span_le, Set.singleton_subset_iff]\n      exact nat.find_spec this\n#align exists_maximal_ideal_pow_eq_of_principal exists_maximal_ideal_pow_eq_of_principal\n\n"}