{"one_of_is_unit":
 "theorem one_of_is_unit {x : O} (hx : is_unit x) : v (algebra_map O R x) = 1 :=\n  let ⟨u, hu⟩ := hx\n  le_antisymm (hv.2 _) <|\n    by\n    rw [← v.map_one, ← (algebra_map O R).map_one, ← u.mul_inv, ← mul_one (v (algebra_map O R x)), hu,\n      (algebra_map O R).map_mul, v.map_mul]\n    exact mul_le_mul_left' (hv.2 (u⁻¹ : Units O)) _\n#align one_of_is_unit one_of_is_unit\n\n",
 "le_of_dvd":
 "theorem le_of_dvd {x y : O} (h : x ∣ y) : v (algebra_map O R y) ≤ v (algebra_map O R x) :=\n  by\n  let ⟨z, hz⟩ := h\n  rw [← mul_one (v (algebra_map O R x)), hz, RingHom.map_mul, v.map_mul]\n  exact mul_le_mul_left' (hv.2 z) _\n#align le_of_dvd le_of_dvd\n\n",
 "le_iff_dvd":
 "theorem le_iff_dvd {x y : O} : v (algebra_map O F x) ≤ v (algebra_map O F y) ↔ y ∣ x :=\n  ⟨hv.dvd_of_le, hv.le_of_dvd⟩\n#align le_iff_dvd le_iff_dvd\n\n",
 "is_unit_of_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem is_unit_of_one {x : O} (hx : is_unit (algebra_map O R x)) (hvx : v (algebra_map O R x) = 1) : is_unit x :=\n  let ⟨u, hu⟩ := hx\n  have h1 : v u ≤ 1 := hu.symm ▸ hv.2 x\n  have h2 : v (u⁻¹ : «expr ˣ» R) ≤ 1 := by rw [← one_mul (v _), ← hvx, ← v.map_mul, ← hu, u.mul_inv, hu, hvx, v.map_one]\n  let ⟨r1, hr1⟩ := hv.3 h1\n  let ⟨r2, hr2⟩ := hv.3 h2\n  ⟨⟨r1, r2, hv.1 <| by rw [RingHom.map_mul, RingHom.map_one, hr1, hr2, Units.mul_inv],\n      hv.1 <| by rw [RingHom.map_mul, RingHom.map_one, hr1, hr2, Units.inv_mul]⟩,\n    hv.1 <| hr1.trans hu⟩\n#align is_unit_of_one is_unit_of_one\n\n",
 "integers":
 "/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n-- typeclass shortcut\ntheorem integer.integers : v.integers v.integer :=\n  { hom_inj := subtype.coe_injective\n    map_le_one := fun r => r.2\n    exists_of_le_one := fun r hr => ⟨⟨r, hr⟩, rfl⟩ }\n#align integer.integers integer.integers\n\n",
 "dvd_of_le":
 "theorem dvd_of_le {x y : O} (h : v (algebra_map O F x) ≤ v (algebra_map O F y)) : y ∣ x :=\n  by_cases\n    (fun hy : algebra_map O F y = 0 =>\n      have hx : x = 0 := hv.1 <| (algebra_map O F).map_zero.symm ▸ (v.zero_iff.1 <| le_zero_iff.1 (v.map_zero ▸ hy ▸ h))\n      hx.symm ▸ dvd_zero y)\n    fun hy : algebra_map O F y ≠ 0 =>\n    have : v ((algebra_map O F y)⁻¹ * algebra_map O F x) ≤ 1 :=\n      by\n      rw [← v.map_one, ← inv_mul_cancel hy, v.map_mul, v.map_mul]\n      exact mul_le_mul_left' h _\n    let ⟨z, hz⟩ := hv.3 this\n    ⟨z, hv.1 <| ((algebra_map O F).map_mul y z).symm ▸ hz.symm ▸ (mul_inv_cancel_left₀ hy _).symm⟩\n#align dvd_of_le dvd_of_le\n\n",
 "dvd_iff_le":
 "theorem dvd_iff_le {x y : O} : x ∣ y ↔ v (algebra_map O F y) ≤ v (algebra_map O F x) :=\n  ⟨hv.le_of_dvd, hv.dvd_of_le⟩\n#align dvd_iff_le dvd_iff_le\n\n"}