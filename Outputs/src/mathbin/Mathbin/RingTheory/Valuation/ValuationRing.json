{"valuation_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\ntheorem _root_.function.surjective.valuation_ring {R S : Type _} [CommRing R] [IsDomain R] [valuation_ring R]\n    [CommRing S] [IsDomain S] (f : ¬´expr ‚Üí+* ¬ª R S) (hf : function.surjective f) : valuation_ring S :=\n  ‚ü®fun a b => by\n    obtain ‚ü®‚ü®a, rfl‚ü©, ‚ü®b, rfl‚ü©‚ü© := hf a, hf b\n    obtain ‚ü®c, rfl | rfl‚ü© := valuation_ring.cond a b\n    exacts[‚ü®f c, or.inl <| (map_mul _ _ _).symm‚ü©, ‚ü®f c, or.inr <| (map_mul _ _ _).symm‚ü©]‚ü©\n#align function.surjective.valuation_ring function.surjective.valuation_ring\n\n",
 "unique_irreducible":
 "theorem unique_irreducible [valuation_ring R] ‚¶Ép q : R‚¶Ñ (hp : Irreducible p) (hq : Irreducible q) : Associated p q :=\n  by\n  have := dvd_total p q\n  rw [Irreducible.dvd_comm hp hq, or_self_iff] at this\n  exact associated_of_dvd_dvd (Irreducible.dvd_symm hq hp this) this\n#align unique_irreducible unique_irreducible\n\n",
 "tfae":
 "protected theorem tfae (R : Type u) [CommRing R] [IsDomain R] :\n    TFAE\n      [valuation_ring R, ‚àÄ x : FractionRing R, IsLocalization.IsInteger R x ‚à® IsLocalization.IsInteger R x‚Åª¬π,\n        is_total R (¬∑ ‚à£ ¬∑), is_total (Ideal R) (¬∑ ‚â§ ¬∑), local_ring R ‚àß is_bezout R] :=\n  by\n  tfae_have 1 ‚Üî 2; ¬∑ exact iff_is_integer_or_is_integer R _\n  tfae_have 1 ‚Üî 3; ¬∑ exact iff_dvd_total\n  tfae_have 1 ‚Üî 4; ¬∑ exact iff_ideal_total\n  tfae_have 1 ‚Üî 5; ¬∑ exact iff_local_bezout_domain\n  tfae_finish\n#align tfae tfae\n\n",
 "range_algebra_map_eq":
 "theorem range_algebra_map_eq : (valuation A K).integer = (algebraMap A K).range :=\n  by\n  ext\n  exact mem_integer_iff _ _ _\n#align range_algebra_map_eq range_algebra_map_eq\n\n",
 "of_integers":
 "/-- If `ùí™` satisfies `v.integers ùí™` where `v` is a valuation on a field, then `ùí™`\nis a valuation ring. -/\ntheorem of_integers : valuation_ring ùí™ := by\n  constructor\n  intro a b\n  cases le_total (v (algebraMap ùí™ K a)) (v (algebraMap ùí™ K b))\n  ¬∑ obtain ‚ü®c, hc‚ü© := Valuation.Integers.dvd_of_le hh h\n    use c\n    exact or.inr hc.symm\n  ¬∑ obtain ‚ü®c, hc‚ü© := Valuation.Integers.dvd_of_le hh h\n    use c\n    exact or.inl hc.symm\n#align of_integers of_integers\n\n",
 "mem_integer_iff":
 "theorem mem_integer_iff (x : K) : x ‚àà (valuation A K).integer ‚Üî ‚àÉ a : A, algebraMap A K a = x :=\n  by\n  constructor\n  ¬∑ rintro ‚ü®c, rfl‚ü©\n    use c\n    rw [Algebra.smul_def, mul_one]\n  ¬∑ rintro ‚ü®c, rfl‚ü©\n    use c\n    rw [Algebra.smul_def, mul_one]\n#align mem_integer_iff mem_integer_iff\n\n",
 "le_total":
 "#print le_total /-\n/-\nCopyright (c) 2022 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\nprotected theorem le_total (a b : value_group A K) : a ‚â§ b ‚à® b ‚â§ a :=\n  by\n  rcases a with ‚ü®a‚ü©; rcases b with ‚ü®b‚ü©\n  obtain ‚ü®xa, ya, hya, rfl‚ü© : ‚àÉ a b : A, _ := IsFractionRing.div_surjective a\n  obtain ‚ü®xb, yb, hyb, rfl‚ü© : ‚àÉ a b : A, _ := IsFractionRing.div_surjective b\n  have : (algebraMap A K) ya ‚â† 0 := IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors hya\n  have : (algebraMap A K) yb ‚â† 0 := IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors hyb\n  obtain ‚ü®c, h | h‚ü© := valuation_ring.cond (xa * yb) (xb * ya)\n  ¬∑ right\n    use c\n    rw [Algebra.smul_def]\n    field_simp\n    simp only [‚Üê RingHom.map_mul, ‚Üê h]\n    congr 1\n    ring\n  ¬∑ left\n    use c\n    rw [Algebra.smul_def]\n    field_simp\n    simp only [‚Üê RingHom.map_mul, ‚Üê h]\n    congr 1\n    ring\n#align le_total le_total\n-/\n\n",
 "is_integer_or_is_integer":
 "theorem is_integer_or_is_integer [h : valuation_ring R] (x : K) :\n    IsLocalization.IsInteger R x ‚à® IsLocalization.IsInteger R x‚Åª¬π :=\n  (iff_is_integer_or_is_integer R K).mp h x\n#align is_integer_or_is_integer is_integer_or_is_integer\n\n",
 "iff_local_bezout_domain":
 "-- This implies that valuation rings are integrally closed through typeclass search.\ntheorem iff_local_bezout_domain : valuation_ring R ‚Üî local_ring R ‚àß is_bezout R := by\n  classical\n    refine' ‚ü®fun H => ‚ü®inferInstance, inferInstance‚ü©, _‚ü©\n    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©\n    skip\n    refine' iff_dvd_total.mpr ‚ü®fun a b => _‚ü©\n    obtain ‚ü®g, e : _ = Ideal.span _‚ü© := is_bezout.span_pair_is_principal a b\n    obtain ‚ü®a, rfl‚ü© :=\n      ideal.mem_span_singleton'.mp\n        (show a ‚àà Ideal.span {g} by\n          rw [‚Üê e]\n          exact Ideal.subset_span (by simp))\n    obtain ‚ü®b, rfl‚ü© :=\n      ideal.mem_span_singleton'.mp\n        (show b ‚àà Ideal.span {g} by\n          rw [‚Üê e]\n          exact Ideal.subset_span (by simp))\n    obtain ‚ü®x, y, e'‚ü© :=\n      ideal.mem_span_pair.mp\n        (show g ‚àà Ideal.span {a * g, b * g} by\n          rw [e]\n          exact Ideal.subset_span (by simp))\n    cases' eq_or_ne g 0 with h h\n    ¬∑ simp [h]\n    have : x * a + y * b = 1 := by\n      apply mul_left_injective‚ÇÄ h\n      convert e' <;> ring_nf\n    cases' local_ring.is_unit_or_is_unit_of_add_one this with h' h'\n    left\n    swap\n    right\n    all_goals exact mul_dvd_mul_right (is_unit_iff_forall_dvd.mp (isUnit_of_mul_isUnit_right h') _) _\n#align iff_local_bezout_domain iff_local_bezout_domain\n\n",
 "iff_is_integer_or_is_integer":
 "theorem iff_is_integer_or_is_integer :\n    valuation_ring R ‚Üî ‚àÄ x : K, IsLocalization.IsInteger R x ‚à® IsLocalization.IsInteger R x‚Åª¬π :=\n  by\n  constructor\n  ¬∑ intro H x\n    obtain ‚ü®x : R, y, hy, rfl‚ü© := IsFractionRing.div_surjective x\n    any_goals infer_instance\n    have := (map_ne_zero_iff _ (IsFractionRing.injective R K)).mpr (nonZeroDivisors.ne_zero hy)\n    obtain ‚ü®s, rfl | rfl‚ü© := valuation_ring.cond x y\n    ¬∑ exact or.inr ‚ü®s, eq_inv_of_mul_eq_one_left <| by rwa [mul_div, div_eq_one_iff_eq, map_mul, mul_comm]‚ü©\n    ¬∑ exact or.inl ‚ü®s, by rwa [eq_div_iff, map_mul, mul_comm]‚ü©\n  ¬∑ intro H\n    constructor\n    intro a b\n    by_cases ha : a = 0\n    ¬∑ subst ha\n      exact ‚ü®0, or.inr <| MulZeroClass.mul_zero b‚ü©\n    by_cases hb : b = 0\n    ¬∑ subst hb\n      exact ‚ü®0, or.inl <| MulZeroClass.mul_zero a‚ü©\n    replace ha := (map_ne_zero_iff _ (IsFractionRing.injective R K)).mpr ha\n    replace hb := (map_ne_zero_iff _ (IsFractionRing.injective R K)).mpr hb\n    obtain ‚ü®c, e‚ü© | ‚ü®c, e‚ü© := H (algebraMap R K a / algebraMap R K b)\n    ¬∑ rw [eq_div_iff hb, ‚Üê map_mul, (IsFractionRing.injective R K).eq_iff, mul_comm] at e\n      exact ‚ü®c, or.inr e‚ü©\n    ¬∑ rw [inv_div, eq_div_iff ha, ‚Üê map_mul, (IsFractionRing.injective R K).eq_iff, mul_comm c] at e\n      exact ‚ü®c, or.inl e‚ü©\n#align iff_is_integer_or_is_integer iff_is_integer_or_is_integer\n\n",
 "iff_ideal_total":
 "theorem iff_ideal_total : valuation_ring R ‚Üî is_total (Ideal R) (¬∑ ‚â§ ¬∑) := by\n  classical\n    refine' ‚ü®fun _ => ‚ü®le_total‚ü©, fun H => iff_dvd_total.mpr ‚ü®fun a b => _‚ü©‚ü©\n    have := @is_total.total _ _ H (Ideal.span {a}) (Ideal.span {b})\n    simp_rw [Ideal.span_singleton_le_span_singleton] at this\n    exact this.symm\n#align iff_ideal_total iff_ideal_total\n\n",
 "iff_dvd_total":
 "theorem iff_dvd_total : valuation_ring R ‚Üî is_total R (¬∑ ‚à£ ¬∑) := by\n  classical\n    refine' ‚ü®fun H => ‚ü®fun a b => _‚ü©, fun H => ‚ü®fun a b => _‚ü©‚ü© <;> skip\n    ¬∑ obtain ‚ü®c, rfl | rfl‚ü© := @valuation_ring.cond _ _ H a b <;> simp\n    ¬∑ obtain ‚ü®c, rfl‚ü© | ‚ü®c, rfl‚ü© := @is_total.total _ _ H a b <;> use c <;> simp\n#align iff_dvd_total iff_dvd_total\n\n",
 "dvd_total":
 "theorem dvd_total [h : valuation_ring R] (x y : R) : x ‚à£ y ‚à® y ‚à£ x :=\n  @is_total.total _ (iff_dvd_total.mp h) x y\n#align dvd_total dvd_total\n\n",
 "coe_equiv_integer_apply":
 "@[simp]\ntheorem coe_equiv_integer_apply (a : A) : (equiv_integer A K a : K) = algebraMap A K a :=\n  rfl\n#align coe_equiv_integer_apply coe_equiv_integer_apply\n\n"}