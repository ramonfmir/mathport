{"valuation_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\ntheorem _root_.function.surjective.valuation_ring {R S : Type _} [CommRing R] [IsDomain R] [valuation_ring R]\n    [CommRing S] [IsDomain S] (f : ¬´expr ‚Üí+* ¬ª R S) (hf : function.surjective f) : valuation_ring S :=\n  ‚ü®fun a b => by\n    obtain ‚ü®‚ü®a, rfl‚ü©, ‚ü®b, rfl‚ü©‚ü© := hf a, hf b\n    obtain ‚ü®c, rfl | rfl‚ü© := valuation_ring.cond a b\n    exacts[‚ü®f c, or.inl <| (map_mul _ _ _).symm‚ü©, ‚ü®f c, or.inr <| (map_mul _ _ _).symm‚ü©]‚ü©\n#align function.surjective.valuation_ring function.surjective.valuation_ring\n\n",
 "unique_irreducible":
 "theorem unique_irreducible [valuation_ring R] ‚¶Ép q : R‚¶Ñ (hp : Irreducible p) (hq : Irreducible q) : Associated p q :=\n  by\n  have := dvd_total p q\n  rw [Irreducible.dvd_comm hp hq, or_self_iff] at this\n  exact associated_of_dvd_dvd (Irreducible.dvd_symm hq hp this) this\n#align unique_irreducible unique_irreducible\n\n",
 "tfae":
 "/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [(Command.protected \"protected\")] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae [])\n      (Command.declSig\n       [(Term.explicitBinder \"(\" [`R] [\":\" (Term.type \"Type\" [`u])] [] \")\")\n        (Term.instBinder \"[\" [] (Term.app `CommRing [`R]) \"]\")\n        (Term.instBinder \"[\" [] (Term.app `IsDomain [`R]) \"]\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(¬´term[_]¬ª\n           \"[\"\n           [(Term.app `valuation_ring [`R])\n            \",\"\n            (Term.forall\n             \"‚àÄ\"\n             [`x]\n             [(Term.typeSpec \":\" (Term.app `fraction_ring [`R]))]\n             \",\"\n             (¬´term_‚à®_¬ª\n              (Term.app `is_localization.is_integer [`R `x])\n              \"‚à®\"\n              (Term.app `is_localization.is_integer [`R (¬´term_‚Åª¬π¬ª `x \"‚Åª¬π\")])))\n            \",\"\n            (Term.app `is_total [`R (Term.paren \"(\" (¬´term_‚à£_¬ª (Term.cdot \"¬∑\") \"‚à£\" (Term.cdot \"¬∑\")) \")\")])\n            \",\"\n            (Term.app\n             `is_total\n             [(Term.app `ideal [`R]) (Term.paren \"(\" (¬´term_‚â§_¬ª (Term.cdot \"¬∑\") \"‚â§\" (Term.cdot \"¬∑\")) \")\")])\n            \",\"\n            (¬´term_‚àß_¬ª (Term.app `local_ring [`R]) \"‚àß\" (Term.app `is_bezout [`R]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üî\" (num \"2\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\")))\n            [(Tactic.exact \"exact\" (Term.app `iff_is_integer_or_is_integer [`R (Term.hole \"_\")]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üî\" (num \"3\"))\n           \";\"\n           (tactic__ (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\"))) [(Tactic.exact \"exact\" `iff_dvd_total)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üî\" (num \"4\"))\n           \";\"\n           (tactic__ (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\"))) [(Tactic.exact \"exact\" `iff_ideal_total)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üî\" (num \"5\"))\n           \";\"\n           (tactic__ (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\"))) [(Tactic.exact \"exact\" `iff_local_bezout_domain)])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üî\" (num \"2\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\")))\n           [(Tactic.exact \"exact\" (Term.app `iff_is_integer_or_is_integer [`R (Term.hole \"_\")]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üî\" (num \"3\"))\n          \";\"\n          (tactic__ (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\"))) [(Tactic.exact \"exact\" `iff_dvd_total)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üî\" (num \"4\"))\n          \";\"\n          (tactic__ (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\"))) [(Tactic.exact \"exact\" `iff_ideal_total)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üî\" (num \"5\"))\n          \";\"\n          (tactic__ (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\"))) [(Tactic.exact \"exact\" `iff_local_bezout_domain)])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__ (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\"))) [(Tactic.exact \"exact\" `iff_local_bezout_domain)])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" `iff_local_bezout_domain)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `iff_local_bezout_domain\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üî\" (num \"5\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '¬´‚Üî¬ª', expected 'token.¬´ ‚Üí ¬ª'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '¬´‚Üî¬ª', expected 'token.¬´ ‚Üî ¬ª'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '¬´‚Üî¬ª', expected 'token.¬´ ‚Üê ¬ª'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\nprotected\n  theorem\n    tfae\n    ( R : Type u ) [ CommRing R ] [ IsDomain R ]\n      :\n        TFAE\n          [\n            valuation_ring R\n              ,\n              ‚àÄ x : fraction_ring R , is_localization.is_integer R x ‚à® is_localization.is_integer R x ‚Åª¬π\n              ,\n              is_total R ( ¬∑ ‚à£ ¬∑ )\n              ,\n              is_total ideal R ( ¬∑ ‚â§ ¬∑ )\n              ,\n              local_ring R ‚àß is_bezout R\n            ]\n    :=\n      by\n        tfae_have 1 ‚Üî 2\n          ;\n          ¬∑ exact iff_is_integer_or_is_integer R _\n          tfae_have 1 ‚Üî 3\n          ;\n          ¬∑ exact iff_dvd_total\n          tfae_have 1 ‚Üî 4\n          ;\n          ¬∑ exact iff_ideal_total\n          tfae_have 1 ‚Üî 5\n          ;\n          ¬∑ exact iff_local_bezout_domain\n          tfae_finish\n#align tfae tfae\n\n",
 "range_algebra_map_eq":
 "theorem range_algebra_map_eq : (valuation A K).integer = (algebra_map A K).range :=\n  by\n  ext\n  exact mem_integer_iff _ _ _\n#align range_algebra_map_eq range_algebra_map_eq\n\n",
 "of_integers":
 "/-- If `ùí™` satisfies `v.integers ùí™` where `v` is a valuation on a field, then `ùí™`\nis a valuation ring. -/\ntheorem of_integers : valuation_ring ùí™ := by\n  constructor\n  intro a b\n  cases le_total (v (algebra_map ùí™ K a)) (v (algebra_map ùí™ K b))\n  ¬∑ obtain ‚ü®c, hc‚ü© := valuation.integers.dvd_of_le hh h\n    use c\n    exact or.inr hc.symm\n  ¬∑ obtain ‚ü®c, hc‚ü© := valuation.integers.dvd_of_le hh h\n    use c\n    exact or.inl hc.symm\n#align of_integers of_integers\n\n",
 "mem_integer_iff":
 "theorem mem_integer_iff (x : K) : x ‚àà (valuation A K).integer ‚Üî ‚àÉ a : A, algebra_map A K a = x :=\n  by\n  constructor\n  ¬∑ rintro ‚ü®c, rfl‚ü©\n    use c\n    rw [algebra.smul_def, mul_one]\n  ¬∑ rintro ‚ü®c, rfl‚ü©\n    use c\n    rw [algebra.smul_def, mul_one]\n#align mem_integer_iff mem_integer_iff\n\n",
 "le_total":
 "#print le_total /-\n/-\nCopyright (c) 2022 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\nprotected theorem le_total (a b : value_group A K) : a ‚â§ b ‚à® b ‚â§ a :=\n  by\n  rcases a with ‚ü®a‚ü©; rcases b with ‚ü®b‚ü©\n  obtain ‚ü®xa, ya, hya, rfl‚ü© : ‚àÉ a b : A, _ := is_fraction_ring.div_surjective a\n  obtain ‚ü®xb, yb, hyb, rfl‚ü© : ‚àÉ a b : A, _ := is_fraction_ring.div_surjective b\n  have : (algebra_map A K) ya ‚â† 0 := is_fraction_ring.to_map_ne_zero_of_mem_non_zero_divisors hya\n  have : (algebra_map A K) yb ‚â† 0 := is_fraction_ring.to_map_ne_zero_of_mem_non_zero_divisors hyb\n  obtain ‚ü®c, h | h‚ü© := valuation_ring.cond (xa * yb) (xb * ya)\n  ¬∑ right\n    use c\n    rw [algebra.smul_def]\n    field_simp\n    simp only [‚Üê RingHom.map_mul, ‚Üê h]\n    congr 1\n    ring\n  ¬∑ left\n    use c\n    rw [algebra.smul_def]\n    field_simp\n    simp only [‚Üê RingHom.map_mul, ‚Üê h]\n    congr 1\n    ring\n#align le_total le_total\n-/\n\n",
 "is_integer_or_is_integer":
 "theorem is_integer_or_is_integer [h : valuation_ring R] (x : K) :\n    is_localization.is_integer R x ‚à® is_localization.is_integer R x‚Åª¬π :=\n  (iff_is_integer_or_is_integer R K).mp h x\n#align is_integer_or_is_integer is_integer_or_is_integer\n\n",
 "iff_local_bezout_domain":
 "-- This implies that valuation rings are integrally closed through typeclass search.\ntheorem iff_local_bezout_domain : valuation_ring R ‚Üî local_ring R ‚àß is_bezout R := by\n  classical\n    refine' ‚ü®fun H => ‚ü®infer_instance, infer_instance‚ü©, _‚ü©\n    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©\n    skip\n    refine' iff_dvd_total.mpr ‚ü®fun a b => _‚ü©\n    obtain ‚ü®g, e : _ = ideal.span _‚ü© := is_bezout.span_pair_is_principal a b\n    obtain ‚ü®a, rfl‚ü© :=\n      ideal.mem_span_singleton'.mp\n        (show a ‚àà ideal.span {g} by\n          rw [‚Üê e]\n          exact ideal.subset_span (by simp))\n    obtain ‚ü®b, rfl‚ü© :=\n      ideal.mem_span_singleton'.mp\n        (show b ‚àà ideal.span {g} by\n          rw [‚Üê e]\n          exact ideal.subset_span (by simp))\n    obtain ‚ü®x, y, e'‚ü© :=\n      ideal.mem_span_pair.mp\n        (show g ‚àà ideal.span {a * g, b * g} by\n          rw [e]\n          exact ideal.subset_span (by simp))\n    cases' eq_or_ne g 0 with h h\n    ¬∑ simp [h]\n    have : x * a + y * b = 1 := by\n      apply mul_left_injective‚ÇÄ h\n      convert e' <;> ring_nf\n    cases' local_ring.is_unit_or_is_unit_of_add_one this with h' h'\n    left\n    swap\n    right\n    all_goals exact mul_dvd_mul_right (is_unit_iff_forall_dvd.mp (isUnit_of_mul_isUnit_right h') _) _\n#align iff_local_bezout_domain iff_local_bezout_domain\n\n",
 "iff_is_integer_or_is_integer":
 "theorem iff_is_integer_or_is_integer :\n    valuation_ring R ‚Üî ‚àÄ x : K, is_localization.is_integer R x ‚à® is_localization.is_integer R x‚Åª¬π :=\n  by\n  constructor\n  ¬∑ intro H x\n    obtain ‚ü®x : R, y, hy, rfl‚ü© := is_fraction_ring.div_surjective x\n    any_goals infer_instance\n    have := (map_ne_zero_iff _ (is_fraction_ring.injective R K)).mpr (non_zero_divisors.ne_zero hy)\n    obtain ‚ü®s, rfl | rfl‚ü© := valuation_ring.cond x y\n    ¬∑ exact or.inr ‚ü®s, eq_inv_of_mul_eq_one_left <| by rwa [mul_div, div_eq_one_iff_eq, map_mul, mul_comm]‚ü©\n    ¬∑ exact or.inl ‚ü®s, by rwa [eq_div_iff, map_mul, mul_comm]‚ü©\n  ¬∑ intro H\n    constructor\n    intro a b\n    by_cases ha : a = 0\n    ¬∑ subst ha\n      exact ‚ü®0, or.inr <| mul_zero b‚ü©\n    by_cases hb : b = 0\n    ¬∑ subst hb\n      exact ‚ü®0, or.inl <| mul_zero a‚ü©\n    replace ha := (map_ne_zero_iff _ (is_fraction_ring.injective R K)).mpr ha\n    replace hb := (map_ne_zero_iff _ (is_fraction_ring.injective R K)).mpr hb\n    obtain ‚ü®c, e‚ü© | ‚ü®c, e‚ü© := H (algebra_map R K a / algebra_map R K b)\n    ¬∑ rw [eq_div_iff hb, ‚Üê map_mul, (is_fraction_ring.injective R K).eq_iff, mul_comm] at e\n      exact ‚ü®c, or.inr e‚ü©\n    ¬∑ rw [inv_div, eq_div_iff ha, ‚Üê map_mul, (is_fraction_ring.injective R K).eq_iff, mul_comm c] at e\n      exact ‚ü®c, or.inl e‚ü©\n#align iff_is_integer_or_is_integer iff_is_integer_or_is_integer\n\n",
 "iff_ideal_total":
 "theorem iff_ideal_total : valuation_ring R ‚Üî is_total (ideal R) (¬∑ ‚â§ ¬∑) := by\n  classical\n    refine' ‚ü®fun _ => ‚ü®le_total‚ü©, fun H => iff_dvd_total.mpr ‚ü®fun a b => _‚ü©‚ü©\n    have := @is_total.total _ _ H (ideal.span {a}) (ideal.span {b})\n    simp_rw [ideal.span_singleton_le_span_singleton] at this\n    exact this.symm\n#align iff_ideal_total iff_ideal_total\n\n",
 "iff_dvd_total":
 "theorem iff_dvd_total : valuation_ring R ‚Üî is_total R (¬∑ ‚à£ ¬∑) := by\n  classical\n    refine' ‚ü®fun H => ‚ü®fun a b => _‚ü©, fun H => ‚ü®fun a b => _‚ü©‚ü© <;> skip\n    ¬∑ obtain ‚ü®c, rfl | rfl‚ü© := @valuation_ring.cond _ _ H a b <;> simp\n    ¬∑ obtain ‚ü®c, rfl‚ü© | ‚ü®c, rfl‚ü© := @is_total.total _ _ H a b <;> use c <;> simp\n#align iff_dvd_total iff_dvd_total\n\n",
 "dvd_total":
 "theorem dvd_total [h : valuation_ring R] (x y : R) : x ‚à£ y ‚à® y ‚à£ x :=\n  @is_total.total _ (iff_dvd_total.mp h) x y\n#align dvd_total dvd_total\n\n",
 "coe_equiv_integer_apply":
 "@[simp]\ntheorem coe_equiv_integer_apply (a : A) : (equiv_integer A K a : K) = algebra_map A K a :=\n  rfl\n#align coe_equiv_integer_apply coe_equiv_integer_apply\n\n"}