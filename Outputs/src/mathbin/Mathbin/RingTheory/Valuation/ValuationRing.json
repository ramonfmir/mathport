{"valuation_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem _root_.function.surjective.valuation_ring {R S : Type _} [CommRing R] [IsDomain R] [valuation_ring R]\n    [CommRing S] [IsDomain S] (f : «expr →+* » R S) (hf : function.surjective f) : valuation_ring S :=\n  ⟨fun a b => by\n    obtain ⟨⟨a, rfl⟩, ⟨b, rfl⟩⟩ := hf a, hf b\n    obtain ⟨c, rfl | rfl⟩ := valuation_ring.cond a b\n    exacts[⟨f c, or.inl <| (map_mul _ _ _).symm⟩, ⟨f c, or.inr <| (map_mul _ _ _).symm⟩]⟩\n#align function.surjective.valuation_ring function.surjective.valuation_ring\n\n",
 "unique_irreducible":
 "theorem unique_irreducible [valuation_ring R] ⦃p q : R⦄ (hp : Irreducible p) (hq : Irreducible q) : Associated p q :=\n  by\n  have := dvd_total p q\n  rw [Irreducible.dvd_comm hp hq, or_self_iff] at this\n  exact associated_of_dvd_dvd (Irreducible.dvd_symm hq hp this) this\n#align unique_irreducible unique_irreducible\n\n",
 "tfae":
 "/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [(Command.protected \"protected\")] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae [])\n      (Command.declSig\n       [(Term.explicitBinder \"(\" [`R] [\":\" (Term.type \"Type\" [`u])] [] \")\")\n        (Term.instBinder \"[\" [] (Term.app `CommRing [`R]) \"]\")\n        (Term.instBinder \"[\" [] (Term.app `IsDomain [`R]) \"]\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `valuation_ring [`R])\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`x]\n             [(Term.typeSpec \":\" (Term.app `fraction_ring [`R]))]\n             \",\"\n             («term_∨_»\n              (Term.app `is_localization.is_integer [`R `x])\n              \"∨\"\n              (Term.app `is_localization.is_integer [`R («term_⁻¹» `x \"⁻¹\")])))\n            \",\"\n            (Term.app `is_total [`R (Term.paren \"(\" («term_∣_» (Term.cdot \"·\") \"∣\" (Term.cdot \"·\")) \")\")])\n            \",\"\n            (Term.app\n             `is_total\n             [(Term.app `ideal [`R]) (Term.paren \"(\" («term_≤_» (Term.cdot \"·\") \"≤\" (Term.cdot \"·\")) \")\")])\n            \",\"\n            («term_∧_» (Term.app `local_ring [`R]) \"∧\" (Term.app `is_bezout [`R]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `iff_is_integer_or_is_integer [`R (Term.hole \"_\")]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"3\"))\n           \";\"\n           (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.exact \"exact\" `iff_dvd_total)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"4\"))\n           \";\"\n           (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.exact \"exact\" `iff_ideal_total)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"5\"))\n           \";\"\n           (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.exact \"exact\" `iff_local_bezout_domain)])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `iff_is_integer_or_is_integer [`R (Term.hole \"_\")]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"3\"))\n          \";\"\n          (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.exact \"exact\" `iff_dvd_total)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"4\"))\n          \";\"\n          (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.exact \"exact\" `iff_ideal_total)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"5\"))\n          \";\"\n          (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.exact \"exact\" `iff_local_bezout_domain)])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.exact \"exact\" `iff_local_bezout_domain)])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" `iff_local_bezout_domain)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `iff_local_bezout_domain\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"5\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\nprotected\n  theorem\n    tfae\n    ( R : Type u ) [ CommRing R ] [ IsDomain R ]\n      :\n        TFAE\n          [\n            valuation_ring R\n              ,\n              ∀ x : fraction_ring R , is_localization.is_integer R x ∨ is_localization.is_integer R x ⁻¹\n              ,\n              is_total R ( · ∣ · )\n              ,\n              is_total ideal R ( · ≤ · )\n              ,\n              local_ring R ∧ is_bezout R\n            ]\n    :=\n      by\n        tfae_have 1 ↔ 2\n          ;\n          · exact iff_is_integer_or_is_integer R _\n          tfae_have 1 ↔ 3\n          ;\n          · exact iff_dvd_total\n          tfae_have 1 ↔ 4\n          ;\n          · exact iff_ideal_total\n          tfae_have 1 ↔ 5\n          ;\n          · exact iff_local_bezout_domain\n          tfae_finish\n#align tfae tfae\n\n",
 "range_algebra_map_eq":
 "theorem range_algebra_map_eq : (valuation A K).integer = (algebra_map A K).range :=\n  by\n  ext\n  exact mem_integer_iff _ _ _\n#align range_algebra_map_eq range_algebra_map_eq\n\n",
 "of_integers":
 "/-- If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪`\nis a valuation ring. -/\ntheorem of_integers : valuation_ring 𝒪 := by\n  constructor\n  intro a b\n  cases le_total (v (algebra_map 𝒪 K a)) (v (algebra_map 𝒪 K b))\n  · obtain ⟨c, hc⟩ := valuation.integers.dvd_of_le hh h\n    use c\n    exact or.inr hc.symm\n  · obtain ⟨c, hc⟩ := valuation.integers.dvd_of_le hh h\n    use c\n    exact or.inl hc.symm\n#align of_integers of_integers\n\n",
 "mem_integer_iff":
 "theorem mem_integer_iff (x : K) : x ∈ (valuation A K).integer ↔ ∃ a : A, algebra_map A K a = x :=\n  by\n  constructor\n  · rintro ⟨c, rfl⟩\n    use c\n    rw [algebra.smul_def, mul_one]\n  · rintro ⟨c, rfl⟩\n    use c\n    rw [algebra.smul_def, mul_one]\n#align mem_integer_iff mem_integer_iff\n\n",
 "le_total":
 "#print le_total /-\n/-\nCopyright (c) 2022 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\nprotected theorem le_total (a b : value_group A K) : a ≤ b ∨ b ≤ a :=\n  by\n  rcases a with ⟨a⟩; rcases b with ⟨b⟩\n  obtain ⟨xa, ya, hya, rfl⟩ : ∃ a b : A, _ := is_fraction_ring.div_surjective a\n  obtain ⟨xb, yb, hyb, rfl⟩ : ∃ a b : A, _ := is_fraction_ring.div_surjective b\n  have : (algebra_map A K) ya ≠ 0 := is_fraction_ring.to_map_ne_zero_of_mem_non_zero_divisors hya\n  have : (algebra_map A K) yb ≠ 0 := is_fraction_ring.to_map_ne_zero_of_mem_non_zero_divisors hyb\n  obtain ⟨c, h | h⟩ := valuation_ring.cond (xa * yb) (xb * ya)\n  · right\n    use c\n    rw [algebra.smul_def]\n    field_simp\n    simp only [← RingHom.map_mul, ← h]\n    congr 1\n    ring\n  · left\n    use c\n    rw [algebra.smul_def]\n    field_simp\n    simp only [← RingHom.map_mul, ← h]\n    congr 1\n    ring\n#align le_total le_total\n-/\n\n",
 "is_integer_or_is_integer":
 "theorem is_integer_or_is_integer [h : valuation_ring R] (x : K) :\n    is_localization.is_integer R x ∨ is_localization.is_integer R x⁻¹ :=\n  (iff_is_integer_or_is_integer R K).mp h x\n#align is_integer_or_is_integer is_integer_or_is_integer\n\n",
 "iff_local_bezout_domain":
 "-- This implies that valuation rings are integrally closed through typeclass search.\ntheorem iff_local_bezout_domain : valuation_ring R ↔ local_ring R ∧ is_bezout R := by\n  classical\n    refine' ⟨fun H => ⟨infer_instance, infer_instance⟩, _⟩\n    rintro ⟨h₁, h₂⟩\n    skip\n    refine' iff_dvd_total.mpr ⟨fun a b => _⟩\n    obtain ⟨g, e : _ = ideal.span _⟩ := is_bezout.span_pair_is_principal a b\n    obtain ⟨a, rfl⟩ :=\n      ideal.mem_span_singleton'.mp\n        (show a ∈ ideal.span {g} by\n          rw [← e]\n          exact ideal.subset_span (by simp))\n    obtain ⟨b, rfl⟩ :=\n      ideal.mem_span_singleton'.mp\n        (show b ∈ ideal.span {g} by\n          rw [← e]\n          exact ideal.subset_span (by simp))\n    obtain ⟨x, y, e'⟩ :=\n      ideal.mem_span_pair.mp\n        (show g ∈ ideal.span {a * g, b * g} by\n          rw [e]\n          exact ideal.subset_span (by simp))\n    cases' eq_or_ne g 0 with h h\n    · simp [h]\n    have : x * a + y * b = 1 := by\n      apply mul_left_injective₀ h\n      convert e' <;> ring_nf\n    cases' local_ring.is_unit_or_is_unit_of_add_one this with h' h'\n    left\n    swap\n    right\n    all_goals exact mul_dvd_mul_right (is_unit_iff_forall_dvd.mp (isUnit_of_mul_isUnit_right h') _) _\n#align iff_local_bezout_domain iff_local_bezout_domain\n\n",
 "iff_is_integer_or_is_integer":
 "theorem iff_is_integer_or_is_integer :\n    valuation_ring R ↔ ∀ x : K, is_localization.is_integer R x ∨ is_localization.is_integer R x⁻¹ :=\n  by\n  constructor\n  · intro H x\n    obtain ⟨x : R, y, hy, rfl⟩ := is_fraction_ring.div_surjective x\n    any_goals infer_instance\n    have := (map_ne_zero_iff _ (is_fraction_ring.injective R K)).mpr (non_zero_divisors.ne_zero hy)\n    obtain ⟨s, rfl | rfl⟩ := valuation_ring.cond x y\n    · exact or.inr ⟨s, eq_inv_of_mul_eq_one_left <| by rwa [mul_div, div_eq_one_iff_eq, map_mul, mul_comm]⟩\n    · exact or.inl ⟨s, by rwa [eq_div_iff, map_mul, mul_comm]⟩\n  · intro H\n    constructor\n    intro a b\n    by_cases ha : a = 0\n    · subst ha\n      exact ⟨0, or.inr <| mul_zero b⟩\n    by_cases hb : b = 0\n    · subst hb\n      exact ⟨0, or.inl <| mul_zero a⟩\n    replace ha := (map_ne_zero_iff _ (is_fraction_ring.injective R K)).mpr ha\n    replace hb := (map_ne_zero_iff _ (is_fraction_ring.injective R K)).mpr hb\n    obtain ⟨c, e⟩ | ⟨c, e⟩ := H (algebra_map R K a / algebra_map R K b)\n    · rw [eq_div_iff hb, ← map_mul, (is_fraction_ring.injective R K).eq_iff, mul_comm] at e\n      exact ⟨c, or.inr e⟩\n    · rw [inv_div, eq_div_iff ha, ← map_mul, (is_fraction_ring.injective R K).eq_iff, mul_comm c] at e\n      exact ⟨c, or.inl e⟩\n#align iff_is_integer_or_is_integer iff_is_integer_or_is_integer\n\n",
 "iff_ideal_total":
 "theorem iff_ideal_total : valuation_ring R ↔ is_total (ideal R) (· ≤ ·) := by\n  classical\n    refine' ⟨fun _ => ⟨le_total⟩, fun H => iff_dvd_total.mpr ⟨fun a b => _⟩⟩\n    have := @is_total.total _ _ H (ideal.span {a}) (ideal.span {b})\n    simp_rw [ideal.span_singleton_le_span_singleton] at this\n    exact this.symm\n#align iff_ideal_total iff_ideal_total\n\n",
 "iff_dvd_total":
 "theorem iff_dvd_total : valuation_ring R ↔ is_total R (· ∣ ·) := by\n  classical\n    refine' ⟨fun H => ⟨fun a b => _⟩, fun H => ⟨fun a b => _⟩⟩ <;> skip\n    · obtain ⟨c, rfl | rfl⟩ := @valuation_ring.cond _ _ H a b <;> simp\n    · obtain ⟨c, rfl⟩ | ⟨c, rfl⟩ := @is_total.total _ _ H a b <;> use c <;> simp\n#align iff_dvd_total iff_dvd_total\n\n",
 "dvd_total":
 "theorem dvd_total [h : valuation_ring R] (x y : R) : x ∣ y ∨ y ∣ x :=\n  @is_total.total _ (iff_dvd_total.mp h) x y\n#align dvd_total dvd_total\n\n",
 "coe_equiv_integer_apply":
 "@[simp]\ntheorem coe_equiv_integer_apply (a : A) : (equiv_integer A K a : K) = algebra_map A K a :=\n  rfl\n#align coe_equiv_integer_apply coe_equiv_integer_apply\n\n"}