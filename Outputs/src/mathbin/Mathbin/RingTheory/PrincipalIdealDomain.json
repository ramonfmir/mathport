{"to_maximal_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- TODO -- for a non-ID one could perhaps prove that if p < q are prime then q maximal;\n-- 0 isn't prime in a non-ID PIR but the Krull dimension is still <= 1.\n-- The below result follows from this, but we could also use the below result to\n-- prove this (quotient out by p).\ntheorem to_maximal_ideal [CommRing R] [IsDomain R] [is_principal_ideal_ring R] {S : ideal R} [hpi : is_prime S]\n    (hS : S ≠ «expr⊥») : is_maximal S :=\n  is_maximal_iff.2\n    ⟨(ne_top_iff_one S).1 hpi.1, by\n      intro T x hST hxS hxT\n      cases' (mem_iff_generator_dvd _).1 (hST <| generator_mem S) with z hz\n      cases hpi.mem_or_mem (show generator T * z ∈ S from hz ▸ generator_mem S)\n      · have hTS : T ≤ S\n        rwa [← T.span_singleton_generator, ideal.span_le, singleton_subset_iff]\n        exact (hxS <| hTS hxT).elim\n      cases' (mem_iff_generator_dvd _).1 h with y hy\n      have : generator S ≠ 0 := mt (eq_bot_iff_generator_eq_zero _).2 hS\n      rw [← mul_one (generator S), hy, mul_left_comm, mul_right_inj' this] at hz\n      exact hz.symm ▸ T.mul_mem_right _ (generator_mem T)⟩\n#align to_maximal_ideal to_maximal_ideal\n\n",
 "span_singleton_generator":
 "theorem _root_.ideal.span_singleton_generator (I : ideal R) [I.is_principal] : ideal.span ({generator I} : set R) = I :=\n  eq.symm (Classical.choose_spec (principal I))\n#align ideal.span_singleton_generator ideal.span_singleton_generator\n\n",
 "span_gcd":
 "theorem span_gcd (x y : R) : span ({gcd x y} : set R) = span ({x, y} : set R) :=\n  by\n  obtain ⟨d, hd⟩ := is_principal_ideal_ring.principal (span ({x, y} : set R))\n  rw [submodule_span_eq] at hd\n  rw [hd]\n  suffices Associated d (gcd x y) by\n    obtain ⟨D, HD⟩ := this\n    rw [← HD]\n    exact span_singleton_mul_right_unit D.is_unit _\n  apply associated_of_dvd_dvd\n  · rw [dvd_gcd_iff]\n    constructor <;> rw [← ideal.mem_span_singleton, ← hd, ideal.mem_span_pair]\n    · use 1, 0\n      rw [one_mul, zero_mul, add_zero]\n    · use 0, 1\n      rw [one_mul, zero_mul, zero_add]\n  · obtain ⟨r, s, rfl⟩ : ∃ r s, r * x + s * y = d := by rw [← ideal.mem_span_pair, hd, ideal.mem_span_singleton]\n    apply dvd_add <;> apply dvd_mul_of_dvd_right\n    exacts[gcd_dvd_left x y, gcd_dvd_right x y]\n#align span_gcd span_gcd\n\n",
 "ring_hom_mem_submonoid_of_factors_subset_of_units_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- If a `ring_hom` maps all units and all factors of an element `a` into a submonoid `s`, then it\nalso maps `a` into that submonoid. -/\ntheorem ring_hom_mem_submonoid_of_factors_subset_of_units_subset {R S : Type _} [CommRing R] [IsDomain R]\n    [is_principal_ideal_ring R] [Semiring S] (f : «expr →+* » R S) (s : Submonoid S) (a : R) (ha : a ≠ 0)\n    (h : ∀ b ∈ factors a, f b ∈ s) (hf : ∀ c : «expr ˣ» R, f c ∈ s) : f a ∈ s :=\n  mem_submonoid_of_factors_subset_of_units_subset (s.comap f.to_monoid_hom) ha h hf\n#align ring_hom_mem_submonoid_of_factors_subset_of_units_subset ring_hom_mem_submonoid_of_factors_subset_of_units_subset\n\n",
 "prime_generator_of_is_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem prime_generator_of_is_prime (S : ideal R) [submodule.is_principal S] [is_prime : S.is_prime]\n    (ne_bot : S ≠ «expr⊥») : Prime (generator S) :=\n  ⟨fun h => ne_bot ((eq_bot_iff_generator_eq_zero S).2 h), fun h =>\n    is_prime.ne_top (S.eq_top_of_is_unit_mem (generator_mem S) h), fun _ _ => by\n    simpa only [← mem_iff_generator_dvd S] using is_prime.2⟩\n#align prime_generator_of_is_prime prime_generator_of_is_prime\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/\ntheorem is_principal_ideal_ring.of_surjective [is_principal_ideal_ring R] (f : «expr →+* » R S)\n    (hf : function.surjective f) : is_principal_ideal_ring S :=\n  ⟨fun I => ideal.is_principal.of_comap f hf I⟩\n#align is_principal_ideal_ring.of_surjective is_principal_ideal_ring.of_surjective\n\n",
 "of_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ideal.is_principal.of_comap (f : «expr →+* » R S) (hf : function.surjective f) (I : ideal S)\n    [hI : is_principal (I.comap f)] : is_principal I :=\n  ⟨⟨f (is_principal.generator (I.comap f)), by\n      rw [ideal.submodule_span_eq, ← Set.image_singleton, ← ideal.map_span, ideal.span_singleton_generator,\n        ideal.map_comap_of_surjective f hf]⟩⟩\n#align ideal.is_principal.of_comap ideal.is_principal.of_comap\n\n",
 "ne_zero_of_mem_factors":
 "theorem ne_zero_of_mem_factors {R : Type v} [CommRing R] [IsDomain R] [is_principal_ideal_ring R] {a b : R} (ha : a ≠ 0)\n    (hb : b ∈ factors a) : b ≠ 0 :=\n  Irreducible.ne_zero ((factors_spec a ha).1 b hb)\n#align ne_zero_of_mem_factors ne_zero_of_mem_factors\n\n",
 "mod_mem_iff":
 "theorem mod_mem_iff {S : ideal R} {x y : R} (hy : y ∈ S) : x % y ∈ S ↔ x ∈ S :=\n  ⟨fun hxy => div_add_mod x y ▸ S.add_mem (S.mul_mem_right _ hy) hxy, fun hx =>\n    (mod_eq_sub_mul_div x y).symm ▸ S.sub_mem hx (S.mul_mem_right _ hy)⟩\n#align mod_mem_iff mod_mem_iff\n\n",
 "mem_submonoid_of_factors_subset_of_units_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem mem_submonoid_of_factors_subset_of_units_subset (s : Submonoid R) {a : R} (ha : a ≠ 0)\n    (hfac : ∀ b ∈ factors a, b ∈ s) (hunit : ∀ c : «expr ˣ» R, (c : R) ∈ s) : a ∈ s :=\n  by\n  rcases(factors_spec a ha).2 with ⟨c, hc⟩\n  rw [← hc]\n  exact mul_mem (multiset_prod_mem _ hfac) (hunit _)\n#align mem_submonoid_of_factors_subset_of_units_subset mem_submonoid_of_factors_subset_of_units_subset\n\n",
 "mem_iff_generator_dvd":
 "theorem mem_iff_generator_dvd (S : ideal R) [S.is_principal] {x : R} : x ∈ S ↔ generator S ∣ x :=\n  (mem_iff_eq_smul_generator S).trans (exists_congr fun a => by simp only [mul_comm, smul_eq_mul])\n#align mem_iff_generator_dvd mem_iff_generator_dvd\n\n",
 "mem_iff_eq_smul_generator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_iff_eq_smul_generator (S : submodule R M) [S.is_principal] {x : M} :\n    x ∈ S ↔ ∃ s : R, x = «expr • » s (generator S) := by\n  simp_rw [@eq_comm _ x, ← mem_span_singleton, span_singleton_generator]\n#align mem_iff_eq_smul_generator mem_iff_eq_smul_generator\n\n",
 "is_principal_ideal_ring":
 "-- see Note [lower instance priority]\ntheorem is_field.is_principal_ideal_ring {R : Type _} [CommRing R] (h : IsField R) : is_principal_ideal_ring R :=\n  @euclidean_domain.to_principal_ideal_domain R (@Field.toEuclideanDomain R h.to_field)\n#align is_field.is_principal_ideal_ring is_field.is_principal_ideal_ring\n\n",
 "is_maximal_of_irreducible":
 "-- see Note [lower instance priority]\ntheorem is_maximal_of_irreducible [CommRing R] [is_principal_ideal_ring R] {p : R} (hp : Irreducible p) :\n    ideal.is_maximal (span R ({p} : set R)) :=\n  ⟨⟨mt ideal.span_singleton_eq_top.1 hp.1, fun I hI =>\n      by\n      rcases principal I with ⟨a, rfl⟩\n      erw [ideal.span_singleton_eq_top]\n      rcases ideal.span_singleton_le_span_singleton.1 (le_of_lt hI) with ⟨b, rfl⟩\n      refine' (of_irreducible_mul hp).resolve_right (mt (fun hb => _) (not_le_of_lt hI))\n      erw [ideal.span_singleton_le_span_singleton, is_unit.mul_right_dvd hb]⟩⟩\n#align is_maximal_of_irreducible is_maximal_of_irreducible\n\n",
 "is_coprime_of_prime_dvd":
 "theorem is_coprime_of_prime_dvd {x y : R} (nonzero : ¬(x = 0 ∧ y = 0)) (H : ∀ z : R, Prime z → z ∣ x → ¬z ∣ y) :\n    IsCoprime x y :=\n  is_coprime_of_irreducible_dvd nonzero fun z zi => H z <| GCDMonoid.prime_of_irreducible zi\n#align is_coprime_of_prime_dvd is_coprime_of_prime_dvd\n\n",
 "is_coprime_of_irreducible_dvd":
 "theorem is_coprime_of_irreducible_dvd {x y : R} (nonzero : ¬(x = 0 ∧ y = 0))\n    (H : ∀ z : R, Irreducible z → z ∣ x → ¬z ∣ y) : IsCoprime x y :=\n  by\n  apply is_coprime_of_dvd x y nonzero\n  intro z znu znz zx zy\n  obtain ⟨i, h1, h2⟩ := wf_dvd_monoid.exists_irreducible_factor znu znz\n  apply H i h1 <;>\n    · apply dvd_trans h2\n      assumption\n#align is_coprime_of_irreducible_dvd is_coprime_of_irreducible_dvd\n\n",
 "is_coprime_of_dvd":
 "-- this should be proved for UFDs surely?\ntheorem is_coprime_of_dvd (x y : R) (nonzero : ¬(x = 0 ∧ y = 0)) (H : ∀ z ∈ nonunits R, z ≠ 0 → z ∣ x → ¬z ∣ y) :\n    IsCoprime x y := by\n  rw [← gcd_is_unit_iff]\n  by_contra h\n  refine' H _ h _ (gcd_dvd_left _ _) (gcd_dvd_right _ _)\n  rwa [ne, gcd_eq_zero_iff]\n#align is_coprime_of_dvd is_coprime_of_dvd\n\n",
 "irreducible_iff_prime":
 "theorem irreducible_iff_prime {p : R} : Irreducible p ↔ Prime p :=\n  ⟨fun hp => (ideal.span_singleton_prime hp.ne_zero).1 <| (is_maximal_of_irreducible hp).is_prime, Prime.irreducible⟩\n#align irreducible_iff_prime irreducible_iff_prime\n\n",
 "generator_submodule_image_dvd_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- Note that the converse may not hold if `ϕ` is not injective.\ntheorem generator_submodule_image_dvd_of_mem {N O : submodule R M} (hNO : N ≤ O) (ϕ : «expr →ₗ[ ] » O R R)\n    [(ϕ.submodule_image N).is_principal] {x : M} (hx : x ∈ N) : generator (ϕ.submodule_image N) ∣ ϕ ⟨x, hNO hx⟩ :=\n  by\n  rw [← mem_iff_generator_dvd, linear_map.mem_submodule_image_of_le hNO]\n  exact ⟨x, hx, rfl⟩\n#align generator_submodule_image_dvd_of_mem generator_submodule_image_dvd_of_mem\n\n",
 "generator_mem":
 "@[simp]\ntheorem generator_mem (S : submodule R M) [S.is_principal] : generator S ∈ S :=\n  by\n  conv_rhs => rw [← span_singleton_generator S]\n  exact subset_span (mem_singleton _)\n#align generator_mem generator_mem\n\n",
 "generator_map_dvd_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- Note that the converse may not hold if `ϕ` is not injective.\ntheorem generator_map_dvd_of_mem {N : submodule R M} (ϕ : «expr →ₗ[ ] » M R R) [(N.map ϕ).is_principal] {x : M}\n    (hx : x ∈ N) : generator (N.map ϕ) ∣ ϕ x :=\n  by\n  rw [← mem_iff_generator_dvd, submodule.mem_map]\n  exact ⟨x, hx, rfl⟩\n#align generator_map_dvd_of_mem generator_map_dvd_of_mem\n\n",
 "gcd_is_unit_iff":
 "theorem gcd_is_unit_iff (x y : R) : is_unit (gcd x y) ↔ IsCoprime x y := by\n  rw [IsCoprime, ← ideal.mem_span_pair, ← span_gcd, ← span_singleton_eq_top, eq_top_iff_one]\n#align gcd_is_unit_iff gcd_is_unit_iff\n\n",
 "gcd_dvd_iff_exists":
 "theorem gcd_dvd_iff_exists (a b : R) {z} : gcd a b ∣ z ↔ ∃ x y, z = a * x + b * y := by\n  simp_rw [mul_comm a, mul_comm b, @eq_comm _ z, ← ideal.mem_span_pair, ← span_gcd, ideal.mem_span_singleton]\n#align gcd_dvd_iff_exists gcd_dvd_iff_exists\n\n",
 "factors_spec":
 "theorem factors_spec (a : R) (h : a ≠ 0) : (∀ b ∈ factors a, Irreducible b) ∧ Associated (factors a).prod a :=\n  by\n  unfold factors; rw [dif_neg h]\n  exact Classical.choose_spec (wf_dvd_monoid.exists_factors a h)\n#align factors_spec factors_spec\n\n",
 "exists_gcd_eq_mul_add_mul":
 "/-- **Bézout's lemma** -/\ntheorem exists_gcd_eq_mul_add_mul (a b : R) : ∃ x y, gcd a b = a * x + b * y := by rw [← gcd_dvd_iff_exists]\n#align exists_gcd_eq_mul_add_mul exists_gcd_eq_mul_add_mul\n\n",
 "exists_associated_pow_of_mul_eq_pow'":
 "theorem exists_associated_pow_of_mul_eq_pow' {a b c : R} (hab : IsCoprime a b) {k : ℕ} (h : a * b = c ^ k) :\n    ∃ d, Associated (d ^ k) a :=\n  exists_associated_pow_of_mul_eq_pow ((gcd_is_unit_iff _ _).mpr hab) h\n#align exists_associated_pow_of_mul_eq_pow' exists_associated_pow_of_mul_eq_pow'\n\n",
 "eq_bot_iff_generator_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem eq_bot_iff_generator_eq_zero (S : submodule R M) [S.is_principal] : S = «expr⊥» ↔ generator S = 0 := by\n  rw [← @span_singleton_eq_bot R M, span_singleton_generator]\n#align eq_bot_iff_generator_eq_zero eq_bot_iff_generator_eq_zero\n\n",
 "dvd_or_coprime":
 "-- this should be proved for UFDs surely?\ntheorem dvd_or_coprime (x y : R) (h : Irreducible x) : x ∣ y ∨ IsCoprime x y :=\n  by\n  refine' or_iff_not_imp_left.2 fun h' => _\n  apply is_coprime_of_dvd\n  · rintro ⟨rfl, rfl⟩\n    simpa using h\n  · rintro z nu nz ⟨w, rfl⟩ dy\n    refine' h' (dvd_trans _ dy)\n    simpa using mul_dvd_mul_left z (isUnit_iff_dvd_one.1 <| (of_irreducible_mul h).resolve_left nu)\n#align dvd_or_coprime dvd_or_coprime\n\n",
 "dvd_iff_not_coprime":
 "theorem irreducible.dvd_iff_not_coprime {p n : R} (hp : Irreducible p) : p ∣ n ↔ ¬IsCoprime p n :=\n  iff_not_comm.2 hp.coprime_iff_not_dvd\n#align irreducible.dvd_iff_not_coprime irreducible.dvd_iff_not_coprime\n\n",
 "coprime_pow_of_not_dvd":
 "theorem irreducible.coprime_pow_of_not_dvd {p a : R} (m : ℕ) (hp : Irreducible p) (h : ¬p ∣ a) : IsCoprime a (p ^ m) :=\n  (hp.coprime_iff_not_dvd.2 h).symm.pow_right\n#align irreducible.coprime_pow_of_not_dvd irreducible.coprime_pow_of_not_dvd\n\n",
 "coprime_or_dvd":
 "theorem irreducible.coprime_or_dvd {p : R} (hp : Irreducible p) (i : R) : IsCoprime p i ∨ p ∣ i :=\n  (em _).imp_right hp.dvd_iff_not_coprime.2\n#align irreducible.coprime_or_dvd irreducible.coprime_or_dvd\n\n",
 "coprime_iff_not_dvd":
 "theorem prime.coprime_iff_not_dvd {p n : R} (pp : Prime p) : IsCoprime p n ↔ ¬p ∣ n :=\n  pp.irreducible.coprime_iff_not_dvd\n#align prime.coprime_iff_not_dvd prime.coprime_iff_not_dvd\n\n",
 "associates_irreducible_iff_prime":
 "theorem associates_irreducible_iff_prime : ∀ {p : Associates R}, Irreducible p ↔ Prime p :=\n  Associates.irreducible_iff_prime_iff.1 fun _ => irreducible_iff_prime\n#align associates_irreducible_iff_prime associates_irreducible_iff_prime\n\n"}