{"to_maximal_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- TODO -- for a non-ID one could perhaps prove that if p < q are prime then q maximal;\n-- 0 isn't prime in a non-ID PIR but the Krull dimension is still <= 1.\n-- The below result follows from this, but we could also use the below result to\n-- prove this (quotient out by p).\ntheorem to_maximal_ideal [CommRing R] [IsDomain R] [IsPrincipalIdealRing R] {S : Ideal R} [hpi : IsPrime S]\n    (hS : S ≠ «expr⊥») : IsMaximal S :=\n  isMaximal_iff.2\n    ⟨(ne_top_iff_one S).1 hpi.1, by\n      intro T x hST hxS hxT\n      cases' (mem_iff_generator_dvd _).1 (hST <| generator_mem S) with z hz\n      cases hpi.mem_or_mem (show generator T * z ∈ S from hz ▸ generator_mem S)\n      · have hTS : T ≤ S\n        rwa [← T.span_singleton_generator, Ideal.span_le, singleton_subset_iff]\n        exact (hxS <| hTS hxT).elim\n      cases' (mem_iff_generator_dvd _).1 h with y hy\n      have : generator S ≠ 0 := mt (eq_bot_iff_generator_eq_zero _).2 hS\n      rw [← mul_one (generator S), hy, mul_left_comm, mul_right_inj' this] at hz\n      exact hz.symm ▸ T.mul_mem_right _ (generator_mem T)⟩\n#align to_maximal_ideal to_maximal_ideal\n\n",
 "span_singleton_generator":
 "#print Ideal.span_singleton_generator /-\ntheorem Ideal.span_singleton_generator (I : Ideal R) [I.is_principal] : Ideal.span ({generator I} : Set R) = I :=\n  Eq.symm (Classical.choose_spec (principal I))\n#align ideal.span_singleton_generator Ideal.span_singleton_generator\n-/\n\n",
 "span_gcd":
 "#print span_gcd /-\ntheorem span_gcd (x y : R) : span ({gcd x y} : Set R) = span ({x, y} : Set R) :=\n  by\n  obtain ⟨d, hd⟩ := is_principal_ideal_ring.principal (span ({x, y} : Set R))\n  rw [submodule_span_eq] at hd\n  rw [hd]\n  suffices Associated d (gcd x y) by\n    obtain ⟨D, HD⟩ := this\n    rw [← HD]\n    exact span_singleton_mul_right_unit D.is_unit _\n  apply associated_of_dvd_dvd\n  · rw [dvd_gcd_iff]\n    constructor <;> rw [← Ideal.mem_span_singleton, ← hd, Ideal.mem_span_pair]\n    · use 1, 0\n      rw [one_mul, MulZeroClass.zero_mul, add_zero]\n    · use 0, 1\n      rw [one_mul, MulZeroClass.zero_mul, zero_add]\n  · obtain ⟨r, s, rfl⟩ : ∃ r s, r * x + s * y = d := by rw [← Ideal.mem_span_pair, hd, Ideal.mem_span_singleton]\n    apply dvd_add <;> apply dvd_mul_of_dvd_right\n    exacts[gcd_dvd_left x y, gcd_dvd_right x y]\n#align span_gcd span_gcd\n-/\n\n",
 "ring_hom_mem_submonoid_of_factors_subset_of_units_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- If a `ring_hom` maps all units and all factors of an element `a` into a submonoid `s`, then it\nalso maps `a` into that submonoid. -/\ntheorem ring_hom_mem_submonoid_of_factors_subset_of_units_subset {R S : Type _} [CommRing R] [IsDomain R]\n    [IsPrincipalIdealRing R] [Semiring S] (f : «expr →+* » R S) (s : Submonoid S) (a : R) (ha : a ≠ 0)\n    (h : ∀ b ∈ factors a, f b ∈ s) (hf : ∀ c : «expr ˣ» R, f c ∈ s) : f a ∈ s :=\n  mem_submonoid_of_factors_subset_of_units_subset (s.comap f.to_monoid_hom) ha h hf\n#align ring_hom_mem_submonoid_of_factors_subset_of_units_subset ring_hom_mem_submonoid_of_factors_subset_of_units_subset\n\n",
 "prime_generator_of_is_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem prime_generator_of_is_prime (S : Ideal R) [Submodule.IsPrincipal S] [is_prime : S.is_prime]\n    (ne_bot : S ≠ «expr⊥») : Prime (generator S) :=\n  ⟨fun h => ne_bot ((eq_bot_iff_generator_eq_zero S).2 h), fun h =>\n    is_prime.ne_top (S.eq_top_of_is_unit_mem (generator_mem S) h), fun _ _ => by\n    simpa only [← mem_iff_generator_dvd S] using is_prime.2⟩\n#align prime_generator_of_is_prime prime_generator_of_is_prime\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print IsPrincipalIdealRing.of_surjective /-\n/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/\ntheorem IsPrincipalIdealRing.of_surjective [IsPrincipalIdealRing R] (f : «expr →+* » R S) (hf : function.surjective f) :\n    IsPrincipalIdealRing S :=\n  ⟨fun I => Ideal.IsPrincipal.of_comap f hf I⟩\n#align is_principal_ideal_ring.of_surjective IsPrincipalIdealRing.of_surjective\n-/\n\n",
 "of_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print IsPrincipalIdealRing.of_prime /-\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem IsPrincipalIdealRing.of_prime (H : ∀ P : Ideal R, P.is_prime → P.is_principal) : IsPrincipalIdealRing R :=\n  by\n  -- Suppose the set of `non_principals` is not empty.\n  rw [← nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]\n  intro J hJ\n  -- We will show a maximal element `I ∈ non_principals R` (which exists by Zorn) is prime.\n  obtain ⟨I, Ibad, -, Imax⟩ := zorn_nonempty_partialOrder₀ (nonPrincipals R) nonPrincipals_zorn _ hJ\n  have Imax' : ∀ {J}, I < J → J.is_principal := by\n    intro J hJ\n    by_contra He\n    exact hJ.ne (Imax _ ((nonPrincipals_def R).2 He) hJ.le).symm\n  by_cases hI1 : I = «expr⊤»\n  · subst hI1\n    exact Ibad top_isPrincipal\n  -- Let `x y : R` with `x * y ∈ I` and suppose WLOG `y ∉ I`.\n  refine' Ibad (H I ⟨hI1, fun x y hxy => or_iff_not_imp_right.mpr fun hy => _⟩)\n  obtain ⟨a, ha⟩ : («expr ⊔ » I (span {y})).is_principal :=\n    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))\n  -- Then `x ∈ I.colon (span {y})`, which is equal to `I` if it's not principal.\n  suffices He : ¬(I.colon (span {y})).is_principal\n  · rw [← Imax _ ((nonPrincipals_def R).2 He) fun a ha => Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]\n    exact Ideal.mem_colon_singleton.2 hxy\n  -- So suppose for the sake of contradiction that both `I ⊔ span {y}` and `I.colon (span {y})`\n  -- are principal.\n  rintro ⟨b, hb⟩\n  -- We will show `I` is generated by `a * b`.\n  refine'\n    (nonPrincipals_def _).1 Ibad\n      ⟨⟨a * b, (le_antisymm fun i hi => _) <| (span_singleton_mul_span_singleton a b).ge.trans _⟩⟩\n  · have hisup : i ∈ «expr ⊔ » I (span {y}) := Ideal.mem_sup_left hi\n    have : y ∈ «expr ⊔ » I (span {y}) := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)\n    erw [ha, mem_span_singleton'] at hisup this\n    obtain ⟨v, rfl⟩ := this\n    obtain ⟨u, rfl⟩ := hisup\n    have hucolon : u ∈ I.colon (span {v * a}) :=\n      by\n      rw [Ideal.mem_colon_singleton, mul_comm v, ← mul_assoc]\n      exact mul_mem_right _ _ hi\n    erw [hb, mem_span_singleton'] at hucolon\n    obtain ⟨z, rfl⟩ := hucolon\n    exact mem_span_singleton'.2 ⟨z, by ring⟩\n  · rw [← Ideal.submodule_span_eq, ← ha, Ideal.sup_mul, sup_le_iff, span_singleton_mul_span_singleton, mul_comm y,\n      Ideal.span_singleton_le_iff_mem]\n    exact ⟨mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm ▸ Ideal.mem_span_singleton_self b⟩\n#align is_principal_ideal_ring.of_prime IsPrincipalIdealRing.of_prime\n-/\n\n",
 "of_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print Ideal.IsPrincipal.of_comap /-\ntheorem Ideal.IsPrincipal.of_comap (f : «expr →+* » R S) (hf : function.surjective f) (I : Ideal S)\n    [hI : IsPrincipal (I.comap f)] : IsPrincipal I :=\n  ⟨⟨f (IsPrincipal.generator (I.comap f)), by\n      rw [Ideal.submodule_span_eq, ← Set.image_singleton, ← Ideal.map_span, Ideal.span_singleton_generator,\n        Ideal.map_comap_of_surjective f hf]⟩⟩\n#align ideal.is_principal.of_comap Ideal.IsPrincipal.of_comap\n-/\n\n",
 "nonPrincipals_zorn":
 "#print nonPrincipals_zorn /-\n/-- Any chain in the set of non-principal ideals has an upper bound which is non-principal.\n(Namely, the union of the chain is such an upper bound.)\n-/\ntheorem nonPrincipals_zorn (c : Set (Ideal R)) (hs : c ⊆ nonPrincipals R) (hchain : IsChain (· ≤ ·) c) {K : Ideal R}\n    (hKmem : K ∈ c) : ∃ I ∈ nonPrincipals R, ∀ J ∈ c, J ≤ I :=\n  by\n  refine' ⟨Sup c, _, fun J hJ => le_supₛ hJ⟩\n  rintro ⟨x, hx⟩\n  have hxmem : x ∈ Sup c := hx.symm ▸ Submodule.mem_span_singleton_self x\n  obtain ⟨J, hJc, hxJ⟩ := (Submodule.mem_supₛ_of_directed ⟨K, hKmem⟩ hchain.directed_on).1 hxmem\n  have hSupJ : Sup c = J := le_antisymm (by simp [hx, Ideal.span_le, hxJ]) (le_supₛ hJc)\n  specialize hs hJc\n  rw [← hSupJ, hx, nonPrincipals_def] at hs\n  exact hs ⟨⟨x, rfl⟩⟩\n#align non_principals_zorn nonPrincipals_zorn\n-/\n\n",
 "nonPrincipals_eq_empty_iff":
 "#print nonPrincipals_eq_empty_iff /-\ntheorem nonPrincipals_eq_empty_iff : nonPrincipals R = ∅ ↔ IsPrincipalIdealRing R := by\n  simp [Set.eq_empty_iff_forall_not_mem, is_principal_ideal_ring_iff, nonPrincipals_def]\n#align non_principals_eq_empty_iff nonPrincipals_eq_empty_iff\n-/\n\n",
 "nonPrincipals_def":
 "#print nonPrincipals_def /-\ntheorem nonPrincipals_def {I : Ideal R} : I ∈ nonPrincipals R ↔ ¬I.is_principal :=\n  iff.rfl\n#align non_principals_def nonPrincipals_def\n-/\n\n",
 "ne_zero_of_mem_factors":
 "theorem ne_zero_of_mem_factors {R : Type v} [CommRing R] [IsDomain R] [IsPrincipalIdealRing R] {a b : R} (ha : a ≠ 0)\n    (hb : b ∈ factors a) : b ≠ 0 :=\n  Irreducible.ne_zero ((factors_spec a ha).1 b hb)\n#align ne_zero_of_mem_factors ne_zero_of_mem_factors\n\n",
 "mod_mem_iff":
 "#print mod_mem_iff /-\ntheorem mod_mem_iff {S : Ideal R} {x y : R} (hy : y ∈ S) : x % y ∈ S ↔ x ∈ S :=\n  ⟨fun hxy => div_add_mod x y ▸ S.add_mem (S.mul_mem_right _ hy) hxy, fun hx =>\n    (mod_eq_sub_mul_div x y).symm ▸ S.sub_mem hx (S.mul_mem_right _ hy)⟩\n#align mod_mem_iff mod_mem_iff\n-/\n\n",
 "mem_submonoid_of_factors_subset_of_units_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem mem_submonoid_of_factors_subset_of_units_subset (s : Submonoid R) {a : R} (ha : a ≠ 0)\n    (hfac : ∀ b ∈ factors a, b ∈ s) (hunit : ∀ c : «expr ˣ» R, (c : R) ∈ s) : a ∈ s :=\n  by\n  rcases(factors_spec a ha).2 with ⟨c, hc⟩\n  rw [← hc]\n  exact mul_mem (multiset_prod_mem _ hfac) (hunit _)\n#align mem_submonoid_of_factors_subset_of_units_subset mem_submonoid_of_factors_subset_of_units_subset\n\n",
 "mem_iff_generator_dvd":
 "theorem mem_iff_generator_dvd (S : Ideal R) [S.is_principal] {x : R} : x ∈ S ↔ generator S ∣ x :=\n  (mem_iff_eq_smul_generator S).trans (exists_congr fun a => by simp only [mul_comm, smul_eq_mul])\n#align mem_iff_generator_dvd mem_iff_generator_dvd\n\n",
 "mem_iff_eq_smul_generator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_iff_eq_smul_generator (S : Submodule R M) [S.is_principal] {x : M} :\n    x ∈ S ↔ ∃ s : R, x = «expr • » s (generator S) := by\n  simp_rw [@eq_comm _ x, ← mem_span_singleton, span_singleton_generator]\n#align mem_iff_eq_smul_generator mem_iff_eq_smul_generator\n\n",
 "is_maximal_of_irreducible":
 "-- see Note [lower instance priority]\ntheorem is_maximal_of_irreducible [CommRing R] [IsPrincipalIdealRing R] {p : R} (hp : Irreducible p) :\n    Ideal.IsMaximal (span R ({p} : Set R)) :=\n  ⟨⟨mt Ideal.span_singleton_eq_top.1 hp.1, fun I hI =>\n      by\n      rcases principal I with ⟨a, rfl⟩\n      erw [Ideal.span_singleton_eq_top]\n      rcases Ideal.span_singleton_le_span_singleton.1 (le_of_lt hI) with ⟨b, rfl⟩\n      refine' (of_irreducible_mul hp).resolve_right (mt (fun hb => _) (not_le_of_lt hI))\n      erw [Ideal.span_singleton_le_span_singleton, IsUnit.mul_right_dvd hb]⟩⟩\n#align is_maximal_of_irreducible is_maximal_of_irreducible\n\n",
 "isPrincipalIdealRing":
 "#print IsField.isPrincipalIdealRing /-\n-- see Note [lower instance priority]\ntheorem IsField.isPrincipalIdealRing {R : Type _} [CommRing R] (h : IsField R) : IsPrincipalIdealRing R :=\n  @EuclideanDomain.to_principal_ideal_domain R (@Field.toEuclideanDomain R h.to_field)\n#align is_field.is_principal_ideal_ring IsField.isPrincipalIdealRing\n-/\n\n",
 "isCoprime_of_prime_dvd":
 "#print isCoprime_of_prime_dvd /-\ntheorem isCoprime_of_prime_dvd {x y : R} (nonzero : ¬(x = 0 ∧ y = 0)) (H : ∀ z : R, Prime z → z ∣ x → ¬z ∣ y) :\n    IsCoprime x y :=\n  isCoprime_of_irreducible_dvd nonzero fun z zi => H z <| GCDMonoid.prime_of_irreducible zi\n#align is_coprime_of_prime_dvd isCoprime_of_prime_dvd\n-/\n\n",
 "isCoprime_of_irreducible_dvd":
 "#print isCoprime_of_irreducible_dvd /-\ntheorem isCoprime_of_irreducible_dvd {x y : R} (nonzero : ¬(x = 0 ∧ y = 0))\n    (H : ∀ z : R, Irreducible z → z ∣ x → ¬z ∣ y) : IsCoprime x y :=\n  by\n  apply isCoprime_of_dvd x y nonzero\n  intro z znu znz zx zy\n  obtain ⟨i, h1, h2⟩ := WfDvdMonoid.exists_irreducible_factor znu znz\n  apply H i h1 <;>\n    · apply dvd_trans h2\n      assumption\n#align is_coprime_of_irreducible_dvd isCoprime_of_irreducible_dvd\n-/\n\n",
 "isCoprime_of_dvd":
 "#print isCoprime_of_dvd /-\n-- this should be proved for UFDs surely?\ntheorem isCoprime_of_dvd (x y : R) (nonzero : ¬(x = 0 ∧ y = 0)) (H : ∀ z ∈ nonunits R, z ≠ 0 → z ∣ x → ¬z ∣ y) :\n    IsCoprime x y := by\n  rw [← gcd_isUnit_iff]\n  by_contra h\n  refine' H _ h _ (gcd_dvd_left _ _) (gcd_dvd_right _ _)\n  rwa [ne, gcd_eq_zero_iff]\n#align is_coprime_of_dvd isCoprime_of_dvd\n-/\n\n",
 "irreducible_iff_prime":
 "theorem irreducible_iff_prime {p : R} : Irreducible p ↔ Prime p :=\n  ⟨fun hp => (Ideal.span_singleton_prime hp.ne_zero).1 <| (isMaximal_of_irreducible hp).is_prime, Prime.irreducible⟩\n#align irreducible_iff_prime irreducible_iff_prime\n\n",
 "generator_submodule_image_dvd_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- Note that the converse may not hold if `ϕ` is not injective.\ntheorem generator_submodule_image_dvd_of_mem {N O : Submodule R M} (hNO : N ≤ O) (ϕ : «expr →ₗ[ ] » O R R)\n    [(ϕ.submodule_image N).is_principal] {x : M} (hx : x ∈ N) : generator (ϕ.submodule_image N) ∣ ϕ ⟨x, hNO hx⟩ :=\n  by\n  rw [← mem_iff_generator_dvd, LinearMap.mem_submoduleImage_of_le hNO]\n  exact ⟨x, hx, rfl⟩\n#align generator_submodule_image_dvd_of_mem generator_submodule_image_dvd_of_mem\n\n",
 "generator_mem":
 "@[simp]\ntheorem generator_mem (S : Submodule R M) [S.is_principal] : generator S ∈ S :=\n  by\n  conv_rhs => rw [← span_singleton_generator S]\n  exact subset_span (mem_singleton _)\n#align generator_mem generator_mem\n\n",
 "generator_map_dvd_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- Note that the converse may not hold if `ϕ` is not injective.\ntheorem generator_map_dvd_of_mem {N : Submodule R M} (ϕ : «expr →ₗ[ ] » M R R) [(N.map ϕ).is_principal] {x : M}\n    (hx : x ∈ N) : generator (N.map ϕ) ∣ ϕ x :=\n  by\n  rw [← mem_iff_generator_dvd, Submodule.mem_map]\n  exact ⟨x, hx, rfl⟩\n#align generator_map_dvd_of_mem generator_map_dvd_of_mem\n\n",
 "gcd_isUnit_iff":
 "#print gcd_isUnit_iff /-\ntheorem gcd_isUnit_iff (x y : R) : IsUnit (gcd x y) ↔ IsCoprime x y := by\n  rw [IsCoprime, ← Ideal.mem_span_pair, ← span_gcd, ← span_singleton_eq_top, eq_top_iff_one]\n#align gcd_is_unit_iff gcd_isUnit_iff\n-/\n\n",
 "gcd_dvd_iff_exists":
 "#print gcd_dvd_iff_exists /-\ntheorem gcd_dvd_iff_exists (a b : R) {z} : gcd a b ∣ z ↔ ∃ x y, z = a * x + b * y := by\n  simp_rw [mul_comm a, mul_comm b, @eq_comm _ z, ← Ideal.mem_span_pair, ← span_gcd, Ideal.mem_span_singleton]\n#align gcd_dvd_iff_exists gcd_dvd_iff_exists\n-/\n\n",
 "factors_spec":
 "theorem factors_spec (a : R) (h : a ≠ 0) : (∀ b ∈ factors a, Irreducible b) ∧ Associated (factors a).prod a :=\n  by\n  unfold factors; rw [dif_neg h]\n  exact Classical.choose_spec (WfDvdMonoid.exists_factors a h)\n#align factors_spec factors_spec\n\n",
 "exists_gcd_eq_mul_add_mul":
 "#print exists_gcd_eq_mul_add_mul /-\n/-- **Bézout's lemma** -/\ntheorem exists_gcd_eq_mul_add_mul (a b : R) : ∃ x y, gcd a b = a * x + b * y := by rw [← gcd_dvd_iff_exists]\n#align exists_gcd_eq_mul_add_mul exists_gcd_eq_mul_add_mul\n-/\n\n",
 "exists_associated_pow_of_mul_eq_pow'":
 "#print exists_associated_pow_of_mul_eq_pow' /-\ntheorem exists_associated_pow_of_mul_eq_pow' {a b c : R} (hab : IsCoprime a b) {k : ℕ} (h : a * b = c ^ k) :\n    ∃ d, Associated (d ^ k) a :=\n  exists_associated_pow_of_mul_eq_pow ((gcd_isUnit_iff _ _).mpr hab) h\n#align exists_associated_pow_of_mul_eq_pow' exists_associated_pow_of_mul_eq_pow'\n-/\n\n",
 "eq_bot_iff_generator_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem eq_bot_iff_generator_eq_zero (S : Submodule R M) [S.is_principal] : S = «expr⊥» ↔ generator S = 0 := by\n  rw [← @span_singleton_eq_bot R M, span_singleton_generator]\n#align eq_bot_iff_generator_eq_zero eq_bot_iff_generator_eq_zero\n\n",
 "dvd_or_coprime":
 "#print dvd_or_coprime /-\n-- this should be proved for UFDs surely?\ntheorem dvd_or_coprime (x y : R) (h : Irreducible x) : x ∣ y ∨ IsCoprime x y :=\n  by\n  refine' or_iff_not_imp_left.2 fun h' => _\n  apply isCoprime_of_dvd\n  · rintro ⟨rfl, rfl⟩\n    simpa using h\n  · rintro z nu nz ⟨w, rfl⟩ dy\n    refine' h' (dvd_trans _ dy)\n    simpa using mul_dvd_mul_left z (isUnit_iff_dvd_one.1 <| (of_irreducible_mul h).resolve_left nu)\n#align dvd_or_coprime dvd_or_coprime\n-/\n\n",
 "dvd_iff_not_coprime":
 "#print Irreducible.dvd_iff_not_coprime /-\ntheorem Irreducible.dvd_iff_not_coprime {p n : R} (hp : Irreducible p) : p ∣ n ↔ ¬IsCoprime p n :=\n  iff_not_comm.2 hp.coprime_iff_not_dvd\n#align irreducible.dvd_iff_not_coprime Irreducible.dvd_iff_not_coprime\n-/\n\n",
 "coprime_pow_of_not_dvd":
 "#print Irreducible.coprime_pow_of_not_dvd /-\ntheorem Irreducible.coprime_pow_of_not_dvd {p a : R} (m : ℕ) (hp : Irreducible p) (h : ¬p ∣ a) : IsCoprime a (p ^ m) :=\n  (hp.coprime_iff_not_dvd.2 h).symm.pow_right\n#align irreducible.coprime_pow_of_not_dvd Irreducible.coprime_pow_of_not_dvd\n-/\n\n",
 "coprime_or_dvd":
 "#print Irreducible.coprime_or_dvd /-\ntheorem Irreducible.coprime_or_dvd {p : R} (hp : Irreducible p) (i : R) : IsCoprime p i ∨ p ∣ i :=\n  (em _).imp_right hp.dvd_iff_not_coprime.2\n#align irreducible.coprime_or_dvd Irreducible.coprime_or_dvd\n-/\n\n",
 "coprime_iff_not_dvd":
 "#print Prime.coprime_iff_not_dvd /-\ntheorem Prime.coprime_iff_not_dvd {p n : R} (pp : Prime p) : IsCoprime p n ↔ ¬p ∣ n :=\n  pp.irreducible.coprime_iff_not_dvd\n#align prime.coprime_iff_not_dvd Prime.coprime_iff_not_dvd\n-/\n\n",
 "associates_irreducible_iff_prime":
 "theorem associates_irreducible_iff_prime : ∀ {p : Associates R}, Irreducible p ↔ Prime p :=\n  Associates.irreducible_iff_prime_iff.1 fun _ => irreducible_iff_prime\n#align associates_irreducible_iff_prime associates_irreducible_iff_prime\n\n"}