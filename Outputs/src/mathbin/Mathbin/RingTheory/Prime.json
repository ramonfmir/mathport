{"neg":
 "#print Prime.neg /-\ntheorem Prime.neg {p : α} (hp : Prime p) : Prime (-p) :=\n  by\n  obtain ⟨h1, h2, h3⟩ := hp\n  exact ⟨neg_ne_zero.mpr h1, by rwa [IsUnit.neg_iff], by simpa [neg_dvd] using h3⟩\n#align prime.neg Prime.neg\n-/\n\n",
 "mul_eq_mul_prime_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print mul_eq_mul_prime_prod /-\n/-\nCopyright (c) 2020 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n/-- If `x * y = a * ∏ i in s, p i` where `p i` is always prime, then\n  `x` and `y` can both be written as a divisor of `a` multiplied by\n  a product over a subset of `s`  -/\ntheorem mul_eq_mul_prime_prod {α : Type _} [DecidableEq α] {x y a : R} {s : Finset α} {p : α → R}\n    (hp : ∀ i ∈ s, Prime (p i))\n    (hx :\n      x * y =\n        a * finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (p i)) :\n    ∃ (t u : Finset α)(b c : R),\n      t ∪ u = s ∧\n        Disjoint t u ∧\n          a = b * c ∧\n            x =\n                b *\n                  finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t\n                    (p i) ∧\n              y =\n                c *\n                  finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" u\n                    (p i) :=\n  by\n  induction' s using Finset.induction with i s his ih generalizing x y a\n  · exact ⟨∅, ∅, x, y, by simp [hx]⟩\n  · rw [prod_insert his, ← mul_assoc] at hx\n    have hpi : Prime (p i) := hp i (mem_insert_self _ _)\n    rcases ih (fun i hi => hp i (mem_insert_of_mem hi)) hx with ⟨t, u, b, c, htus, htu, hbc, rfl, rfl⟩\n    have hit : i ∉ t := fun hit => his (htus ▸ mem_union_left _ hit)\n    have hiu : i ∉ u := fun hiu => his (htus ▸ mem_union_right _ hiu)\n    obtain ⟨d, rfl⟩ | ⟨d, rfl⟩ : p i ∣ b ∨ p i ∣ c\n    exact hpi.dvd_or_dvd ⟨a, by rw [← hbc, mul_comm]⟩\n    · rw [mul_assoc, mul_comm a, mul_right_inj' hpi.ne_zero] at hbc\n      exact\n        ⟨insert i t, u, d, c, by rw [insert_union, htus], disjoint_insert_left.2 ⟨hiu, htu⟩, by\n          simp [hbc, prod_insert hit, mul_assoc, mul_comm, mul_left_comm]⟩\n    · rw [← mul_assoc, mul_right_comm b, mul_left_inj' hpi.ne_zero] at hbc\n      exact\n        ⟨t, insert i u, b, d, by rw [union_insert, htus], disjoint_insert_right.2 ⟨hit, htu⟩, by\n          simp [← hbc, prod_insert hiu, mul_assoc, mul_comm, mul_left_comm]⟩\n#align mul_eq_mul_prime_prod mul_eq_mul_prime_prod\n-/\n\n",
 "mul_eq_mul_prime_pow":
 "#print mul_eq_mul_prime_pow /-\n/-- If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written\n  as the product of a power of `p` and a divisor of `a`. -/\ntheorem mul_eq_mul_prime_pow {x y a p : R} {n : ℕ} (hp : Prime p) (hx : x * y = a * p ^ n) :\n    ∃ (i j : ℕ)(b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j :=\n  by\n  rcases mul_eq_mul_prime_prod (fun _ _ => hp) (show x * y = a * (range n).prod fun _ => p by simpa) with\n    ⟨t, u, b, c, htus, htu, rfl, rfl, rfl⟩\n  exact ⟨t.card, u.card, b, c, by rw [← card_disjoint_union htu, htus, card_range], by simp⟩\n#align mul_eq_mul_prime_pow mul_eq_mul_prime_pow\n-/\n\n",
 "abs":
 "#print Prime.abs /-\ntheorem Prime.abs [linear_order α] {p : α} (hp : Prime p) : Prime (abs p) :=\n  by\n  obtain h | h := abs_choice p <;> rw [h]\n  · exact hp\n  · exact hp.neg\n#align prime.abs Prime.abs\n-/\n\n"}