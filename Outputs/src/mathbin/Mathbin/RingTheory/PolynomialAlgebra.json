{"to_fun_linear_tmul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n@[simp]\ntheorem to_fun_linear_tmul_apply (a : A) (p : polynomial R) :\n    to_fun_linear R A («expr ⊗ₜ[ ] » a R p) = to_fun_bilinear R A a p :=\n  rfl\n#align to_fun_linear_tmul_apply to_fun_linear_tmul_apply\n\n",
 "to_fun_linear_mul_tmul_mul_aux_2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem to_fun_linear_mul_tmul_mul_aux_2 (k : ℕ) (a₁ a₂ : A) (p₁ p₂ : polynomial R) :\n    a₁ * a₂ * (algebraMap R A) ((p₁ * p₂).coeff k) =\n      (Finset.Nat.antidiagonal k).sum fun x =>\n        a₁ * (algebraMap R A) (coeff p₁ x.1) * (a₂ * (algebraMap R A) (coeff p₂ x.2)) :=\n  by\n  simp_rw [mul_assoc, Algebra.commutes, ← Finset.mul_sum, mul_assoc, ← Finset.mul_sum]\n  congr\n  simp_rw [Algebra.commutes (coeff p₂ _), coeff_mul, RingHom.map_sum, RingHom.map_mul]\n#align to_fun_linear_mul_tmul_mul_aux_2 to_fun_linear_mul_tmul_mul_aux_2\n\n",
 "to_fun_linear_mul_tmul_mul_aux_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n-- We apparently need to provide the decidable instance here\n-- in order to successfully rewrite by this lemma.\ntheorem to_fun_linear_mul_tmul_mul_aux_1 (p : polynomial R) (k : ℕ) (h : Decidable ¬p.coeff k = 0) (a : A) :\n    ite (¬coeff p k = 0) (a * (algebraMap R A) (coeff p k)) 0 = a * (algebraMap R A) (coeff p k) := by\n  classical split_ifs <;> simp [*]\n#align to_fun_linear_mul_tmul_mul_aux_1 to_fun_linear_mul_tmul_mul_aux_1\n\n",
 "to_fun_linear_mul_tmul_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\ntheorem to_fun_linear_mul_tmul_mul (a₁ a₂ : A) (p₁ p₂ : polynomial R) :\n    (to_fun_linear R A) («expr ⊗ₜ[ ] » (a₁ * a₂) R (p₁ * p₂)) =\n      (to_fun_linear R A) («expr ⊗ₜ[ ] » a₁ R p₁) * (to_fun_linear R A) («expr ⊗ₜ[ ] » a₂ R p₂) :=\n  by\n  classical\n    simp only [to_fun_linear_tmul_apply, to_fun_bilinear_apply_eq_sum]\n    ext k\n    simp_rw [coeff_sum, coeff_monomial, sum_def, Finset.sum_ite_eq', mem_support_iff, ne.def]\n    conv_rhs => rw [coeff_mul]\n    simp_rw [finset_sum_coeff, coeff_monomial, Finset.sum_ite_eq', mem_support_iff, ne.def, mul_ite,\n      MulZeroClass.mul_zero, ite_mul, MulZeroClass.zero_mul]\n    simp_rw [ite_mul_zero_left (¬coeff p₁ _ = 0) (a₁ * (algebraMap R A) (coeff p₁ _))]\n    simp_rw [ite_mul_zero_right (¬coeff p₂ _ = 0) _ (_ * _)]\n    simp_rw [to_fun_linear_mul_tmul_mul_aux_1, to_fun_linear_mul_tmul_mul_aux_2]\n#align to_fun_linear_mul_tmul_mul to_fun_linear_mul_tmul_mul\n\n",
 "to_fun_linear_algebra_map_tmul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem to_fun_linear_algebra_map_tmul_one (r : R) :\n    (to_fun_linear R A) («expr ⊗ₜ[ ] » ((algebraMap R A) r) R 1) = (algebraMap R (polynomial A)) r := by\n  rw [to_fun_linear_tmul_apply, to_fun_bilinear_apply_apply, Polynomial.aeval_one, algebraMap_smul,\n    Algebra.algebraMap_eq_smul_one]\n#align to_fun_linear_algebra_map_tmul_one to_fun_linear_algebra_map_tmul_one\n\n",
 "to_fun_bilinear_apply_eq_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\ntheorem to_fun_bilinear_apply_eq_sum (a : A) (p : polynomial R) :\n    to_fun_bilinear R A a p = p.sum fun n r => monomial n (a * algebraMap R A r) :=\n  by\n  simp only [to_fun_bilinear_apply_apply, aeval_def, eval₂_eq_sum, Polynomial.sum, Finset.smul_sum]\n  congr with i : 1\n  rw [← Algebra.smul_def, ← C_mul', mul_smul_comm, C_mul_X_pow_eq_monomial, ← Algebra.commutes, ← Algebra.smul_def,\n    smul_monomial]\n#align to_fun_bilinear_apply_eq_sum to_fun_bilinear_apply_eq_sum\n\n",
 "to_fun_alg_hom_apply_tmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n@[simp]\ntheorem to_fun_alg_hom_apply_tmul (a : A) (p : polynomial R) :\n    to_fun_alg_hom R A («expr ⊗ₜ[ ] » a R p) = p.sum fun n r => monomial n (a * (algebraMap R A) r) :=\n  to_fun_bilinear_apply_eq_sum R A _ _\n#align to_fun_alg_hom_apply_tmul to_fun_alg_hom_apply_tmul\n\n",
 "support_subset_support_mat_poly_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem support_subset_support_mat_poly_equiv (m : Matrix n n (polynomial R)) (i j : n) :\n    support (m i j) ⊆ support (mat_poly_equiv m) := by\n  intro k\n  contrapose\n  simp only [not_mem_support_iff]\n  intro hk\n  rw [← mat_poly_equiv_coeff_apply, hk]\n  rfl\n#align support_subset_support_mat_poly_equiv support_subset_support_mat_poly_equiv\n\n",
 "right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem right_inv (x : polynomial A) : (to_fun_alg_hom R A) (inv_fun R A x) = x :=\n  by\n  apply Polynomial.induction_on' x\n  · intro p q hp hq\n    simp only [inv_fun_add, AlgHom.map_add, hp, hq]\n  · intro n a\n    rw [inv_fun_monomial, algebra.tensor_product.include_left_apply, algebra.tensor_product.tmul_pow, one_pow,\n        algebra.tensor_product.tmul_mul_tmul, mul_one, one_mul, to_fun_alg_hom_apply_tmul, X_pow_eq_monomial,\n        sum_monomial_index] <;>\n      simp\n#align right_inv right_inv\n\n",
 "poly_equiv_tensor_symm_apply_tmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n@[simp]\ntheorem poly_equiv_tensor_symm_apply_tmul (a : A) (p : polynomial R) :\n    (poly_equiv_tensor R A).symm («expr ⊗ₜ » a p) = p.sum fun n r => monomial n (a * algebraMap R A r) :=\n  to_fun_alg_hom_apply_tmul _ _ _ _\n#align poly_equiv_tensor_symm_apply_tmul poly_equiv_tensor_symm_apply_tmul\n\n",
 "poly_equiv_tensor_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem poly_equiv_tensor_apply (p : polynomial A) :\n    poly_equiv_tensor R A p =\n      p.eval₂ (include_left : «expr →ₐ[ ] » A R (tensor_product A R (polynomial R)))\n        («expr ⊗ₜ[ ] » (1 : A) R (X : polynomial R)) :=\n  rfl\n#align poly_equiv_tensor_apply poly_equiv_tensor_apply\n\n",
 "mat_poly_equiv_symm_apply_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem mat_poly_equiv_symm_apply_coeff (p : polynomial (Matrix n n R)) (i j : n) (k : ℕ) :\n    coeff (mat_poly_equiv.symm p i j) k = coeff p k i j :=\n  by\n  have t : p = mat_poly_equiv (mat_poly_equiv.symm p) := by simp\n  conv_rhs => rw [t]\n  simp only [mat_poly_equiv_coeff_apply]\n#align mat_poly_equiv_symm_apply_coeff mat_poly_equiv_symm_apply_coeff\n\n",
 "mat_poly_equiv_smul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mat_poly_equiv_smul_one (p : polynomial R) :\n    mat_poly_equiv («expr • » p 1) = p.map (algebraMap R (Matrix n n R)) :=\n  by\n  ext (m i j)\n  simp only [coeff_map, one_apply, algebra_map_matrix_apply, mul_boole, Pi.smul_apply, mat_poly_equiv_coeff_apply]\n  split_ifs <;> simp\n#align mat_poly_equiv_smul_one mat_poly_equiv_smul_one\n\n",
 "mat_poly_equiv_coeff_apply_aux_2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mat_poly_equiv_coeff_apply_aux_2 (i j : n) (p : polynomial R) (k : ℕ) :\n    coeff (mat_poly_equiv (stdBasisMatrix i j p)) k = stdBasisMatrix i j (coeff p k) :=\n  by\n  apply Polynomial.induction_on' p\n  · intro p q hp hq\n    ext\n    simp [hp, hq, coeff_add, add_apply, std_basis_matrix_add]\n  · intro k x\n    simp only [mat_poly_equiv_coeff_apply_aux_1, coeff_monomial]\n    split_ifs <;>\n      · funext\n        simp\n#align mat_poly_equiv_coeff_apply_aux_2 mat_poly_equiv_coeff_apply_aux_2\n\n",
 "mat_poly_equiv_coeff_apply_aux_1":
 "theorem mat_poly_equiv_coeff_apply_aux_1 (i j : n) (k : ℕ) (x : R) :\n    mat_poly_equiv (stdBasisMatrix i j <| monomial k x) = monomial k (stdBasisMatrix i j x) :=\n  by\n  simp only [mat_poly_equiv, AlgEquiv.trans_apply, matrix_equiv_tensor_apply_std_basis]\n  apply (poly_equiv_tensor R (Matrix n n R)).injective\n  simp only [AlgEquiv.apply_symm_apply]\n  convert algebra.tensor_product.comm_tmul _ _ _ _ _\n  simp only [poly_equiv_tensor_apply]\n  convert eval₂_monomial _ _\n  simp only [algebra.tensor_product.tmul_mul_tmul, one_pow, one_mul, Matrix.mul_one, algebra.tensor_product.tmul_pow,\n    algebra.tensor_product.include_left_apply, mul_eq_mul]\n  rw [← smul_X_eq_monomial, ← TensorProduct.smul_tmul]\n  congr with (i' j') <;> simp\n#align mat_poly_equiv_coeff_apply_aux_1 mat_poly_equiv_coeff_apply_aux_1\n\n",
 "mat_poly_equiv_coeff_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem mat_poly_equiv_coeff_apply (m : Matrix n n (polynomial R)) (k : ℕ) (i j : n) :\n    coeff (mat_poly_equiv m) k i j = coeff (m i j) k :=\n  by\n  apply Matrix.induction_on' m\n  · simp\n  · intro p q hp hq\n    simp [hp, hq]\n  · intro i' j' x\n    erw [mat_poly_equiv_coeff_apply_aux_2]\n    dsimp [std_basis_matrix]\n    split_ifs\n    · rcases h with ⟨rfl, rfl⟩\n      simp [std_basis_matrix]\n    · simp [std_basis_matrix, h]\n#align mat_poly_equiv_coeff_apply mat_poly_equiv_coeff_apply\n\n",
 "left_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product.infer -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem left_inv (x : tensor_product.infer A (polynomial R)) : inv_fun R A ((to_fun_alg_hom R A) x) = x :=\n  by\n  apply TensorProduct.induction_on x\n  · simp [inv_fun]\n  · intro a p\n    dsimp only [inv_fun]\n    rw [to_fun_alg_hom_apply_tmul, eval₂_sum]\n    simp_rw [eval₂_monomial, AlgHom.coe_toRingHom, algebra.tensor_product.tmul_pow, one_pow,\n      algebra.tensor_product.include_left_apply, algebra.tensor_product.tmul_mul_tmul, mul_one, one_mul, ←\n      Algebra.commutes, ← Algebra.smul_def, smul_tmul, sum_def, ← tmul_sum]\n    conv_rhs => rw [← sum_C_mul_X_pow_eq p]\n    simp only [Algebra.smul_def]\n    rfl\n  · intro p q hp hq\n    simp only [AlgHom.map_add, inv_fun_add, hp, hq]\n#align left_inv left_inv\n\n",
 "inv_fun_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem inv_fun_monomial (n : ℕ) (a : A) :\n    inv_fun R A (monomial n a) = include_left a * «expr ⊗ₜ[ ] » (1 : A) R (X : polynomial R) ^ n :=\n  eval₂_monomial _ _\n#align inv_fun_monomial inv_fun_monomial\n\n",
 "inv_fun_add":
 "@[simp]\ntheorem inv_fun_add {p q} : inv_fun R A (p + q) = inv_fun R A p + inv_fun R A q := by simp only [inv_fun, eval₂_add]\n#align inv_fun_add inv_fun_add\n\n"}