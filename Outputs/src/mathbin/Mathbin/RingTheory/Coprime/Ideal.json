{"supr_infi_eq_top_iff_pairwise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2022 Pierre-Alexandre Bazin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Pierre-Alexandre Bazin\n-/\n/-- A finite family of ideals is pairwise coprime (that is, any two of them generate the whole ring)\niff when taking all the possible intersections of all but one of these ideals, the resulting family\nof ideals still generate the whole ring.\n\nFor example with three ideals : `I ⊔ J = I ⊔ K = J ⊔ K = ⊤ ↔ (I ⊓ J) ⊔ (I ⊓ K) ⊔ (J ⊓ K) = ⊤`.\n\nWhen ideals are all of the form `I i = R ∙ s i`, this is equivalent to the\n`exists_sum_eq_one_iff_pairwise_coprime` lemma.-/\ntheorem supr_infi_eq_top_iff_pairwise {t : Finset ι} (h : t.nonempty) (I : ι → Ideal R) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (I j)) =\n        «expr⊤» ↔\n      (t : Set ι).pairwise fun i j => «expr ⊔ » (I i) (I j) = «expr⊤» :=\n  by\n  haveI : DecidableEq ι := Classical.decEq ι\n  rw [eq_top_iff_one, Submodule.mem_supᵢ_finset_iff_exists_sum]\n  refine' h.cons_induction _ _ <;> clear t h\n  · simp only [Finset.sum_singleton, Finset.coe_singleton, Set.pairwise_singleton, iff_true_iff]\n    refine' fun a => ⟨fun i => if h : i = a then ⟨1, _⟩ else 0, _⟩\n    · rw [h]\n      simp only [Finset.mem_singleton, ne.def, infᵢ_infᵢ_eq_left, eq_self_iff_true, not_true, infᵢ_false]\n    · simp only [dif_pos, dif_ctx_congr, Submodule.coe_mk, eq_self_iff_true]\n  intro a t hat h ih\n  rw [Finset.coe_cons,\n    Set.pairwise_insert_of_symmetric fun i j (h : «expr ⊔ » (I i) (I j) = «expr⊤») => sup_comm.trans h]\n  constructor\n  · rintro ⟨μ, hμ⟩\n    rw [Finset.sum_cons] at hμ\n    refine' ⟨ih.mp ⟨Pi.single h.some ⟨μ a, _⟩ + fun i => ⟨μ i, _⟩, _⟩, fun b hb ab => _⟩\n    · have := Submodule.coe_mem (μ a)\n      rw [mem_infi] at this⊢\n      --for some reason `simp only [mem_infi]` times out\n      intro i\n      specialize this i\n      rw [mem_infi, mem_infi] at this⊢\n      intro hi _\n      apply this (Finset.subset_cons _ hi)\n      rintro rfl\n      exact hat hi\n    · have := Submodule.coe_mem (μ i)\n      simp only [mem_infi] at this⊢\n      intro j hj ij\n      exact this _ (Finset.subset_cons _ hj) ij\n    · rw [← @if_pos _ _ h.some_spec R (μ a) 0, ← Finset.sum_pi_single', ← Finset.sum_add_distrib] at hμ\n      convert hμ\n      ext i\n      rw [Pi.add_apply, Submodule.coe_add, Submodule.coe_mk]\n      by_cases hi : i = h.some\n      · rw [hi, Pi.single_eq_same, Pi.single_eq_same, Submodule.coe_mk]\n      · rw [Pi.single_eq_of_ne hi, Pi.single_eq_of_ne hi, Submodule.coe_zero]\n    · rw [eq_top_iff_one, Submodule.mem_sup]\n      rw [add_comm] at hμ\n      refine' ⟨_, _, _, _, hμ⟩\n      · refine' sum_mem _ fun x hx => _\n        have := Submodule.coe_mem (μ x)\n        simp only [mem_infi] at this\n        apply this _ (Finset.mem_cons_self _ _)\n        rintro rfl\n        exact hat hx\n      · have := Submodule.coe_mem (μ a)\n        simp only [mem_infi] at this\n        exact this _ (Finset.subset_cons _ hb) ab.symm\n  · rintro ⟨hs, Hb⟩\n    obtain ⟨μ, hμ⟩ := ih.mpr hs\n    have := sup_infi_eq_top fun b hb => Hb b hb (ne_of_mem_of_not_mem hb hat).symm\n    rw [eq_top_iff_one, Submodule.mem_sup] at this\n    obtain ⟨u, hu, v, hv, huv⟩ := this\n    refine' ⟨fun i => if hi : i = a then ⟨v, _⟩ else ⟨u * μ i, _⟩, _⟩\n    · simp only [mem_infi] at hv⊢\n      intro j hj ij\n      rw [Finset.mem_cons, ← hi] at hj\n      exact hv _ (hj.resolve_left ij)\n    · have := Submodule.coe_mem (μ i)\n      simp only [mem_infi] at this⊢\n      intro j hj ij\n      rcases finset.mem_cons.mp hj with (rfl | hj)\n      · exact mul_mem_right _ _ hu\n      · exact mul_mem_left _ _ (this _ hj ij)\n    · rw [Finset.sum_cons, dif_pos rfl, add_comm]\n      rw [← mul_one u] at huv\n      rw [← huv, ← hμ, Finset.mul_sum]\n      congr 1\n      apply Finset.sum_congr rfl\n      intro j hj\n      rw [dif_neg]\n      rfl\n      rintro rfl\n      exact hat hj\n#align supr_infi_eq_top_iff_pairwise supr_infi_eq_top_iff_pairwise\n\n"}