{"prod_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print IsCoprime.prod_right_iff /-\ntheorem IsCoprime.prod_right_iff :\n    IsCoprime x\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (s i)) ↔\n      ∀ i ∈ t, IsCoprime x (s i) :=\n  by simpa only [isCoprime_comm] using IsCoprime.prod_left_iff\n#align is_coprime.prod_right_iff IsCoprime.prod_right_iff\n-/\n\n",
 "prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print IsCoprime.prod_right /-\ntheorem IsCoprime.prod_right :\n    (∀ i ∈ t, IsCoprime x (s i)) →\n      IsCoprime x\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (s i)) :=\n  by simpa only [isCoprime_comm] using IsCoprime.prod_left\n#align is_coprime.prod_right IsCoprime.prod_right\n-/\n\n",
 "prod_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print IsCoprime.prod_left_iff /-\ntheorem IsCoprime.prod_left_iff :\n    IsCoprime\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (s i)) x ↔\n      ∀ i ∈ t, IsCoprime (s i) x :=\n  Finset.induction_on t (iff_of_true isCoprime_one_left fun _ => false.elim) fun b t hbt ih => by\n    rw [Finset.prod_insert hbt, IsCoprime.mul_left_iff, ih, Finset.forall_mem_insert]\n#align is_coprime.prod_left_iff IsCoprime.prod_left_iff\n-/\n\n",
 "prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print IsCoprime.prod_left /-\ntheorem IsCoprime.prod_left :\n    (∀ i ∈ t, IsCoprime (s i) x) →\n      IsCoprime\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (s i)) x :=\n  Finset.induction_on t (fun _ => isCoprime_one_left) fun b t hbt ih H =>\n    by\n    rw [Finset.prod_insert hbt]\n    rw [Finset.forall_mem_insert] at H\n    exact H.1.mul_left (ih H.2)\n#align is_coprime.prod_left IsCoprime.prod_left\n-/\n\n",
 "prod_dvd_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print Fintype.prod_dvd_of_coprime /-\ntheorem Fintype.prod_dvd_of_coprime [Fintype I] (Hs : Pairwise («expr on » IsCoprime s)) (Hs1 : ∀ i, s i ∣ z) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (s x) ∣\n      z :=\n  Finset.prod_dvd_of_coprime (Hs.set_pairwise _) fun i _ => Hs1 i\n#align fintype.prod_dvd_of_coprime Fintype.prod_dvd_of_coprime\n-/\n\n",
 "pow_right_iff":
 "#print IsCoprime.pow_right_iff /-\ntheorem IsCoprime.pow_right_iff (hm : 0 < m) : IsCoprime x (y ^ m) ↔ IsCoprime x y :=\n  isCoprime_comm.trans <| (IsCoprime.pow_left_iff hm).trans <| isCoprime_comm\n#align is_coprime.pow_right_iff IsCoprime.pow_right_iff\n-/\n\n",
 "pow_right":
 "#print IsCoprime.pow_right /-\ntheorem IsCoprime.pow_right (H : IsCoprime x y) : IsCoprime x (y ^ n) :=\n  by\n  rw [← Finset.card_range n, ← Finset.prod_const]\n  exact IsCoprime.prod_right fun _ _ => H\n#align is_coprime.pow_right IsCoprime.pow_right\n-/\n\n",
 "pow_left_iff":
 "#print IsCoprime.pow_left_iff /-\ntheorem IsCoprime.pow_left_iff (hm : 0 < m) : IsCoprime (x ^ m) y ↔ IsCoprime x y :=\n  by\n  refine' ⟨fun h => _, IsCoprime.pow_left⟩\n  rw [← Finset.card_range m, ← Finset.prod_const] at h\n  exact h.of_prod_left 0 (finset.mem_range.mpr hm)\n#align is_coprime.pow_left_iff IsCoprime.pow_left_iff\n-/\n\n",
 "pow_left":
 "#print IsCoprime.pow_left /-\ntheorem IsCoprime.pow_left (H : IsCoprime x y) : IsCoprime (x ^ m) y :=\n  by\n  rw [← Finset.card_range m, ← Finset.prod_const]\n  exact IsCoprime.prod_left fun _ _ => H\n#align is_coprime.pow_left IsCoprime.pow_left\n-/\n\n",
 "pow_iff":
 "#print IsCoprime.pow_iff /-\ntheorem IsCoprime.pow_iff (hm : 0 < m) (hn : 0 < n) : IsCoprime (x ^ m) (y ^ n) ↔ IsCoprime x y :=\n  (IsCoprime.pow_left_iff hm).trans <| IsCoprime.pow_right_iff hn\n#align is_coprime.pow_iff IsCoprime.pow_iff\n-/\n\n",
 "pow":
 "#print IsCoprime.pow /-\ntheorem IsCoprime.pow (H : IsCoprime x y) : IsCoprime (x ^ m) (y ^ n) :=\n  H.pow_left.pow_right\n#align is_coprime.pow IsCoprime.pow\n-/\n\n",
 "pairwise_coprime_iff_coprime_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print pairwise_coprime_iff_coprime_prod /-\ntheorem pairwise_coprime_iff_coprime_prod [DecidableEq I] :\n    Pairwise («expr on » IsCoprime fun i : t => s i) ↔\n      ∀ i ∈ t,\n        IsCoprime (s i)\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t \\ {i})\n            (s j)) :=\n  by\n  refine' ⟨fun hp i hi => is_coprime.prod_right_iff.mpr fun j hj => _, fun hp => _⟩\n  · rw [Finset.mem_sdiff, Finset.mem_singleton] at hj\n    obtain ⟨hj, ji⟩ := hj\n    exact @hp ⟨i, hi⟩ ⟨j, hj⟩ fun h => ji (congr_arg coe h).symm\n  · rintro ⟨i, hi⟩ ⟨j, hj⟩ h\n    apply is_coprime.prod_right_iff.mp (hp i hi)\n    exact finset.mem_sdiff.mpr ⟨hj, fun f => h <| Subtype.ext (finset.mem_singleton.mp f).symm⟩\n#align pairwise_coprime_iff_coprime_prod pairwise_coprime_iff_coprime_prod\n-/\n\n",
 "of_prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print IsCoprime.of_prod_right /-\ntheorem IsCoprime.of_prod_right\n    (H1 :\n      IsCoprime x\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (s i)))\n    (i : I) (hit : i ∈ t) : IsCoprime x (s i) :=\n  IsCoprime.prod_right_iff.1 H1 i hit\n#align is_coprime.of_prod_right IsCoprime.of_prod_right\n-/\n\n",
 "of_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print IsCoprime.of_prod_left /-\ntheorem IsCoprime.of_prod_left\n    (H1 :\n      IsCoprime\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (s i)) x)\n    (i : I) (hit : i ∈ t) : IsCoprime (s i) x :=\n  IsCoprime.prod_left_iff.1 H1 i hit\n#align is_coprime.of_prod_left IsCoprime.of_prod_left\n-/\n\n",
 "isCoprime_iff_coprime":
 "#print Nat.isCoprime_iff_coprime /-\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Ken Lee, Chris Hughes\n-/\ntheorem Nat.isCoprime_iff_coprime {m n : ℕ} : IsCoprime (m : ℤ) n ↔ Nat.coprime m n :=\n  ⟨fun ⟨a, b, H⟩ =>\n    nat.eq_one_of_dvd_one <|\n      Int.coe_nat_dvd.1 <| by\n        rw [Int.ofNat_one, ← H]\n        exact\n          dvd_add (dvd_mul_of_dvd_right (Int.coe_nat_dvd.2 <| Nat.gcd_dvd_left m n) _)\n            (dvd_mul_of_dvd_right (Int.coe_nat_dvd.2 <| Nat.gcd_dvd_right m n) _),\n    fun H =>\n    ⟨Nat.gcdA m n, Nat.gcdB m n, by\n      rw [mul_comm _ (m : ℤ), mul_comm _ (n : ℤ), ← Nat.gcd_eq_gcd_ab, show _ = _ from H, Int.ofNat_one]⟩⟩\n#align nat.is_coprime_iff_coprime Nat.isCoprime_iff_coprime\n-/\n\n",
 "exists_sum_eq_one_iff_pairwise_coprime'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n#print exists_sum_eq_one_iff_pairwise_coprime' /-\ntheorem exists_sum_eq_one_iff_pairwise_coprime' [Fintype I] [Nonempty I] [DecidableEq I] :\n    (∃ μ : I → R,\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (μ i *\n              finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                («expr ᶜ» {i}) (s j)) =\n          1) ↔\n      Pairwise («expr on » IsCoprime s) :=\n  by\n  convert exists_sum_eq_one_iff_pairwise_coprime Finset.univ_nonempty using 1\n  simp only [function.on_fun, pairwise_subtype_iff_pairwise_finset', coe_univ, Set.pairwise_univ]\n  assumption\n#align exists_sum_eq_one_iff_pairwise_coprime' exists_sum_eq_one_iff_pairwise_coprime'\n-/\n\n",
 "exists_sum_eq_one_iff_pairwise_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n#print exists_sum_eq_one_iff_pairwise_coprime /-\ntheorem exists_sum_eq_one_iff_pairwise_coprime [DecidableEq I] (h : t.nonempty) :\n    (∃ μ : I → R,\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            (μ i *\n              finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                (t \\ {i}) (s j)) =\n          1) ↔\n      Pairwise («expr on » IsCoprime fun i : t => s i) :=\n  by\n  refine' h.cons_induction _ _ <;> clear t h\n  · simp only [Pairwise, sum_singleton, Finset.sdiff_self, prod_empty, mul_one, exists_apply_eq_apply, ne.def,\n      true_iff_iff]\n    rintro a ⟨i, hi⟩ ⟨j, hj⟩ h\n    rw [Finset.mem_singleton] at hi hj\n    simpa [hi, hj] using h\n  intro a t hat h ih\n  rw [pairwise_cons']\n  have mem : ∀ x ∈ t, a ∈ insert a t \\ {x} := fun x hx =>\n    by\n    rw [mem_sdiff, mem_singleton]\n    exact ⟨mem_insert_self _ _, fun ha => hat (ha.symm.cases_on hx)⟩\n  constructor\n  · rintro ⟨μ, hμ⟩\n    rw [sum_cons, cons_eq_insert, sdiff_singleton_eq_erase, erase_insert hat] at hμ\n    refine' ⟨ih.mp ⟨Pi.single h.some (μ a * s h.some) + μ * fun _ => s a, _⟩, fun b hb => _⟩\n    · rw [prod_eq_mul_prod_diff_singleton h.some_spec, ← mul_assoc, ← @if_pos _ _ h.some_spec R (_ * _) 0, ←\n        sum_pi_single', ← sum_add_distrib] at hμ\n      rw [← hμ, sum_congr rfl]\n      intro x hx\n      convert@add_mul R _ _ _ _ _ _ using 2\n      · by_cases hx : x = h.some\n        · rw [hx, Pi.single_eq_same, Pi.single_eq_same]\n        · rw [Pi.single_eq_of_ne hx, Pi.single_eq_of_ne hx, MulZeroClass.zero_mul]\n      · convert(mul_assoc _ _ _).symm\n        convert prod_eq_mul_prod_diff_singleton (mem x hx) _ using 3\n        convert sdiff_sdiff_comm\n        rw [sdiff_singleton_eq_erase, erase_insert hat]\n    · have : IsCoprime (s b) (s a) :=\n        ⟨μ a *\n            finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t \\ {b})\n              (s i),\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            (μ i *\n              finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                (t \\ {i}) (s j)),\n          _⟩\n      · exact ⟨this.symm, this⟩\n      rw [mul_assoc, ← prod_eq_prod_diff_singleton_mul hb, sum_mul, ← hμ, sum_congr rfl]\n      intro x hx\n      convert mul_assoc _ _ _\n      convert prod_eq_prod_diff_singleton_mul (mem x hx) _ using 3\n      convert sdiff_sdiff_comm\n      rw [sdiff_singleton_eq_erase, erase_insert hat]\n  · rintro ⟨hs, Hb⟩\n    obtain ⟨μ, hμ⟩ := ih.mpr hs\n    obtain ⟨u, v, huv⟩ := IsCoprime.prod_left fun b hb => (Hb b hb).right\n    use fun i => if i = a then u else v * μ i\n    have hμ' :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n          (v *\n            (μ i *\n                finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                  (t \\ {i}) (s j) *\n              s a)) =\n        v * s a :=\n      by rw [← mul_sum, ← sum_mul, hμ, one_mul]\n    rw [sum_cons, cons_eq_insert, sdiff_singleton_eq_erase, erase_insert hat, if_pos rfl, ← huv, ← hμ', sum_congr rfl]\n    intro x hx\n    rw [mul_assoc, if_neg fun ha : x = a => hat (ha.cases_on hx)]\n    convert mul_assoc _ _ _\n    convert(prod_eq_prod_diff_singleton_mul (mem x hx) _).symm using 3\n    convert sdiff_sdiff_comm\n    rw [sdiff_singleton_eq_erase, erase_insert hat]\n#align exists_sum_eq_one_iff_pairwise_coprime exists_sum_eq_one_iff_pairwise_coprime\n-/\n\n"}