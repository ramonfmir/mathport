{"variance":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A certain linear combination of the previous three identities,\nwhich we'll want later.\n-/\ntheorem variance (n : ℕ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1)) ((«expr • » n Polynomial.X - ν) ^ 2 * bernstein_polynomial R n ν) =\n      «expr • » n Polynomial.X * (1 - Polynomial.X) :=\n  by\n  have p :\n    ((((Finset.range (n + 1)).sum fun ν => «expr • » (ν * (ν - 1)) (bernstein_polynomial R n ν)) +\n          (1 - «expr • » (2 * n) Polynomial.X) *\n            (Finset.range (n + 1)).sum fun ν => «expr • » ν (bernstein_polynomial R n ν)) +\n        «expr • » (n ^ 2) (X ^ 2) * (Finset.range (n + 1)).sum fun ν => bernstein_polynomial R n ν) =\n      _ :=\n    rfl\n  conv at p =>\n    lhs\n    rw [Finset.mul_sum, Finset.mul_sum, ← Finset.sum_add_distrib, ← Finset.sum_add_distrib]\n    simp only [← nat_cast_mul]\n    simp only [← mul_assoc]\n    simp only [← add_mul]\n  conv at p =>\n    rhs\n    rw [Sum, sum_smul, sum_mul_smul, ← nat_cast_mul]\n  calc\n    _ = _ := Finset.sum_congr rfl fun k m => _\n    _ = _ := p\n    _ = _ := _\n    \n  · congr 1\n    simp only [← nat_cast_mul, push_cast]\n    cases k <;>\n      · simp\n        ring\n  · simp only [← nat_cast_mul, push_cast]\n    cases n\n    · simp\n    · simp\n      ring\n#align variance variance\n\n",
 "sum_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sum_smul (n : ℕ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1)) («expr • » ν (bernstein_polynomial R n ν)) =\n      «expr • » n X :=\n  by\n  -- We calculate the `x`-derivative of `(x+y)^n`, evaluated at `y=(1-x)`,\n  -- either directly or by using the binomial theorem.\n  -- We'll work in `mv_polynomial bool R`.\n  let x : MvPolynomial Bool R := MvPolynomial.X tt\n  let y : MvPolynomial Bool R := MvPolynomial.X ff\n  have pderiv_tt_x : pderiv tt x = 1 := by\n    rw [pderiv_X]\n    rfl\n  have pderiv_tt_y : pderiv tt y = 0 := by\n    rw [pderiv_X]\n    rfl\n  let e : Bool → polynomial R := fun i => cond i X (1 - X)\n  -- Start with `(x+y)^n = (x+y)^n`,\n  -- take the `x`-derivative, evaluate at `x=X, y=1-X`, and multiply by `X`:\n  trans aeval e (pderiv tt ((x + y) ^ n)) * X\n  -- On the left hand side we'll use the binomial theorem, then simplify.\n  · -- We first prepare a tedious rewrite:\n    have w :\n      ∀ k : ℕ,\n        «expr • » k (bernstein_polynomial R n k) =\n          ↑k * Polynomial.X ^ (k - 1) * (1 - Polynomial.X) ^ (n - k) * ↑(n.choose k) * Polynomial.X :=\n      by\n      rintro (_ | k)\n      · simp\n      · rw [bernstein_polynomial]\n        simp only [← nat_cast_mul, nat.succ_eq_add_one, Nat.add_succ_sub_one, add_zero, pow_succ]\n        push_cast\n        ring\n    rw [add_pow, (pderiv tt).map_sum, (MvPolynomial.aeval e).map_sum, Finset.sum_mul]\n    -- Step inside the sum:\n    refine' Finset.sum_congr rfl fun k hk => (w k).trans _\n    simp only [pderiv_tt_x, pderiv_tt_y, Algebra.id.smul_eq_mul, nsmul_eq_mul, e, Bool.cond_true, Bool.cond_false,\n      add_zero, mul_one, MulZeroClass.mul_zero, smul_zero, MvPolynomial.aeval_X, mv_polynomial.pderiv_mul,\n      derivation.leibniz_pow, derivation.map_coe_nat, map_natCast, map_pow, map_mul]\n  · rw [(pderiv tt).leibniz_pow, (pderiv tt).map_add, pderiv_tt_x, pderiv_tt_y]\n    simp only [Algebra.id.smul_eq_mul, nsmul_eq_mul, map_natCast, map_pow, map_add, map_mul, e, Bool.cond_true,\n      Bool.cond_false, MvPolynomial.aeval_X, add_sub_cancel'_right, one_pow, add_zero, mul_one]\n#align sum_smul sum_smul\n\n",
 "sum_mul_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sum_mul_smul (n : ℕ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1)) («expr • » (ν * (ν - 1)) (bernstein_polynomial R n ν)) =\n      «expr • » (n * (n - 1)) (X ^ 2) :=\n  by\n  -- We calculate the second `x`-derivative of `(x+y)^n`, evaluated at `y=(1-x)`,\n  -- either directly or by using the binomial theorem.\n  -- We'll work in `mv_polynomial bool R`.\n  let x : MvPolynomial Bool R := MvPolynomial.X tt\n  let y : MvPolynomial Bool R := MvPolynomial.X ff\n  have pderiv_tt_x : pderiv tt x = 1 := by\n    rw [pderiv_X]\n    rfl\n  have pderiv_tt_y : pderiv tt y = 0 := by\n    rw [pderiv_X]\n    rfl\n  let e : Bool → polynomial R := fun i => cond i X (1 - X)\n  -- Start with `(x+y)^n = (x+y)^n`,\n  -- take the second `x`-derivative, evaluate at `x=X, y=1-X`, and multiply by `X`:\n  trans aeval e (pderiv tt (pderiv tt ((x + y) ^ n))) * X ^ 2\n  -- On the left hand side we'll use the binomial theorem, then simplify.\n  · -- We first prepare a tedious rewrite:\n    have w :\n      ∀ k : ℕ,\n        «expr • » (k * (k - 1)) (bernstein_polynomial R n k) =\n          ↑(n.choose k) * ((1 - Polynomial.X) ^ (n - k) * (↑k * (↑(k - 1) * Polynomial.X ^ (k - 1 - 1)))) *\n            Polynomial.X ^ 2 :=\n      by\n      rintro (_ | _ | k)\n      · simp\n      · simp\n      · rw [bernstein_polynomial]\n        simp only [← nat_cast_mul, nat.succ_eq_add_one, Nat.add_succ_sub_one, add_zero, pow_succ]\n        push_cast\n        ring\n    rw [add_pow, (pderiv tt).map_sum, (pderiv tt).map_sum, (MvPolynomial.aeval e).map_sum, Finset.sum_mul]\n    -- Step inside the sum:\n    refine' Finset.sum_congr rfl fun k hk => (w k).trans _\n    simp only [pderiv_tt_x, pderiv_tt_y, Algebra.id.smul_eq_mul, nsmul_eq_mul, e, Bool.cond_true, Bool.cond_false,\n      add_zero, zero_add, MulZeroClass.mul_zero, smul_zero, mul_one, MvPolynomial.aeval_X, mv_polynomial.pderiv_X_self,\n      mv_polynomial.pderiv_X_of_ne, derivation.leibniz_pow, derivation.leibniz, derivation.map_coe_nat, map_natCast,\n      map_pow, map_mul, map_add]\n  -- On the right hand side, we'll just simplify.\n  ·\n    simp only [pderiv_one, pderiv_mul, (pderiv _).leibniz_pow, (pderiv _).map_coe_nat, (pderiv tt).map_add, pderiv_tt_x,\n      pderiv_tt_y, Algebra.id.smul_eq_mul, add_zero, mul_one, derivation.map_smul_of_tower, map_nsmul, map_pow, map_add,\n      e, Bool.cond_true, Bool.cond_false, MvPolynomial.aeval_X, add_sub_cancel'_right, one_pow, smul_smul, smul_one_mul]\n#align sum_mul_smul sum_mul_smul\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map (f : «expr →+* » R S) (n ν : ℕ) : (bernstein_polynomial R n ν).map f = bernstein_polynomial S n ν := by\n  simp [bernstein_polynomial]\n#align map map\n\n",
 "linear_independent_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem linear_independent_aux (n k : ℕ) (h : k ≤ n + 1) :\n    LinearIndependent (exprℚ) fun ν : Fin k => bernstein_polynomial (exprℚ) n ν :=\n  by\n  induction' k with k ih\n  · apply linearIndependent_empty_type\n  · apply linear_independent_fin_succ'.mpr\n    fconstructor\n    · exact ih (le_of_lt h)\n    · -- The actual work!\n      -- We show that the (n-k)-th derivative at 1 doesn't vanish,\n      -- but vanishes for everything in the span.\n      clear ih\n      simp only [nat.succ_eq_add_one, add_le_add_iff_right] at h\n      simp only [Fin.val_last, Fin.init_def]\n      dsimp\n      apply not_mem_span_of_apply_not_mem_span_image (@Polynomial.derivative (exprℚ) _ ^ (n - k))\n      simp only [not_exists, not_and, Submodule.mem_map, Submodule.span_image]\n      intro p m\n      apply_fun Polynomial.eval (1 : exprℚ)\n      simp only [LinearMap.pow_apply]\n      -- The right hand side is nonzero,\n      -- so it will suffice to show the left hand side is always zero.\n      suffices ((«expr ^[ ]» Polynomial.derivative (n - k)) p).eval 1 = 0\n        by\n        rw [this]\n        exact (iterate_derivative_at_1_ne_zero (exprℚ) n k h).symm\n      apply span_induction m\n      · simp\n        rintro ⟨a, w⟩\n        simp only [Fin.val_mk]\n        rw [iterate_derivative_at_1_eq_zero_of_lt (exprℚ) n ((tsub_lt_tsub_iff_left_of_le h).mpr w)]\n      · simp\n      · intro x y hx hy\n        simp [hx, hy]\n      · intro a x h\n        simp [h]\n#align linear_independent_aux linear_independent_aux\n\n",
 "iterate_derivative_succ_at_0_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem iterate_derivative_succ_at_0_eq_zero (n ν : ℕ) :\n    ((«expr ^[ ]» Polynomial.derivative ν) (bernstein_polynomial R n (ν + 1))).eval 0 = 0 :=\n  iterate_derivative_at_0_eq_zero_of_lt R n (lt_add_one ν)\n#align iterate_derivative_succ_at_0_eq_zero iterate_derivative_succ_at_0_eq_zero\n\n",
 "iterate_derivative_at_1_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_derivative_at_1_ne_zero [CharZero R] (n ν : ℕ) (h : ν ≤ n) :\n    ((«expr ^[ ]» Polynomial.derivative (n - ν)) (bernstein_polynomial R n ν)).eval 1 ≠ 0 :=\n  by\n  rw [bernstein_polynomial.iterate_derivative_at_1 _ _ _ h, ne.def, neg_one_pow_mul_eq_zero_iff, ← Nat.cast_succ, ←\n    pochhammer_eval_cast, ← Nat.cast_zero, Nat.cast_inj]\n  exact (pochhammer_pos _ _ (nat.succ_pos ν)).ne'\n#align iterate_derivative_at_1_ne_zero iterate_derivative_at_1_ne_zero\n\n",
 "iterate_derivative_at_1_eq_zero_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_derivative_at_1_eq_zero_of_lt (n : ℕ) {ν k : ℕ} :\n    k < n - ν → ((«expr ^[ ]» Polynomial.derivative k) (bernstein_polynomial R n ν)).eval 1 = 0 :=\n  by\n  intro w\n  rw [flip' _ _ _ (tsub_pos_iff_lt.mp (pos_of_gt w)).le]\n  simp [Polynomial.eval_comp, iterate_derivative_at_0_eq_zero_of_lt R n w]\n#align iterate_derivative_at_1_eq_zero_of_lt iterate_derivative_at_1_eq_zero_of_lt\n\n",
 "iterate_derivative_at_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem iterate_derivative_at_1 (n ν : ℕ) (h : ν ≤ n) :\n    ((«expr ^[ ]» Polynomial.derivative (n - ν)) (bernstein_polynomial R n ν)).eval 1 =\n      (-1) ^ (n - ν) * (pochhammer R (n - ν)).eval (ν + 1) :=\n  by\n  rw [flip' _ _ _ h]\n  simp [Polynomial.eval_comp, h]\n  obtain rfl | h' := h.eq_or_lt\n  · simp\n  · congr\n    norm_cast\n    rw [← tsub_add_eq_tsub_tsub, tsub_tsub_cancel_of_le (nat.succ_le_iff.mpr h')]\n#align iterate_derivative_at_1 iterate_derivative_at_1\n\n",
 "iterate_derivative_at_0_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_derivative_at_0_ne_zero [CharZero R] (n ν : ℕ) (h : ν ≤ n) :\n    ((«expr ^[ ]» Polynomial.derivative ν) (bernstein_polynomial R n ν)).eval 0 ≠ 0 :=\n  by\n  simp only [Int.coe_nat_eq_zero, bernstein_polynomial.iterate_derivative_at_0, ne.def, Nat.cast_eq_zero]\n  simp only [← pochhammer_eval_cast]\n  norm_cast\n  apply ne_of_gt\n  obtain rfl | h' := nat.eq_zero_or_pos ν\n  · simp\n  · rw [← nat.succ_pred_eq_of_pos h'] at h\n    exact pochhammer_pos _ _ (tsub_pos_of_lt (nat.lt_of_succ_le h))\n#align iterate_derivative_at_0_ne_zero iterate_derivative_at_0_ne_zero\n\n",
 "iterate_derivative_at_0_eq_zero_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_derivative_at_0_eq_zero_of_lt (n : ℕ) {ν k : ℕ} :\n    k < ν → ((«expr ^[ ]» Polynomial.derivative k) (bernstein_polynomial R n ν)).eval 0 = 0 :=\n  by\n  cases ν\n  · rintro ⟨⟩\n  · rw [Nat.lt_succ_iff]\n    induction' k with k ih generalizing n ν\n    · simp [eval_at_0]\n    · simp only [derivative_succ, Int.coe_nat_eq_zero, mul_eq_zero, Function.comp_apply, Function.iterate_succ,\n        Polynomial.iterate_derivative_sub, Polynomial.iterate_derivative_nat_cast_mul, Polynomial.eval_mul,\n        Polynomial.eval_nat_cast, Polynomial.eval_sub]\n      intro h\n      apply mul_eq_zero_of_right\n      rw [ih _ _ (nat.le_of_succ_le h), sub_zero]\n      convert ih _ _ (nat.pred_le_pred h)\n      exact (nat.succ_pred_eq_of_pos (k.succ_pos.trans_le h)).symm\n#align iterate_derivative_at_0_eq_zero_of_lt iterate_derivative_at_0_eq_zero_of_lt\n\n",
 "iterate_derivative_at_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem iterate_derivative_at_0 (n ν : ℕ) :\n    ((«expr ^[ ]» Polynomial.derivative ν) (bernstein_polynomial R n ν)).eval 0 =\n      (pochhammer R ν).eval (n - (ν - 1) : ℕ) :=\n  by\n  by_cases h : ν ≤ n\n  · induction' ν with ν ih generalizing n h\n    · simp [eval_at_0]\n    · have h' : ν ≤ n - 1 := le_tsub_of_add_le_right h\n      simp only [derivative_succ, ih (n - 1) h', iterate_derivative_succ_at_0_eq_zero, nat.succ_sub_succ_eq_sub,\n        tsub_zero, sub_zero, iterate_derivative_sub, iterate_derivative_nat_cast_mul, eval_one, eval_mul, eval_add,\n        eval_sub, eval_X, eval_comp, eval_nat_cast, Function.comp_apply, Function.iterate_succ, pochhammer_succ_left]\n      obtain rfl | h'' := ν.eq_zero_or_pos\n      · simp\n      · have : n - 1 - (ν - 1) = n - ν := by\n          rw [← Nat.succ_le_iff] at h''\n          rw [← tsub_add_eq_tsub_tsub, add_comm, tsub_add_cancel_of_le h'']\n        rw [this, pochhammer_eval_succ]\n        rw_mod_cast [tsub_add_cancel_of_le (h'.trans n.pred_le)]\n  · simp only [not_le] at h\n    rw [tsub_eq_zero_iff_le.mpr (Nat.le_pred_of_lt h), eq_zero_of_lt R h]\n    simp [pos_iff_ne_zero.mp (pos_of_gt h)]\n#align iterate_derivative_at_0 iterate_derivative_at_0\n\n",
 "flip'":
 "theorem flip' (n ν : ℕ) (h : ν ≤ n) : bernstein_polynomial R n ν = (bernstein_polynomial R n (n - ν)).comp (1 - X) := by\n  simp [← flip _ _ _ h, Polynomial.comp_assoc]\n#align flip' flip'\n\n",
 "flip":
 "#print flip /-\ntheorem flip (n ν : ℕ) (h : ν ≤ n) : (bernstein_polynomial R n ν).comp (1 - X) = bernstein_polynomial R n (n - ν) := by\n  simp [bernstein_polynomial, h, tsub_tsub_assoc, mul_right_comm]\n#align flip flip\n-/\n\n",
 "eval_at_1":
 "theorem eval_at_1 (n ν : ℕ) : (bernstein_polynomial R n ν).eval 1 = if ν = n then 1 else 0 :=\n  by\n  rw [bernstein_polynomial]\n  split_ifs\n  · subst h\n    simp\n  · obtain w | w := (n - ν).eq_zero_or_pos\n    · simp [Nat.choose_eq_zero_of_lt ((tsub_eq_zero_iff_le.mp w).lt_of_ne (ne.symm h))]\n    · simp [zero_pow w]\n#align eval_at_1 eval_at_1\n\n",
 "eval_at_0":
 "theorem eval_at_0 (n ν : ℕ) : (bernstein_polynomial R n ν).eval 0 = if ν = 0 then 1 else 0 :=\n  by\n  rw [bernstein_polynomial]\n  split_ifs\n  · subst h\n    simp\n  · simp [zero_pow (nat.pos_of_ne_zero h)]\n#align eval_at_0 eval_at_0\n\n",
 "eq_zero_of_lt":
 "/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\ntheorem eq_zero_of_lt {n ν : ℕ} (h : n < ν) : bernstein_polynomial R n ν = 0 := by\n  simp [bernstein_polynomial, Nat.choose_eq_zero_of_lt h]\n#align eq_zero_of_lt eq_zero_of_lt\n\n",
 "derivative_zero":
 "theorem derivative_zero (n : ℕ) : (bernstein_polynomial R n 0).derivative = -n * bernstein_polynomial R (n - 1) 0 := by\n  simp [bernstein_polynomial, Polynomial.derivative_pow]\n#align derivative_zero derivative_zero\n\n",
 "derivative_succ_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem derivative_succ_aux (n ν : ℕ) :\n    (bernstein_polynomial R (n + 1) (ν + 1)).derivative =\n      (n + 1) * (bernstein_polynomial R n ν - bernstein_polynomial R n (ν + 1)) :=\n  by\n  rw [bernstein_polynomial]\n  suffices\n    ↑((n + 1).choose (ν + 1)) * (↑(ν + 1) * X ^ ν) * (1 - X) ^ (n - ν) -\n        ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - ν - 1)) =\n      ↑(n + 1) *\n        (↑(n.choose ν) * X ^ ν * (1 - X) ^ (n - ν) - ↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))\n    by\n    simpa only [Polynomial.derivative_pow, ← sub_eq_add_neg, nat.succ_sub_succ_eq_sub, Polynomial.derivative_mul,\n      Polynomial.derivative_nat_cast, MulZeroClass.zero_mul, Nat.cast_add, algebraMap.coe_one, Polynomial.derivative_X,\n      mul_one, zero_add, Polynomial.derivative_sub, Polynomial.derivative_one, zero_sub, mul_neg, nat.sub_zero, ←\n      Nat.cast_succ, Polynomial.C_eq_nat_cast]\n  conv_rhs => rw [mul_sub]\n  -- We'll prove the two terms match up separately.\n  refine' congr (congr_arg has_sub.sub _) _\n  · simp only [← mul_assoc]\n    refine' congr (congr_arg (· * ·) (congr (congr_arg (· * ·) _) rfl)) rfl\n    -- Now it's just about binomial coefficients\n    exact_mod_cast congr_arg (fun m : ℕ => (m : polynomial R)) (Nat.succ_mul_choose_eq n ν).symm\n  · rw [← tsub_add_eq_tsub_tsub, ← mul_assoc, ← mul_assoc]\n    congr 1\n    rw [mul_comm, ← mul_assoc, ← mul_assoc]\n    congr 1\n    norm_cast\n    congr 1\n    convert(Nat.choose_mul_succ_eq n (ν + 1)).symm using 1\n    · convert mul_comm _ _ using 2\n      simp\n    · apply mul_comm\n#align derivative_succ_aux derivative_succ_aux\n\n",
 "derivative_succ":
 "theorem derivative_succ (n ν : ℕ) :\n    (bernstein_polynomial R n (ν + 1)).derivative =\n      n * (bernstein_polynomial R (n - 1) ν - bernstein_polynomial R (n - 1) (ν + 1)) :=\n  by\n  cases n\n  · simp [bernstein_polynomial]\n  · rw [Nat.cast_succ]\n    apply derivative_succ_aux\n#align derivative_succ derivative_succ\n\n",
 "Sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print Sum /-\ntheorem Sum (n : ℕ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1)) (bernstein_polynomial R n ν) =\n      1 :=\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1)) (bernstein_polynomial R n ν) =\n        (X + (1 - X)) ^ n :=\n      by\n      rw [add_pow]\n      simp only [bernstein_polynomial, mul_comm, mul_assoc, mul_left_comm]\n    _ = 1 := by simp\n    \n#align sum Sum\n-/\n\n",
 "LinearIndependent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print LinearIndependent /-\n/-- The Bernstein polynomials are linearly independent.\n\nWe prove by induction that the collection of `bernstein_polynomial n ν` for `ν = 0, ..., k`\nare linearly independent.\nThe inductive step relies on the observation that the `(n-k)`-th derivative, evaluated at 1,\nannihilates `bernstein_polynomial n ν` for `ν < k`, but has a nonzero value at `ν = k`.\n-/\ntheorem LinearIndependent (n : ℕ) : LinearIndependent (exprℚ) fun ν : Fin (n + 1) => bernstein_polynomial (exprℚ) n ν :=\n  linear_independent_aux n (n + 1) le_rfl\n#align linear_independent LinearIndependent\n-/\n\n"}