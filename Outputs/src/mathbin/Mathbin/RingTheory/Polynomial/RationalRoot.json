{"scale_roots_aeval_eq_zero_of_aeval_mk'_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\ntheorem scale_roots_aeval_eq_zero_of_aeval_mk'_eq_zero {p : polynomial A} {r : A} {s : M}\n    (hr : aeval (mk' S r s) p = 0) : aeval (algebra_map A S r) (scale_roots p s) = 0 :=\n  by\n  convert scale_roots_eval₂_eq_zero (algebra_map A S) hr\n  rw [aeval_def, mk'_spec' _ r s]\n#align scale_roots_aeval_eq_zero_of_aeval_mk'_eq_zero scale_roots_aeval_eq_zero_of_aeval_mk'_eq_zero\n\n",
 "num_is_root_scale_roots_of_aeval_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem num_is_root_scale_roots_of_aeval_eq_zero [unique_factorization_monoid A] {p : polynomial A} {x : K}\n    (hr : aeval x p = 0) : is_root (scale_roots p (denom A x)) (Num A x) :=\n  by\n  apply is_root_of_eval₂_map_eq_zero (is_fraction_ring.injective A K)\n  refine' scale_roots_aeval_eq_zero_of_aeval_mk'_eq_zero _\n  rw [mk'_num_denom]\n  exact hr\n#align num_is_root_scale_roots_of_aeval_eq_zero num_is_root_scale_roots_of_aeval_eq_zero\n\n",
 "num_dvd_of_is_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Rational root theorem part 1:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the numerator of `r` divides the constant coefficient -/\ntheorem num_dvd_of_is_root {p : polynomial A} {r : K} (hr : aeval r p = 0) : Num A r ∣ p.coeff 0 :=\n  by\n  suffices Num A r ∣ (scale_roots p (denom A r)).coeff 0\n    by\n    simp only [coeff_scale_roots, tsub_zero] at this\n    haveI := classical.prop_decidable\n    by_cases hr : Num A r = 0\n    · obtain ⟨u, hu⟩ := (is_unit_denom_of_num_eq_zero hr).pow p.nat_degree\n      rw [← hu] at this\n      exact units.dvd_mul_right.mp this\n    · refine' dvd_of_dvd_mul_left_of_no_prime_factors hr _ this\n      intro q dvd_num dvd_denom_pow hq\n      apply hq.not_unit\n      exact num_denom_reduced A r dvd_num (hq.dvd_of_dvd_pow dvd_denom_pow)\n  convert dvd_term_of_is_root_of_dvd_terms 0 (num_is_root_scale_roots_of_aeval_eq_zero hr) _\n  · rw [pow_zero, mul_one]\n  intro j hj\n  apply dvd_mul_of_dvd_right\n  convert pow_dvd_pow (Num A r) (nat.succ_le_of_lt (bot_lt_iff_ne_bot.mpr hj))\n  exact (pow_one _).symm\n#align num_dvd_of_is_root num_dvd_of_is_root\n\n",
 "is_integer_of_is_root_of_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Integral root theorem:\nif `r : f.codomain` is a root of a monic polynomial over the ufd `A`,\nthen `r` is an integer -/\ntheorem is_integer_of_is_root_of_monic {p : polynomial A} (hp : monic p) {r : K} (hr : aeval r p = 0) :\n    is_integer A r :=\n  is_integer_of_is_unit_denom (isUnit_of_dvd_one _ (hp ▸ denom_dvd_of_is_root hr))\n#align is_integer_of_is_root_of_monic is_integer_of_is_root_of_monic\n\n",
 "integer_of_integral":
 "theorem integer_of_integral {x : K} : is_integral A x → is_integer A x := fun ⟨p, hp, hx⟩ =>\n  is_integer_of_is_root_of_monic hp hx\n#align integer_of_integral integer_of_integral\n\n",
 "denom_dvd_of_is_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Rational root theorem part 2:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the denominator of `r` divides the leading coefficient -/\ntheorem denom_dvd_of_is_root {p : polynomial A} {r : K} (hr : aeval r p = 0) : (denom A r : A) ∣ p.leading_coeff :=\n  by\n  suffices (denom A r : A) ∣ p.leading_coeff * Num A r ^ p.nat_degree\n    by\n    refine' dvd_of_dvd_mul_left_of_no_prime_factors (mem_non_zero_divisors_iff_ne_zero.mp (denom A r).2) _ this\n    intro q dvd_denom dvd_num_pow hq\n    apply hq.not_unit\n    exact num_denom_reduced A r (hq.dvd_of_dvd_pow dvd_num_pow) dvd_denom\n  rw [← coeff_scale_roots_nat_degree]\n  apply dvd_term_of_is_root_of_dvd_terms _ (num_is_root_scale_roots_of_aeval_eq_zero hr)\n  intro j hj\n  by_cases h : j < p.nat_degree\n  · rw [coeff_scale_roots]\n    refine' (dvd_mul_of_dvd_right _ _).mul_right _\n    convert pow_dvd_pow _ (nat.succ_le_iff.mpr (lt_tsub_iff_left.mpr _))\n    · exact (pow_one _).symm\n    simpa using h\n  rw [← nat_degree_scale_roots p (denom A r)] at *\n  rw [coeff_eq_zero_of_nat_degree_lt (lt_of_le_of_ne (le_of_not_gt h) hj.symm), zero_mul]\n  exact dvd_zero _\n#align denom_dvd_of_is_root denom_dvd_of_is_root\n\n"}