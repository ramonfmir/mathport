{"zero_scale_roots":
 "@[simp]\ntheorem zero_scale_roots (s : R) : scale_roots 0 s = 0 := by\n  ext\n  simp\n#align zero_scale_roots zero_scale_roots\n\n",
 "support_scale_roots_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem support_scale_roots_le (p : polynomial R) (s : R) : (scale_roots p s).support ≤ p.support :=\n  by\n  intro\n  simpa using left_ne_zero_of_mul\n#align support_scale_roots_le support_scale_roots_le\n\n",
 "support_scale_roots_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem support_scale_roots_eq (p : polynomial R) {s : R} (hs : s ∈ non_zero_divisors R) :\n    (scale_roots p s).support = p.support :=\n  le_antisymm (support_scale_roots_le p s)\n    (by\n      intro i\n      simp only [coeff_scale_roots, polynomial.mem_support_iff]\n      intro p_ne_zero ps_zero\n      have := pow_mem hs (p.nat_degree - i) _ ps_zero\n      contradiction)\n#align support_scale_roots_eq support_scale_roots_eq\n\n",
 "scale_roots_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem scale_roots_ne_zero {p : polynomial R} (hp : p ≠ 0) (s : R) : scale_roots p s ≠ 0 :=\n  by\n  intro h\n  have : p.coeff p.nat_degree ≠ 0 := mt leading_coeff_eq_zero.mp hp\n  have : (scale_roots p s).coeff p.nat_degree = 0 := congr_fun (congr_arg (coeff : polynomial R → ℕ → R) h) p.nat_degree\n  rw [coeff_scale_roots_nat_degree] at this\n  contradiction\n#align scale_roots_ne_zero scale_roots_ne_zero\n\n",
 "scale_roots_eval₂_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem scale_roots_eval₂_mul {p : polynomial S} (f : «expr →+* » S R) (r : R) (s : S) :\n    eval₂ f (f s * r) (scale_roots p s) = f s ^ p.nat_degree * eval₂ f r p :=\n  calc\n    eval₂ f (f s * r) (scale_roots p s) =\n        (scale_roots p s).support.sum fun i => f (coeff p i * s ^ (p.nat_degree - i)) * (f s * r) ^ i :=\n      by simp [eval₂_eq_sum, sum_def]\n    _ = p.support.sum fun i => f (coeff p i * s ^ (p.nat_degree - i)) * (f s * r) ^ i :=\n      finset.sum_subset (support_scale_roots_le p s) fun i hi hi' =>\n        by\n        let this : coeff p i * s ^ (p.nat_degree - i) = 0 := by simpa using hi'\n        simp [this]\n    _ = p.support.sum fun i : ℕ => f (p.coeff i) * f s ^ (p.nat_degree - i + i) * r ^ i :=\n      finset.sum_congr rfl fun i hi => by simp_rw [f.map_mul, f.map_pow, pow_add, mul_pow, mul_assoc]\n    _ = p.support.sum fun i : ℕ => f s ^ p.nat_degree * (f (p.coeff i) * r ^ i) :=\n      finset.sum_congr rfl fun i hi =>\n        by\n        rw [mul_assoc, mul_left_comm, tsub_add_cancel_of_le]\n        exact le_nat_degree_of_ne_zero (polynomial.mem_support_iff.mp hi)\n    _ = f s ^ p.nat_degree * p.support.sum fun i : ℕ => f (p.coeff i) * r ^ i := finset.mul_sum.symm\n    _ = f s ^ p.nat_degree * eval₂ f r p := by simp [eval₂_eq_sum, sum_def]\n    \n#align scale_roots_eval₂_mul scale_roots_eval₂_mul\n\n",
 "scale_roots_eval₂_eq_zero_of_eval₂_div_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem scale_roots_eval₂_eq_zero_of_eval₂_div_eq_zero {p : polynomial A} {f : «expr →+* » A K}\n    (hf : function.injective f) {r s : A} (hr : eval₂ f (f r / f s) p = 0) (hs : s ∈ non_zero_divisors A) :\n    eval₂ f (f r) (scale_roots p s) = 0 :=\n  by\n  convert scale_roots_eval₂_eq_zero f hr\n  rw [← mul_div_assoc, mul_comm, mul_div_cancel]\n  exact map_ne_zero_of_mem_non_zero_divisors _ hf hs\n#align scale_roots_eval₂_eq_zero_of_eval₂_div_eq_zero scale_roots_eval₂_eq_zero_of_eval₂_div_eq_zero\n\n",
 "scale_roots_eval₂_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem scale_roots_eval₂_eq_zero {p : polynomial S} (f : «expr →+* » S R) {r : R} {s : S} (hr : eval₂ f r p = 0) :\n    eval₂ f (f s * r) (scale_roots p s) = 0 := by rw [scale_roots_eval₂_mul, hr, _root_.mul_zero]\n#align scale_roots_eval₂_eq_zero scale_roots_eval₂_eq_zero\n\n",
 "scale_roots_aeval_eq_zero_of_aeval_div_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem scale_roots_aeval_eq_zero_of_aeval_div_eq_zero [algebra A K] (inj : function.injective (algebra_map A K))\n    {p : polynomial A} {r s : A} (hr : aeval (algebra_map A K r / algebra_map A K s) p = 0)\n    (hs : s ∈ non_zero_divisors A) : aeval (algebra_map A K r) (scale_roots p s) = 0 :=\n  scale_roots_eval₂_eq_zero_of_eval₂_div_eq_zero inj hr hs\n#align scale_roots_aeval_eq_zero_of_aeval_div_eq_zero scale_roots_aeval_eq_zero_of_aeval_div_eq_zero\n\n",
 "scale_roots_aeval_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem scale_roots_aeval_eq_zero [algebra S R] {p : polynomial S} {r : R} {s : S} (hr : aeval r p = 0) :\n    aeval (algebra_map S R s * r) (scale_roots p s) = 0 :=\n  scale_roots_eval₂_eq_zero (algebra_map S R) hr\n#align scale_roots_aeval_eq_zero scale_roots_aeval_eq_zero\n\n",
 "nat_degree_scale_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem nat_degree_scale_roots (p : polynomial R) (s : R) : nat_degree (scale_roots p s) = nat_degree p := by\n  simp only [nat_degree, degree_scale_roots]\n#align nat_degree_scale_roots nat_degree_scale_roots\n\n",
 "monic_scale_roots_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic_scale_roots_iff {p : polynomial R} (s : R) : monic (scale_roots p s) ↔ monic p := by\n  simp only [monic, leading_coeff, nat_degree_scale_roots, coeff_scale_roots_nat_degree]\n#align monic_scale_roots_iff monic_scale_roots_iff\n\n",
 "map_scale_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_scale_roots (p : polynomial R) (x : R) (f : «expr →+* » R S) (h : f p.leading_coeff ≠ 0) :\n    (p.scale_roots x).map f = (p.map f).scale_roots (f x) :=\n  by\n  ext\n  simp [polynomial.nat_degree_map_of_leading_coeff_ne_zero _ h]\n#align map_scale_roots map_scale_roots\n\n",
 "degree_scale_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem degree_scale_roots (p : polynomial R) {s : R} : degree (scale_roots p s) = degree p :=\n  by\n  haveI := classical.prop_decidable\n  by_cases hp : p = 0\n  · rw [hp, zero_scale_roots]\n  have := scale_roots_ne_zero hp s\n  refine' le_antisymm (finset.sup_mono (support_scale_roots_le p s)) (degree_le_degree _)\n  rw [coeff_scale_roots_nat_degree]\n  intro h\n  have := leading_coeff_eq_zero.mp h\n  contradiction\n#align degree_scale_roots degree_scale_roots\n\n",
 "coeff_scale_roots_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_scale_roots_nat_degree (p : polynomial R) (s : R) :\n    (scale_roots p s).coeff p.nat_degree = p.leading_coeff := by\n  rw [leading_coeff, coeff_scale_roots, tsub_self, pow_zero, mul_one]\n#align coeff_scale_roots_nat_degree coeff_scale_roots_nat_degree\n\n",
 "coeff_scale_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen, Devon Tuma\n-/\n@[simp]\ntheorem coeff_scale_roots (p : polynomial R) (s : R) (i : ℕ) :\n    (scale_roots p s).coeff i = coeff p i * s ^ (p.nat_degree - i) := by\n  simp (config := { contextual := true }) [scale_roots, coeff_monomial]\n#align coeff_scale_roots coeff_scale_roots\n\n"}