{"one_sub_X_sq_mul_derivative_T_eq_poly_in_T":
 "theorem one_sub_X_sq_mul_derivative_T_eq_poly_in_T (n : ℕ) :\n    (1 - X ^ 2) * derivative (T R (n + 1)) = (n + 1) * (T R n - X * T R (n + 1)) :=\n  calc\n    (1 - X ^ 2) * derivative (T R (n + 1)) = (1 - X ^ 2) * ((n + 1) * U R n) := by rw [T_derivative_eq_U]\n    _ = (n + 1) * ((1 - X ^ 2) * U R n) := by ring\n    _ = (n + 1) * (X * T R (n + 1) - (2 * X * T R (n + 1) - T R n)) := by rw [one_sub_X_sq_mul_U_eq_pol_in_T, T_add_two]\n    _ = (n + 1) * (T R n - X * T R (n + 1)) := by ring\n    \n#align one_sub_X_sq_mul_derivative_T_eq_poly_in_T one_sub_X_sq_mul_derivative_T_eq_poly_in_T\n\n",
 "one_sub_X_sq_mul_U_eq_pol_in_T":
 "theorem one_sub_X_sq_mul_U_eq_pol_in_T (n : ℕ) : (1 - X ^ 2) * U R n = X * T R (n + 1) - T R (n + 2) := by\n  rw [T_eq_X_mul_T_sub_pol_U, ← sub_add, sub_self, zero_add]\n#align one_sub_X_sq_mul_U_eq_pol_in_T one_sub_X_sq_mul_U_eq_pol_in_T\n\n",
 "mul_T":
 "/-- The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. -/\ntheorem mul_T : ∀ m k, 2 * T R m * T R (m + k) = T R (2 * m + k) + T R k\n  | 0 => by simp [two_mul, add_mul]\n  | 1 => by simp [add_comm]\n  | m + 2 => by\n    intro k\n    -- clean up the `T` nat indices in the goal\n    suffices 2 * T R (m + 2) * T R (m + k + 2) = T R (2 * m + k + 4) + T R k\n      by\n      have h_nat₁ : 2 * (m + 2) + k = 2 * m + k + 4 := by ring\n      have h_nat₂ : m + 2 + k = m + k + 2 := by simp [add_comm, add_assoc]\n      simpa [h_nat₁, h_nat₂] using this\n    -- clean up the `T` nat indices in the inductive hypothesis applied to `m + 1` and\n    -- `k + 1`\n    have H₁ : 2 * T R (m + 1) * T R (m + k + 2) = T R (2 * m + k + 3) + T R (k + 1) :=\n      by\n      have h_nat₁ : m + 1 + (k + 1) = m + k + 2 := by ring\n      have h_nat₂ : 2 * (m + 1) + (k + 1) = 2 * m + k + 3 := by ring\n      simpa [h_nat₁, h_nat₂] using mul_T (m + 1) (k + 1)\n    -- clean up the `T` nat indices in the inductive hypothesis applied to `m` and `k + 2`\n    have H₂ : 2 * T R m * T R (m + k + 2) = T R (2 * m + k + 2) + T R (k + 2) :=\n      by\n      have h_nat₁ : 2 * m + (k + 2) = 2 * m + k + 2 := by simp [add_assoc]\n      have h_nat₂ : m + (k + 2) = m + k + 2 := by simp [add_assoc]\n      simpa [h_nat₁, h_nat₂] using mul_T m (k + 2)\n    -- state the `T` recurrence relation for a few useful indices\n    have h₁ := T_add_two R m\n    have h₂ := T_add_two R (2 * m + k + 2)\n    have h₃ := T_add_two R k\n    -- the desired identity is an appropriate linear combination of H₁, H₂, h₁, h₂, h₃\n    linear_combination 2 * T R (m + k + 2) * h₁ + 2 * X * H₁ - H₂ - h₂ - h₃\n#align mul_T mul_T\n\n",
 "map_U":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map_U (f : «expr →+* » R S) : ∀ n : ℕ, map f (U R n) = U S n\n  | 0 => by simp only [U_zero, Polynomial.map_one]\n  | 1 => by\n    simp only [U_one, map_X, Polynomial.map_mul, Polynomial.map_add, Polynomial.map_one]\n    change map f (1 + 1) * X = 2 * X\n    simpa only [Polynomial.map_add, Polynomial.map_one]\n  | n + 2 =>\n    by\n    simp only [U_add_two, Polynomial.map_mul, Polynomial.map_sub, map_X, bit0, Polynomial.map_add, Polynomial.map_one]\n    rw [map_U (n + 1), map_U n]\n#align map_U map_U\n\n",
 "map_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map_T (f : «expr →+* » R S) : ∀ n : ℕ, map f (T R n) = T S n\n  | 0 => by simp only [T_zero, Polynomial.map_one]\n  | 1 => by simp only [T_one, map_X]\n  | n + 2 =>\n    by\n    simp only [T_add_two, Polynomial.map_mul, Polynomial.map_sub, map_X, bit0, Polynomial.map_add, Polynomial.map_one]\n    rw [map_T (n + 1), map_T n]\n#align map_T map_T\n\n",
 "add_one_mul_T_eq_poly_in_U":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem add_one_mul_T_eq_poly_in_U (n : ℕ) :\n    ((n : polynomial R) + 1) * T R (n + 1) = X * U R n - (1 - X ^ 2) * derivative (U R n) :=\n  by\n  have h :\n    derivative (T R (n + 2)) =\n      U R (n + 1) - X * U R n + X * derivative (T R (n + 1)) + 2 * X * U R n - (1 - X ^ 2) * derivative (U R n) :=\n    by\n    conv_lhs => rw [T_eq_X_mul_T_sub_pol_U]\n    simp only [derivative_sub, derivative_mul, derivative_X, derivative_one, derivative_X_pow, one_mul,\n      T_derivative_eq_U]\n    rw [T_eq_U_sub_X_mul_U, C_eq_nat_cast, Nat.cast_bit0, Nat.cast_one]\n    ring\n  calc\n    ((n : polynomial R) + 1) * T R (n + 1) =\n        ((n : polynomial R) + 1 + 1) * (X * U R n + T R (n + 1)) - X * ((n + 1) * U R n) - (X * U R n + T R (n + 1)) :=\n      by ring\n    _ = derivative (T R (n + 2)) - X * derivative (T R (n + 1)) - U R (n + 1) := by\n      rw [← U_eq_X_mul_U_add_T, ← T_derivative_eq_U, ← Nat.cast_one, ← Nat.cast_add, Nat.cast_one, ←\n        T_derivative_eq_U (n + 1)]\n    _ =\n        U R (n + 1) - X * U R n + X * derivative (T R (n + 1)) + 2 * X * U R n - (1 - X ^ 2) * derivative (U R n) -\n            X * derivative (T R (n + 1)) -\n          U R (n + 1) :=\n      by rw [h]\n    _ = X * U R n - (1 - X ^ 2) * derivative (U R n) := by ring\n    \n#align add_one_mul_T_eq_poly_in_U add_one_mul_T_eq_poly_in_U\n\n",
 "U_zero":
 "@[simp]\ntheorem U_zero : U R 0 = 1 :=\n  rfl\n#align U_zero U_zero\n\n",
 "U_two":
 "theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by\n  simp only [U]\n  ring\n#align U_two U_two\n\n",
 "U_one":
 "@[simp]\ntheorem U_one : U R 1 = 2 * X :=\n  rfl\n#align U_one U_one\n\n",
 "U_of_two_le":
 "theorem U_of_two_le (n : ℕ) (h : 2 ≤ n) : U R n = 2 * X * U R (n - 1) - U R (n - 2) :=\n  by\n  obtain ⟨n, rfl⟩ := Nat.exists_eq_add_of_le h\n  rw [add_comm]\n  exact U_add_two R n\n#align U_of_two_le U_of_two_le\n\n",
 "U_eq_X_mul_U_add_T":
 "theorem U_eq_X_mul_U_add_T : ∀ n : ℕ, U R (n + 1) = X * U R n + T R (n + 1)\n  | 0 => by\n    simp only [U_zero, U_one, T_one]\n    ring\n  | 1 => by\n    simp only [U_one, T_two, U_two]\n    ring\n  | n + 2 =>\n    calc\n      U R (n + 2 + 1) = 2 * X * (X * U R (n + 1) + T R (n + 2)) - (X * U R n + T R (n + 1)) := by\n        simp only [U_add_two, U_eq_X_mul_U_add_T n, U_eq_X_mul_U_add_T (n + 1)]\n      _ = X * (2 * X * U R (n + 1) - U R n) + (2 * X * T R (n + 2) - T R (n + 1)) := by ring\n      _ = X * U R (n + 2) + T R (n + 2 + 1) := by simp only [U_add_two, T_add_two]\n      \n#align U_eq_X_mul_U_add_T U_eq_X_mul_U_add_T\n\n",
 "U_add_two":
 "@[simp]\ntheorem U_add_two (n : ℕ) : U R (n + 2) = 2 * X * U R (n + 1) - U R n := by rw [U]\n#align U_add_two U_add_two\n\n",
 "T_zero":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Julian Kuelshammer, Heather Macbeth\n-/\n@[simp]\ntheorem T_zero : T R 0 = 1 :=\n  rfl\n#align T_zero T_zero\n\n",
 "T_two":
 "theorem T_two : T R 2 = 2 * X ^ 2 - 1 := by simp only [T, sub_left_inj, sq, mul_assoc]\n#align T_two T_two\n\n",
 "T_one":
 "@[simp]\ntheorem T_one : T R 1 = X :=\n  rfl\n#align T_one T_one\n\n",
 "T_of_two_le":
 "theorem T_of_two_le (n : ℕ) (h : 2 ≤ n) : T R n = 2 * X * T R (n - 1) - T R (n - 2) :=\n  by\n  obtain ⟨n, rfl⟩ := Nat.exists_eq_add_of_le h\n  rw [add_comm]\n  exact T_add_two R n\n#align T_of_two_le T_of_two_le\n\n",
 "T_mul":
 "/-- The `(m * n)`-th Chebyshev polynomial is the composition of the `m`-th and `n`-th -/\ntheorem T_mul : ∀ m n, T R (m * n) = (T R m).comp (T R n)\n  | 0 => by simp\n  | 1 => by simp\n  | m + 2 => by\n    intro n\n    have : 2 * T R n * T R ((m + 1) * n) = T R ((m + 2) * n) + T R (m * n) := by convert mul_T R n (m * n) <;> ring\n    simp [this, T_mul m, ← T_mul (m + 1)]\n#align T_mul T_mul\n\n",
 "T_eq_X_mul_T_sub_pol_U":
 "theorem T_eq_X_mul_T_sub_pol_U : ∀ n : ℕ, T R (n + 2) = X * T R (n + 1) - (1 - X ^ 2) * U R n\n  | 0 => by\n    simp only [T_one, T_two, U_zero]\n    ring\n  | 1 => by\n    simp only [T_add_two, T_zero, T_add_two, U_one, T_one]\n    ring\n  | n + 2 =>\n    calc\n      T R (n + 2 + 2) = 2 * X * T R (n + 2 + 1) - T R (n + 2) := T_add_two _ _\n      _ = 2 * X * (X * T R (n + 2) - (1 - X ^ 2) * U R (n + 1)) - (X * T R (n + 1) - (1 - X ^ 2) * U R n) := by\n        simp only [T_eq_X_mul_T_sub_pol_U]\n      _ = X * (2 * X * T R (n + 2) - T R (n + 1)) - (1 - X ^ 2) * (2 * X * U R (n + 1) - U R n) := by ring\n      _ = X * T R (n + 2 + 1) - (1 - X ^ 2) * U R (n + 2) := by rw [T_add_two _ (n + 1), U_add_two]\n      \n#align T_eq_X_mul_T_sub_pol_U T_eq_X_mul_T_sub_pol_U\n\n",
 "T_eq_U_sub_X_mul_U":
 "theorem T_eq_U_sub_X_mul_U (n : ℕ) : T R (n + 1) = U R (n + 1) - X * U R n := by\n  rw [U_eq_X_mul_U_add_T, add_comm (X * U R n), add_sub_cancel]\n#align T_eq_U_sub_X_mul_U T_eq_U_sub_X_mul_U\n\n",
 "T_derivative_eq_U":
 "theorem T_derivative_eq_U : ∀ n : ℕ, derivative (T R (n + 1)) = (n + 1) * U R n\n  | 0 => by simp only [T_one, U_zero, derivative_X, Nat.cast_zero, zero_add, mul_one]\n  | 1 =>\n    by\n    simp only [T_two, U_one, derivative_sub, derivative_one, derivative_mul, derivative_X_pow, Nat.cast_one,\n      Nat.cast_two]\n    norm_num\n  | n + 2 =>\n    calc\n      derivative (T R (n + 2 + 1)) =\n          2 * T R (n + 2) + 2 * X * derivative (T R (n + 1 + 1)) - derivative (T R (n + 1)) :=\n        by\n        simp only [T_add_two _ (n + 1), derivative_sub, derivative_mul, derivative_X, derivative_bit0, derivative_one,\n          bit0_zero, MulZeroClass.zero_mul, zero_add, mul_one]\n      _ = 2 * (U R (n + 1 + 1) - X * U R (n + 1)) + 2 * X * ((n + 1 + 1) * U R (n + 1)) - (n + 1) * U R n := by\n        rw_mod_cast [T_derivative_eq_U, T_derivative_eq_U, T_eq_U_sub_X_mul_U]\n      _ = (n + 1) * (2 * X * U R (n + 1) - U R n) + 2 * U R (n + 2) := by ring\n      _ = (n + 1) * U R (n + 2) + 2 * U R (n + 2) := by rw [U_add_two]\n      _ = (n + 2 + 1) * U R (n + 2) := by ring\n      _ = (↑(n + 2) + 1) * U R (n + 2) := by norm_cast\n      \n#align T_derivative_eq_U T_derivative_eq_U\n\n",
 "T_add_two":
 "@[simp]\ntheorem T_add_two (n : ℕ) : T R (n + 2) = 2 * X * T R (n + 1) - T R n := by rw [T]\n#align T_add_two T_add_two\n\n"}