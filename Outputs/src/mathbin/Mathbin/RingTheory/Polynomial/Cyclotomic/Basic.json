{"unique_int_coeff_of_cycl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `K` is of characteristic `0` and there is a primitive `n`-th root of unity in `K`,\nthen `cyclotomic n K` comes from a unique polynomial with integer coefficients. -/\ntheorem unique_int_coeff_of_cycl {K : Type _} [CommRing K] [IsDomain K] [CharZero K] {ζ : K} {n : «exprℕ+»}\n    (h : is_primitive_root ζ n) : ∃! P : polynomial ℤ, map (Int.castRingHom K) P = cyclotomic' n K :=\n  by\n  obtain ⟨P, hP⟩ := int_coeff_of_cyclotomic' h\n  refine' ⟨P, hP.1, fun Q hQ => _⟩\n  apply map_injective (Int.castRingHom K) Int.cast_injective\n  rw [hP.1, hQ]\n#align unique_int_coeff_of_cycl unique_int_coeff_of_cycl\n\n",
 "roots_to_finset_eq_primitive_roots":
 "theorem cyclotomic.roots_to_finset_eq_primitive_roots [ne_zero (n : R)] :\n    (⟨(cyclotomic n R).roots, roots_cyclotomic_nodup⟩ : Finset _) = primitive_roots n R :=\n  by\n  ext\n  simp [cyclotomic_ne_zero n R, is_root_cyclotomic_iff, mem_primitive_roots, NeZero.pos_of_neZero_natCast R]\n#align cyclotomic.roots_to_finset_eq_primitive_roots cyclotomic.roots_to_finset_eq_primitive_roots\n\n",
 "roots_of_cyclotomic":
 "/-- The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. -/\ntheorem roots_of_cyclotomic (n : ℕ) (R : Type _) [CommRing R] [IsDomain R] :\n    (cyclotomic' n R).roots = (primitive_roots n R).val :=\n  by\n  rw [cyclotomic']\n  exact roots_prod_X_sub_C (primitive_roots n R)\n#align roots_of_cyclotomic roots_of_cyclotomic\n\n",
 "roots_eq_primitive_roots_val":
 "theorem cyclotomic.roots_eq_primitive_roots_val [ne_zero (n : R)] :\n    (cyclotomic n R).roots = (primitive_roots n R).val := by rw [← cyclotomic.roots_to_finset_eq_primitive_roots]\n#align cyclotomic.roots_eq_primitive_roots_val cyclotomic.roots_eq_primitive_roots_val\n\n",
 "roots_cyclotomic_nodup":
 "theorem roots_cyclotomic_nodup [ne_zero (n : R)] : (cyclotomic n R).roots.nodup :=\n  by\n  obtain h | ⟨ζ, hζ⟩ := (cyclotomic n R).roots.empty_or_exists_mem\n  · exact h.symm ▸ Multiset.nodup_zero\n  rw [mem_roots <| cyclotomic_ne_zero n R, is_root_cyclotomic_iff] at hζ\n  refine'\n    Multiset.nodup_of_le\n      (roots.le_of_dvd (X_pow_sub_C_ne_zero (NeZero.pos_of_neZero_natCast R) 1) <| cyclotomic.dvd_X_pow_sub_one n R)\n      hζ.nth_roots_nodup\n#align roots_cyclotomic_nodup roots_cyclotomic_nodup\n\n",
 "prod_cyclotomic_eq_geom_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem prod_cyclotomic_eq_geom_sum {n : ℕ} (h : 0 < n) (R) [CommRing R] :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (n.divisors.erase 1) (cyclotomic i R) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (X ^ i) :=\n  by\n  suffices\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (n.divisors.erase 1) (cyclotomic i ℤ) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (X ^ i)\n    by\n    simpa only [polynomial.map_prod, map_cyclotomic_int, polynomial.map_sum, polynomial.map_pow, polynomial.map_X] using\n      congr_arg (map (Int.castRingHom R)) this\n  rw [← mul_left_inj' (cyclotomic_ne_zero 1 ℤ), prod_erase_mul _ _ (nat.one_mem_divisors.2 h.ne'), cyclotomic_one,\n    geom_sum_mul, prod_cyclotomic_eq_X_pow_sub_one h]\n#align prod_cyclotomic_eq_geom_sum prod_cyclotomic_eq_geom_sum\n\n",
 "prod_cyclotomic_eq_X_pow_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- `∏ i in nat.divisors n, cyclotomic i R = X ^ n - 1`. -/\ntheorem prod_cyclotomic_eq_X_pow_sub_one {n : ℕ} (hpos : 0 < n) (R : Type _) [CommRing R] :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (nat.divisors n)\n        (cyclotomic i R) =\n      X ^ n - 1 :=\n  by\n  have integer :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (nat.divisors n)\n        (cyclotomic i ℤ) =\n      X ^ n - 1 :=\n    by\n    apply map_injective (Int.castRingHom (exprℂ)) Int.cast_injective\n    simp only [polynomial.map_prod, int_cyclotomic_spec, polynomial.map_pow, map_X, polynomial.map_one,\n      polynomial.map_sub]\n    exact prod_cyclotomic'_eq_X_pow_sub_one hpos (complex.is_primitive_root_exp n hpos.ne')\n  simpa only [polynomial.map_prod, map_cyclotomic_int, polynomial.map_sub, polynomial.map_one, polynomial.map_pow,\n    polynomial.map_X] using congr_arg (map (Int.castRingHom R)) integer\n#align prod_cyclotomic_eq_X_pow_sub_one prod_cyclotomic_eq_X_pow_sub_one\n\n",
 "prod_cyclotomic'_eq_X_pow_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`∏ i in nat.divisors n, cyclotomic' i K = X ^ n - 1`. -/\ntheorem prod_cyclotomic'_eq_X_pow_sub_one {K : Type _} [CommRing K] [IsDomain K] {ζ : K} {n : ℕ} (hpos : 0 < n)\n    (h : is_primitive_root ζ n) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (nat.divisors n)\n        (cyclotomic' i K) =\n      X ^ n - 1 :=\n  by\n  have hd : (n.divisors : set ℕ).pairwise_disjoint fun k => primitive_roots k K := fun x hx y hy hne =>\n    is_primitive_root.disjoint hne\n  simp only [X_pow_sub_one_eq_prod hpos h, cyclotomic', ← finset.prod_bUnion hd,\n    h.nth_roots_one_eq_bUnion_primitive_roots]\n#align prod_cyclotomic'_eq_X_pow_sub_one prod_cyclotomic'_eq_X_pow_sub_one\n\n",
 "order_of_root_cyclotomic_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `(a : ℕ)` is a root of `cyclotomic n (zmod p)`, then the multiplicative order of `a` modulo\n`p` divides `n`. -/\ntheorem order_of_root_cyclotomic_dvd {n : ℕ} (hpos : 0 < n) {p : ℕ} [fact p.prime] {a : ℕ}\n    (hroot : is_root (cyclotomic n (zmod p)) (nat.cast_ring_hom (zmod p) a)) :\n    order_of (zmod.unit_of_coprime a (coprime_of_root_cyclotomic hpos hroot)) ∣ n :=\n  by\n  apply order_of_dvd_of_pow_eq_one\n  suffices hpow : eval (nat.cast_ring_hom (zmod p) a) (X ^ n - 1 : polynomial (zmod p)) = 0\n  · simp only [eval_X, eval_one, eval_pow, eval_sub, eq_nat_cast] at hpow\n    apply Units.val_eq_one.1\n    simp only [sub_eq_zero.mp hpow, zmod.coe_unit_of_coprime, Units.val_pow_eq_pow_val]\n  rw [is_root.def] at hroot\n  rw [← prod_cyclotomic_eq_X_pow_sub_one hpos (zmod p), ← nat.cons_self_proper_divisors hpos.ne', finset.prod_cons,\n    eval_mul, hroot, zero_mul]\n#align order_of_root_cyclotomic_dvd order_of_root_cyclotomic_dvd\n\n",
 "nat_degree_cyclotomic'":
 "/-- The natural degree of `cyclotomic' n R` is `totient n` if there is a primitive root of\nunity in `R`. -/\ntheorem nat_degree_cyclotomic' {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) :\n    (cyclotomic' n R).nat_degree = nat.totient n :=\n  by\n  rw [cyclotomic']\n  rw [nat_degree_prod (primitive_roots n R) fun z : R => X - C z]\n  simp only [is_primitive_root.card_primitive_roots h, mul_one, nat_degree_X_sub_C, nat.cast_id, finset.sum_const,\n    nsmul_eq_mul]\n  intro z hz\n  exact X_sub_C_ne_zero z\n#align nat_degree_cyclotomic' nat_degree_cyclotomic'\n\n",
 "nat_degree_cyclotomic":
 "/-- The natural degree of `cyclotomic n` is `totient n`. -/\ntheorem nat_degree_cyclotomic (n : ℕ) (R : Type _) [Ring R] [nontrivial R] :\n    (cyclotomic n R).nat_degree = nat.totient n := by rw [nat_degree, degree_cyclotomic, WithBot.unbot'_coe]\n#align nat_degree_cyclotomic nat_degree_cyclotomic\n\n",
 "monic":
 "/-- `cyclotomic n` is monic. -/\ntheorem cyclotomic.monic (n : ℕ) (R : Type _) [Ring R] : (cyclotomic n R).monic :=\n  by\n  rw [← map_cyclotomic_int]\n  exact (int_cyclotomic_spec n).2.2.map _\n#align cyclotomic.monic cyclotomic.monic\n\n",
 "minpoly_eq_cyclotomic_of_irreducible":
 "theorem _root_.is_primitive_root.minpoly_eq_cyclotomic_of_irreducible {K : Type _} [Field K] {R : Type _} [CommRing R]\n    [IsDomain R] {μ : R} {n : ℕ} [algebra K R] (hμ : is_primitive_root μ n) (h : Irreducible <| cyclotomic n K)\n    [ne_zero (n : K)] : cyclotomic n K = minpoly K μ :=\n  by\n  haveI := ne_zero.of_no_zero_smul_divisors K R n\n  refine' minpoly.eq_of_irreducible_of_monic h _ (cyclotomic.monic n K)\n  rwa [aeval_def, eval₂_eq_eval_map, map_cyclotomic, ← is_root.def, is_root_cyclotomic_iff]\n#align is_primitive_root.minpoly_eq_cyclotomic_of_irreducible is_primitive_root.minpoly_eq_cyclotomic_of_irreducible\n\n",
 "minpoly_dvd_cyclotomic":
 "/-- The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. -/\ntheorem _root_.is_primitive_root.minpoly_dvd_cyclotomic {n : ℕ} {K : Type _} [Field K] {μ : K}\n    (h : is_primitive_root μ n) (hpos : 0 < n) [CharZero K] : minpoly ℤ μ ∣ cyclotomic n ℤ :=\n  by\n  apply minpoly.gcd_domain_dvd (is_integral h hpos) (cyclotomic_ne_zero n ℤ)\n  simpa [aeval_def, eval₂_eq_eval_map, is_root.def] using is_root_cyclotomic hpos h\n#align is_primitive_root.minpoly_dvd_cyclotomic is_primitive_root.minpoly_dvd_cyclotomic\n\n",
 "map_cyclotomic_int":
 "/-- `cyclotomic n R` comes from `cyclotomic n ℤ`. -/\ntheorem map_cyclotomic_int (n : ℕ) (R : Type _) [Ring R] : map (Int.castRingHom R) (cyclotomic n ℤ) = cyclotomic n R :=\n  by\n  by_cases hzero : n = 0\n  · simp only [hzero, cyclotomic, dif_pos, polynomial.map_one]\n  simp only [cyclotomic, int_cyclotomic_rw, hzero, ne.def, dif_neg, not_false_iff]\n#align map_cyclotomic_int map_cyclotomic_int\n\n",
 "map_cyclotomic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- The definition of `cyclotomic n R` commutes with any ring homomorphism. -/\n@[simp]\ntheorem map_cyclotomic (n : ℕ) {R S : Type _} [Ring R] [Ring S] (f : «expr →+* » R S) :\n    map f (cyclotomic n R) = cyclotomic n S :=\n  by\n  rw [← map_cyclotomic_int n R, ← map_cyclotomic_int n S, map_map]\n  congr\n#align map_cyclotomic map_cyclotomic\n\n",
 "is_root_of_unity_of_root_cyclotomic":
 "theorem is_root_of_unity_of_root_cyclotomic {n : ℕ} {R} [CommRing R] {ζ : R} {i : ℕ} (hi : i ∈ n.divisors)\n    (h : (cyclotomic i R).is_root ζ) : ζ ^ n = 1 :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · exact pow_zero _\n  have := congr_arg (eval ζ) (prod_cyclotomic_eq_X_pow_sub_one hn R).symm\n  rw [eval_sub, eval_pow, eval_X, eval_one] at this\n  convert eq_add_of_sub_eq' this\n  convert (add_zero _).symm\n  apply eval_eq_zero_of_dvd_of_eval_eq_zero _ h\n  exact finset.dvd_prod_of_mem _ hi\n#align is_root_of_unity_of_root_cyclotomic is_root_of_unity_of_root_cyclotomic\n\n",
 "is_root_of_unity_iff":
 "theorem _root_.is_root_of_unity_iff {n : ℕ} (h : 0 < n) (R : Type _) [CommRing R] [IsDomain R] {ζ : R} :\n    ζ ^ n = 1 ↔ ∃ i ∈ n.divisors, (cyclotomic i R).is_root ζ := by\n  rw [← mem_nth_roots h, nth_roots, mem_roots <| X_pow_sub_C_ne_zero h _, C_1, ← prod_cyclotomic_eq_X_pow_sub_one h,\n      is_root_prod] <;>\n    infer_instance\n#align is_root_of_unity_iff is_root_of_unity_iff\n\n",
 "is_root_cyclotomic_prime_pow_mul_iff_of_char_p":
 "/-- If `R` is of characteristic `p` and `¬p ∣ m`, then `ζ` is a root of `cyclotomic (p ^ k * m) R`\n if and only if it is a primitive `m`-th root of unity. -/\ntheorem is_root_cyclotomic_prime_pow_mul_iff_of_char_p {m k p : ℕ} {R : Type _} [CommRing R] [IsDomain R]\n    [hp : fact (Nat.Prime p)] [hchar : char_p R p] {μ : R} [ne_zero (m : R)] :\n    (polynomial.cyclotomic (p ^ k * m) R).is_root μ ↔ is_primitive_root μ m :=\n  by\n  rcases k.eq_zero_or_pos with (rfl | hk)\n  · rw [pow_zero, one_mul, is_root_cyclotomic_iff]\n  refine' ⟨fun h => _, fun h => _⟩\n  · rw [is_root.def, cyclotomic_mul_prime_pow_eq R (ne_zero.not_char_dvd R p m) hk, eval_pow] at h\n    replace h := pow_eq_zero h\n    rwa [← is_root.def, is_root_cyclotomic_iff] at h\n  · rw [← is_root_cyclotomic_iff, is_root.def] at h\n    rw [cyclotomic_mul_prime_pow_eq R (ne_zero.not_char_dvd R p m) hk, is_root.def, eval_pow, h, zero_pow]\n    simp only [tsub_pos_iff_lt]\n    apply pow_strict_mono_right hp.out.one_lt (nat.pred_lt hk.ne')\n#align is_root_cyclotomic_prime_pow_mul_iff_of_char_p is_root_cyclotomic_prime_pow_mul_iff_of_char_p\n\n",
 "is_root_cyclotomic_iff_char_zero":
 "/-- If `R` is of characteristic zero, then `ζ` is a root of `cyclotomic n R` if and only if it is a\nprimitive `n`-th root of unity. -/\ntheorem is_root_cyclotomic_iff_char_zero {n : ℕ} {R : Type _} [CommRing R] [IsDomain R] [CharZero R] {μ : R}\n    (hn : 0 < n) : (polynomial.cyclotomic n R).is_root μ ↔ is_primitive_root μ n :=\n  letI := NeZero.of_gt hn\n  is_root_cyclotomic_iff\n#align is_root_cyclotomic_iff_char_zero is_root_cyclotomic_iff_char_zero\n\n",
 "is_root_cyclotomic_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\nprivate theorem is_root_cyclotomic_iff' {n : ℕ} {K : Type _} [Field K] {μ : K} [ne_zero (n : K)] :\n    is_root (cyclotomic n K) μ ↔ is_primitive_root μ n :=\n  by\n  -- in this proof, `o` stands for `order_of μ`\n  have hnpos : 0 < n := (NeZero.of_neZero_natCast K).out.bot_lt\n  refine' ⟨fun hμ => _, is_primitive_root.is_root_cyclotomic hnpos⟩\n  have hμn : μ ^ n = 1 := by\n    rw [is_root_of_unity_iff hnpos]\n    exact ⟨n, n.mem_divisors_self hnpos.ne', hμ⟩\n  by_contra hnμ\n  have ho : 0 < order_of μ := by\n    apply order_of_pos'\n    rw [is_of_fin_order_iff_pow_eq_one]\n    exact ⟨n, hnpos, hμn⟩\n  have := pow_order_of_eq_one μ\n  rw [is_root_of_unity_iff ho] at this\n  obtain ⟨i, hio, hiμ⟩ := this\n  replace hio := nat.dvd_of_mem_divisors hio\n  rw [is_primitive_root.not_iff] at hnμ\n  rw [← order_of_dvd_iff_pow_eq_one] at hμn\n  have key : i < n := (nat.le_of_dvd ho hio).trans_lt ((nat.le_of_dvd hnpos hμn).lt_of_ne hnμ)\n  have key' : i ∣ n := hio.trans hμn\n  rw [← polynomial.dvd_iff_is_root] at hμ hiμ\n  have hni : {i, n} ⊆ n.divisors := by simpa [Finset.insert_subset, key'] using hnpos.ne'\n  obtain ⟨k, hk⟩ := hiμ\n  obtain ⟨j, hj⟩ := hμ\n  have := prod_cyclotomic_eq_X_pow_sub_one hnpos K\n  rw [← finset.prod_sdiff hni, finset.prod_pair key.ne, hk, hj] at this\n  have hn := (X_pow_sub_one_separable_iff.mpr <| NeZero.natCast_ne n K).squarefree\n  rw [← this, squarefree] at hn\n  contrapose! hn\n  refine'\n    ⟨X - C μ,\n      ⟨finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n              (n.divisors \\ {i, n}) (cyclotomic x K) *\n            k *\n          j,\n        by ring⟩,\n      _⟩\n  simp [polynomial.is_unit_iff_degree_eq_zero]\n#align is_root_cyclotomic_iff' is_root_cyclotomic_iff'\n\n",
 "is_root_cyclotomic_iff":
 "theorem is_root_cyclotomic_iff [ne_zero (n : R)] {μ : R} : is_root (cyclotomic n R) μ ↔ is_primitive_root μ n :=\n  by\n  have hf : function.injective _ := is_fraction_ring.injective R (fraction_ring R)\n  haveI : ne_zero (n : fraction_ring R) := ne_zero.nat_of_injective hf\n  rw [← is_root_map_iff hf, ← is_primitive_root.map_iff_of_injective hf, map_cyclotomic, ← is_root_cyclotomic_iff']\n#align is_root_cyclotomic_iff is_root_cyclotomic_iff\n\n",
 "is_root_cyclotomic":
 "/-- Any `n`-th primitive root of unity is a root of `cyclotomic n K`.-/\ntheorem _root_.is_primitive_root.is_root_cyclotomic (hpos : 0 < n) {μ : R} (h : is_primitive_root μ n) :\n    is_root (cyclotomic n R) μ :=\n  by\n  rw [← mem_roots (cyclotomic_ne_zero n R), cyclotomic_eq_prod_X_sub_primitive_roots h, roots_prod_X_sub_C, ←\n    Finset.mem_def]\n  rwa [← mem_primitive_roots hpos] at h\n#align is_primitive_root.is_root_cyclotomic is_primitive_root.is_root_cyclotomic\n\n",
 "is_primitive":
 "/-- `cyclotomic n` is primitive. -/\ntheorem cyclotomic.is_primitive (n : ℕ) (R : Type _) [CommRing R] : (cyclotomic n R).is_primitive :=\n  (cyclotomic.monic n R).is_primitive\n#align cyclotomic.is_primitive cyclotomic.is_primitive\n\n",
 "is_coprime_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- If `n ≠ m`, then `(cyclotomic n ℚ)` and `(cyclotomic m ℚ)` are coprime. -/\ntheorem cyclotomic.is_coprime_rat {n m : ℕ} (h : n ≠ m) : IsCoprime (cyclotomic n (exprℚ)) (cyclotomic m (exprℚ)) :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hnzero)\n  · exact isCoprime_one_left\n  rcases m.eq_zero_or_pos with (rfl | hmzero)\n  · exact isCoprime_one_right\n  rw [irreducible.coprime_iff_not_dvd <| cyclotomic.irreducible_rat <| hnzero]\n  exact fun hdiv =>\n    h <|\n      cyclotomic_injective <|\n        eq_of_monic_of_associated (cyclotomic.monic n (exprℚ)) (cyclotomic.monic m (exprℚ)) <|\n          Irreducible.associated_of_dvd (cyclotomic.irreducible_rat hnzero) (cyclotomic.irreducible_rat hmzero) hdiv\n#align cyclotomic.is_coprime_rat cyclotomic.is_coprime_rat\n\n",
 "irreducible_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem cyclotomic.irreducible_rat {n : ℕ} (hpos : 0 < n) : Irreducible (cyclotomic n (exprℚ)) :=\n  by\n  rw [← map_cyclotomic_int]\n  exact\n    (is_primitive.irreducible_iff_irreducible_map_fraction_map (cyclotomic.is_primitive n ℤ)).1\n      (cyclotomic.irreducible hpos)\n#align cyclotomic.irreducible_rat cyclotomic.irreducible_rat\n\n",
 "irreducible":
 "/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem cyclotomic.irreducible {n : ℕ} (hpos : 0 < n) : Irreducible (cyclotomic n ℤ) :=\n  by\n  rw [cyclotomic_eq_minpoly (is_primitive_root_exp n hpos.ne') hpos]\n  apply minpoly.irreducible\n  exact (is_primitive_root_exp n hpos.ne').is_integral hpos\n#align cyclotomic.irreducible cyclotomic.irreducible\n\n",
 "int_cyclotomic_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem int_cyclotomic_unique {n : ℕ} {P : polynomial ℤ} (h : map (Int.castRingHom (exprℂ)) P = cyclotomic' n (exprℂ)) :\n    P = cyclotomic n ℤ := by\n  apply map_injective (Int.castRingHom (exprℂ)) Int.cast_injective\n  rw [h, (int_cyclotomic_spec n).1]\n#align int_cyclotomic_unique int_cyclotomic_unique\n\n",
 "int_cyclotomic_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem int_cyclotomic_spec (n : ℕ) :\n    map (Int.castRingHom (exprℂ)) (cyclotomic n ℤ) = cyclotomic' n (exprℂ) ∧\n      (cyclotomic n ℤ).degree = (cyclotomic' n (exprℂ)).degree ∧ (cyclotomic n ℤ).monic :=\n  by\n  by_cases hzero : n = 0\n  ·\n    simp only [hzero, cyclotomic, degree_one, monic_one, cyclotomic'_zero, dif_pos, eq_self_iff_true,\n      polynomial.map_one, and_self_iff]\n  rw [int_cyclotomic_rw hzero]\n  exact (int_coeff_of_cyclotomic' (complex.is_primitive_root_exp n hzero)).some_spec\n#align int_cyclotomic_spec int_cyclotomic_spec\n\n",
 "int_cyclotomic_rw":
 "theorem int_cyclotomic_rw {n : ℕ} (h : n ≠ 0) :\n    cyclotomic n ℤ = (int_coeff_of_cyclotomic' (complex.is_primitive_root_exp n h)).some :=\n  by\n  simp only [cyclotomic, h, dif_neg, not_false_iff]\n  ext i\n  simp only [coeff_map, Int.cast_id, eq_intCast]\n#align int_cyclotomic_rw int_cyclotomic_rw\n\n",
 "int_coeff_of_cyclotomic'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If there is a primitive `n`-th root of unity in `K`, then `cyclotomic' n K` comes from a\nmonic polynomial with integer coefficients. -/\ntheorem int_coeff_of_cyclotomic' {K : Type _} [CommRing K] [IsDomain K] {ζ : K} {n : ℕ} (h : is_primitive_root ζ n) :\n    ∃ P : polynomial ℤ, map (Int.castRingHom K) P = cyclotomic' n K ∧ P.degree = (cyclotomic' n K).degree ∧ P.monic :=\n  by\n  refine' lifts_and_degree_eq_and_monic _ (cyclotomic'.monic n K)\n  induction' n using nat.strong_induction_on with k ihk generalizing ζ h\n  rcases k.eq_zero_or_pos with (rfl | hpos)\n  · use 1\n    simp only [cyclotomic'_zero, coe_map_ring_hom, polynomial.map_one]\n  let B : polynomial K :=\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n      (nat.proper_divisors k) (cyclotomic' i K)\n  have Bmo : B.monic := by\n    apply monic_prod_of_monic\n    intro i hi\n    exact cyclotomic'.monic i K\n  have Bint : B ∈ lifts (Int.castRingHom K) :=\n    by\n    refine' subsemiring.prod_mem (lifts (Int.castRingHom K)) _\n    intro x hx\n    have xsmall := (nat.mem_proper_divisors.1 hx).2\n    obtain ⟨d, hd⟩ := (nat.mem_proper_divisors.1 hx).1\n    rw [mul_comm] at hd\n    exact ihk x xsmall (h.pow hpos hd)\n  replace Bint := lifts_and_degree_eq_and_monic Bint Bmo\n  obtain ⟨B₁, hB₁, hB₁deg, hB₁mo⟩ := Bint\n  let Q₁ : polynomial ℤ := «expr /ₘ » (X ^ k - 1) B₁\n  have huniq : 0 + B * cyclotomic' k K = X ^ k - 1 ∧ (0 : polynomial K).degree < B.degree :=\n    by\n    constructor\n    ·\n      rw [zero_add, mul_comm, ← prod_cyclotomic'_eq_X_pow_sub_one hpos h, ← nat.cons_self_proper_divisors hpos.ne',\n        finset.prod_cons]\n    · simpa only [degree_zero, bot_lt_iff_ne_bot, ne.def, degree_eq_bot] using Bmo.ne_zero\n  replace huniq := div_mod_by_monic_unique (cyclotomic' k K) (0 : polynomial K) Bmo huniq\n  simp only [lifts, ring_hom.mem_srange]\n  use Q₁\n  rw [coe_map_ring_hom, map_div_by_monic (Int.castRingHom K) hB₁mo, hB₁, ← huniq.1]\n  simp\n#align int_coeff_of_cyclotomic' int_coeff_of_cyclotomic'\n\n",
 "eval_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem cyclotomic.eval_apply {R S : Type _} (q : R) (n : ℕ) [Ring R] [Ring S] (f : «expr →+* » R S) :\n    eval (f q) (cyclotomic n S) = f (eval q (cyclotomic n R)) := by rw [← map_cyclotomic n f, eval_map, eval₂_at_apply]\n#align cyclotomic.eval_apply cyclotomic.eval_apply\n\n",
 "eq_cyclotomic_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem eq_cyclotomic_iff {R : Type _} [CommRing R] {n : ℕ} (hpos : 0 < n) (P : polynomial R) :\n    P = cyclotomic n R ↔\n      P *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (nat.proper_divisors n) (polynomial.cyclotomic i R) =\n        X ^ n - 1 :=\n  by\n  nontriviality R\n  refine' ⟨fun hcycl => _, fun hP => _⟩\n  · rw [hcycl, ← prod_cyclotomic_eq_X_pow_sub_one hpos R, ← nat.cons_self_proper_divisors hpos.ne', finset.prod_cons]\n  · have prod_monic :\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (nat.proper_divisors n) (cyclotomic i R)).monic :=\n      by\n      apply monic_prod_of_monic\n      intro i hi\n      exact cyclotomic.monic i R\n    rw [@cyclotomic_eq_X_pow_sub_one_div R _ _ hpos, (div_mod_by_monic_unique P 0 prod_monic _).1]\n    refine' ⟨by rwa [zero_add, mul_comm], _⟩\n    rw [degree_zero, bot_lt_iff_ne_bot]\n    intro h\n    exact monic.ne_zero prod_monic (degree_eq_bot.1 h)\n#align eq_cyclotomic_iff eq_cyclotomic_iff\n\n",
 "dvd_X_pow_sub_one":
 "theorem cyclotomic.dvd_X_pow_sub_one (n : ℕ) (R : Type _) [Ring R] : cyclotomic n R ∣ X ^ n - 1 :=\n  by\n  suffices cyclotomic n ℤ ∣ X ^ n - 1 by\n    simpa only [map_cyclotomic_int, polynomial.map_sub, polynomial.map_one, polynomial.map_pow, polynomial.map_X] using\n      map_dvd (Int.castRingHom R) this\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  rw [← prod_cyclotomic_eq_X_pow_sub_one hn]\n  exact finset.dvd_prod_of_mem _ (n.mem_divisors_self hn.ne')\n#align cyclotomic.dvd_X_pow_sub_one cyclotomic.dvd_X_pow_sub_one\n\n",
 "degree_cyclotomic_pos":
 "/-- The degree of `cyclotomic n R` is positive. -/\ntheorem degree_cyclotomic_pos (n : ℕ) (R : Type _) (hpos : 0 < n) [Ring R] [nontrivial R] :\n    0 < (cyclotomic n R).degree := by\n  rw [degree_cyclotomic n R]\n  exact_mod_cast nat.totient_pos hpos\n#align degree_cyclotomic_pos degree_cyclotomic_pos\n\n",
 "degree_cyclotomic'":
 "/-- The degree of `cyclotomic' n R` is `totient n` if there is a primitive root of unity in `R`. -/\ntheorem degree_cyclotomic' {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : (cyclotomic' n R).degree = nat.totient n := by\n  simp only [degree_eq_nat_degree (cyclotomic'_ne_zero n R), nat_degree_cyclotomic' h]\n#align degree_cyclotomic' degree_cyclotomic'\n\n",
 "degree_cyclotomic":
 "/-- The degree of `cyclotomic n` is `totient n`. -/\ntheorem degree_cyclotomic (n : ℕ) (R : Type _) [Ring R] [nontrivial R] : (cyclotomic n R).degree = nat.totient n :=\n  by\n  rw [← map_cyclotomic_int]\n  rw [degree_map_eq_of_leading_coeff_ne_zero (Int.castRingHom R) _]\n  · cases' n with k\n    · simp only [cyclotomic, degree_one, dif_pos, nat.totient_zero, with_top.coe_zero]\n    rw [← degree_cyclotomic' (complex.is_primitive_root_exp k.succ (nat.succ_ne_zero k))]\n    exact (int_cyclotomic_spec k.succ).2.1\n  simp only [(int_cyclotomic_spec n).right.right, eq_intCast, monic.leading_coeff, Int.cast_one, ne.def, not_false_iff,\n    one_ne_zero]\n#align degree_cyclotomic degree_cyclotomic\n\n",
 "cyclotomic_zero":
 "/-- The zeroth cyclotomic polyomial is `1`. -/\n@[simp]\ntheorem cyclotomic_zero (R : Type _) [Ring R] : cyclotomic 0 R = 1 := by simp only [cyclotomic, dif_pos]\n#align cyclotomic_zero cyclotomic_zero\n\n",
 "cyclotomic_two":
 "@[simp]\ntheorem cyclotomic_two (R : Type _) [Ring R] : cyclotomic 2 R = X + 1 := by simp [cyclotomic_prime]\n#align cyclotomic_two cyclotomic_two\n\n",
 "cyclotomic_three":
 "@[simp]\ntheorem cyclotomic_three (R : Type _) [Ring R] : cyclotomic 3 R = X ^ 2 + X + 1 := by\n  simp [cyclotomic_prime, sum_range_succ']\n#align cyclotomic_three cyclotomic_three\n\n",
 "cyclotomic_prime_pow_mul_X_pow_sub_one":
 "theorem cyclotomic_prime_pow_mul_X_pow_sub_one (R : Type _) [CommRing R] (p k : ℕ) [hn : fact (Nat.Prime p)] :\n    cyclotomic (p ^ (k + 1)) R * (X ^ p ^ k - 1) = X ^ p ^ (k + 1) - 1 := by\n  rw [cyclotomic_prime_pow_eq_geom_sum hn.out, geom_sum_mul, ← pow_mul, pow_succ, mul_comm]\n#align cyclotomic_prime_pow_mul_X_pow_sub_one cyclotomic_prime_pow_mul_X_pow_sub_one\n\n",
 "cyclotomic_prime_pow_eq_geom_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If `p ^ k` is a prime power, then\n`cyclotomic (p ^ (n + 1)) R = ∑ i in range p, (X ^ (p ^ n)) ^ i`. -/\ntheorem cyclotomic_prime_pow_eq_geom_sum {R : Type _} [CommRing R] {p n : ℕ} (hp : p.prime) :\n    cyclotomic (p ^ (n + 1)) R =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range p)\n        ((X ^ p ^ n) ^ i) :=\n  by\n  have :\n    ∀ m,\n      cyclotomic (p ^ (m + 1)) R =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.range p) ((X ^ p ^ m) ^ i) ↔\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range p)\n              ((X ^ p ^ m) ^ i) *\n            finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n              (Finset.range (m + 1)) (cyclotomic (p ^ x) R) =\n          X ^ p ^ (m + 1) - 1 :=\n    by\n    intro m\n    have := eq_cyclotomic_iff (pow_pos hp.pos (m + 1)) _\n    rw [eq_comm] at this\n    rw [this, nat.prod_proper_divisors_prime_pow hp]\n  induction' n with n_n n_ih\n  · haveI := fact.mk hp\n    simp [cyclotomic_prime]\n  rw [((eq_cyclotomic_iff (pow_pos hp.pos (n_n.succ + 1)) _).mpr _).symm]\n  rw [nat.prod_proper_divisors_prime_pow hp, finset.prod_range_succ, n_ih]\n  rw [this] at n_ih\n  rw [mul_comm _ (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" _ _),\n    n_ih, geom_sum_mul, sub_left_inj, ← pow_mul, pow_add, pow_one]\n#align cyclotomic_prime_pow_eq_geom_sum cyclotomic_prime_pow_eq_geom_sum\n\n",
 "cyclotomic_prime_mul_X_sub_one":
 "theorem cyclotomic_prime_mul_X_sub_one (R : Type _) [Ring R] (p : ℕ) [hn : fact (Nat.Prime p)] :\n    cyclotomic p R * (X - 1) = X ^ p - 1 := by rw [cyclotomic_prime, geom_sum_mul]\n#align cyclotomic_prime_mul_X_sub_one cyclotomic_prime_mul_X_sub_one\n\n",
 "cyclotomic_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If `p` is prime, then `cyclotomic p R = ∑ i in range p, X ^ i`. -/\ntheorem cyclotomic_prime (R : Type _) [Ring R] (p : ℕ) [hp : fact p.prime] :\n    cyclotomic p R =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range p)\n        (X ^ i) :=\n  by\n  suffices\n    cyclotomic p ℤ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range p) (X ^ i)\n    by\n    simpa only [map_cyclotomic_int, polynomial.map_sum, polynomial.map_pow, polynomial.map_X] using\n      congr_arg (map (Int.castRingHom R)) this\n  rw [← prod_cyclotomic_eq_geom_sum hp.out.pos, hp.out.divisors, erase_insert (mem_singleton.not.2 hp.out.ne_one.symm),\n    prod_singleton]\n#align cyclotomic_prime cyclotomic_prime\n\n",
 "cyclotomic_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The first cyclotomic polyomial is `X - 1`. -/\n@[simp]\ntheorem cyclotomic_one (R : Type _) [Ring R] : cyclotomic 1 R = X - 1 :=\n  by\n  have hspec : map (Int.castRingHom (exprℂ)) (X - 1) = cyclotomic' 1 (exprℂ) := by\n    simp only [cyclotomic'_one, PNat.one_coe, map_X, polynomial.map_one, polynomial.map_sub]\n  symm\n  rw [← map_cyclotomic_int, ← int_cyclotomic_unique hspec]\n  simp only [map_X, polynomial.map_one, polynomial.map_sub]\n#align cyclotomic_one cyclotomic_one\n\n",
 "cyclotomic_ne_zero":
 "/-- `cyclotomic n R` is different from `0`. -/\ntheorem cyclotomic_ne_zero (n : ℕ) (R : Type _) [Ring R] [nontrivial R] : cyclotomic n R ≠ 0 :=\n  (cyclotomic.monic n R).ne_zero\n#align cyclotomic_ne_zero cyclotomic_ne_zero\n\n",
 "cyclotomic_mul_prime_pow_eq":
 "/-- If `R` is of characteristic `p` and `¬p ∣ m`, then\n`cyclotomic (p ^ k * m) R = (cyclotomic m R) ^ (p ^ k - p ^ (k - 1))`. -/\ntheorem cyclotomic_mul_prime_pow_eq (R : Type _) {p m : ℕ} [fact (Nat.Prime p)] [Ring R] [char_p R p] (hm : ¬p ∣ m) :\n    ∀ {k}, 0 < k → cyclotomic (p ^ k * m) R = cyclotomic m R ^ (p ^ k - p ^ (k - 1))\n  | 1, _ => by rw [pow_one, nat.sub_self, pow_zero, mul_comm, cyclotomic_mul_prime_eq_pow_of_not_dvd R hm]\n  | a + 2, _ => by\n    have hdiv : p ∣ p ^ a.succ * m := ⟨p ^ a * m, by rw [← mul_assoc, pow_succ]⟩\n    rw [pow_succ, mul_assoc, mul_comm, cyclotomic_mul_prime_dvd_eq_pow R hdiv, cyclotomic_mul_prime_pow_eq a.succ_pos, ←\n      pow_mul]\n    congr 1\n    simp only [tsub_zero, nat.succ_sub_succ_eq_sub]\n    rw [nat.mul_sub_right_distrib, mul_comm, pow_succ']\n#align cyclotomic_mul_prime_pow_eq cyclotomic_mul_prime_pow_eq\n\n",
 "cyclotomic_mul_prime_eq_pow_of_not_dvd":
 "/-- If `R` is of characteristic `p` and `¬p ∣ n`, then\n`cyclotomic (n * p) R = (cyclotomic n R) ^ (p - 1)`. -/\ntheorem cyclotomic_mul_prime_eq_pow_of_not_dvd (R : Type _) {p n : ℕ} [hp : fact (Nat.Prime p)] [Ring R] [char_p R p]\n    (hn : ¬p ∣ n) : cyclotomic (n * p) R = cyclotomic n R ^ (p - 1) :=\n  by\n  suffices cyclotomic (n * p) (zmod p) = cyclotomic n (zmod p) ^ (p - 1) by\n    rw [← map_cyclotomic _ (algebra_map (zmod p) R), ← map_cyclotomic _ (algebra_map (zmod p) R), this,\n      polynomial.map_pow]\n  apply mul_right_injective₀ (cyclotomic_ne_zero n <| zmod p)\n  rw [← pow_succ, tsub_add_cancel_of_le hp.out.one_lt.le, mul_comm, ← zmod.expand_card]\n  nth_rw 3 [← map_cyclotomic_int]\n  rw [← map_expand, cyclotomic_expand_eq_cyclotomic_mul hp.out hn, polynomial.map_mul, map_cyclotomic, map_cyclotomic]\n#align cyclotomic_mul_prime_eq_pow_of_not_dvd cyclotomic_mul_prime_eq_pow_of_not_dvd\n\n",
 "cyclotomic_mul_prime_dvd_eq_pow":
 "/-- If `R` is of characteristic `p` and `p ∣ n`, then\n`cyclotomic (n * p) R = (cyclotomic n R) ^ p`. -/\ntheorem cyclotomic_mul_prime_dvd_eq_pow (R : Type _) {p n : ℕ} [hp : fact (Nat.Prime p)] [Ring R] [char_p R p]\n    (hn : p ∣ n) : cyclotomic (n * p) R = cyclotomic n R ^ p :=\n  by\n  suffices cyclotomic (n * p) (zmod p) = cyclotomic n (zmod p) ^ p by\n    rw [← map_cyclotomic _ (algebra_map (zmod p) R), ← map_cyclotomic _ (algebra_map (zmod p) R), this,\n      polynomial.map_pow]\n  rw [← zmod.expand_card, ← map_cyclotomic_int n, ← map_expand, cyclotomic_expand_eq_cyclotomic hp.out hn,\n    map_cyclotomic, mul_comm]\n#align cyclotomic_mul_prime_dvd_eq_pow cyclotomic_mul_prime_dvd_eq_pow\n\n",
 "cyclotomic_irreducible_pow_of_irreducible_pow":
 "/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem cyclotomic_irreducible_pow_of_irreducible_pow {p : ℕ} (hp : Nat.Prime p) {R} [CommRing R] [IsDomain R] {n m : ℕ}\n    (hmn : m ≤ n) (h : Irreducible (cyclotomic (p ^ n) R)) : Irreducible (cyclotomic (p ^ m) R) :=\n  by\n  rcases m.eq_zero_or_pos with (rfl | hm)\n  · simpa using irreducible_X_sub_C (1 : R)\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le hmn\n  induction' k with k hk\n  · simpa using h\n  have : m + k ≠ 0 := (add_pos_of_pos_of_nonneg hm k.zero_le).ne'\n  rw [nat.add_succ, pow_succ', ← cyclotomic_expand_eq_cyclotomic hp <| dvd_pow_self p this] at h\n  exact hk (by linarith) (of_irreducible_expand hp.ne_zero h)\n#align cyclotomic_irreducible_pow_of_irreducible_pow cyclotomic_irreducible_pow_of_irreducible_pow\n\n",
 "cyclotomic_irreducible_of_irreducible_pow":
 "/-- If `irreducible (cyclotomic (p ^ n) R)` then `irreducible (cyclotomic p R).` -/\ntheorem cyclotomic_irreducible_of_irreducible_pow {p : ℕ} (hp : Nat.Prime p) {R} [CommRing R] [IsDomain R] {n : ℕ}\n    (hn : n ≠ 0) (h : Irreducible (cyclotomic (p ^ n) R)) : Irreducible (cyclotomic p R) :=\n  pow_one p ▸ cyclotomic_irreducible_pow_of_irreducible_pow hp hn.bot_lt h\n#align cyclotomic_irreducible_of_irreducible_pow cyclotomic_irreducible_of_irreducible_pow\n\n",
 "cyclotomic_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- Over a ring `R` of characteristic zero, `λ n, cyclotomic n R` is injective. -/\ntheorem cyclotomic_injective {R : Type _} [CommRing R] [CharZero R] : function.injective fun n => cyclotomic n R :=\n  by\n  intro n m hnm\n  simp only at hnm\n  rcases eq_or_ne n 0 with (rfl | hzero)\n  · rw [cyclotomic_zero] at hnm\n    replace hnm := congr_arg nat_degree hnm\n    rw [nat_degree_one, nat_degree_cyclotomic] at hnm\n    by_contra\n    exact (nat.totient_pos (zero_lt_iff.2 (ne.symm h))).ne hnm\n  · haveI := ne_zero.mk hzero\n    rw [← map_cyclotomic_int _ R, ← map_cyclotomic_int _ R] at hnm\n    replace hnm := map_injective (Int.castRingHom R) Int.cast_injective hnm\n    replace hnm := congr_arg (map (Int.castRingHom (exprℂ))) hnm\n    rw [map_cyclotomic_int, map_cyclotomic_int] at hnm\n    have hprim := complex.is_primitive_root_exp _ hzero\n    have hroot := is_root_cyclotomic_iff.2 hprim\n    rw [hnm] at hroot\n    haveI hmzero : ne_zero m := ⟨fun h => by simpa [h] using hroot⟩\n    rw [is_root_cyclotomic_iff] at hroot\n    replace hprim := hprim.eq_order_of\n    rwa [← is_primitive_root.eq_order_of hroot] at hprim\n#align cyclotomic_injective cyclotomic_injective\n\n",
 "cyclotomic_expand_eq_cyclotomic_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- If `p` is a prime such that `¬ p ∣ n`, then\n`expand R p (cyclotomic n R) = (cyclotomic (n * p) R) * (cyclotomic n R)`. -/\n@[simp]\ntheorem cyclotomic_expand_eq_cyclotomic_mul {p n : ℕ} (hp : Nat.Prime p) (hdiv : ¬p ∣ n) (R : Type _) [CommRing R] :\n    expand R p (cyclotomic n R) = cyclotomic (n * p) R * cyclotomic n R :=\n  by\n  rcases nat.eq_zero_or_pos n with (rfl | hnpos)\n  · simp\n  haveI := ne_zero.of_pos hnpos\n  suffices expand ℤ p (cyclotomic n ℤ) = cyclotomic (n * p) ℤ * cyclotomic n ℤ by\n    rw [← map_cyclotomic_int, ← map_expand, this, polynomial.map_mul, map_cyclotomic_int]\n  refine'\n    eq_of_monic_of_dvd_of_nat_degree_le ((cyclotomic.monic _ _).mul (cyclotomic.monic _ _))\n      ((cyclotomic.monic n ℤ).expand hp.pos) _ _\n  · refine'\n      (is_primitive.int.dvd_iff_map_cast_dvd_map_cast _ _\n            (is_primitive.mul (cyclotomic.is_primitive (n * p) ℤ) (cyclotomic.is_primitive n ℤ))\n            ((cyclotomic.monic n ℤ).expand hp.pos).is_primitive).2\n        _\n    rw [polynomial.map_mul, map_cyclotomic_int, map_cyclotomic_int, map_expand, map_cyclotomic_int]\n    refine' IsCoprime.mul_dvd (cyclotomic.is_coprime_rat fun h => _) _ _\n    · replace h : n * p = n * 1 := by simp [h]\n      exact Nat.Prime.ne_one hp (mul_left_cancel₀ hnpos.ne' h)\n    · have hpos : 0 < n * p := mul_pos hnpos hp.pos\n      have hprim := complex.is_primitive_root_exp _ hpos.ne'\n      rw [cyclotomic_eq_minpoly_rat hprim hpos]\n      refine' @minpoly.dvd (exprℚ) (exprℂ) _ _ algebra_rat _ _ _\n      rw [aeval_def, ← eval_map, map_expand, map_cyclotomic, expand_eval, ← is_root.def, is_root_cyclotomic_iff]\n      convert is_primitive_root.pow_of_dvd hprim hp.ne_zero (dvd_mul_left p n)\n      rw [nat.mul_div_cancel _ (Nat.Prime.pos hp)]\n    · have hprim := complex.is_primitive_root_exp _ hnpos.ne.symm\n      rw [cyclotomic_eq_minpoly_rat hprim hnpos]\n      refine' @minpoly.dvd (exprℚ) (exprℂ) _ _ algebra_rat _ _ _\n      rw [aeval_def, ← eval_map, map_expand, expand_eval, ← is_root.def, ← cyclotomic_eq_minpoly_rat hprim hnpos,\n        map_cyclotomic, is_root_cyclotomic_iff]\n      exact is_primitive_root.pow_of_prime hprim hp hdiv\n  ·\n    rw [nat_degree_expand, nat_degree_cyclotomic, nat_degree_mul (cyclotomic_ne_zero _ ℤ) (cyclotomic_ne_zero _ ℤ),\n      nat_degree_cyclotomic, nat_degree_cyclotomic, mul_comm n,\n      nat.totient_mul ((Nat.Prime.coprime_iff_not_dvd hp).2 hdiv), nat.totient_prime hp, mul_comm (p - 1), ←\n      nat.mul_succ, nat.sub_one, nat.succ_pred_eq_of_pos hp.pos]\n#align cyclotomic_expand_eq_cyclotomic_mul cyclotomic_expand_eq_cyclotomic_mul\n\n",
 "cyclotomic_expand_eq_cyclotomic":
 "/-- If `p` is a prime such that `p ∣ n`, then\n`expand R p (cyclotomic n R) = cyclotomic (p * n) R`. -/\n@[simp]\ntheorem cyclotomic_expand_eq_cyclotomic {p n : ℕ} (hp : Nat.Prime p) (hdiv : p ∣ n) (R : Type _) [CommRing R] :\n    expand R p (cyclotomic n R) = cyclotomic (n * p) R :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hzero)\n  · simp\n  haveI := ne_zero.of_pos hzero\n  suffices expand ℤ p (cyclotomic n ℤ) = cyclotomic (n * p) ℤ by\n    rw [← map_cyclotomic_int, ← map_expand, this, map_cyclotomic_int]\n  refine' eq_of_monic_of_dvd_of_nat_degree_le (cyclotomic.monic _ _) ((cyclotomic.monic n ℤ).expand hp.pos) _ _\n  · have hpos := nat.mul_pos hzero hp.pos\n    have hprim := complex.is_primitive_root_exp _ hpos.ne.symm\n    rw [cyclotomic_eq_minpoly hprim hpos]\n    refine' minpoly.gcd_domain_dvd (hprim.is_integral hpos) ((cyclotomic.monic n ℤ).expand hp.pos).ne_zero _\n    rw [aeval_def, ← eval_map, map_expand, map_cyclotomic, expand_eval, ← is_root.def, is_root_cyclotomic_iff]\n    · convert is_primitive_root.pow_of_dvd hprim hp.ne_zero (dvd_mul_left p n)\n      rw [nat.mul_div_cancel _ hp.pos]\n  ·\n    rw [nat_degree_expand, nat_degree_cyclotomic, nat_degree_cyclotomic, mul_comm n,\n      nat.totient_mul_of_prime_of_dvd hp hdiv, mul_comm]\n#align cyclotomic_expand_eq_cyclotomic cyclotomic_expand_eq_cyclotomic\n\n",
 "cyclotomic_eq_prod_X_sub_primitive_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic n K = ∏ μ in primitive_roots n R, (X - C μ)`. In particular,\n`cyclotomic n K = cyclotomic' n K` -/\ntheorem cyclotomic_eq_prod_X_sub_primitive_roots {K : Type _} [CommRing K] [IsDomain K] {ζ : K} {n : ℕ}\n    (hz : is_primitive_root ζ n) :\n    cyclotomic n K =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (primitive_roots n K) (X - C μ) :=\n  by\n  rw [← cyclotomic']\n  induction' n using nat.strong_induction_on with k hk generalizing ζ hz\n  obtain hzero | hpos := k.eq_zero_or_pos\n  · simp only [hzero, cyclotomic'_zero, cyclotomic_zero]\n  have h : ∀ i ∈ k.proper_divisors, cyclotomic i K = cyclotomic' i K :=\n    by\n    intro i hi\n    obtain ⟨d, hd⟩ := (nat.mem_proper_divisors.1 hi).1\n    rw [mul_comm] at hd\n    exact hk i (nat.mem_proper_divisors.1 hi).2 (is_primitive_root.pow hpos hz hd)\n  rw [@cyclotomic_eq_X_pow_sub_one_div _ _ _ hpos, cyclotomic'_eq_X_pow_sub_one_div hpos hz,\n    finset.prod_congr (refl k.proper_divisors) h]\n#align cyclotomic_eq_prod_X_sub_primitive_roots cyclotomic_eq_prod_X_sub_primitive_roots\n\n",
 "cyclotomic_eq_prod_X_pow_sub_one_pow_moebius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `moebius -/\n/-- `cyclotomic n R` can be expressed as a product in a fraction field of `R[X]`\n  using Möbius inversion. -/\ntheorem cyclotomic_eq_prod_X_pow_sub_one_pow_moebius {n : ℕ} (R : Type _) [CommRing R] [IsDomain R] :\n    algebra_map _ (ratfunc R) (cyclotomic n R) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        n.divisors_antidiagonal (algebra_map (polynomial R) _ (X ^ i.snd - 1) ^ (moebius) i.fst) :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hpos)\n  · simp\n  have h :\n    ∀ n : ℕ,\n      0 < n →\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (nat.divisors n) (algebra_map _ (ratfunc R) (cyclotomic i R)) =\n          algebra_map _ _ (X ^ n - 1) :=\n    by\n    intro n hn\n    rw [← prod_cyclotomic_eq_X_pow_sub_one hn R, ring_hom.map_prod]\n  rw [(prod_eq_iff_prod_pow_moebius_eq_of_nonzero (fun n hn => _) fun n hn => _).1 h n hpos] <;>\n    rw [ne.def, is_fraction_ring.to_map_eq_zero_iff]\n  · apply cyclotomic_ne_zero\n  · apply monic.ne_zero\n    apply monic_X_pow_sub_C _ (ne_of_gt hn)\n#align cyclotomic_eq_prod_X_pow_sub_one_pow_moebius cyclotomic_eq_prod_X_pow_sub_one_pow_moebius\n\n",
 "cyclotomic_eq_minpoly_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- `cyclotomic n ℚ` is the minimal polynomial of a primitive `n`-th root of unity `μ`. -/\ntheorem cyclotomic_eq_minpoly_rat {n : ℕ} {K : Type _} [Field K] {μ : K} (h : is_primitive_root μ n) (hpos : 0 < n)\n    [CharZero K] : cyclotomic n (exprℚ) = minpoly (exprℚ) μ :=\n  by\n  rw [← map_cyclotomic_int, cyclotomic_eq_minpoly h hpos]\n  exact (minpoly.gcd_domain_eq_field_fractions' _ (is_integral h hpos)).symm\n#align cyclotomic_eq_minpoly_rat cyclotomic_eq_minpoly_rat\n\n",
 "cyclotomic_eq_minpoly":
 "/-- `cyclotomic n ℤ` is the minimal polynomial of a primitive `n`-th root of unity `μ`. -/\ntheorem cyclotomic_eq_minpoly {n : ℕ} {K : Type _} [Field K] {μ : K} (h : is_primitive_root μ n) (hpos : 0 < n)\n    [CharZero K] : cyclotomic n ℤ = minpoly ℤ μ :=\n  by\n  refine'\n    eq_of_monic_of_dvd_of_nat_degree_le (minpoly.monic (is_integral h hpos)) (cyclotomic.monic n ℤ)\n      (h.minpoly_dvd_cyclotomic hpos) _\n  simpa [nat_degree_cyclotomic n ℤ] using totient_le_degree_minpoly h\n#align cyclotomic_eq_minpoly cyclotomic_eq_minpoly\n\n",
 "cyclotomic_eq_X_pow_sub_one_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- We have\n`cyclotomic n R = (X ^ k - 1) /ₘ (∏ i in nat.proper_divisors k, cyclotomic i K)`. -/\ntheorem cyclotomic_eq_X_pow_sub_one_div {R : Type _} [CommRing R] {n : ℕ} (hpos : 0 < n) :\n    cyclotomic n R =\n      «expr /ₘ » (X ^ n - 1)\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (nat.proper_divisors n) (cyclotomic i R)) :=\n  by\n  nontriviality R\n  rw [← prod_cyclotomic_eq_X_pow_sub_one hpos, ← nat.cons_self_proper_divisors hpos.ne', finset.prod_cons]\n  have prod_monic :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (nat.proper_divisors n) (cyclotomic i R)).monic :=\n    by\n    apply monic_prod_of_monic\n    intro i hi\n    exact cyclotomic.monic i R\n  rw [(div_mod_by_monic_unique (cyclotomic n R) 0 prod_monic _).1]\n  simp only [degree_zero, zero_add]\n  constructor\n  · rw [mul_comm]\n  rw [bot_lt_iff_ne_bot]\n  intro h\n  exact monic.ne_zero prod_monic (degree_eq_bot.1 h)\n#align cyclotomic_eq_X_pow_sub_one_div cyclotomic_eq_X_pow_sub_one_div\n\n",
 "cyclotomic_dvd_geom_sum_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem cyclotomic_dvd_geom_sum_of_dvd (R) [Ring R] {d n : ℕ} (hdn : d ∣ n) (hd : d ≠ 1) :\n    cyclotomic d R ∣\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (X ^ i) :=\n  by\n  suffices\n    cyclotomic d ℤ ∣\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (X ^ i)\n    by\n    simpa only [map_cyclotomic_int, polynomial.map_sum, polynomial.map_pow, polynomial.map_X] using\n      map_dvd (Int.castRingHom R) this\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  rw [← prod_cyclotomic_eq_geom_sum hn]\n  apply finset.dvd_prod_of_mem\n  simp [hd, hdn, hn.ne']\n#align cyclotomic_dvd_geom_sum_of_dvd cyclotomic_dvd_geom_sum_of_dvd\n\n",
 "cyclotomic_coeff_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The constant term of `cyclotomic n R` is `1` if `2 ≤ n`. -/\ntheorem cyclotomic_coeff_zero (R : Type _) [CommRing R] {n : ℕ} (hn : 1 < n) : (cyclotomic n R).coeff 0 = 1 :=\n  by\n  induction' n using nat.strong_induction_on with n hi\n  have hprod :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (nat.proper_divisors n) ((polynomial.cyclotomic i R).coeff 0) =\n      -1 :=\n    by\n    rw [← Finset.insert_erase (nat.one_mem_proper_divisors_iff_one_lt.2 (lt_of_lt_of_le one_lt_two hn)),\n      finset.prod_insert (Finset.not_mem_erase 1 _), cyclotomic_one R]\n    have hleq : ∀ j ∈ n.proper_divisors.erase 1, 2 ≤ j :=\n      by\n      intro j hj\n      apply nat.succ_le_of_lt\n      exact\n        (Ne.le_iff_lt (Finset.mem_erase.1 hj).1.symm).mp\n          (nat.succ_le_of_lt (nat.pos_of_mem_proper_divisors (Finset.mem_erase.1 hj).2))\n    have hcongr : ∀ j ∈ n.proper_divisors.erase 1, (cyclotomic j R).coeff 0 = 1 :=\n      by\n      intro j hj\n      exact hi j (nat.mem_proper_divisors.1 (Finset.mem_erase.1 hj).2).2 (hleq j hj)\n    have hrw :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (n.proper_divisors.erase 1) ((cyclotomic x R).coeff 0) =\n        1 :=\n      by\n      rw [finset.prod_congr (refl (n.proper_divisors.erase 1)) hcongr]\n      simp only [finset.prod_const_one]\n    simp only [hrw, mul_one, zero_sub, coeff_one_zero, coeff_X_zero, coeff_sub]\n  have heq : (X ^ n - 1).coeff 0 = -(cyclotomic n R).coeff 0 := by\n    rw [← prod_cyclotomic_eq_X_pow_sub_one (zero_le_one.trans_lt hn), ← nat.cons_self_proper_divisors hn.ne_bot,\n      finset.prod_cons, mul_coeff_zero, coeff_zero_prod, hprod, mul_neg, mul_one]\n  have hzero : (X ^ n - 1).coeff 0 = (-1 : R) :=\n    by\n    rw [coeff_zero_eq_eval_zero _]\n    simp only [zero_pow (lt_of_lt_of_le zero_lt_two hn), eval_X, eval_one, zero_sub, eval_pow, eval_sub]\n  rw [hzero] at heq\n  exact neg_inj.mp (eq.symm HEq)\n#align cyclotomic_coeff_zero cyclotomic_coeff_zero\n\n",
 "cyclotomic'_zero":
 "/-\nCopyright (c) 2020 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\n/-- The zeroth modified cyclotomic polyomial is `1`. -/\n@[simp]\ntheorem cyclotomic'_zero (R : Type _) [CommRing R] [IsDomain R] : cyclotomic' 0 R = 1 := by\n  simp only [cyclotomic', finset.prod_empty, primitive_roots_zero]\n#align cyclotomic'_zero cyclotomic'_zero\n\n",
 "cyclotomic'_two":
 "/-- The second modified cyclotomic polyomial is `X + 1` if the characteristic of `R` is not `2`. -/\n@[simp]\ntheorem cyclotomic'_two (R : Type _) [CommRing R] [IsDomain R] (p : ℕ) [char_p R p] (hp : p ≠ 2) :\n    cyclotomic' 2 R = X + 1 := by\n  rw [cyclotomic']\n  have prim_root_two : primitive_roots 2 R = {(-1 : R)} :=\n    by\n    simp only [Finset.eq_singleton_iff_unique_mem, mem_primitive_roots two_pos]\n    exact ⟨is_primitive_root.neg_one p hp, fun x => is_primitive_root.eq_neg_one_of_two_right⟩\n  simp only [prim_root_two, finset.prod_singleton, RingHom.map_neg, RingHom.map_one, sub_neg_eq_add]\n#align cyclotomic'_two cyclotomic'_two\n\n",
 "cyclotomic'_splits":
 "/-- `cyclotomic' n K` splits. -/\ntheorem cyclotomic'_splits (n : ℕ) : splits (RingHom.id K) (cyclotomic' n K) :=\n  by\n  apply splits_prod (RingHom.id K)\n  intro z hz\n  simp only [splits_X_sub_C (RingHom.id K)]\n#align cyclotomic'_splits cyclotomic'_splits\n\n",
 "cyclotomic'_one":
 "/-- The first modified cyclotomic polyomial is `X - 1`. -/\n@[simp]\ntheorem cyclotomic'_one (R : Type _) [CommRing R] [IsDomain R] : cyclotomic' 1 R = X - 1 := by\n  simp only [cyclotomic', finset.prod_singleton, RingHom.map_one, is_primitive_root.primitive_roots_one]\n#align cyclotomic'_one cyclotomic'_one\n\n",
 "cyclotomic'_ne_zero":
 "/-- `cyclotomic' n R` is different from `0`. -/\ntheorem cyclotomic'_ne_zero (n : ℕ) (R : Type _) [CommRing R] [IsDomain R] : cyclotomic' n R ≠ 0 :=\n  (cyclotomic'.monic n R).ne_zero\n#align cyclotomic'_ne_zero cyclotomic'_ne_zero\n\n",
 "cyclotomic'_eq_X_pow_sub_one_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic' n K = (X ^ k - 1) /ₘ (∏ i in nat.proper_divisors k, cyclotomic' i K)`. -/\ntheorem cyclotomic'_eq_X_pow_sub_one_div {K : Type _} [CommRing K] [IsDomain K] {ζ : K} {n : ℕ} (hpos : 0 < n)\n    (h : is_primitive_root ζ n) :\n    cyclotomic' n K =\n      «expr /ₘ » (X ^ n - 1)\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (nat.proper_divisors n) (cyclotomic' i K)) :=\n  by\n  rw [← prod_cyclotomic'_eq_X_pow_sub_one hpos h, ← nat.cons_self_proper_divisors hpos.ne', finset.prod_cons]\n  have prod_monic :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (nat.proper_divisors n) (cyclotomic' i K)).monic :=\n    by\n    apply monic_prod_of_monic\n    intro i hi\n    exact cyclotomic'.monic i K\n  rw [(div_mod_by_monic_unique (cyclotomic' n K) 0 prod_monic _).1]\n  simp only [degree_zero, zero_add]\n  refine' ⟨by rw [mul_comm], _⟩\n  rw [bot_lt_iff_ne_bot]\n  intro h\n  exact monic.ne_zero prod_monic (degree_eq_bot.1 h)\n#align cyclotomic'_eq_X_pow_sub_one_div cyclotomic'_eq_X_pow_sub_one_div\n\n",
 "coprime_of_root_cyclotomic":
 "/-- If `(a : ℕ)` is a root of `cyclotomic n (zmod p)`, where `p` is a prime, then `a` and `p` are\ncoprime. -/\ntheorem coprime_of_root_cyclotomic {n : ℕ} (hpos : 0 < n) {p : ℕ} [hprime : fact p.prime] {a : ℕ}\n    (hroot : is_root (cyclotomic n (zmod p)) (nat.cast_ring_hom (zmod p) a)) : a.coprime p :=\n  by\n  apply nat.coprime.symm\n  rw [hprime.1.coprime_iff_not_dvd]\n  intro h\n  replace h := (zmod.nat_coe_zmod_eq_zero_iff_dvd a p).2 h\n  rw [is_root.def, eq_nat_cast, h, ← coeff_zero_eq_eval_zero] at hroot\n  by_cases hone : n = 1\n  · simp only [hone, cyclotomic_one, zero_sub, coeff_one_zero, coeff_X_zero, neg_eq_zero, one_ne_zero, coeff_sub] at\n      hroot\n    exact hroot\n  rw [cyclotomic_coeff_zero (zmod p) (nat.succ_le_of_lt (lt_of_le_of_ne (nat.succ_le_of_lt hpos) (ne.symm hone)))] at\n    hroot\n  exact one_ne_zero hroot\n#align coprime_of_root_cyclotomic coprime_of_root_cyclotomic\n\n",
 "X_pow_sub_one_splits":
 "/-- If there is a primitive `n`-th root of unity in `K`, then `X ^ n - 1`splits. -/\ntheorem X_pow_sub_one_splits {ζ : K} {n : ℕ} (h : is_primitive_root ζ n) : splits (RingHom.id K) (X ^ n - C (1 : K)) :=\n  by rw [splits_iff_card_roots, ← nth_roots, is_primitive_root.card_nth_roots h, nat_degree_X_pow_sub_C]\n#align X_pow_sub_one_splits X_pow_sub_one_splits\n\n",
 "X_pow_sub_one_mul_prod_cyclotomic_eq_X_pow_sub_one_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem X_pow_sub_one_mul_prod_cyclotomic_eq_X_pow_sub_one_of_dvd (R) [CommRing R] {d n : ℕ}\n    (h : d ∈ n.proper_divisors) :\n    (X ^ d - 1) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (n.divisors \\ d.divisors) (cyclotomic x R) =\n      X ^ n - 1 :=\n  by\n  obtain ⟨hd, hdn⟩ := nat.mem_proper_divisors.mp h\n  have h0n : 0 < n := pos_of_gt hdn\n  have h0d : 0 < d := nat.pos_of_dvd_of_pos hd h0n\n  rw [← prod_cyclotomic_eq_X_pow_sub_one h0d, ← prod_cyclotomic_eq_X_pow_sub_one h0n, mul_comm,\n    finset.prod_sdiff (nat.divisors_subset_of_dvd h0n.ne' hd)]\n#align\n  X_pow_sub_one_mul_prod_cyclotomic_eq_X_pow_sub_one_of_dvd X_pow_sub_one_mul_prod_cyclotomic_eq_X_pow_sub_one_of_dvd\n\n",
 "X_pow_sub_one_mul_cyclotomic_dvd_X_pow_sub_one_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem X_pow_sub_one_mul_cyclotomic_dvd_X_pow_sub_one_of_dvd (R) [CommRing R] {d n : ℕ} (h : d ∈ n.proper_divisors) :\n    (X ^ d - 1) * cyclotomic n R ∣ X ^ n - 1 :=\n  by\n  have hdn := (nat.mem_proper_divisors.mp h).2\n  use\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n      (n.proper_divisors \\ d.divisors) (cyclotomic x R)\n  symm\n  convert X_pow_sub_one_mul_prod_cyclotomic_eq_X_pow_sub_one_of_dvd R h using 1\n  rw [mul_assoc]\n  congr 1\n  rw [← nat.insert_self_proper_divisors hdn.ne_bot, insert_sdiff_of_not_mem, prod_insert]\n  · exact Finset.not_mem_sdiff_of_not_mem_left nat.proper_divisors.not_self_mem\n  · exact fun hk => hdn.not_le <| nat.divisor_le hk\n#align X_pow_sub_one_mul_cyclotomic_dvd_X_pow_sub_one_of_dvd X_pow_sub_one_mul_cyclotomic_dvd_X_pow_sub_one_of_dvd\n\n",
 "X_pow_sub_one_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = ∏ (X - μ)`, where `μ`\nvaries over the `n`-th roots of unity. -/\ntheorem X_pow_sub_one_eq_prod {ζ : R} {n : ℕ} (hpos : 0 < n) (h : is_primitive_root ζ n) :\n    X ^ n - 1 =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (nth_roots_finset n R) (X - C ζ) :=\n  by\n  rw [nth_roots_finset, ← Multiset.toFinset_eq (is_primitive_root.nth_roots_nodup h)]\n  simp only [finset.prod_mk, RingHom.map_one]\n  rw [nth_roots]\n  have hmonic : (X ^ n - C (1 : R)).monic := monic_X_pow_sub_C (1 : R) (ne_of_lt hpos).symm\n  symm\n  apply prod_multiset_X_sub_C_of_monic_of_roots_card_eq hmonic\n  rw [@nat_degree_X_pow_sub_C R _ _ n 1, ← nth_roots]\n  exact is_primitive_root.card_nth_roots h\n#align X_pow_sub_one_eq_prod X_pow_sub_one_eq_prod\n\n",
 "X_pow_sub_one_dvd_prod_cyclotomic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If `m` is a proper divisor of `n`, then `X ^ m - 1` divides\n`∏ i in nat.proper_divisors n, cyclotomic i R`. -/\ntheorem X_pow_sub_one_dvd_prod_cyclotomic (R : Type _) [CommRing R] {n m : ℕ} (hpos : 0 < n) (hm : m ∣ n)\n    (hdiff : m ≠ n) :\n    X ^ m - 1 ∣\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (nat.proper_divisors n) (cyclotomic i R) :=\n  by\n  replace hm :=\n    nat.mem_proper_divisors.2 ⟨hm, lt_of_le_of_ne (nat.divisor_le (nat.mem_divisors.2 ⟨hm, hpos.ne'⟩)) hdiff⟩\n  rw [←\n    Finset.sdiff_union_of_subset\n      (nat.divisors_subset_proper_divisors (ne_of_lt hpos).symm (nat.mem_proper_divisors.1 hm).1\n        (ne_of_lt (nat.mem_proper_divisors.1 hm).2)),\n    finset.prod_union Finset.sdiff_disjoint, prod_cyclotomic_eq_X_pow_sub_one (nat.pos_of_mem_proper_divisors hm)]\n  exact\n    ⟨finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (n.proper_divisors \\ m.divisors) (cyclotomic x R),\n      by rw [mul_comm]⟩\n#align X_pow_sub_one_dvd_prod_cyclotomic X_pow_sub_one_dvd_prod_cyclotomic\n\n"}