{"sub_one_pow_totient_lt_nat_abs_cyclotomic_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem sub_one_pow_totient_lt_nat_abs_cyclotomic_eval {n : ℕ} {q : ℕ} (hn' : 1 < n) (hq : q ≠ 1) :\n    (q - 1) ^ totient n < ((cyclotomic n ℤ).eval ↑q).nat_abs :=\n  by\n  rcases hq.lt_or_lt.imp_left nat.lt_one_iff.mp with (rfl | hq')\n  · rw [zero_tsub, zero_pow (nat.totient_pos (pos_of_gt hn')), pos_iff_ne_zero, Int.natAbs_ne_zero, Nat.cast_zero, ←\n      coeff_zero_eq_eval_zero, cyclotomic_coeff_zero _ hn']\n    exact one_ne_zero\n  rw [← @nat.cast_lt (exprℝ), Nat.cast_pow, Nat.cast_sub hq'.le, Nat.cast_one, Int.cast_natAbs]\n  refine' (sub_one_pow_totient_lt_cyclotomic_eval hn' (nat.one_lt_cast.2 hq')).trans_le _\n  exact (cyclotomic.eval_apply (q : ℤ) n (algebra_map ℤ (exprℝ))).trans_le (le_abs_self _)\n#align sub_one_pow_totient_lt_nat_abs_cyclotomic_eval sub_one_pow_totient_lt_nat_abs_cyclotomic_eval\n\n",
 "sub_one_pow_totient_lt_cyclotomic_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem sub_one_pow_totient_lt_cyclotomic_eval {n : ℕ} {q : exprℝ} (hn' : 2 ≤ n) (hq' : 1 < q) :\n    (q - 1) ^ totient n < (cyclotomic n (exprℝ)).eval q :=\n  by\n  have hn : 0 < n := pos_of_gt hn'\n  have hq := zero_lt_one.trans hq'\n  have hfor : ∀ ζ' ∈ primitive_roots n (exprℂ), q - 1 ≤ «expr‖ ‖» (↑q - ζ') :=\n    by\n    intro ζ' hζ'\n    rw [mem_primitive_roots hn] at hζ'\n    convert norm_sub_norm_le (↑q) ζ'\n    · rw [complex.norm_real, real.norm_of_nonneg hq.le]\n    · rw [hζ'.norm'_eq_one hn.ne']\n  let ζ := complex.exp (2 * ↑real.pi * complex.I / ↑n)\n  have hζ : is_primitive_root ζ n := complex.is_primitive_root_exp n hn.ne'\n  have hex : ∃ ζ' ∈ primitive_roots n (exprℂ), q - 1 < «expr‖ ‖» (↑q - ζ') :=\n    by\n    refine' ⟨ζ, (mem_primitive_roots hn).mpr hζ, _⟩\n    suffices ¬same_ray (exprℝ) (q : exprℂ) ζ by\n      convert lt_norm_sub_of_not_same_ray this <;>\n        simp only [hζ.norm'_eq_one hn.ne', real.norm_of_nonneg hq.le, complex.norm_real]\n    rw [complex.same_ray_iff]\n    push_neg\n    refine' ⟨by exact_mod_cast hq.ne', hζ.ne_zero hn.ne', _⟩\n    rw [complex.arg_of_real_of_nonneg hq.le, ne.def, eq_comm, hζ.arg_eq_zero_iff hn.ne']\n    clear_value ζ\n    rintro rfl\n    linarith [hζ.unique is_primitive_root.one]\n  have : ¬eval (↑q) (cyclotomic n (exprℂ)) = 0 :=\n    by\n    erw [cyclotomic.eval_apply q n (algebra_map (exprℝ) (exprℂ))]\n    simpa only [complex.coe_algebra_map, complex.of_real_eq_zero] using (cyclotomic_pos' n hq').ne'\n  suffices\n    Units.mk0 (real.to_nnreal (q - 1)) (by simp [hq']) ^ totient n <\n      Units.mk0 («expr‖ ‖₊» ((cyclotomic n (exprℂ)).eval q)) (by simp [this])\n    by\n    simp only [← Units.val_lt_val, Units.val_pow_eq_pow_val, Units.val_mk0, ← nnreal.coe_lt_coe, hq'.le,\n      real.to_nnreal_lt_to_nnreal_iff_of_nonneg, coe_nnnorm, complex.norm_eq_abs, nnreal.coe_pow, real.coe_to_nnreal',\n      max_eq_left, sub_nonneg] at this\n    convert this\n    erw [cyclotomic.eval_apply q n (algebra_map (exprℝ) (exprℂ)), eq_comm]\n    simp only [cyclotomic_nonneg n hq'.le, complex.coe_algebra_map, complex.abs_of_real, abs_eq_self]\n  simp only [cyclotomic_eq_prod_X_sub_primitive_roots hζ, eval_prod, eval_C, eval_X, eval_sub, nnnorm_prod,\n    units.mk0_prod]\n  convert finset.prod_lt_prod' _ _\n  swap\n  · exact fun _ => Units.mk0 (real.to_nnreal (q - 1)) (by simp [hq'])\n  · simp only [complex.card_primitive_roots, prod_const, card_attach]\n  · simp only [subtype.coe_mk, Finset.mem_attach, forall_true_left, subtype.forall, ← Units.val_le_val, ←\n      nnreal.coe_le_coe, complex.abs.nonneg, hq'.le, Units.val_mk0, real.coe_to_nnreal', coe_nnnorm,\n      complex.norm_eq_abs, max_le_iff, tsub_le_iff_right]\n    intro x hx\n    simpa only [and_true_iff, tsub_le_iff_right] using hfor x hx\n  · simp only [subtype.coe_mk, Finset.mem_attach, exists_true_left, subtype.exists, ← nnreal.coe_lt_coe, ←\n      Units.val_lt_val, Units.val_mk0 _, coe_nnnorm]\n    simpa only [hq'.le, real.coe_to_nnreal', max_eq_left, sub_nonneg] using hex\n#align sub_one_pow_totient_lt_cyclotomic_eval sub_one_pow_totient_lt_cyclotomic_eval\n\n",
 "sub_one_pow_totient_le_cyclotomic_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem sub_one_pow_totient_le_cyclotomic_eval {q : exprℝ} (hq' : 1 < q) :\n    ∀ n, (q - 1) ^ totient n ≤ (cyclotomic n (exprℝ)).eval q\n  | 0 => by simp only [totient_zero, pow_zero, cyclotomic_zero, eval_one]\n  | 1 => by simp only [totient_one, pow_one, cyclotomic_one, eval_sub, eval_X, eval_one]\n  | n + 2 => (sub_one_pow_totient_lt_cyclotomic_eval (by decide) hq').le\n#align sub_one_pow_totient_le_cyclotomic_eval sub_one_pow_totient_le_cyclotomic_eval\n\n",
 "sub_one_lt_nat_abs_cyclotomic_eval":
 "theorem sub_one_lt_nat_abs_cyclotomic_eval {n : ℕ} {q : ℕ} (hn' : 1 < n) (hq : q ≠ 1) :\n    q - 1 < ((cyclotomic n ℤ).eval ↑q).nat_abs :=\n  calc\n    q - 1 ≤ (q - 1) ^ totient n := Nat.le_self_pow (nat.totient_pos <| pos_of_gt hn').ne' _\n    _ < ((cyclotomic n ℤ).eval ↑q).nat_abs := sub_one_pow_totient_lt_nat_abs_cyclotomic_eval hn' hq\n    \n#align sub_one_lt_nat_abs_cyclotomic_eval sub_one_lt_nat_abs_cyclotomic_eval\n\n",
 "eval₂_one_cyclotomic_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_one_cyclotomic_prime_pow {R S : Type _} [CommRing R] [Semiring S] (f : «expr →+* » R S) {p : ℕ} (k : ℕ)\n    [fact p.prime] : eval₂ f 1 (cyclotomic (p ^ (k + 1)) R) = p := by simp\n#align eval₂_one_cyclotomic_prime_pow eval₂_one_cyclotomic_prime_pow\n\n",
 "eval₂_one_cyclotomic_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_one_cyclotomic_prime {R S : Type _} [CommRing R] [Semiring S] (f : «expr →+* » R S) {p : ℕ}\n    [fact p.prime] : eval₂ f 1 (cyclotomic p R) = p := by simp\n#align eval₂_one_cyclotomic_prime eval₂_one_cyclotomic_prime\n\n",
 "eval_one_cyclotomic_prime_pow":
 "@[simp]\ntheorem eval_one_cyclotomic_prime_pow {R : Type _} [CommRing R] {p : ℕ} (k : ℕ) [hn : fact p.prime] :\n    eval 1 (cyclotomic (p ^ (k + 1)) R) = p := by\n  simp only [cyclotomic_prime_pow_eq_geom_sum hn.out, eval_X, one_pow, finset.sum_const, eval_pow, eval_finset_sum,\n    finset.card_range, smul_one_eq_coe]\n#align eval_one_cyclotomic_prime_pow eval_one_cyclotomic_prime_pow\n\n",
 "eval_one_cyclotomic_prime":
 "/-\nCopyright (c) 2021 Eric Rodriguez. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Rodriguez\n-/\n@[simp]\ntheorem eval_one_cyclotomic_prime {R : Type _} [CommRing R] {p : ℕ} [hn : fact p.prime] : eval 1 (cyclotomic p R) = p :=\n  by\n  simp only [cyclotomic_prime, eval_X, one_pow, finset.sum_const, eval_pow, eval_finset_sum, finset.card_range,\n    smul_one_eq_coe]\n#align eval_one_cyclotomic_prime eval_one_cyclotomic_prime\n\n",
 "eval_one_cyclotomic_not_prime_pow":
 "theorem eval_one_cyclotomic_not_prime_pow {R : Type _} [Ring R] {n : ℕ} (h : ∀ {p : ℕ}, p.prime → ∀ k : ℕ, p ^ k ≠ n) :\n    eval 1 (cyclotomic n R) = 1 := by\n  rcases n.eq_zero_or_pos with (rfl | hn')\n  · simp\n  have hn : 1 < n := one_lt_iff_ne_zero_and_ne_one.mpr ⟨hn'.ne', (h Nat.prime_two 0).symm⟩\n  rsuffices h | h : eval 1 (cyclotomic n ℤ) = 1 ∨ eval 1 (cyclotomic n ℤ) = -1\n  · have := eval_int_cast_map (Int.castRingHom R) (cyclotomic n ℤ) 1\n    simpa only [map_cyclotomic, Int.cast_one, h, eq_intCast] using this\n  · exfalso\n    linarith [cyclotomic_nonneg n (le_refl (1 : ℤ))]\n  rw [← Int.natAbs_eq_natAbs_iff, Int.natAbs_one, Nat.eq_one_iff_not_exists_prime_dvd]\n  intro p hp hpe\n  haveI := fact.mk hp\n  have hpn : p ∣ n := by\n    apply hpe.trans\n    nth_rw 2 [← Int.natAbs_ofNat n]\n    rw [Int.natAbs_dvd_natAbs, ← one_geom_sum, ← eval_geom_sum, ← prod_cyclotomic_eq_geom_sum hn']\n    apply eval_dvd\n    apply finset.dvd_prod_of_mem\n    simp [hn'.ne', hn.ne']\n  have := prod_cyclotomic_eq_geom_sum hn' ℤ\n  apply_fun eval 1  at this\n  rw [eval_geom_sum, one_geom_sum, eval_prod, eq_comm, ←\n    finset.prod_sdiff <| @range_pow_padic_val_nat_subset_divisors' p _ _, finset.prod_image] at this\n  simp_rw [eval_one_cyclotomic_prime_pow, finset.prod_const, finset.card_range, mul_comm] at this\n  rw [← finset.prod_sdiff <| show {n} ⊆ _ from _] at this\n  any_goals infer_instance\n  swap\n  · simp only [singleton_subset_iff, mem_sdiff, mem_erase, ne.def, mem_divisors, dvd_refl, true_and_iff, mem_image,\n      mem_range, exists_prop, not_exists, not_and]\n    exact ⟨⟨hn.ne', hn'.ne'⟩, fun t _ => h hp _⟩\n  rw [← Int.natAbs_ofNat p, Int.natAbs_dvd_natAbs] at hpe\n  obtain ⟨t, ht⟩ := hpe\n  rw [finset.prod_singleton, ht, mul_left_comm, mul_comm, ← mul_assoc, mul_assoc] at this\n  have : (p ^ padic_val_nat p n * p : ℤ) ∣ n := ⟨_, this⟩\n  simp only [← pow_succ', ← Int.natAbs_dvd_natAbs, Int.natAbs_ofNat, Int.natAbs_pow] at this\n  exact pow_succ_padic_val_nat_not_dvd hn'.ne' this\n  · rintro x - y - hxy\n    apply Nat.succ_injective\n    exact Nat.pow_right_injective hp.two_le hxy\n#align eval_one_cyclotomic_not_prime_pow eval_one_cyclotomic_not_prime_pow\n\n",
 "cyclotomic_pos_and_nonneg":
 "theorem cyclotomic_pos_and_nonneg (n : ℕ) {R} [LinearOrderedCommRing R] (x : R) :\n    (1 < x → 0 < eval x (cyclotomic n R)) ∧ (1 ≤ x → 0 ≤ eval x (cyclotomic n R)) :=\n  by\n  rcases n with (_ | _ | _ | n) <;>\n    simp only [cyclotomic_zero, cyclotomic_one, cyclotomic_two, succ_eq_add_one, eval_X, eval_one, eval_add, eval_sub,\n      sub_nonneg, sub_pos, zero_lt_one, zero_le_one, imp_true_iff, imp_self, and_self_iff]\n  · constructor <;> intro <;> linarith\n  · have : 2 < n + 3 := by decide\n    constructor <;> intro <;> [skip, apply le_of_lt] <;> apply cyclotomic_pos this\n#align cyclotomic_pos_and_nonneg cyclotomic_pos_and_nonneg\n\n",
 "cyclotomic_pos'":
 "/-- Cyclotomic polynomials are always positive on inputs larger than one.\nSimilar to `cyclotomic_pos` but with the condition on the input rather than index of the\ncyclotomic polynomial. -/\ntheorem cyclotomic_pos' (n : ℕ) {R} [LinearOrderedCommRing R] {x : R} (hx : 1 < x) : 0 < eval x (cyclotomic n R) :=\n  (cyclotomic_pos_and_nonneg n x).1 hx\n#align cyclotomic_pos' cyclotomic_pos'\n\n",
 "cyclotomic_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem cyclotomic_pos {n : ℕ} (hn : 2 < n) {R} [LinearOrderedCommRing R] (x : R) : 0 < eval x (cyclotomic n R) :=\n  by\n  induction' n using nat.strong_induction_on with n ih\n  have hn' : 0 < n := pos_of_gt hn\n  have hn'' : 1 < n := one_lt_two.trans hn\n  dsimp at ih\n  have := prod_cyclotomic_eq_geom_sum hn' R\n  apply_fun eval x  at this\n  rw [← cons_self_proper_divisors hn'.ne', finset.erase_cons_of_ne _ hn''.ne', finset.prod_cons, eval_mul,\n    eval_geom_sum] at this\n  rcases lt_trichotomy 0\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (x ^ i)) with\n    (h | h | h)\n  · apply pos_of_mul_pos_left\n    · rwa [this]\n    rw [eval_prod]\n    refine' finset.prod_nonneg fun i hi => _\n    simp only [Finset.mem_erase, mem_proper_divisors] at hi\n    rw [geom_sum_pos_iff hn'.ne'] at h\n    cases' h with hk hx\n    · refine' (ih _ hi.2.2 (Nat.two_lt_of_ne _ hi.1 _)).le <;> rintro rfl\n      · exact hn'.ne' (zero_dvd_iff.mp hi.2.1)\n      · exact even_iff_not_odd.mp (even_iff_two_dvd.mpr hi.2.1) hk\n    · rcases eq_or_ne i 2 with (rfl | hk)\n      · simpa only [eval_X, eval_one, cyclotomic_two, eval_add] using hx.le\n      refine' (ih _ hi.2.2 (Nat.two_lt_of_ne _ hi.1 hk)).le\n      rintro rfl\n      exact hn'.ne' <| zero_dvd_iff.mp hi.2.1\n  · rw [eq_comm, geom_sum_eq_zero_iff_neg_one hn'.ne'] at h\n    exact h.1.symm ▸ cyclotomic_neg_one_pos hn\n  · apply pos_of_mul_neg_left\n    · rwa [this]\n    rw [geom_sum_neg_iff hn'.ne'] at h\n    have h2 : 2 ∈ n.proper_divisors.erase 1 :=\n      by\n      rw [Finset.mem_erase, mem_proper_divisors]\n      exact ⟨by decide, even_iff_two_dvd.mp h.1, hn⟩\n    rw [eval_prod, ← finset.prod_erase_mul _ _ h2]\n    apply mul_nonpos_of_nonneg_of_nonpos\n    · refine' finset.prod_nonneg fun i hi => le_of_lt _\n      simp only [Finset.mem_erase, mem_proper_divisors] at hi\n      refine' ih _ hi.2.2.2 (Nat.two_lt_of_ne _ hi.2.1 hi.1)\n      rintro rfl\n      rw [zero_dvd_iff] at hi\n      exact hn'.ne' hi.2.2.1\n    · simpa only [eval_X, eval_one, cyclotomic_two, eval_add] using h.right.le\n#align cyclotomic_pos cyclotomic_pos\n\n",
 "cyclotomic_nonneg":
 "/-- Cyclotomic polynomials are always nonnegative on inputs one or more. -/\ntheorem cyclotomic_nonneg (n : ℕ) {R} [LinearOrderedCommRing R] {x : R} (hx : 1 ≤ x) : 0 ≤ eval x (cyclotomic n R) :=\n  (cyclotomic_pos_and_nonneg n x).2 hx\n#align cyclotomic_nonneg cyclotomic_nonneg\n\n",
 "cyclotomic_neg_one_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprivate theorem cyclotomic_neg_one_pos {n : ℕ} (hn : 2 < n) {R} [LinearOrderedCommRing R] :\n    0 < eval (-1 : R) (cyclotomic n R) := by\n  haveI := NeZero.of_gt hn\n  rw [← map_cyclotomic_int, ← Int.cast_one, ← Int.cast_neg, eval_int_cast_map, Int.coe_castRingHom, Int.cast_pos]\n  suffices 0 < eval (↑(-1 : ℤ)) (cyclotomic n (exprℝ))\n    by\n    rw [← map_cyclotomic_int n (exprℝ), eval_int_cast_map, Int.coe_castRingHom] at this\n    exact_mod_cast this\n  simp only [Int.cast_one, Int.cast_neg]\n  have h0 := cyclotomic_coeff_zero (exprℝ) hn.le\n  rw [coeff_zero_eq_eval_zero] at h0\n  by_contra' hx\n  have := intermediate_value_univ (-1) 0 (cyclotomic n (exprℝ)).continuous\n  obtain ⟨y, hy : is_root _ y⟩ := this (show (0 : exprℝ) ∈ Set.Icc _ _ by simpa [h0] using hx)\n  rw [is_root_cyclotomic_iff] at hy\n  rw [hy.eq_order_of] at hn\n  exact hn.not_le linear_ordered_ring.order_of_le_two\n#align cyclotomic_neg_one_pos cyclotomic_neg_one_pos\n\n",
 "cyclotomic_eval_lt_add_one_pow_totient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cyclotomic_eval_lt_add_one_pow_totient {n : ℕ} {q : exprℝ} (hn' : 3 ≤ n) (hq' : 1 < q) :\n    (cyclotomic n (exprℝ)).eval q < (q + 1) ^ totient n :=\n  by\n  have hn : 0 < n := pos_of_gt hn'\n  have hq := zero_lt_one.trans hq'\n  have hfor : ∀ ζ' ∈ primitive_roots n (exprℂ), «expr‖ ‖» (↑q - ζ') ≤ q + 1 :=\n    by\n    intro ζ' hζ'\n    rw [mem_primitive_roots hn] at hζ'\n    convert norm_sub_le (↑q) ζ'\n    · rw [complex.norm_real, real.norm_of_nonneg (zero_le_one.trans_lt hq').le]\n    · rw [hζ'.norm'_eq_one hn.ne']\n  let ζ := complex.exp (2 * ↑real.pi * complex.I / ↑n)\n  have hζ : is_primitive_root ζ n := complex.is_primitive_root_exp n hn.ne'\n  have hex : ∃ ζ' ∈ primitive_roots n (exprℂ), «expr‖ ‖» (↑q - ζ') < q + 1 :=\n    by\n    refine' ⟨ζ, (mem_primitive_roots hn).mpr hζ, _⟩\n    suffices ¬same_ray (exprℝ) (q : exprℂ) (-ζ) by\n      convert norm_add_lt_of_not_same_ray this <;>\n        simp [real.norm_of_nonneg hq.le, hζ.norm'_eq_one hn.ne', -complex.norm_eq_abs]\n    rw [complex.same_ray_iff]\n    push_neg\n    refine' ⟨by exact_mod_cast hq.ne', neg_ne_zero.mpr <| hζ.ne_zero hn.ne', _⟩\n    rw [complex.arg_of_real_of_nonneg hq.le, ne.def, eq_comm]\n    intro h\n    rw [complex.arg_eq_zero_iff, complex.neg_re, neg_nonneg, complex.neg_im, neg_eq_zero] at h\n    have hζ₀ : ζ ≠ 0 := by\n      clear_value ζ\n      rintro rfl\n      exact hn.ne' (hζ.unique is_primitive_root.zero)\n    have : ζ.re < 0 ∧ ζ.im = 0 := ⟨h.1.lt_of_ne _, h.2⟩\n    rw [← complex.arg_eq_pi_iff, hζ.arg_eq_pi_iff hn.ne'] at this\n    rw [this] at hζ\n    linarith [hζ.unique <| is_primitive_root.neg_one 0 two_ne_zero.symm]\n    · contrapose! hζ₀\n      ext <;> simp [hζ₀, h.2]\n  have : ¬eval (↑q) (cyclotomic n (exprℂ)) = 0 :=\n    by\n    erw [cyclotomic.eval_apply q n (algebra_map (exprℝ) (exprℂ))]\n    simp only [complex.coe_algebra_map, complex.of_real_eq_zero]\n    exact (cyclotomic_pos' n hq').ne.symm\n  suffices\n    Units.mk0 («expr‖ ‖₊» ((cyclotomic n (exprℂ)).eval q)) (by simp [this]) <\n      Units.mk0 (real.to_nnreal (q + 1)) (by simp <;> linarith) ^ totient n\n    by\n    simp only [← Units.val_lt_val, Units.val_pow_eq_pow_val, Units.val_mk0, ← nnreal.coe_lt_coe, hq'.le,\n      real.to_nnreal_lt_to_nnreal_iff_of_nonneg, coe_nnnorm, complex.norm_eq_abs, nnreal.coe_pow, real.coe_to_nnreal',\n      max_eq_left, sub_nonneg] at this\n    convert this\n    · erw [cyclotomic.eval_apply q n (algebra_map (exprℝ) (exprℂ)), eq_comm]\n      simp [cyclotomic_nonneg n hq'.le]\n    rw [eq_comm, max_eq_left_iff]\n    linarith\n  simp only [cyclotomic_eq_prod_X_sub_primitive_roots hζ, eval_prod, eval_C, eval_X, eval_sub, nnnorm_prod,\n    units.mk0_prod]\n  convert finset.prod_lt_prod' _ _\n  swap\n  · exact fun _ => Units.mk0 (real.to_nnreal (q + 1)) (by simp <;> linarith only [hq'])\n  · simp [complex.card_primitive_roots]\n  · simp only [subtype.coe_mk, Finset.mem_attach, forall_true_left, subtype.forall, ← Units.val_le_val, ←\n      nnreal.coe_le_coe, complex.abs.nonneg, hq'.le, Units.val_mk0, real.coe_to_nnreal, coe_nnnorm, complex.norm_eq_abs,\n      max_le_iff]\n    intro x hx\n    have : complex.abs _ ≤ _ := hfor x hx\n    simp [this]\n  · simp only [subtype.coe_mk, Finset.mem_attach, exists_true_left, subtype.exists, ← nnreal.coe_lt_coe, ←\n      Units.val_lt_val, Units.val_mk0 _, coe_nnnorm]\n    obtain ⟨ζ, hζ, hhζ : complex.abs _ < _⟩ := hex\n    exact ⟨ζ, hζ, by simp [hhζ]⟩\n#align cyclotomic_eval_lt_add_one_pow_totient cyclotomic_eval_lt_add_one_pow_totient\n\n",
 "cyclotomic_eval_le_add_one_pow_totient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cyclotomic_eval_le_add_one_pow_totient {q : exprℝ} (hq' : 1 < q) :\n    ∀ n, (cyclotomic n (exprℝ)).eval q ≤ (q + 1) ^ totient n\n  | 0 => by simp\n  | 1 => by simp [add_assoc, add_nonneg, zero_le_one]\n  | 2 => by simp\n  | n + 3 => (cyclotomic_eval_lt_add_one_pow_totient (by decide) hq').le\n#align cyclotomic_eval_le_add_one_pow_totient cyclotomic_eval_le_add_one_pow_totient\n\n"}