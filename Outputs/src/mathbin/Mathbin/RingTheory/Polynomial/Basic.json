{"unique_factorization_monoid_of_fintype":
 "private theorem unique_factorization_monoid_of_fintype [fintype σ] : unique_factorization_monoid (mv_polynomial σ D) :=\n  (rename_equiv D (fintype.equiv_fin σ)).to_mul_equiv.symm.unique_factorization_monoid <|\n    by\n    induction' fintype.card σ with d hd\n    · apply (is_empty_alg_equiv D (fin 0)).to_mul_equiv.symm.unique_factorization_monoid\n      infer_instance\n    · apply (fin_succ_equiv D d).to_mul_equiv.symm.unique_factorization_monoid\n      exact polynomial.unique_factorization_monoid\n#align unique_factorization_monoid_of_fintype unique_factorization_monoid_of_fintype\n\n",
 "to_subring_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem to_subring_zero : to_subring (0 : polynomial R) T (by simp [frange_zero]) = 0 :=\n  by\n  ext i\n  simp\n#align to_subring_zero to_subring_zero\n\n",
 "to_subring_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem to_subring_one :\n    to_subring (1 : polynomial R) T (Set.Subset.trans frange_one <| Finset.singleton_subset_set_iff.2 T.one_mem) = 1 :=\n  ext fun i => subtype.eq <| by rw [coeff_to_subring', coeff_one, coeff_one] <;> split_ifs <;> rfl\n#align to_subring_one to_subring_one\n\n",
 "support_to_subring":
 "@[simp]\ntheorem support_to_subring : support (to_subring p T hp) = support p :=\n  by\n  ext i\n  simp only [mem_support_iff, not_iff_not, ne.def]\n  conv_rhs => rw [← coeff_to_subring p T hp]\n  exact\n    ⟨fun H => by\n      rw [H]\n      rfl, fun H => subtype.coe_injective H⟩\n#align support_to_subring support_to_subring\n\n",
 "support_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem support_restriction (p : polynomial R) : support (restriction p) = support p :=\n  by\n  ext i\n  simp only [mem_support_iff, not_iff_not, ne.def]\n  conv_rhs => rw [← coeff_restriction]\n  exact\n    ⟨fun H => by\n      rw [H]\n      rfl, fun H => subtype.coe_injective H⟩\n#align support_restriction support_restriction\n\n",
 "sup_ker_aeval_le_ker_aeval_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_ker_aeval_le_ker_aeval_mul {f : «expr →ₗ[ ] » M R M} {p q : polynomial R} :\n    «expr ⊔ » (aeval f p).ker (aeval f q).ker ≤ (aeval f (p * q)).ker :=\n  by\n  intro v hv\n  rcases submodule.mem_sup.1 hv with ⟨x, hx, y, hy, hxy⟩\n  have h_eval_x : aeval f (p * q) x = 0 := by\n    rw [mul_comm, aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hx, linear_map.map_zero]\n  have h_eval_y : aeval f (p * q) y = 0 := by\n    rw [aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hy, linear_map.map_zero]\n  rw [linear_map.mem_ker, ← hxy, linear_map.map_add, h_eval_x, h_eval_y, add_zero]\n#align sup_ker_aeval_le_ker_aeval_mul sup_ker_aeval_le_ker_aeval_mul\n\n",
 "sup_ker_aeval_eq_ker_aeval_mul_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_ker_aeval_eq_ker_aeval_mul_of_coprime (f : «expr →ₗ[ ] » M R M) {p q : polynomial R} (hpq : IsCoprime p q) :\n    «expr ⊔ » (aeval f p).ker (aeval f q).ker = (aeval f (p * q)).ker :=\n  by\n  apply le_antisymm sup_ker_aeval_le_ker_aeval_mul\n  intro v hv\n  rw [submodule.mem_sup]\n  rcases hpq with ⟨p', q', hpq'⟩\n  have h_eval₂_qpp' :=\n    calc\n      aeval f (q * (p * p')) v = aeval f (p' * (p * q)) v := by\n        rw [mul_comm, mul_assoc, mul_comm, mul_assoc, mul_comm q p]\n      _ = 0 := by rw [aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hv, linear_map.map_zero]\n      \n  have h_eval₂_pqq' :=\n    calc\n      aeval f (p * (q * q')) v = aeval f (q' * (p * q)) v := by rw [← mul_assoc, mul_comm]\n      _ = 0 := by rw [aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hv, linear_map.map_zero]\n      \n  rw [aeval_mul] at h_eval₂_qpp' h_eval₂_pqq'\n  refine'\n    ⟨aeval f (q * q') v, linear_map.mem_ker.1 h_eval₂_pqq', aeval f (p * p') v, linear_map.mem_ker.1 h_eval₂_qpp', _⟩\n  rw [add_comm, mul_comm p p', mul_comm q q']\n  simpa using congr_arg (fun p : polynomial R => aeval f p v) hpq'\n#align sup_ker_aeval_eq_ker_aeval_mul_of_coprime sup_ker_aeval_eq_ker_aeval_mul_of_coprime\n\n",
 "sup_aeval_range_eq_top_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem sup_aeval_range_eq_top_of_coprime (f : «expr →ₗ[ ] » M R M) {p q : polynomial R} (hpq : IsCoprime p q) :\n    «expr ⊔ » (aeval f p).range (aeval f q).range = «expr⊤» :=\n  by\n  rw [eq_top_iff]\n  intro v hv\n  rw [submodule.mem_sup]\n  rcases hpq with ⟨p', q', hpq'⟩\n  use aeval f (p * p') v\n  use linear_map.mem_range.2 ⟨aeval f p' v, by simp only [linear_map.mul_apply, aeval_mul]⟩\n  use aeval f (q * q') v\n  use linear_map.mem_range.2 ⟨aeval f q' v, by simp only [linear_map.mul_apply, aeval_mul]⟩\n  simpa only [mul_comm p p', mul_comm q q', aeval_one, aeval_add] using\n    congr_arg (fun p : polynomial R => aeval f p v) hpq'\n#align sup_aeval_range_eq_top_of_coprime sup_aeval_range_eq_top_of_coprime\n\n",
 "restriction_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem restriction_zero : restriction (0 : polynomial R) = 0 := by\n  simp only [restriction, finset.sum_empty, support_zero]\n#align restriction_zero restriction_zero\n\n",
 "restriction_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem restriction_one : restriction (1 : polynomial R) = 1 :=\n  ext fun i => subtype.eq <| by rw [coeff_restriction', coeff_one, coeff_one] <;> split_ifs <;> rfl\n#align restriction_one restriction_one\n\n",
 "quotient_map_C_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem quotient_map_C_eq_zero {I : ideal R} {i : R} (hi : i ∈ I) :\n    (ideal.quotient.mk (ideal.map (C : «expr →+* » R (mv_polynomial σ R)) I : ideal (mv_polynomial σ R))).comp C i =\n      0 :=\n  by\n  simp only [Function.comp_apply, RingHom.coe_comp, ideal.quotient.eq_zero_iff_mem]\n  exact ideal.mem_map_of_mem _ hi\n#align quotient_map_C_eq_zero quotient_map_C_eq_zero\n\n",
 "prime_rename_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem prime_rename_iff (s : set σ) {p : mv_polynomial s R} : Prime (rename (coe : s → σ) p) ↔ Prime p := by\n  classical\n    symm\n    let eqv :=\n      (sum_alg_equiv R _ _).symm.trans\n        (rename_equiv R <| (Equiv.sumComm («expr↥ » («expr ᶜ» s)) s).trans <| Equiv.Set.sumCompl s)\n    rw [← prime_C_iff («expr↥ » («expr ᶜ» s)), eqv.to_mul_equiv.prime_iff]\n    convert iff.rfl\n    suffices (rename coe).to_ring_hom = eqv.to_alg_hom.to_ring_hom.comp C by apply RingHom.congr_fun this\n    · apply ring_hom_ext\n      · intro\n        dsimp [eqv]\n        erw [iter_to_sum_C_C, rename_C, rename_C]\n      · intro\n        dsimp [eqv]\n        erw [iter_to_sum_C_X, rename_X, rename_X]\n        rfl\n#align prime_rename_iff prime_rename_iff\n\n",
 "prime_C_iff_of_fintype":
 "private theorem prime_C_iff_of_fintype [fintype σ] : Prime (C r : mv_polynomial σ R) ↔ Prime r :=\n  by\n  rw [(rename_equiv R (fintype.equiv_fin σ)).to_mul_equiv.prime_iff]\n  convert_to Prime (C r) ↔ _;\n  · congr\n    apply rename_C\n  · symm\n    induction' fintype.card σ with d hd\n    · exact (is_empty_alg_equiv R (fin 0)).to_mul_equiv.symm.prime_iff\n    · rw [hd, ← polynomial.prime_C_iff]\n      convert (fin_succ_equiv R d).to_mul_equiv.symm.prime_iff\n      rw [← fin_succ_equiv_comp_C_eq_C]\n      rfl\n#align prime_C_iff_of_fintype prime_C_iff_of_fintype\n\n",
 "prime_C_iff":
 "theorem prime_C_iff : Prime (C r : mv_polynomial σ R) ↔ Prime r :=\n  ⟨comap_prime C constant_coeff (constant_coeff_C _), fun hr =>\n    ⟨fun h =>\n      hr.1 <| by\n        rw [← C_inj, h]\n        simp,\n      fun h =>\n      hr.2.1 <| by\n        rw [← constant_coeff_C _ r]\n        exact h.map _,\n      fun a b hd => by\n      obtain ⟨s, a', b', rfl, rfl⟩ := exists_finset_rename₂ a b\n      rw [← algebra_map_eq] at hd\n      have : algebra_map R _ r ∣ a' * b' :=\n        by\n        convert (kill_compl subtype.coe_injective).to_ring_hom.map_dvd hd\n        simpa\n        simp\n      rw [← rename_C (coe : s → σ)]\n      let f := (rename (coe : s → σ)).to_ring_hom\n      exact (((prime_C_iff_of_fintype s).2 hr).2.2 a' b' this).imp f.map_dvd f.map_dvd⟩⟩\n#align prime_C_iff prime_C_iff\n\n",
 "polynomial_quotient_equiv_quotient_polynomial_symm_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem polynomial_quotient_equiv_quotient_polynomial_symm_mk (I : ideal R) (f : polynomial R) :\n    I.polynomial_quotient_equiv_quotient_polynomial.symm (quotient.mk _ f) = f.map (quotient.mk I) := by\n  rw [polynomial_quotient_equiv_quotient_polynomial, RingEquiv.symm_mk, [anonymous], ideal.quotient.lift_mk,\n    coe_eval₂_ring_hom, eval₂_eq_eval_map, ← polynomial.map_map, ← eval₂_eq_eval_map, polynomial.eval₂_C_X]\n#align polynomial_quotient_equiv_quotient_polynomial_symm_mk polynomial_quotient_equiv_quotient_polynomial_symm_mk\n\n",
 "polynomial_quotient_equiv_quotient_polynomial_map_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem polynomial_quotient_equiv_quotient_polynomial_map_mk (I : ideal R) (f : polynomial R) :\n    I.polynomial_quotient_equiv_quotient_polynomial (f.map I) = quotient.mk _ f :=\n  by\n  apply (polynomial_quotient_equiv_quotient_polynomial I).symm.injective\n  rw [RingEquiv.symm_apply_apply, polynomial_quotient_equiv_quotient_polynomial_symm_mk]\n#align polynomial_quotient_equiv_quotient_polynomial_map_mk polynomial_quotient_equiv_quotient_polynomial_map_mk\n\n",
 "polynomial_not_is_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- `R[X]` is never a field for any ring `R`. -/\ntheorem polynomial_not_is_field : ¬IsField (polynomial R) :=\n  by\n  nontriviality R\n  intro hR\n  obtain ⟨p, hp⟩ := hR.mul_inv_cancel X_ne_zero\n  have hp0 : p ≠ 0 := by\n    rintro rfl\n    rw [mul_zero] at hp\n    exact zero_ne_one hp\n  have := degree_lt_degree_mul_X hp0\n  rw [← X_mul, congr_arg degree hp, degree_one, Nat.WithBot.lt_zero_iff, degree_eq_bot] at this\n  exact hp0 this\n#align polynomial_not_is_field polynomial_not_is_field\n\n",
 "polynomial_mem_ideal_of_coeff_mem_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem polynomial_mem_ideal_of_coeff_mem_ideal (I : ideal (polynomial R)) (p : polynomial R)\n    (hp : ∀ n : ℕ, p.coeff n ∈ I.comap (C : «expr →+* » R (polynomial R))) : p ∈ I :=\n  sum_C_mul_X_pow_eq p ▸ submodule.sum_mem I fun n hn => I.mul_mem_right _ (hp n)\n#align polynomial_mem_ideal_of_coeff_mem_ideal polynomial_mem_ideal_of_coeff_mem_ideal\n\n",
 "no_zero_divisors_of_finite":
 "/-- Auxiliary definition:\nMultivariate polynomials in finitely many variables over an integral domain form an integral domain.\nThis fact is proven by transport of structure from the `mv_polynomial.no_zero_divisors_fin`,\nand then used to prove the general case without finiteness hypotheses.\nSee `mv_polynomial.no_zero_divisors` for the general case. -/\ntheorem no_zero_divisors_of_finite (R : Type u) (σ : Type v) [CommSemiring R] [Finite σ] [no_zero_divisors R] :\n    no_zero_divisors (mv_polynomial σ R) := by\n  cases nonempty_fintype σ\n  haveI := no_zero_divisors_fin R (fintype.card σ)\n  exact (rename_equiv R (fintype.equiv_fin σ)).injective.no_zero_divisors _ (map_zero _) (map_mul _)\n#align no_zero_divisors_of_finite no_zero_divisors_of_finite\n\n",
 "no_zero_divisors_fin":
 "/-- Auxiliary lemma:\nMultivariate polynomials over an integral domain\nwith variables indexed by `fin n` form an integral domain.\nThis fact is proven inductively,\nand then used to prove the general case without any finiteness hypotheses.\nSee `mv_polynomial.no_zero_divisors` for the general case. -/\ntheorem no_zero_divisors_fin (R : Type u) [CommSemiring R] [no_zero_divisors R] :\n    ∀ n : ℕ, no_zero_divisors (mv_polynomial (fin n) R)\n  | 0 => (mv_polynomial.is_empty_alg_equiv R _).injective.no_zero_divisors _ (map_zero _) (map_mul _)\n  | n + 1 =>\n    haveI := no_zero_divisors_fin n\n    (mv_polynomial.fin_succ_equiv R n).injective.no_zero_divisors _ (map_zero _) (map_mul _)\n#align no_zero_divisors_fin no_zero_divisors_fin\n\n",
 "nat_degree_to_subring":
 "@[simp]\ntheorem nat_degree_to_subring : (to_subring p T hp).nat_degree = p.nat_degree := by simp [nat_degree]\n#align nat_degree_to_subring nat_degree_to_subring\n\n",
 "nat_degree_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem nat_degree_restriction {p : polynomial R} : (restriction p).nat_degree = p.nat_degree := by simp [nat_degree]\n#align nat_degree_restriction nat_degree_restriction\n\n",
 "monic_to_subring":
 "@[simp]\ntheorem monic_to_subring : monic (to_subring p T hp) ↔ monic p :=\n  by\n  simp_rw [monic, leading_coeff, nat_degree_to_subring, ← coeff_to_subring p T hp]\n  exact\n    ⟨fun H => by\n      rw [H]\n      rfl, fun H => subtype.coe_injective H⟩\n#align monic_to_subring monic_to_subring\n\n",
 "monic_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem monic_restriction {p : polynomial R} : monic (restriction p) ↔ monic p :=\n  by\n  simp only [monic, leading_coeff, nat_degree_restriction]\n  rw [← @coeff_restriction _ _ p]\n  exact\n    ⟨fun H => by\n      rw [H]\n      rfl, fun H => subtype.coe_injective H⟩\n#align monic_restriction monic_restriction\n\n",
 "monic_geom_sum_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic_geom_sum_X {n : ℕ} (hn : n ≠ 0) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n        ((X : polynomial R) ^ i)).monic :=\n  by\n  nontriviality R\n  apply monic_X.geom_sum _ hn\n  simpa only [nat_degree_X] using zero_lt_one\n#align monic_geom_sum_X monic_geom_sum_X\n\n",
 "mem_of_polynomial":
 "theorem mem_of_polynomial (x) : x ∈ I.of_polynomial ↔ x ∈ I :=\n  iff.rfl\n#align mem_of_polynomial mem_of_polynomial\n\n",
 "mem_map_C_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- The push-forward of an ideal `I` of `R` to `mv_polynomial σ R` via inclusion\n is exactly the set of polynomials whose coefficients are in `I` -/\ntheorem mem_map_C_iff {I : ideal R} {f : mv_polynomial σ R} :\n    f ∈ (ideal.map (C : «expr →+* » R (mv_polynomial σ R)) I : ideal (mv_polynomial σ R)) ↔\n      ∀ m : «expr →₀ » σ ℕ, f.coeff m ∈ I :=\n  by\n  constructor\n  · intro hf\n    apply submodule.span_induction hf\n    · intro f hf n\n      cases' (Set.mem_image _ _ _).mp hf with x hx\n      rw [← hx.right, coeff_C]\n      by_cases n = 0\n      · simpa [h] using hx.left\n      · simp [ne.symm h]\n    · simp\n    · exact fun f g hf hg n => by simp [I.add_mem (hf n) (hg n)]\n    · refine' fun f g hg n => _\n      rw [smul_eq_mul, coeff_mul]\n      exact I.sum_mem fun c hc => I.mul_mem_left (f.coeff c.fst) (hg c.snd)\n  · intro hf\n    rw [as_sum f]\n    suffices ∀ m ∈ f.support, monomial m (coeff m f) ∈ (ideal.map C I : ideal (mv_polynomial σ R)) by\n      exact submodule.sum_mem _ this\n    intro m hm\n    rw [← mul_one (coeff m f), ← C_mul_monomial]\n    suffices C (coeff m f) ∈ (ideal.map C I : ideal (mv_polynomial σ R)) by exact ideal.mul_mem_right _ _ this\n    apply ideal.mem_map_of_mem _\n    exact hf m\n#align mem_map_C_iff mem_map_C_iff\n\n",
 "mem_leading_coeff_nth_zero":
 "theorem mem_leading_coeff_nth_zero (x) : x ∈ I.leading_coeff_nth 0 ↔ C x ∈ I :=\n  (mem_leading_coeff_nth _ _ _).trans\n    ⟨fun ⟨p, hpI, hpdeg, hpx⟩ => by\n      rwa [← hpx, polynomial.leading_coeff, nat.eq_zero_of_le_zero (nat_degree_le_of_degree_le hpdeg), ←\n        eq_C_of_degree_le_zero hpdeg],\n      fun hx => ⟨C x, hx, degree_C_le, leading_coeff_C x⟩⟩\n#align mem_leading_coeff_nth_zero mem_leading_coeff_nth_zero\n\n",
 "mem_leading_coeff_nth":
 "theorem mem_leading_coeff_nth (n : ℕ) (x) : x ∈ I.leading_coeff_nth n ↔ ∃ p ∈ I, degree p ≤ n ∧ p.leading_coeff = x :=\n  by\n  simp only [leading_coeff_nth, degree_le, submodule.mem_map, lcoeff_apply, submodule.mem_inf, mem_degree_le]\n  constructor\n  · rintro ⟨p, ⟨hpdeg, hpI⟩, rfl⟩\n    cases' lt_or_eq_of_le hpdeg with hpdeg hpdeg\n    · refine' ⟨0, I.zero_mem, bot_le, _⟩\n      rw [leading_coeff_zero, eq_comm]\n      exact coeff_eq_zero_of_degree_lt hpdeg\n    · refine' ⟨p, hpI, le_of_eq hpdeg, _⟩\n      rw [polynomial.leading_coeff, nat_degree, hpdeg]\n      rfl\n  · rintro ⟨p, hpI, hpdeg, rfl⟩\n    have : nat_degree p + (n - nat_degree p) = n := add_tsub_cancel_of_le (nat_degree_le_of_degree_le hpdeg)\n    refine' ⟨p * X ^ (n - nat_degree p), ⟨_, I.mul_mem_right _ hpI⟩, _⟩\n    · apply le_trans (degree_mul_le _ _) _\n      apply le_trans (add_le_add degree_le_nat_degree (degree_X_pow_le _)) _\n      rw [← WithBot.coe_add, this]\n      exact le_rfl\n    · rw [polynomial.leading_coeff, ← coeff_mul_X_pow p (n - nat_degree p), this]\n#align mem_leading_coeff_nth mem_leading_coeff_nth\n\n",
 "mem_leading_coeff":
 "theorem mem_leading_coeff (x) : x ∈ I.leading_coeff ↔ ∃ p ∈ I, polynomial.leading_coeff p = x :=\n  by\n  rw [leading_coeff, submodule.mem_supr_of_directed]\n  simp only [mem_leading_coeff_nth]\n  · constructor\n    · rintro ⟨i, p, hpI, hpdeg, rfl⟩\n      exact ⟨p, hpI, rfl⟩\n    rintro ⟨p, hpI, rfl⟩\n    exact ⟨nat_degree p, p, hpI, degree_le_nat_degree, rfl⟩\n  intro i j;\n  exact ⟨i + j, I.leading_coeff_nth_mono (nat.le_add_right _ _), I.leading_coeff_nth_mono (nat.le_add_left _ _)⟩\n#align mem_leading_coeff mem_leading_coeff\n\n",
 "mem_ker_mod_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_ker_mod_by_monic (hq : q.monic) {p : polynomial R} : p ∈ (mod_by_monic_hom q).ker ↔ q ∣ p :=\n  linear_map.mem_ker.trans (dvd_iff_mod_by_monic_eq_zero hq)\n#align mem_ker_mod_by_monic mem_ker_mod_by_monic\n\n",
 "mem_ideal_of_coeff_mem_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself,\nmultivariate version. -/\ntheorem mem_ideal_of_coeff_mem_ideal (I : ideal (mv_polynomial σ R)) (p : mv_polynomial σ R)\n    (hcoe : ∀ m : «expr →₀ » σ ℕ, p.coeff m ∈ I.comap (C : «expr →+* » R (mv_polynomial σ R))) : p ∈ I :=\n  by\n  rw [as_sum p]\n  suffices ∀ m ∈ p.support, monomial m (mv_polynomial.coeff m p) ∈ I by exact submodule.sum_mem I this\n  intro m hm\n  rw [← mul_one (coeff m p), ← C_mul_monomial]\n  suffices C (coeff m p) ∈ I by exact I.mul_mem_right (monomial m 1) this\n  simpa [ideal.mem_comap] using hcoe m\n#align mem_ideal_of_coeff_mem_ideal mem_ideal_of_coeff_mem_ideal\n\n",
 "mem_frange_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_frange_iff {p : polynomial R} {c : R} : c ∈ p.frange ↔ ∃ n ∈ p.support, c = p.coeff n := by\n  simp [frange, eq_comm]\n#align mem_frange_iff mem_frange_iff\n\n",
 "mem_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_degree_lt {n : ℕ} {f : polynomial R} : f ∈ degree_lt R n ↔ degree f < n :=\n  by\n  simp_rw [degree_lt, submodule.mem_infi, linear_map.mem_ker, degree, finset.max_eq_sup_coe,\n    finset.sup_lt_iff (WithBot.bot_lt_coe n), mem_support_iff, WithBot.coe_lt_coe, lt_iff_not_le, ne, not_imp_not]\n  rfl\n#align mem_degree_lt mem_degree_lt\n\n",
 "mem_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2019 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem mem_degree_le {n : WithBot ℕ} {f : polynomial R} : f ∈ degree_le R n ↔ degree f ≤ n := by\n  simp only [degree_le, submodule.mem_infi, degree_le_iff_coeff_zero, linear_map.mem_ker] <;> rfl\n#align mem_degree_le mem_degree_le\n\n",
 "map_to_subring":
 "@[simp]\ntheorem map_to_subring : (p.to_subring T hp).map (subring.subtype T) = p :=\n  by\n  ext n\n  simp [coeff_map]\n#align map_to_subring map_to_subring\n\n",
 "map_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem map_restriction {R : Type u} [CommRing R] (p : polynomial R) : p.restriction.map (algebra_map _ _) = p :=\n  ext fun n => by rw [coeff_map, algebra.algebra_map_of_subring_apply, coeff_restriction]\n#align map_restriction map_restriction\n\n",
 "map_mv_polynomial_eq_eval₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_mv_polynomial_eq_eval₂ {S : Type _} [CommRing S] [Finite σ] (ϕ : «expr →+* » (mv_polynomial σ R) S)\n    (p : mv_polynomial σ R) : ϕ p = mv_polynomial.eval₂ (ϕ.comp mv_polynomial.C) (fun s => ϕ (mv_polynomial.X s)) p :=\n  by\n  cases nonempty_fintype σ\n  refine' trans (congr_arg ϕ (mv_polynomial.as_sum p)) _\n  rw [mv_polynomial.eval₂_eq', ϕ.map_sum]\n  congr\n  ext\n  simp only [monomial_eq, ϕ.map_pow, ϕ.map_prod, ϕ.comp_apply, ϕ.map_mul, finsupp.prod_pow]\n#align map_mv_polynomial_eq_eval₂ map_mv_polynomial_eq_eval₂\n\n",
 "linear_independent_powers_iff_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem linear_independent_powers_iff_aeval (f : «expr →ₗ[ ] » M R M) (v : M) :\n    (linear_independent R fun n : ℕ => (f ^ n) v) ↔ ∀ p : polynomial R, aeval f p v = 0 → p = 0 :=\n  by\n  rw [linear_independent_iff]\n  simp only [finsupp.total_apply, aeval_endomorphism, forall_iff_forall_finsupp, sum, support, coeff,\n    of_finsupp_eq_zero]\n  exact iff.rfl\n#align linear_independent_powers_iff_aeval linear_independent_powers_iff_aeval\n\n",
 "leading_coeff_nth_mono":
 "theorem leading_coeff_nth_mono {m n : ℕ} (H : m ≤ n) : I.leading_coeff_nth m ≤ I.leading_coeff_nth n :=\n  by\n  intro r hr\n  simp only [SetLike.mem_coe, mem_leading_coeff_nth] at hr⊢\n  rcases hr with ⟨p, hpI, hpdeg, rfl⟩\n  refine' ⟨p * X ^ (n - m), I.mul_mem_right _ hpI, _, leading_coeff_mul_X_pow⟩\n  refine' le_trans (degree_mul_le _ _) _\n  refine' le_trans (add_le_add hpdeg (degree_X_pow_le _)) _\n  rw [← WithBot.coe_add, add_tsub_cancel_of_le H]\n  exact le_rfl\n#align leading_coeff_nth_mono leading_coeff_nth_mono\n\n",
 "ker_mod_by_monic_hom":
 "@[simp]\ntheorem ker_mod_by_monic_hom (hq : q.monic) :\n    (polynomial.mod_by_monic_hom q).ker = (ideal.span {q}).restrict_scalars R :=\n  submodule.ext fun f => (mem_ker_mod_by_monic hq).trans ideal.mem_span_singleton.symm\n#align ker_mod_by_monic_hom ker_mod_by_monic_hom\n\n",
 "ker_map_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem _root_.polynomial.ker_map_ring_hom (f : «expr →+* » R S) :\n    (polynomial.map_ring_hom f).ker = f.ker.map (C : «expr →+* » R (polynomial R)) :=\n  by\n  ext\n  rw [mem_map_C_iff, ring_hom.mem_ker, polynomial.ext_iff]\n  simp_rw [coe_map_ring_hom, coeff_map, coeff_zero, ring_hom.mem_ker]\n#align polynomial.ker_map_ring_hom polynomial.ker_map_ring_hom\n\n",
 "ker_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ker_map (f : «expr →+* » R S) :\n    (map f : «expr →+* » (mv_polynomial σ R) (mv_polynomial σ S)).ker =\n      f.ker.map (C : «expr →+* » R (mv_polynomial σ R)) :=\n  by\n  ext\n  rw [mv_polynomial.mem_map_C_iff, ring_hom.mem_ker, mv_polynomial.ext_iff]\n  simp_rw [coeff_map, coeff_zero, ring_hom.mem_ker]\n#align ker_map ker_map\n\n",
 "is_prime_map_C_of_is_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem is_prime_map_C_of_is_prime {P : ideal R} (H : is_prime P) :\n    is_prime (map (C : «expr →+* » R (polynomial R)) P : ideal (polynomial R)) :=\n  (quotient.is_domain_iff_prime (map C P : ideal (polynomial R))).mp (is_domain_map_C_quotient H)\n#align is_prime_map_C_of_is_prime is_prime_map_C_of_is_prime\n\n",
 "is_noetherian_ring_fin_0":
 "theorem is_noetherian_ring_fin_0 [is_noetherian_ring R] : is_noetherian_ring (mv_polynomial (fin 0) R) :=\n  is_noetherian_ring_of_ring_equiv R\n    ((mv_polynomial.is_empty_ring_equiv R PEmpty).symm.trans (rename_equiv R fin_zero_equiv'.symm).to_ring_equiv)\n#align is_noetherian_ring_fin_0 is_noetherian_ring_fin_0\n\n",
 "is_noetherian_ring_fin":
 "theorem is_noetherian_ring_fin [is_noetherian_ring R] : ∀ {n : ℕ}, is_noetherian_ring (mv_polynomial (fin n) R)\n  | 0 => is_noetherian_ring_fin_0\n  | n + 1 =>\n    @is_noetherian_ring_of_ring_equiv (polynomial (mv_polynomial (fin n) R)) _ _ _\n      (mv_polynomial.fin_succ_equiv _ n).to_ring_equiv.symm\n      (@polynomial.is_noetherian_ring (mv_polynomial (fin n) R) _ is_noetherian_ring_fin)\n#align is_noetherian_ring_fin is_noetherian_ring_fin\n\n",
 "is_noetherian_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. -/\nprotected theorem polynomial.is_noetherian_ring [is_noetherian_ring R] : is_noetherian_ring (polynomial R) :=\n  is_noetherian_ring_iff.2\n    ⟨fun I : ideal (polynomial R) =>\n      let M :=\n        WellFounded.min (is_noetherian_iff_well_founded.1 (by infer_instance)) (Set.range I.leading_coeff_nth)\n          ⟨_, ⟨0, rfl⟩⟩\n      have hm : M ∈ Set.range I.leading_coeff_nth := WellFounded.min_mem _ _ _\n      let ⟨N, HN⟩ := hm\n      let ⟨s, hs⟩ := I.is_fg_degree_le N\n      have hm2 : ∀ k, I.leading_coeff_nth k ≤ M := fun k =>\n        or.cases_on (le_or_lt k N) (fun h => HN ▸ I.leading_coeff_nth_mono h) fun h x hx =>\n          by_contradiction fun hxm =>\n            have : ¬M < I.leading_coeff_nth k := by\n              refine' WellFounded.not_lt_min (well_founded_submodule_gt _ _) _ _ _ <;> exact ⟨k, rfl⟩\n            this ⟨HN ▸ I.leading_coeff_nth_mono (le_of_lt h), fun H => hxm (H hx)⟩\n      have hs2 : ∀ {x}, x ∈ I.degree_le N → x ∈ ideal.span (↑s : set (polynomial R)) :=\n        hs ▸ fun x hx =>\n          submodule.span_induction hx (fun _ hx => ideal.subset_span hx) (ideal.zero_mem _) (fun _ _ => ideal.add_mem _)\n            fun c f hf => f.C_mul' c ▸ ideal.mul_mem_left _ _ hf\n      ⟨s,\n        le_antisymm\n            (ideal.span_le.2 fun x hx =>\n              have : x ∈ I.degree_le N := hs ▸ submodule.subset_span hx\n              this.2) <|\n          by\n          have : submodule.span (polynomial R) ↑s = ideal.span ↑s := by rfl\n          rw [this]\n          intro p hp\n          generalize hn : p.nat_degree = k\n          induction' k using nat.strong_induction_on with k ih generalizing p\n          cases le_or_lt k N\n          · subst k\n            refine'\n              hs2 ⟨polynomial.mem_degree_le.2 (le_trans polynomial.degree_le_nat_degree <| WithBot.coe_le_coe.2 h), hp⟩\n          · have hp0 : p ≠ 0 := by\n              rintro rfl\n              cases hn\n              exact nat.not_lt_zero _ h\n            have : (0 : R) ≠ 1 := by\n              intro h\n              apply hp0\n              ext i\n              refine' (mul_one _).symm.trans _\n              rw [← h, mul_zero]\n              rfl\n            haveI : nontrivial R := ⟨⟨0, 1, this⟩⟩\n            have : p.leading_coeff ∈ I.leading_coeff_nth N := by\n              rw [HN]\n              exact hm2 k ((I.mem_leading_coeff_nth _ _).2 ⟨_, hp, hn ▸ polynomial.degree_le_nat_degree, rfl⟩)\n            rw [I.mem_leading_coeff_nth] at this\n            rcases this with ⟨q, hq, hdq, hlqp⟩\n            have hq0 : q ≠ 0 := by\n              intro H\n              rw [← polynomial.leading_coeff_eq_zero] at H\n              rw [hlqp, polynomial.leading_coeff_eq_zero] at H\n              exact hp0 H\n            have h1 : p.degree = (q * polynomial.X ^ (k - q.nat_degree)).degree :=\n              by\n              rw [polynomial.degree_mul', polynomial.degree_X_pow]\n              rw [polynomial.degree_eq_nat_degree hp0, polynomial.degree_eq_nat_degree hq0]\n              rw [← WithBot.coe_add, add_tsub_cancel_of_le, hn]\n              · refine' le_trans (polynomial.nat_degree_le_of_degree_le hdq) (le_of_lt h)\n              rw [polynomial.leading_coeff_X_pow, mul_one]\n              exact mt polynomial.leading_coeff_eq_zero.1 hq0\n            have h2 : p.leading_coeff = (q * polynomial.X ^ (k - q.nat_degree)).leading_coeff := by\n              rw [← hlqp, polynomial.leading_coeff_mul_X_pow]\n            have := polynomial.degree_sub_lt h1 hp0 h2\n            rw [polynomial.degree_eq_nat_degree hp0] at this\n            rw [← sub_add_cancel p (q * polynomial.X ^ (k - q.nat_degree))]\n            refine' (ideal.span ↑s).add_mem _ ((ideal.span ↑s).mul_mem_right _ _)\n            · by_cases hpq : p - q * polynomial.X ^ (k - q.nat_degree) = 0\n              · rw [hpq]\n                exact ideal.zero_mem _\n              refine' ih _ _ (I.sub_mem hp (I.mul_mem_right _ hq)) rfl\n              rwa [polynomial.degree_eq_nat_degree hpq, WithBot.coe_lt_coe, hn] at this\n            exact hs2 ⟨polynomial.mem_degree_le.2 hdq, hq⟩⟩⟩\n#align polynomial.is_noetherian_ring polynomial.is_noetherian_ring\n\n",
 "is_fg_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_fg_degree_le [is_noetherian_ring R] (I : ideal (polynomial R)) (n : ℕ) : submodule.fg (I.degree_le n) :=\n  is_noetherian_submodule_left.1 (is_noetherian_of_fg_of_noetherian _ ⟨_, degree_le_eq_span_X_pow.symm⟩) _\n#align is_fg_degree_le is_fg_degree_le\n\n",
 "is_domain_map_C_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem is_domain_map_C_quotient {P : ideal R} (H : is_prime P) :\n    IsDomain («expr ⧸ » (polynomial R) (map (C : «expr →+* » R (polynomial R)) P : ideal (polynomial R))) :=\n  RingEquiv.isDomain (polynomial («expr ⧸ » R P)) (polynomial_quotient_equiv_quotient_polynomial P).symm\n#align is_domain_map_C_quotient is_domain_map_C_quotient\n\n",
 "geom_sum_X_comp_X_add_one_eq_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem geom_sum_X_comp_X_add_one_eq_sum (n : ℕ) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n            ((X : polynomial R) ^ i)).comp\n        (X + 1) =\n      (Finset.range n).sum fun i : ℕ => (n.choose (i + 1) : polynomial R) * X ^ i :=\n  by\n  ext i\n  trans (n.choose (i + 1) : R); swap\n  · simp only [finset_sum_coeff, ← C_eq_nat_cast, coeff_C_mul_X_pow]\n    rw [finset.sum_eq_single i, if_pos rfl]\n    · simp (config := { contextual := true }) only [@eq_comm _ i, if_false, eq_self_iff_true, imp_true_iff]\n    ·\n      simp (config := { contextual := true }) only [Nat.lt_add_one_iff, Nat.choose_eq_zero_of_lt, Nat.cast_zero,\n        Finset.mem_range, not_lt, eq_self_iff_true, if_true, imp_true_iff]\n  induction' n with n ih generalizing i\n  · simp only [geom_sum_zero, zero_comp, coeff_zero, Nat.choose_zero_succ, Nat.cast_zero]\n  simp only [geom_sum_succ', ih, add_comp, X_pow_comp, coeff_add, Nat.choose_succ_succ, Nat.cast_add,\n    coeff_X_add_one_pow]\n#align geom_sum_X_comp_X_add_one_eq_sum geom_sum_X_comp_X_add_one_eq_sum\n\n",
 "geom_sum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem monic.geom_sum' {P : polynomial R} (hP : P.monic) (hdeg : 0 < P.degree) {n : ℕ} (hn : n ≠ 0) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n        (P ^ i)).monic :=\n  hP.geom_sum (nat_degree_pos_iff_degree_pos.2 hdeg) hn\n#align monic.geom_sum' monic.geom_sum'\n\n",
 "geom_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem monic.geom_sum {P : polynomial R} (hP : P.monic) (hdeg : 0 < P.nat_degree) {n : ℕ} (hn : n ≠ 0) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n        (P ^ i)).monic :=\n  by\n  nontriviality R\n  cases n; · exact (hn rfl).elim\n  rw [geom_sum_succ']\n  refine' (hP.pow _).add_of_left _\n  refine' lt_of_le_of_lt (degree_sum_le _ _) _\n  rw [finset.sup_lt_iff]\n  · simp only [Finset.mem_range, degree_eq_nat_degree (hP.pow _).ne_zero, WithBot.coe_lt_coe, hP.nat_degree_pow]\n    intro k\n    exact nsmul_lt_nsmul hdeg\n  · rw [bot_lt_iff_ne_bot, ne.def, degree_eq_bot]\n    exact (hP.pow _).ne_zero\n#align monic.geom_sum monic.geom_sum\n\n",
 "frange_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem frange_zero : frange (0 : polynomial R) = ∅ :=\n  rfl\n#align frange_zero frange_zero\n\n",
 "frange_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem frange_one : frange (1 : polynomial R) ⊆ {1} :=\n  by\n  simp [frange, Finset.image_subset_iff]\n  simp only [← C_1, coeff_C]\n  intro n hn\n  simp only [exists_prop, ite_eq_right_iff, not_forall] at hn\n  simp [hn]\n#align frange_one frange_one\n\n",
 "frange_of_subring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem frange_of_subring {p : polynomial T} : (↑(p.of_subring T).frange : set R) ⊆ T :=\n  by\n  intro i hi\n  simp only [frange, Set.mem_image, mem_support_iff, ne.def, Finset.mem_coe, Finset.coe_image] at hi\n  rcases hi with ⟨n, hn, h'n⟩\n  rw [← h'n, coeff_of_subring]\n  exact Subtype.mem (coeff p n : T)\n#align frange_of_subring frange_of_subring\n\n",
 "exists_irreducible_of_nat_degree_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_irreducible_of_nat_degree_pos {R : Type u} [CommRing R] [IsDomain R] [wf_dvd_monoid R] {f : polynomial R}\n    (hf : 0 < f.nat_degree) : ∃ g, Irreducible g ∧ g ∣ f :=\n  exists_irreducible_of_degree_pos <| by\n    contrapose! hf\n    exact nat_degree_le_of_degree_le hf\n#align exists_irreducible_of_nat_degree_pos exists_irreducible_of_nat_degree_pos\n\n",
 "exists_irreducible_of_nat_degree_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_irreducible_of_nat_degree_ne_zero {R : Type u} [CommRing R] [IsDomain R] [wf_dvd_monoid R]\n    {f : polynomial R} (hf : f.nat_degree ≠ 0) : ∃ g, Irreducible g ∧ g ∣ f :=\n  exists_irreducible_of_nat_degree_pos <| nat.pos_of_ne_zero hf\n#align exists_irreducible_of_nat_degree_ne_zero exists_irreducible_of_nat_degree_ne_zero\n\n",
 "exists_irreducible_of_degree_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_irreducible_of_degree_pos {R : Type u} [CommRing R] [IsDomain R] [wf_dvd_monoid R] {f : polynomial R}\n    (hf : 0 < f.degree) : ∃ g, Irreducible g ∧ g ∣ f :=\n  wf_dvd_monoid.exists_irreducible_factor (fun huf => ne_of_gt hf <| degree_eq_zero_of_is_unit huf) fun hf0 =>\n    not_lt_of_lt hf <| hf0.symm ▸ (@degree_zero R _).symm ▸ WithBot.bot_lt_coe _\n#align exists_irreducible_of_degree_pos exists_irreducible_of_degree_pos\n\n",
 "eval₂_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_restriction {p : polynomial R} :\n    eval₂ f x p = eval₂ (f.comp (subring.subtype (subring.closure (p.frange : set R)))) x p.restriction :=\n  by\n  simp only [eval₂_eq_sum, sum, support_restriction, ← @coeff_restriction _ _ p]\n  rfl\n#align eval₂_restriction eval₂_restriction\n\n",
 "eval₂_C_mk_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_C_mk_eq_zero {I : ideal R} {a : mv_polynomial σ R}\n    (ha : a ∈ (ideal.map (C : «expr →+* » R (mv_polynomial σ R)) I : ideal (mv_polynomial σ R))) :\n    eval₂_hom (C.comp (ideal.quotient.mk I)) X a = 0 :=\n  by\n  rw [as_sum a]\n  rw [coe_eval₂_hom, eval₂_sum]\n  refine' finset.sum_eq_zero fun n hn => _\n  simp only [eval₂_monomial, Function.comp_apply, RingHom.coe_comp]\n  refine' mul_eq_zero_of_left _ _\n  suffices coeff n a ∈ I by\n    rw [← @ideal.mk_ker R _ I, ring_hom.mem_ker] at this\n    simp only [this, C_0]\n  exact mem_map_C_iff.1 ha n\n#align eval₂_C_mk_eq_zero eval₂_C_mk_eq_zero\n\n",
 "eval_eq_sum_degree_lt_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem eval_eq_sum_degree_lt_equiv {n : ℕ} {p : polynomial R} (hp : p ∈ degree_lt R n) (x : R) :\n    p.eval x =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (degree_lt_equiv _ _ ⟨p, hp⟩ i * x ^ (i : ℕ)) :=\n  by\n  simp_rw [eval_eq_sum]\n  exact (sum_fin _ (by simp_rw [zero_mul, forall_const]) (mem_degree_lt.mp hp)).symm\n#align eval_eq_sum_degree_lt_equiv eval_eq_sum_degree_lt_equiv\n\n",
 "eq_zero_of_polynomial_mem_map_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\n  If we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\n  In particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\n  This theorem shows `I'` will not contain any non-zero constant polynomials\n  -/\ntheorem eq_zero_of_polynomial_mem_map_range (I : ideal (polynomial R)) (x : ((quotient.mk I).comp C).range)\n    (hx : C x ∈ I.map (polynomial.map_ring_hom ((quotient.mk I).comp C).range_restrict)) : x = 0 :=\n  by\n  let i := ((Quotient.mk'' I).comp C).range_restrict\n  have hi' : (polynomial.map_ring_hom i).ker ≤ I :=\n    by\n    refine' fun f hf => polynomial_mem_ideal_of_coeff_mem_ideal I f fun n => _\n    rw [mem_comap, ← quotient.eq_zero_iff_mem, ← RingHom.comp_apply]\n    rw [ring_hom.mem_ker, coe_map_ring_hom] at hf\n    replace hf := congr_arg (fun f : polynomial _ => f.coeff n) hf\n    simp only [coeff_map, coeff_zero] at hf\n    rwa [subtype.ext_iff, ring_hom.coe_range_restrict] at hf\n  obtain ⟨x, hx'⟩ := x\n  obtain ⟨y, rfl⟩ := ring_hom.mem_range.1 hx'\n  refine' subtype.eq _\n  simp only [RingHom.comp_apply, quotient.eq_zero_iff_mem, ZeroMemClass.coe_zero, subtype.val_eq_coe]\n  suffices C (i y) ∈ I.map (polynomial.map_ring_hom i)\n    by\n    obtain ⟨f, hf⟩ :=\n      mem_image_of_mem_map_of_surjective (polynomial.map_ring_hom i)\n        (polynomial.map_surjective _ ((Quotient.mk'' I).comp C).range_restrict_surjective) this\n    refine' sub_add_cancel (C y) f ▸ I.add_mem (hi' _ : C y - f ∈ I) hf.1\n    rw [ring_hom.mem_ker, RingHom.map_sub, hf.2, sub_eq_zero, coe_map_ring_hom, map_C]\n  exact hx\n#align eq_zero_of_polynomial_mem_map_range eq_zero_of_polynomial_mem_map_range\n\n",
 "eq_zero_of_constant_mem_of_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The only constant in a maximal ideal over a field is `0`. -/\ntheorem eq_zero_of_constant_mem_of_maximal (hR : IsField R) (I : ideal (polynomial R)) [hI : I.is_maximal] (x : R)\n    (hx : C x ∈ I) : x = 0 :=\n  by\n  refine' by_contradiction fun hx0 => hI.ne_top ((eq_top_iff_one I).2 _)\n  obtain ⟨y, hy⟩ := hR.mul_inv_cancel hx0\n  convert I.mul_mem_left (C y) hx\n  rw [← C.map_mul, hR.mul_comm y x, hy, RingHom.map_one]\n#align eq_zero_of_constant_mem_of_maximal eq_zero_of_constant_mem_of_maximal\n\n",
 "disjoint_ker_aeval_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem disjoint_ker_aeval_of_coprime (f : «expr →ₗ[ ] » M R M) {p q : polynomial R} (hpq : IsCoprime p q) :\n    Disjoint (aeval f p).ker (aeval f q).ker :=\n  by\n  rw [disjoint_iff_inf_le]\n  intro v hv\n  rcases hpq with ⟨p', q', hpq'⟩\n  simpa [linear_map.mem_ker.1 (submodule.mem_inf.1 hv).1, linear_map.mem_ker.1 (submodule.mem_inf.1 hv).2] using\n    congr_arg (fun p : polynomial R => aeval f p v) hpq'.symm\n#align disjoint_ker_aeval_of_coprime disjoint_ker_aeval_of_coprime\n\n",
 "degree_to_subring":
 "@[simp]\ntheorem degree_to_subring : (to_subring p T hp).degree = p.degree := by simp [degree]\n#align degree_to_subring degree_to_subring\n\n",
 "degree_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem degree_restriction {p : polynomial R} : (restriction p).degree = p.degree := by simp [degree]\n#align degree_restriction degree_restriction\n\n",
 "degree_lt_mono":
 "@[mono]\ntheorem degree_lt_mono {m n : ℕ} (H : m ≤ n) : degree_lt R m ≤ degree_lt R n := fun f hf =>\n  mem_degree_lt.2 (lt_of_lt_of_le (mem_degree_lt.1 hf) <| WithBot.coe_le_coe.2 H)\n#align degree_lt_mono degree_lt_mono\n\n",
 "degree_lt_equiv_eq_zero_iff_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem degree_lt_equiv_eq_zero_iff_eq_zero {n : ℕ} {p : polynomial R} (hp : p ∈ degree_lt R n) :\n    degree_lt_equiv _ _ ⟨p, hp⟩ = 0 ↔ p = 0 := by rw [linear_equiv.map_eq_zero_iff, submodule.mk_eq_zero]\n#align degree_lt_equiv_eq_zero_iff_eq_zero degree_lt_equiv_eq_zero_iff_eq_zero\n\n",
 "degree_lt_eq_span_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_lt_eq_span_X_pow {n : ℕ} :\n    degree_lt R n = submodule.span R ↑((Finset.range n).image fun n => X ^ n : Finset (polynomial R)) :=\n  by\n  apply le_antisymm\n  · intro p hp\n    replace hp := mem_degree_lt.1 hp\n    rw [← polynomial.sum_monomial_eq p, polynomial.sum]\n    refine' submodule.sum_mem _ fun k hk => _\n    show monomial _ _ ∈ _\n    have := WithBot.coe_lt_coe.1 ((finset.sup_lt_iff <| WithBot.bot_lt_coe n).1 hp k hk)\n    rw [← C_mul_X_pow_eq_monomial, C_mul']\n    refine'\n      submodule.smul_mem _ _\n        (submodule.subset_span <| Finset.mem_coe.2 <| Finset.mem_image.2 ⟨_, Finset.mem_range.2 this, rfl⟩)\n  rw [submodule.span_le, Finset.coe_image, Set.image_subset_iff]\n  intro k hk; apply mem_degree_lt.2\n  exact lt_of_le_of_lt (degree_X_pow_le _) (WithBot.coe_lt_coe.2 <| Finset.mem_range.1 hk)\n#align degree_lt_eq_span_X_pow degree_lt_eq_span_X_pow\n\n",
 "degree_le_mono":
 "@[mono]\ntheorem degree_le_mono {m n : WithBot ℕ} (H : m ≤ n) : degree_le R m ≤ degree_le R n := fun f hf =>\n  mem_degree_le.2 (le_trans (mem_degree_le.1 hf) H)\n#align degree_le_mono degree_le_mono\n\n",
 "degree_le_eq_span_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_le_eq_span_X_pow {n : ℕ} :\n    degree_le R n = submodule.span R ↑((Finset.range (n + 1)).image fun n => (X : polynomial R) ^ n) :=\n  by\n  apply le_antisymm\n  · intro p hp\n    replace hp := mem_degree_le.1 hp\n    rw [← polynomial.sum_monomial_eq p, polynomial.sum]\n    refine' submodule.sum_mem _ fun k hk => _\n    show monomial _ _ ∈ _\n    have := WithBot.coe_le_coe.1 (finset.sup_le_iff.1 hp k hk)\n    rw [← C_mul_X_pow_eq_monomial, C_mul']\n    refine'\n      submodule.smul_mem _ _\n        (submodule.subset_span <|\n          Finset.mem_coe.2 <| Finset.mem_image.2 ⟨_, Finset.mem_range.2 (nat.lt_succ_of_le this), rfl⟩)\n  rw [submodule.span_le, Finset.coe_image, Set.image_subset_iff]\n  intro k hk; apply mem_degree_le.2\n  exact (degree_X_pow_le _).trans (WithBot.coe_le_coe.2 <| nat.le_of_lt_succ <| Finset.mem_range.1 hk)\n#align degree_le_eq_span_X_pow degree_le_eq_span_X_pow\n\n",
 "coeff_to_subring'":
 "@[simp]\ntheorem coeff_to_subring' {n : ℕ} : (coeff (to_subring p T hp) n).1 = coeff p n :=\n  coeff_to_subring _ _ hp\n#align coeff_to_subring' coeff_to_subring'\n\n",
 "coeff_to_subring":
 "@[simp]\ntheorem coeff_to_subring {n : ℕ} : ↑(coeff (to_subring p T hp) n) = coeff p n :=\n  by\n  simp only [to_subring, coeff_monomial, finset_sum_coeff, mem_support_iff, finset.sum_ite_eq', ne.def, ite_not]\n  split_ifs\n  · rw [h]\n    rfl\n  · rfl\n#align coeff_to_subring coeff_to_subring\n\n",
 "coeff_restriction'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coeff_restriction' {p : polynomial R} {n : ℕ} : (coeff (restriction p) n).1 = coeff p n :=\n  coeff_restriction\n#align coeff_restriction' coeff_restriction'\n\n",
 "coeff_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coeff_restriction {p : polynomial R} {n : ℕ} : ↑(coeff (restriction p) n) = coeff p n :=\n  by\n  simp only [restriction, coeff_monomial, finset_sum_coeff, mem_support_iff, finset.sum_ite_eq', ne.def, ite_not]\n  split_ifs\n  · rw [h]\n    rfl\n  · rfl\n#align coeff_restriction coeff_restriction\n\n",
 "coeff_prod_mem_ideal_pow_tsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `I` is an ideal, and `pᵢ` is a finite family of polynomials each satisfying\n`∀ k, (pᵢ)ₖ ∈ Iⁿⁱ⁻ᵏ` for some `nᵢ`, then `p = ∏ pᵢ` also satisfies `∀ k, pₖ ∈ Iⁿ⁻ᵏ` with `n = ∑ nᵢ`.\n-/\ntheorem _root_.polynomial.coeff_prod_mem_ideal_pow_tsub {ι : Type _} (s : Finset ι) (f : ι → polynomial R) (I : ideal R)\n    (n : ι → ℕ) (h : ∀ i ∈ s, ∀ (k), (f i).coeff k ∈ I ^ (n i - k)) (k : ℕ) : (s.prod f).coeff k ∈ I ^ (s.sum n - k) :=\n  by\n  classical\n    induction' s using Finset.induction with a s ha hs generalizing k\n    · rw [sum_empty, prod_empty, coeff_one, zero_tsub, pow_zero, ideal.one_eq_top]\n      exact submodule.mem_top\n    · rw [sum_insert ha, prod_insert ha, coeff_mul]\n      apply sum_mem\n      rintro ⟨i, j⟩ e\n      obtain rfl : i + j = k := nat.mem_antidiagonal.mp e\n      apply ideal.pow_le_pow add_tsub_add_le_tsub_add_tsub\n      rw [pow_add]\n      exact\n        ideal.mul_mem_mul (h _ (finset.mem_insert.mpr <| or.inl rfl) _)\n          (hs (fun i hi k => h _ (finset.mem_insert.mpr <| or.inr hi) _) j)\n#align polynomial.coeff_prod_mem_ideal_pow_tsub polynomial.coeff_prod_mem_ideal_pow_tsub\n\n",
 "coeff_of_subring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_of_subring (p : polynomial T) (n : ℕ) : coeff (of_subring T p) n = (coeff p n : T) :=\n  by\n  simp only [of_subring, coeff_monomial, finset_sum_coeff, mem_support_iff, finset.sum_ite_eq', ite_eq_right_iff,\n    ne.def, ite_not, not_not, ite_eq_left_iff]\n  intro h\n  rw [h]\n  rfl\n#align coeff_of_subring coeff_of_subring\n\n",
 "coeff_mem_frange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_mem_frange (p : polynomial R) (n : ℕ) (h : p.coeff n ≠ 0) : p.coeff n ∈ p.frange :=\n  by\n  simp only [frange, exists_prop, mem_support_iff, Finset.mem_image, ne.def]\n  exact ⟨n, h, rfl⟩\n#align coeff_mem_frange coeff_mem_frange\n\n"}