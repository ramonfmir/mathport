{"unique_factorization_monoid_of_fintype":
 "private theorem unique_factorization_monoid_of_fintype [Fintype σ] : UniqueFactorizationMonoid (MvPolynomial σ D) :=\n  (renameEquiv D (Fintype.equivFin σ)).to_mul_equiv.symm.unique_factorization_monoid <|\n    by\n    induction' Fintype.card σ with d hd\n    · apply (is_empty_alg_equiv D (Fin 0)).to_mul_equiv.symm.unique_factorization_monoid\n      infer_instance\n    · apply (finSuccEquiv D d).to_mul_equiv.symm.unique_factorization_monoid\n      exact Polynomial.uniqueFactorizationMonoid\n#align unique_factorization_monoid_of_fintype unique_factorization_monoid_of_fintype\n\n",
 "to_subring_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem to_subring_zero : toSubring (0 : polynomial R) T (by simp [frange_zero]) = 0 :=\n  by\n  ext i\n  simp\n#align to_subring_zero to_subring_zero\n\n",
 "to_subring_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem to_subring_one :\n    toSubring (1 : polynomial R) T (Set.Subset.trans frange_one <| Finset.singleton_subset_set_iff.2 T.one_mem) = 1 :=\n  ext fun i => Subtype.eq <| by rw [coeff_to_subring', coeff_one, coeff_one] <;> split_ifs <;> rfl\n#align to_subring_one to_subring_one\n\n",
 "support_to_subring":
 "@[simp]\ntheorem support_to_subring : support (toSubring p T hp) = support p :=\n  by\n  ext i\n  simp only [mem_support_iff, not_iff_not, ne.def]\n  conv_rhs => rw [← coeff_to_subring p T hp]\n  exact\n    ⟨fun H => by\n      rw [H]\n      rfl, fun H => Subtype.coe_injective H⟩\n#align support_to_subring support_to_subring\n\n",
 "support_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem support_restriction (p : polynomial R) : support (restriction p) = support p :=\n  by\n  ext i\n  simp only [mem_support_iff, not_iff_not, ne.def]\n  conv_rhs => rw [← coeff_restriction]\n  exact\n    ⟨fun H => by\n      rw [H]\n      rfl, fun H => Subtype.coe_injective H⟩\n#align support_restriction support_restriction\n\n",
 "sup_ker_aeval_le_ker_aeval_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_ker_aeval_le_ker_aeval_mul {f : «expr →ₗ[ ] » M R M} {p q : polynomial R} :\n    «expr ⊔ » (aeval f p).ker (aeval f q).ker ≤ (aeval f (p * q)).ker :=\n  by\n  intro v hv\n  rcases Submodule.mem_sup.1 hv with ⟨x, hx, y, hy, hxy⟩\n  have h_eval_x : aeval f (p * q) x = 0 := by\n    rw [mul_comm, aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hx, LinearMap.map_zero]\n  have h_eval_y : aeval f (p * q) y = 0 := by\n    rw [aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hy, LinearMap.map_zero]\n  rw [LinearMap.mem_ker, ← hxy, LinearMap.map_add, h_eval_x, h_eval_y, add_zero]\n#align sup_ker_aeval_le_ker_aeval_mul sup_ker_aeval_le_ker_aeval_mul\n\n",
 "sup_ker_aeval_eq_ker_aeval_mul_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_ker_aeval_eq_ker_aeval_mul_of_coprime (f : «expr →ₗ[ ] » M R M) {p q : polynomial R} (hpq : IsCoprime p q) :\n    «expr ⊔ » (aeval f p).ker (aeval f q).ker = (aeval f (p * q)).ker :=\n  by\n  apply le_antisymm sup_ker_aeval_le_ker_aeval_mul\n  intro v hv\n  rw [Submodule.mem_sup]\n  rcases hpq with ⟨p', q', hpq'⟩\n  have h_eval₂_qpp' :=\n    calc\n      aeval f (q * (p * p')) v = aeval f (p' * (p * q)) v := by\n        rw [mul_comm, mul_assoc, mul_comm, mul_assoc, mul_comm q p]\n      _ = 0 := by rw [aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hv, LinearMap.map_zero]\n      \n  have h_eval₂_pqq' :=\n    calc\n      aeval f (p * (q * q')) v = aeval f (q' * (p * q)) v := by rw [← mul_assoc, mul_comm]\n      _ = 0 := by rw [aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hv, LinearMap.map_zero]\n      \n  rw [aeval_mul] at h_eval₂_qpp' h_eval₂_pqq'\n  refine'\n    ⟨aeval f (q * q') v, LinearMap.mem_ker.1 h_eval₂_pqq', aeval f (p * p') v, LinearMap.mem_ker.1 h_eval₂_qpp', _⟩\n  rw [add_comm, mul_comm p p', mul_comm q q']\n  simpa only [map_add, map_mul, aeval_one] using congr_arg (fun p : polynomial R => aeval f p v) hpq'\n#align sup_ker_aeval_eq_ker_aeval_mul_of_coprime sup_ker_aeval_eq_ker_aeval_mul_of_coprime\n\n",
 "sup_aeval_range_eq_top_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem sup_aeval_range_eq_top_of_coprime (f : «expr →ₗ[ ] » M R M) {p q : polynomial R} (hpq : IsCoprime p q) :\n    «expr ⊔ » (aeval f p).range (aeval f q).range = «expr⊤» :=\n  by\n  rw [eq_top_iff]\n  intro v hv\n  rw [Submodule.mem_sup]\n  rcases hpq with ⟨p', q', hpq'⟩\n  use aeval f (p * p') v\n  use LinearMap.mem_range.2 ⟨aeval f p' v, by simp only [LinearMap.mul_apply, aeval_mul]⟩\n  use aeval f (q * q') v\n  use LinearMap.mem_range.2 ⟨aeval f q' v, by simp only [LinearMap.mul_apply, aeval_mul]⟩\n  simpa only [mul_comm p p', mul_comm q q', aeval_one, aeval_add] using\n    congr_arg (fun p : polynomial R => aeval f p v) hpq'\n#align sup_aeval_range_eq_top_of_coprime sup_aeval_range_eq_top_of_coprime\n\n",
 "restriction_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem restriction_zero : restriction (0 : polynomial R) = 0 := by\n  simp only [restriction, Finset.sum_empty, support_zero]\n#align restriction_zero restriction_zero\n\n",
 "restriction_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem restriction_one : restriction (1 : polynomial R) = 1 :=\n  ext fun i => Subtype.eq <| by rw [coeff_restriction', coeff_one, coeff_one] <;> split_ifs <;> rfl\n#align restriction_one restriction_one\n\n",
 "prime_rename_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem prime_rename_iff (s : Set σ) {p : MvPolynomial s R} : Prime (rename (coe : s → σ) p) ↔ Prime p := by\n  classical\n    symm\n    let eqv :=\n      (sum_alg_equiv R _ _).symm.trans\n        (rename_equiv R <| (Equiv.sumComm («expr↥ » («expr ᶜ» s)) s).trans <| Equiv.Set.sumCompl s)\n    rw [← prime_C_iff («expr↥ » («expr ᶜ» s)), eqv.to_mul_equiv.prime_iff]\n    convert iff.rfl\n    suffices (rename coe).to_ring_hom = eqv.to_alg_hom.to_ring_hom.comp C by apply RingHom.congr_fun this\n    · apply ring_hom_ext\n      · intro\n        dsimp [eqv]\n        erw [iter_to_sum_C_C, rename_C, rename_C]\n      · intro\n        dsimp [eqv]\n        erw [iter_to_sum_C_X, rename_X, rename_X]\n        rfl\n#align prime_rename_iff prime_rename_iff\n\n",
 "prime_C_iff_of_fintype":
 "private theorem prime_C_iff_of_fintype [Fintype σ] : Prime (C r : MvPolynomial σ R) ↔ Prime r :=\n  by\n  rw [(rename_equiv R (Fintype.equivFin σ)).to_mul_equiv.prime_iff]\n  convert_to Prime (C r) ↔ _;\n  · congr\n    apply rename_C\n  · symm\n    induction' Fintype.card σ with d hd\n    · exact (is_empty_alg_equiv R (Fin 0)).to_mul_equiv.symm.prime_iff\n    · rw [hd, ← Polynomial.prime_C_iff]\n      convert(finSuccEquiv R d).to_mul_equiv.symm.prime_iff\n      rw [← fin_succ_equiv_comp_C_eq_C]\n      rfl\n#align prime_C_iff_of_fintype prime_C_iff_of_fintype\n\n",
 "prime_C_iff":
 "theorem prime_C_iff : Prime (C r : MvPolynomial σ R) ↔ Prime r :=\n  ⟨comap_prime C constantCoeff (constantCoeff_C _), fun hr =>\n    ⟨fun h =>\n      hr.1 <| by\n        rw [← C_inj, h]\n        simp,\n      fun h =>\n      hr.2.1 <| by\n        rw [← constant_coeff_C _ r]\n        exact h.map _,\n      fun a b hd => by\n      obtain ⟨s, a', b', rfl, rfl⟩ := exists_finset_rename₂ a b\n      rw [← algebra_map_eq] at hd\n      have : algebraMap R _ r ∣ a' * b' :=\n        by\n        convert(kill_compl Subtype.coe_injective).to_ring_hom.map_dvd hd\n        simpa\n        simp\n      rw [← rename_C (coe : s → σ)]\n      let f := (rename (coe : s → σ)).to_ring_hom\n      exact (((prime_C_iff_of_fintype s).2 hr).2.2 a' b' this).imp f.map_dvd f.map_dvd⟩⟩\n#align prime_C_iff prime_C_iff\n\n",
 "polynomial_not_is_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- `R[X]` is never a field for any ring `R`. -/\ntheorem polynomial_not_is_field : ¬IsField (polynomial R) :=\n  by\n  nontriviality R\n  intro hR\n  obtain ⟨p, hp⟩ := hR.mul_inv_cancel X_ne_zero\n  have hp0 : p ≠ 0 := by\n    rintro rfl\n    rw [MulZeroClass.mul_zero] at hp\n    exact zero_ne_one hp\n  have := degree_lt_degree_mul_X hp0\n  rw [← X_mul, congr_arg degree hp, degree_one, Nat.WithBot.lt_zero_iff, degree_eq_bot] at this\n  exact hp0 this\n#align polynomial_not_is_field polynomial_not_is_field\n\n",
 "polynomial_mem_ideal_of_coeff_mem_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem polynomial_mem_ideal_of_coeff_mem_ideal (I : Ideal (polynomial R)) (p : polynomial R)\n    (hp : ∀ n : ℕ, p.coeff n ∈ I.comap (C : «expr →+* » R (polynomial R))) : p ∈ I :=\n  sum_C_mul_X_pow_eq p ▸ Submodule.sum_mem I fun n hn => I.mul_mem_right _ (hp n)\n#align polynomial_mem_ideal_of_coeff_mem_ideal polynomial_mem_ideal_of_coeff_mem_ideal\n\n",
 "no_zero_divisors_of_finite":
 "/-- Auxiliary definition:\nMultivariate polynomials in finitely many variables over an integral domain form an integral domain.\nThis fact is proven by transport of structure from the `mv_polynomial.no_zero_divisors_fin`,\nand then used to prove the general case without finiteness hypotheses.\nSee `mv_polynomial.no_zero_divisors` for the general case. -/\ntheorem no_zero_divisors_of_finite (R : Type u) (σ : Type v) [CommSemiring R] [Finite σ] [NoZeroDivisors R] :\n    NoZeroDivisors (MvPolynomial σ R) := by\n  cases nonempty_fintype σ\n  haveI := no_zero_divisors_fin R (Fintype.card σ)\n  exact (rename_equiv R (Fintype.equivFin σ)).injective.no_zero_divisors _ (map_zero _) (map_mul _)\n#align no_zero_divisors_of_finite no_zero_divisors_of_finite\n\n",
 "no_zero_divisors_fin":
 "/-- Auxiliary lemma:\nMultivariate polynomials over an integral domain\nwith variables indexed by `fin n` form an integral domain.\nThis fact is proven inductively,\nand then used to prove the general case without any finiteness hypotheses.\nSee `mv_polynomial.no_zero_divisors` for the general case. -/\ntheorem no_zero_divisors_fin (R : Type u) [CommSemiring R] [NoZeroDivisors R] :\n    ∀ n : ℕ, NoZeroDivisors (MvPolynomial (Fin n) R)\n  | 0 => (MvPolynomial.isEmptyAlgEquiv R _).injective.no_zero_divisors _ (map_zero _) (map_mul _)\n  | n + 1 =>\n    haveI := no_zero_divisors_fin n\n    (MvPolynomial.finSuccEquiv R n).injective.no_zero_divisors _ (map_zero _) (map_mul _)\n#align no_zero_divisors_fin no_zero_divisors_fin\n\n",
 "nat_degree_to_subring":
 "@[simp]\ntheorem nat_degree_to_subring : (toSubring p T hp).nat_degree = p.nat_degree := by simp [nat_degree]\n#align nat_degree_to_subring nat_degree_to_subring\n\n",
 "nat_degree_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem nat_degree_restriction {p : polynomial R} : (restriction p).nat_degree = p.nat_degree := by simp [nat_degree]\n#align nat_degree_restriction nat_degree_restriction\n\n",
 "monic_to_subring":
 "@[simp]\ntheorem monic_to_subring : Monic (toSubring p T hp) ↔ Monic p :=\n  by\n  simp_rw [monic, leading_coeff, nat_degree_to_subring, ← coeff_to_subring p T hp]\n  exact\n    ⟨fun H => by\n      rw [H]\n      rfl, fun H => Subtype.coe_injective H⟩\n#align monic_to_subring monic_to_subring\n\n",
 "monic_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem monic_restriction {p : polynomial R} : Monic (restriction p) ↔ Monic p :=\n  by\n  simp only [monic, leading_coeff, nat_degree_restriction]\n  rw [← @coeff_restriction _ _ p]\n  exact\n    ⟨fun H => by\n      rw [H]\n      rfl, fun H => Subtype.coe_injective H⟩\n#align monic_restriction monic_restriction\n\n",
 "monic_geom_sum_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic_geom_sum_X {n : ℕ} (hn : n ≠ 0) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n        ((X : polynomial R) ^ i)).monic :=\n  by\n  nontriviality R\n  apply monic_X.geom_sum _ hn\n  simpa only [nat_degree_X] using zero_lt_one\n#align monic_geom_sum_X monic_geom_sum_X\n\n",
 "mem_of_polynomial":
 "theorem mem_of_polynomial (x) : x ∈ I.of_polynomial ↔ x ∈ I :=\n  iff.rfl\n#align mem_of_polynomial mem_of_polynomial\n\n",
 "mem_map_C_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- The push-forward of an ideal `I` of `R` to `mv_polynomial σ R` via inclusion\n is exactly the set of polynomials whose coefficients are in `I` -/\ntheorem mem_map_C_iff {I : Ideal R} {f : MvPolynomial σ R} :\n    f ∈ (Ideal.map (C : «expr →+* » R (MvPolynomial σ R)) I : Ideal (MvPolynomial σ R)) ↔\n      ∀ m : «expr →₀ » σ ℕ, f.coeff m ∈ I :=\n  by\n  constructor\n  · intro hf\n    apply Submodule.span_induction hf\n    · intro f hf n\n      cases' (Set.mem_image _ _ _).mp hf with x hx\n      rw [← hx.right, coeff_C]\n      by_cases n = 0\n      · simpa [h] using hx.left\n      · simp [ne.symm h]\n    · simp\n    · exact fun f g hf hg n => by simp [I.add_mem (hf n) (hg n)]\n    · refine' fun f g hg n => _\n      rw [smul_eq_mul, coeff_mul]\n      exact I.sum_mem fun c hc => I.mul_mem_left (f.coeff c.fst) (hg c.snd)\n  · intro hf\n    rw [as_sum f]\n    suffices ∀ m ∈ f.support, monomial m (coeff m f) ∈ (Ideal.map C I : Ideal (MvPolynomial σ R)) by\n      exact Submodule.sum_mem _ this\n    intro m hm\n    rw [← mul_one (coeff m f), ← C_mul_monomial]\n    suffices C (coeff m f) ∈ (Ideal.map C I : Ideal (MvPolynomial σ R)) by exact Ideal.mul_mem_right _ _ this\n    apply Ideal.mem_map_of_mem _\n    exact hf m\n#align mem_map_C_iff mem_map_C_iff\n\n",
 "mem_leading_coeff_nth_zero":
 "theorem mem_leading_coeff_nth_zero (x) : x ∈ I.leading_coeff_nth 0 ↔ C x ∈ I :=\n  (mem_leadingCoeffNth _ _ _).trans\n    ⟨fun ⟨p, hpI, hpdeg, hpx⟩ => by\n      rwa [← hpx, Polynomial.leadingCoeff, nat.eq_zero_of_le_zero (nat_degree_le_of_degree_le hpdeg), ←\n        eq_C_of_degree_le_zero hpdeg],\n      fun hx => ⟨C x, hx, degree_C_le, leadingCoeff_C x⟩⟩\n#align mem_leading_coeff_nth_zero mem_leading_coeff_nth_zero\n\n",
 "mem_leading_coeff_nth":
 "theorem mem_leading_coeff_nth (n : ℕ) (x) : x ∈ I.leading_coeff_nth n ↔ ∃ p ∈ I, degree p ≤ n ∧ p.leading_coeff = x :=\n  by\n  simp only [leading_coeff_nth, degree_le, Submodule.mem_map, lcoeff_apply, Submodule.mem_inf, mem_degree_le]\n  constructor\n  · rintro ⟨p, ⟨hpdeg, hpI⟩, rfl⟩\n    cases' lt_or_eq_of_le hpdeg with hpdeg hpdeg\n    · refine' ⟨0, I.zero_mem, bot_le, _⟩\n      rw [leading_coeff_zero, eq_comm]\n      exact coeff_eq_zero_of_degree_lt hpdeg\n    · refine' ⟨p, hpI, le_of_eq hpdeg, _⟩\n      rw [Polynomial.leadingCoeff, nat_degree, hpdeg]\n      rfl\n  · rintro ⟨p, hpI, hpdeg, rfl⟩\n    have : nat_degree p + (n - nat_degree p) = n := add_tsub_cancel_of_le (nat_degree_le_of_degree_le hpdeg)\n    refine' ⟨p * X ^ (n - nat_degree p), ⟨_, I.mul_mem_right _ hpI⟩, _⟩\n    · apply le_trans (degree_mul_le _ _) _\n      apply le_trans (add_le_add degree_le_nat_degree (degree_X_pow_le _)) _\n      rw [← WithBot.coe_add, this]\n      exact le_rfl\n    · rw [Polynomial.leadingCoeff, ← coeff_mul_X_pow p (n - nat_degree p), this]\n#align mem_leading_coeff_nth mem_leading_coeff_nth\n\n",
 "mem_leading_coeff":
 "theorem mem_leading_coeff (x) : x ∈ I.leading_coeff ↔ ∃ p ∈ I, Polynomial.leadingCoeff p = x :=\n  by\n  rw [leading_coeff, Submodule.mem_supᵢ_of_directed]\n  simp only [mem_leading_coeff_nth]\n  · constructor\n    · rintro ⟨i, p, hpI, hpdeg, rfl⟩\n      exact ⟨p, hpI, rfl⟩\n    rintro ⟨p, hpI, rfl⟩\n    exact ⟨nat_degree p, p, hpI, degree_le_nat_degree, rfl⟩\n  intro i j;\n  exact ⟨i + j, I.leading_coeff_nth_mono (nat.le_add_right _ _), I.leading_coeff_nth_mono (nat.le_add_left _ _)⟩\n#align mem_leading_coeff mem_leading_coeff\n\n",
 "mem_ker_mod_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_ker_mod_by_monic (hq : q.monic) {p : polynomial R} : p ∈ (modByMonicHom q).ker ↔ q ∣ p :=\n  LinearMap.mem_ker.trans (dvd_iff_modByMonic_eq_zero hq)\n#align mem_ker_mod_by_monic mem_ker_mod_by_monic\n\n",
 "mem_ideal_of_coeff_mem_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself,\nmultivariate version. -/\ntheorem mem_ideal_of_coeff_mem_ideal (I : Ideal (MvPolynomial σ R)) (p : MvPolynomial σ R)\n    (hcoe : ∀ m : «expr →₀ » σ ℕ, p.coeff m ∈ I.comap (C : «expr →+* » R (MvPolynomial σ R))) : p ∈ I :=\n  by\n  rw [as_sum p]\n  suffices ∀ m ∈ p.support, monomial m (MvPolynomial.coeff m p) ∈ I by exact Submodule.sum_mem I this\n  intro m hm\n  rw [← mul_one (coeff m p), ← C_mul_monomial]\n  suffices C (coeff m p) ∈ I by exact I.mul_mem_right (monomial m 1) this\n  simpa [Ideal.mem_comap] using hcoe m\n#align mem_ideal_of_coeff_mem_ideal mem_ideal_of_coeff_mem_ideal\n\n",
 "mem_frange_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_frange_iff {p : polynomial R} {c : R} : c ∈ p.frange ↔ ∃ n ∈ p.support, c = p.coeff n := by\n  simp [frange, eq_comm]\n#align mem_frange_iff mem_frange_iff\n\n",
 "mem_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_degree_lt {n : ℕ} {f : polynomial R} : f ∈ degreeLT R n ↔ degree f < n :=\n  by\n  simp_rw [degree_lt, Submodule.mem_infᵢ, LinearMap.mem_ker, degree, Finset.max_eq_sup_coe,\n    Finset.sup_lt_iff (WithBot.bot_lt_coe n), mem_support_iff, WithBot.coe_lt_coe, lt_iff_not_le, ne, not_imp_not]\n  rfl\n#align mem_degree_lt mem_degree_lt\n\n",
 "mem_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2019 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem mem_degree_le {n : WithBot ℕ} {f : polynomial R} : f ∈ degreeLE R n ↔ degree f ≤ n := by\n  simp only [degree_le, Submodule.mem_infᵢ, degree_le_iff_coeff_zero, LinearMap.mem_ker] <;> rfl\n#align mem_degree_le mem_degree_le\n\n",
 "map_to_subring":
 "@[simp]\ntheorem map_to_subring : (p.to_subring T hp).map (Subring.subtype T) = p :=\n  by\n  ext n\n  simp [coeff_map]\n#align map_to_subring map_to_subring\n\n",
 "map_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem map_restriction {R : Type u} [CommRing R] (p : polynomial R) : p.restriction.map (algebraMap _ _) = p :=\n  ext fun n => by rw [coeff_map, Algebra.algebraMap_ofSubring_apply, coeff_restriction]\n#align map_restriction map_restriction\n\n",
 "map_mv_polynomial_eq_eval₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_mv_polynomial_eq_eval₂ {S : Type _} [CommRing S] [Finite σ] (ϕ : «expr →+* » (MvPolynomial σ R) S)\n    (p : MvPolynomial σ R) : ϕ p = MvPolynomial.eval₂ (ϕ.comp MvPolynomial.C) (fun s => ϕ (MvPolynomial.X s)) p :=\n  by\n  cases nonempty_fintype σ\n  refine' trans (congr_arg ϕ (MvPolynomial.as_sum p)) _\n  rw [MvPolynomial.eval₂_eq', ϕ.map_sum]\n  congr\n  ext\n  simp only [monomial_eq, ϕ.map_pow, ϕ.map_prod, ϕ.comp_apply, ϕ.map_mul, Finsupp.prod_pow]\n#align map_mv_polynomial_eq_eval₂ map_mv_polynomial_eq_eval₂\n\n",
 "linear_independent_powers_iff_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem linear_independent_powers_iff_aeval (f : «expr →ₗ[ ] » M R M) (v : M) :\n    (LinearIndependent R fun n : ℕ => (f ^ n) v) ↔ ∀ p : polynomial R, aeval f p v = 0 → p = 0 :=\n  by\n  rw [linearIndependent_iff]\n  simp only [Finsupp.total_apply, aeval_endomorphism, forall_iff_forall_finsupp, Sum, support, coeff,\n    of_finsupp_eq_zero]\n  exact iff.rfl\n#align linear_independent_powers_iff_aeval linear_independent_powers_iff_aeval\n\n",
 "leading_coeff_nth_mono":
 "theorem leading_coeff_nth_mono {m n : ℕ} (H : m ≤ n) : I.leading_coeff_nth m ≤ I.leading_coeff_nth n :=\n  by\n  intro r hr\n  simp only [SetLike.mem_coe, mem_leading_coeff_nth] at hr⊢\n  rcases hr with ⟨p, hpI, hpdeg, rfl⟩\n  refine' ⟨p * X ^ (n - m), I.mul_mem_right _ hpI, _, leading_coeff_mul_X_pow⟩\n  refine' le_trans (degree_mul_le _ _) _\n  refine' le_trans (add_le_add hpdeg (degree_X_pow_le _)) _\n  rw [← WithBot.coe_add, add_tsub_cancel_of_le H]\n  exact le_rfl\n#align leading_coeff_nth_mono leading_coeff_nth_mono\n\n",
 "ker_mod_by_monic_hom":
 "@[simp]\ntheorem ker_mod_by_monic_hom (hq : q.monic) : (Polynomial.modByMonicHom q).ker = (Ideal.span {q}).restrict_scalars R :=\n  Submodule.ext fun f => (mem_ker_mod_by_monic hq).trans Ideal.mem_span_singleton.symm\n#align ker_mod_by_monic_hom ker_mod_by_monic_hom\n\n",
 "ker_map_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print Polynomial.ker_mapRingHom /-\ntheorem Polynomial.ker_mapRingHom (f : «expr →+* » R S) :\n    (Polynomial.mapRingHom f).ker = f.ker.map (C : «expr →+* » R (polynomial R)) :=\n  by\n  ext\n  rw [mem_map_C_iff, RingHom.mem_ker, Polynomial.ext_iff]\n  simp_rw [coe_map_ring_hom, coeff_map, coeff_zero, RingHom.mem_ker]\n#align polynomial.ker_map_ring_hom Polynomial.ker_mapRingHom\n-/\n\n",
 "ker_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ker_map (f : «expr →+* » R S) :\n    (map f : «expr →+* » (MvPolynomial σ R) (MvPolynomial σ S)).ker =\n      f.ker.map (C : «expr →+* » R (MvPolynomial σ R)) :=\n  by\n  ext\n  rw [MvPolynomial.mem_map_C_iff, RingHom.mem_ker, MvPolynomial.ext_iff]\n  simp_rw [coeff_map, coeff_zero, RingHom.mem_ker]\n#align ker_map ker_map\n\n",
 "is_prime_map_C_of_is_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem is_prime_map_C_of_is_prime {P : Ideal R} (H : IsPrime P) :\n    IsPrime (map (C : «expr →+* » R (polynomial R)) P : Ideal (polynomial R)) :=\n  (isPrime_map_C_iff_isPrime P).mpr H\n#align is_prime_map_C_of_is_prime is_prime_map_C_of_is_prime\n\n",
 "is_prime_map_C_iff_is_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem is_prime_map_C_iff_is_prime (P : Ideal R) :\n    IsPrime (map (C : «expr →+* » R (polynomial R)) P : Ideal (polynomial R)) ↔ IsPrime P :=\n  by\n  -- Porting note: the following proof avoids quotient rings\n  -- It can be golfed substantially by using something like\n  -- `(quotient.is_domain_iff_prime (map C P : ideal R[X]))`\n  constructor\n  · intro H\n    have := @comap_is_prime R (polynomial R) («expr →+* » R (polynomial R)) _ _ _ C (map C P) H\n    convert this using 1\n    ext x\n    simp only [mem_comap, mem_map_C_iff]\n    constructor\n    · rintro h (- | n)\n      · simpa only [coeff_C_zero] using h\n      · simp only [coeff_C_ne_zero (nat.succ_ne_zero _), Submodule.zero_mem]\n    · intro h\n      simpa only [coeff_C_zero] using h 0\n  · intro h\n    constructor\n    · rw [ne.def, eq_top_iff_one, mem_map_C_iff, not_forall]\n      use 0\n      rw [coeff_one_zero, ← eq_top_iff_one]\n      exact h.1\n    · intro f g\n      simp only [mem_map_C_iff]\n      contrapose!\n      rintro ⟨hf, hg⟩\n      classical\n        let m := nat.find hf\n        let n := nat.find hg\n        refine' ⟨m + n, _⟩\n        rw [coeff_mul, ← Finset.insert_erase ((@Finset.Nat.mem_antidiagonal _ (m, n)).mpr rfl),\n          Finset.sum_insert (Finset.not_mem_erase _ _), (P.add_mem_iff_left _).not]\n        · apply mt h.2\n          rw [not_or]\n          exact ⟨nat.find_spec hf, nat.find_spec hg⟩\n        apply P.sum_mem\n        rintro ⟨i, j⟩ hij\n        rw [Finset.mem_erase, Finset.Nat.mem_antidiagonal] at hij\n        simp only [ne.def, Prod.mk.inj_iff, not_and_or] at hij\n        obtain hi | hj : i < m ∨ j < n :=\n          by\n          rw [or_iff_not_imp_left, not_lt, le_iff_lt_or_eq]\n          rintro (hmi | rfl)\n          · rw [← not_le]\n            intro hnj\n            exact (add_lt_add_of_lt_of_le hmi hnj).ne hij.2.symm\n          · simpa only [eq_self_iff_true, not_true, false_or_iff, add_right_inj, not_and_self_iff] using hij\n        · rw [mul_comm]\n          apply P.mul_mem_left\n          exact Classical.not_not.1 (nat.find_min hf hi)\n        · apply P.mul_mem_left\n          exact Classical.not_not.1 (nat.find_min hg hj)\n#align is_prime_map_C_iff_is_prime is_prime_map_C_iff_is_prime\n\n",
 "is_noetherian_ring_fin_0":
 "theorem is_noetherian_ring_fin_0 [IsNoetherianRing R] : IsNoetherianRing (MvPolynomial (Fin 0) R) :=\n  isNoetherianRing_of_ringEquiv R\n    ((MvPolynomial.isEmptyRingEquiv R PEmpty).symm.trans (renameEquiv R finZeroEquiv'.symm).to_ring_equiv)\n#align is_noetherian_ring_fin_0 is_noetherian_ring_fin_0\n\n",
 "is_noetherian_ring_fin":
 "theorem is_noetherian_ring_fin [IsNoetherianRing R] : ∀ {n : ℕ}, IsNoetherianRing (MvPolynomial (Fin n) R)\n  | 0 => isNoetherianRing_fin_0\n  | n + 1 =>\n    @isNoetherianRing_of_ringEquiv (Polynomial (MvPolynomial (Fin n) R)) _ _ _\n      (MvPolynomial.finSuccEquiv _ n).to_ring_equiv.symm\n      (@Polynomial.isNoetherianRing (MvPolynomial (Fin n) R) _ is_noetherian_ring_fin)\n#align is_noetherian_ring_fin is_noetherian_ring_fin\n\n",
 "is_fg_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_fg_degree_le [IsNoetherianRing R] (I : Ideal (polynomial R)) (n : ℕ) : Submodule.Fg (I.degree_le n) :=\n  isNoetherian_submodule_left.1 (isNoetherian_of_fg_of_noetherian _ ⟨_, degreeLE_eq_span_X_pow.symm⟩) _\n#align is_fg_degree_le is_fg_degree_le\n\n",
 "isNoetherianRing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print Polynomial.isNoetherianRing /-\n/-- Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. -/\nprotected theorem Polynomial.isNoetherianRing [IsNoetherianRing R] : IsNoetherianRing (polynomial R) :=\n  isNoetherianRing_iff.2\n    ⟨fun I : Ideal (polynomial R) =>\n      let M :=\n        WellFounded.min (isNoetherian_iff_wellFounded.1 (by infer_instance)) (Set.range I.leading_coeff_nth)\n          ⟨_, ⟨0, rfl⟩⟩\n      have hm : M ∈ Set.range I.leading_coeff_nth := WellFounded.min_mem _ _ _\n      let ⟨N, HN⟩ := hm\n      let ⟨s, hs⟩ := I.is_fg_degree_le N\n      have hm2 : ∀ k, I.leading_coeff_nth k ≤ M := fun k =>\n        or.cases_on (le_or_lt k N) (fun h => HN ▸ I.leading_coeff_nth_mono h) fun h x hx =>\n          by_contradiction fun hxm =>\n            have : ¬M < I.leading_coeff_nth k := by\n              refine' WellFounded.not_lt_min (wellFounded_submodule_gt _ _) _ _ _ <;> exact ⟨k, rfl⟩\n            this ⟨HN ▸ I.leading_coeff_nth_mono (le_of_lt h), fun H => hxm (H hx)⟩\n      have hs2 : ∀ {x}, x ∈ I.degree_le N → x ∈ Ideal.span (↑s : Set (polynomial R)) :=\n        hs ▸ fun x hx =>\n          Submodule.span_induction hx (fun _ hx => Ideal.subset_span hx) (Ideal.zero_mem _) (fun _ _ => Ideal.add_mem _)\n            fun c f hf => f.C_mul' c ▸ Ideal.mul_mem_left _ _ hf\n      ⟨s,\n        le_antisymm\n            (Ideal.span_le.2 fun x hx =>\n              have : x ∈ I.degree_le N := hs ▸ Submodule.subset_span hx\n              this.2) <|\n          by\n          have : Submodule.span (polynomial R) ↑s = Ideal.span ↑s := by rfl\n          rw [this]\n          intro p hp\n          generalize hn : p.nat_degree = k\n          induction' k using nat.strong_induction_on with k ih generalizing p\n          cases le_or_lt k N\n          · subst k\n            refine'\n              hs2 ⟨Polynomial.mem_degreeLE.2 (le_trans Polynomial.degree_le_natDegree <| WithBot.coe_le_coe.2 h), hp⟩\n          · have hp0 : p ≠ 0 := by\n              rintro rfl\n              cases hn\n              exact nat.not_lt_zero _ h\n            have : (0 : R) ≠ 1 := by\n              intro h\n              apply hp0\n              ext i\n              refine' (mul_one _).symm.trans _\n              rw [← h, MulZeroClass.mul_zero]\n              rfl\n            haveI : Nontrivial R := ⟨⟨0, 1, this⟩⟩\n            have : p.leading_coeff ∈ I.leading_coeff_nth N := by\n              rw [HN]\n              exact hm2 k ((I.mem_leading_coeff_nth _ _).2 ⟨_, hp, hn ▸ Polynomial.degree_le_natDegree, rfl⟩)\n            rw [I.mem_leading_coeff_nth] at this\n            rcases this with ⟨q, hq, hdq, hlqp⟩\n            have hq0 : q ≠ 0 := by\n              intro H\n              rw [← Polynomial.leadingCoeff_eq_zero] at H\n              rw [hlqp, Polynomial.leadingCoeff_eq_zero] at H\n              exact hp0 H\n            have h1 : p.degree = (q * Polynomial.X ^ (k - q.nat_degree)).degree :=\n              by\n              rw [Polynomial.degree_mul', Polynomial.degree_X_pow]\n              rw [Polynomial.degree_eq_natDegree hp0, Polynomial.degree_eq_natDegree hq0]\n              rw [← WithBot.coe_add, add_tsub_cancel_of_le, hn]\n              · refine' le_trans (Polynomial.natDegree_le_of_degree_le hdq) (le_of_lt h)\n              rw [Polynomial.leadingCoeff_X_pow, mul_one]\n              exact mt Polynomial.leadingCoeff_eq_zero.1 hq0\n            have h2 : p.leading_coeff = (q * Polynomial.X ^ (k - q.nat_degree)).leading_coeff := by\n              rw [← hlqp, Polynomial.leadingCoeff_mul_X_pow]\n            have := Polynomial.degree_sub_lt h1 hp0 h2\n            rw [Polynomial.degree_eq_natDegree hp0] at this\n            rw [← sub_add_cancel p (q * Polynomial.X ^ (k - q.nat_degree))]\n            refine' (Ideal.span ↑s).add_mem _ ((Ideal.span ↑s).mul_mem_right _ _)\n            · by_cases hpq : p - q * Polynomial.X ^ (k - q.nat_degree) = 0\n              · rw [hpq]\n                exact Ideal.zero_mem _\n              refine' ih _ _ (I.sub_mem hp (I.mul_mem_right _ hq)) rfl\n              rwa [Polynomial.degree_eq_natDegree hpq, WithBot.coe_lt_coe, hn] at this\n            exact hs2 ⟨Polynomial.mem_degreeLE.2 hdq, hq⟩⟩⟩\n#align polynomial.is_noetherian_ring Polynomial.isNoetherianRing\n-/\n\n",
 "geom_sum_X_comp_X_add_one_eq_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem geom_sum_X_comp_X_add_one_eq_sum (n : ℕ) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n            ((X : polynomial R) ^ i)).comp\n        (X + 1) =\n      (Finset.range n).sum fun i : ℕ => (n.choose (i + 1) : polynomial R) * X ^ i :=\n  by\n  ext i\n  trans (n.choose (i + 1) : R); swap\n  · simp only [finset_sum_coeff, ← C_eq_nat_cast, coeff_C_mul_X_pow]\n    rw [Finset.sum_eq_single i, if_pos rfl]\n    · simp (config := { contextual := true }) only [@eq_comm _ i, if_false, eq_self_iff_true, imp_true_iff]\n    ·\n      simp (config := { contextual := true }) only [Nat.lt_add_one_iff, Nat.choose_eq_zero_of_lt, Nat.cast_zero,\n        Finset.mem_range, not_lt, eq_self_iff_true, if_true, imp_true_iff]\n  induction' n with n ih generalizing i\n  · simp only [geom_sum_zero, zero_comp, coeff_zero, Nat.choose_zero_succ, Nat.cast_zero]\n  simp only [geom_sum_succ', ih, add_comp, X_pow_comp, coeff_add, Nat.choose_succ_succ, Nat.cast_add,\n    coeff_X_add_one_pow]\n#align geom_sum_X_comp_X_add_one_eq_sum geom_sum_X_comp_X_add_one_eq_sum\n\n",
 "geom_sum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem monic.geom_sum' {P : polynomial R} (hP : P.monic) (hdeg : 0 < P.degree) {n : ℕ} (hn : n ≠ 0) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n        (P ^ i)).monic :=\n  hP.geom_sum (natDegree_pos_iff_degree_pos.2 hdeg) hn\n#align monic.geom_sum' monic.geom_sum'\n\n",
 "geom_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem monic.geom_sum {P : polynomial R} (hP : P.monic) (hdeg : 0 < P.nat_degree) {n : ℕ} (hn : n ≠ 0) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n        (P ^ i)).monic :=\n  by\n  nontriviality R\n  cases n; · exact (hn rfl).elim\n  rw [geom_sum_succ']\n  refine' (hP.pow _).add_of_left _\n  refine' lt_of_le_of_lt (degree_sum_le _ _) _\n  rw [Finset.sup_lt_iff]\n  · simp only [Finset.mem_range, degree_eq_nat_degree (hP.pow _).ne_zero, WithBot.coe_lt_coe, hP.nat_degree_pow]\n    intro k\n    exact nsmul_lt_nsmul hdeg\n  · rw [bot_lt_iff_ne_bot, ne.def, degree_eq_bot]\n    exact (hP.pow _).ne_zero\n#align monic.geom_sum monic.geom_sum\n\n",
 "frange_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem frange_zero : frange (0 : polynomial R) = ∅ :=\n  rfl\n#align frange_zero frange_zero\n\n",
 "frange_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem frange_one : frange (1 : polynomial R) ⊆ {1} :=\n  by\n  simp [frange, Finset.image_subset_iff]\n  simp only [← C_1, coeff_C]\n  intro n hn\n  simp only [exists_prop, ite_eq_right_iff, not_forall] at hn\n  simp [hn]\n#align frange_one frange_one\n\n",
 "frange_of_subring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem frange_of_subring {p : polynomial T} : (↑(p.of_subring T).frange : Set R) ⊆ T :=\n  by\n  intro i hi\n  simp only [frange, Set.mem_image, mem_support_iff, ne.def, Finset.mem_coe, Finset.coe_image] at hi\n  rcases hi with ⟨n, hn, h'n⟩\n  rw [← h'n, coeff_of_subring]\n  exact Subtype.mem (coeff p n : T)\n#align frange_of_subring frange_of_subring\n\n",
 "exists_irreducible_of_nat_degree_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_irreducible_of_nat_degree_pos {R : Type u} [CommRing R] [IsDomain R] [WfDvdMonoid R] {f : polynomial R}\n    (hf : 0 < f.nat_degree) : ∃ g, Irreducible g ∧ g ∣ f :=\n  exists_irreducible_of_degree_pos <| by\n    contrapose! hf\n    exact nat_degree_le_of_degree_le hf\n#align exists_irreducible_of_nat_degree_pos exists_irreducible_of_nat_degree_pos\n\n",
 "exists_irreducible_of_nat_degree_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_irreducible_of_nat_degree_ne_zero {R : Type u} [CommRing R] [IsDomain R] [WfDvdMonoid R]\n    {f : polynomial R} (hf : f.nat_degree ≠ 0) : ∃ g, Irreducible g ∧ g ∣ f :=\n  exists_irreducible_of_natDegree_pos <| nat.pos_of_ne_zero hf\n#align exists_irreducible_of_nat_degree_ne_zero exists_irreducible_of_nat_degree_ne_zero\n\n",
 "exists_irreducible_of_degree_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_irreducible_of_degree_pos {R : Type u} [CommRing R] [IsDomain R] [WfDvdMonoid R] {f : polynomial R}\n    (hf : 0 < f.degree) : ∃ g, Irreducible g ∧ g ∣ f :=\n  WfDvdMonoid.exists_irreducible_factor (fun huf => ne_of_gt hf <| degree_eq_zero_of_isUnit huf) fun hf0 =>\n    not_lt_of_lt hf <| hf0.symm ▸ (@degree_zero R _).symm ▸ WithBot.bot_lt_coe _\n#align exists_irreducible_of_degree_pos exists_irreducible_of_degree_pos\n\n",
 "eval₂_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_restriction {p : polynomial R} :\n    eval₂ f x p = eval₂ (f.comp (Subring.subtype (Subring.closure (p.frange : Set R)))) x p.restriction :=\n  by\n  simp only [eval₂_eq_sum, Sum, support_restriction, ← @coeff_restriction _ _ p]\n  rfl\n#align eval₂_restriction eval₂_restriction\n\n",
 "eval_eq_sum_degree_lt_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem eval_eq_sum_degree_lt_equiv {n : ℕ} {p : polynomial R} (hp : p ∈ degreeLT R n) (x : R) :\n    p.eval x =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (degreeLTEquiv _ _ ⟨p, hp⟩ i * x ^ (i : ℕ)) :=\n  by\n  simp_rw [eval_eq_sum]\n  exact (sum_fin _ (by simp_rw [MulZeroClass.zero_mul, forall_const]) (mem_degree_lt.mp hp)).symm\n#align eval_eq_sum_degree_lt_equiv eval_eq_sum_degree_lt_equiv\n\n",
 "eq_zero_of_constant_mem_of_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The only constant in a maximal ideal over a field is `0`. -/\ntheorem eq_zero_of_constant_mem_of_maximal (hR : IsField R) (I : Ideal (polynomial R)) [hI : I.is_maximal] (x : R)\n    (hx : C x ∈ I) : x = 0 :=\n  by\n  refine' by_contradiction fun hx0 => hI.ne_top ((eq_top_iff_one I).2 _)\n  obtain ⟨y, hy⟩ := hR.mul_inv_cancel hx0\n  convert I.mul_mem_left (C y) hx\n  rw [← C.map_mul, hR.mul_comm y x, hy, RingHom.map_one]\n#align eq_zero_of_constant_mem_of_maximal eq_zero_of_constant_mem_of_maximal\n\n",
 "disjoint_ker_aeval_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem disjoint_ker_aeval_of_coprime (f : «expr →ₗ[ ] » M R M) {p q : polynomial R} (hpq : IsCoprime p q) :\n    Disjoint (aeval f p).ker (aeval f q).ker :=\n  by\n  rw [disjoint_iff_inf_le]\n  intro v hv\n  rcases hpq with ⟨p', q', hpq'⟩\n  simpa [LinearMap.mem_ker.1 (Submodule.mem_inf.1 hv).1, LinearMap.mem_ker.1 (Submodule.mem_inf.1 hv).2] using\n    congr_arg (fun p : polynomial R => aeval f p v) hpq'.symm\n#align disjoint_ker_aeval_of_coprime disjoint_ker_aeval_of_coprime\n\n",
 "degree_to_subring":
 "@[simp]\ntheorem degree_to_subring : (toSubring p T hp).degree = p.degree := by simp [degree]\n#align degree_to_subring degree_to_subring\n\n",
 "degree_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem degree_restriction {p : polynomial R} : (restriction p).degree = p.degree := by simp [degree]\n#align degree_restriction degree_restriction\n\n",
 "degree_lt_mono":
 "@[mono]\ntheorem degree_lt_mono {m n : ℕ} (H : m ≤ n) : degreeLT R m ≤ degreeLT R n := fun f hf =>\n  mem_degreeLT.2 (lt_of_lt_of_le (mem_degreeLT.1 hf) <| WithBot.coe_le_coe.2 H)\n#align degree_lt_mono degree_lt_mono\n\n",
 "degree_lt_equiv_eq_zero_iff_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem degree_lt_equiv_eq_zero_iff_eq_zero {n : ℕ} {p : polynomial R} (hp : p ∈ degreeLT R n) :\n    degreeLTEquiv _ _ ⟨p, hp⟩ = 0 ↔ p = 0 := by rw [LinearEquiv.map_eq_zero_iff, Submodule.mk_eq_zero]\n#align degree_lt_equiv_eq_zero_iff_eq_zero degree_lt_equiv_eq_zero_iff_eq_zero\n\n",
 "degree_lt_eq_span_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_lt_eq_span_X_pow {n : ℕ} :\n    degreeLT R n = Submodule.span R ↑((Finset.range n).image fun n => X ^ n : Finset (polynomial R)) :=\n  by\n  apply le_antisymm\n  · intro p hp\n    replace hp := mem_degree_lt.1 hp\n    rw [← Polynomial.sum_monomial_eq p, Polynomial.sum]\n    refine' Submodule.sum_mem _ fun k hk => _\n    show monomial _ _ ∈ _\n    have := WithBot.coe_lt_coe.1 ((Finset.sup_lt_iff <| WithBot.bot_lt_coe n).1 hp k hk)\n    rw [← C_mul_X_pow_eq_monomial, C_mul']\n    refine'\n      Submodule.smul_mem _ _\n        (Submodule.subset_span <| Finset.mem_coe.2 <| Finset.mem_image.2 ⟨_, Finset.mem_range.2 this, rfl⟩)\n  rw [Submodule.span_le, Finset.coe_image, Set.image_subset_iff]\n  intro k hk; apply mem_degree_lt.2\n  exact lt_of_le_of_lt (degree_X_pow_le _) (WithBot.coe_lt_coe.2 <| Finset.mem_range.1 hk)\n#align degree_lt_eq_span_X_pow degree_lt_eq_span_X_pow\n\n",
 "degree_le_mono":
 "@[mono]\ntheorem degree_le_mono {m n : WithBot ℕ} (H : m ≤ n) : degreeLE R m ≤ degreeLE R n := fun f hf =>\n  mem_degreeLE.2 (le_trans (mem_degreeLE.1 hf) H)\n#align degree_le_mono degree_le_mono\n\n",
 "degree_le_eq_span_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_le_eq_span_X_pow {n : ℕ} :\n    degreeLE R n = Submodule.span R ↑((Finset.range (n + 1)).image fun n => (X : polynomial R) ^ n) :=\n  by\n  apply le_antisymm\n  · intro p hp\n    replace hp := mem_degree_le.1 hp\n    rw [← Polynomial.sum_monomial_eq p, Polynomial.sum]\n    refine' Submodule.sum_mem _ fun k hk => _\n    show monomial _ _ ∈ _\n    have := WithBot.coe_le_coe.1 (Finset.sup_le_iff.1 hp k hk)\n    rw [← C_mul_X_pow_eq_monomial, C_mul']\n    refine'\n      Submodule.smul_mem _ _\n        (Submodule.subset_span <|\n          Finset.mem_coe.2 <| Finset.mem_image.2 ⟨_, Finset.mem_range.2 (nat.lt_succ_of_le this), rfl⟩)\n  rw [Submodule.span_le, Finset.coe_image, Set.image_subset_iff]\n  intro k hk; apply mem_degree_le.2\n  exact (degree_X_pow_le _).trans (WithBot.coe_le_coe.2 <| nat.le_of_lt_succ <| Finset.mem_range.1 hk)\n#align degree_le_eq_span_X_pow degree_le_eq_span_X_pow\n\n",
 "coeff_to_subring'":
 "@[simp]\ntheorem coeff_to_subring' {n : ℕ} : (coeff (toSubring p T hp) n).1 = coeff p n :=\n  coeff_toSubring _ _ hp\n#align coeff_to_subring' coeff_to_subring'\n\n",
 "coeff_to_subring":
 "@[simp]\ntheorem coeff_to_subring {n : ℕ} : ↑(coeff (toSubring p T hp) n) = coeff p n :=\n  by\n  simp only [to_subring, coeff_monomial, finset_sum_coeff, mem_support_iff, Finset.sum_ite_eq', ne.def, ite_not]\n  split_ifs\n  · rw [h]\n    rfl\n  · rfl\n#align coeff_to_subring coeff_to_subring\n\n",
 "coeff_restriction'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coeff_restriction' {p : polynomial R} {n : ℕ} : (coeff (restriction p) n).1 = coeff p n :=\n  coeff_restriction\n#align coeff_restriction' coeff_restriction'\n\n",
 "coeff_restriction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coeff_restriction {p : polynomial R} {n : ℕ} : ↑(coeff (restriction p) n) = coeff p n :=\n  by\n  simp only [restriction, coeff_monomial, finset_sum_coeff, mem_support_iff, Finset.sum_ite_eq', ne.def, ite_not]\n  split_ifs\n  · rw [h]\n    rfl\n  · rfl\n#align coeff_restriction coeff_restriction\n\n",
 "coeff_prod_mem_ideal_pow_tsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print Polynomial.coeff_prod_mem_ideal_pow_tsub /-\n/-- If `I` is an ideal, and `pᵢ` is a finite family of polynomials each satisfying\n`∀ k, (pᵢ)ₖ ∈ Iⁿⁱ⁻ᵏ` for some `nᵢ`, then `p = ∏ pᵢ` also satisfies `∀ k, pₖ ∈ Iⁿ⁻ᵏ` with `n = ∑ nᵢ`.\n-/\ntheorem Polynomial.coeff_prod_mem_ideal_pow_tsub {ι : Type _} (s : Finset ι) (f : ι → polynomial R) (I : Ideal R)\n    (n : ι → ℕ) (h : ∀ i ∈ s, ∀ (k), (f i).coeff k ∈ I ^ (n i - k)) (k : ℕ) : (s.prod f).coeff k ∈ I ^ (s.sum n - k) :=\n  by\n  classical\n    induction' s using Finset.induction with a s ha hs generalizing k\n    · rw [sum_empty, prod_empty, coeff_one, zero_tsub, pow_zero, Ideal.one_eq_top]\n      exact Submodule.mem_top\n    · rw [sum_insert ha, prod_insert ha, coeff_mul]\n      apply sum_mem\n      rintro ⟨i, j⟩ e\n      obtain rfl : i + j = k := nat.mem_antidiagonal.mp e\n      apply Ideal.pow_le_pow add_tsub_add_le_tsub_add_tsub\n      rw [pow_add]\n      exact\n        Ideal.mul_mem_mul (h _ (finset.mem_insert.mpr <| or.inl rfl) _)\n          (hs (fun i hi k => h _ (finset.mem_insert.mpr <| or.inr hi) _) j)\n#align polynomial.coeff_prod_mem_ideal_pow_tsub Polynomial.coeff_prod_mem_ideal_pow_tsub\n-/\n\n",
 "coeff_of_subring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_of_subring (p : polynomial T) (n : ℕ) : coeff (ofSubring T p) n = (coeff p n : T) :=\n  by\n  simp only [of_subring, coeff_monomial, finset_sum_coeff, mem_support_iff, Finset.sum_ite_eq', ite_eq_right_iff,\n    ne.def, ite_not, Classical.not_not, ite_eq_left_iff]\n  intro h\n  rw [h]\n  rfl\n#align coeff_of_subring coeff_of_subring\n\n",
 "coeff_mem_frange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_mem_frange (p : polynomial R) (n : ℕ) (h : p.coeff n ≠ 0) : p.coeff n ∈ p.frange :=\n  by\n  simp only [frange, exists_prop, mem_support_iff, Finset.mem_image, ne.def]\n  exact ⟨n, h, rfl⟩\n#align coeff_mem_frange coeff_mem_frange\n\n"}