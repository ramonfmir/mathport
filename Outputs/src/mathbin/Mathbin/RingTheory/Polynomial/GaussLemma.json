{"is_unit_or_eq_zero_of_is_unit_integer_normalization_prim_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem is_unit_or_eq_zero_of_is_unit_integer_normalization_prim_part {p : polynomial K} (h0 : p ≠ 0)\n    (h : is_unit (integer_normalization (non_zero_divisors R) p).prim_part) : is_unit p :=\n  by\n  rcases is_unit_iff.1 h with ⟨_, ⟨u, rfl⟩, hu⟩\n  obtain ⟨⟨c, c0⟩, hc⟩ := integer_normalization_map_to_map (non_zero_divisors R) p\n  rw [subtype.coe_mk, algebra.smul_def, algebra_map_apply] at hc\n  apply isUnit_of_mul_isUnit_right\n  rw [← hc, (integer_normalization (non_zero_divisors R) p).eq_C_content_mul_prim_part, ← hu, ← RingHom.map_mul,\n    is_unit_iff]\n  refine'\n    ⟨algebra_map R K ((integer_normalization (non_zero_divisors R) p).content * ↑u), isUnit_iff_ne_zero.2 fun con => _,\n      by simp⟩\n  replace con := (injective_iff_map_eq_zero (algebra_map R K)).1 (is_fraction_ring.injective _ _) _ con\n  rw [mul_eq_zero, content_eq_zero_iff, is_fraction_ring.integer_normalization_eq_zero_iff] at con\n  rcases con with (con | con)\n  · apply h0 con\n  · apply Units.ne_zero _ con\n#align\n  is_unit_or_eq_zero_of_is_unit_integer_normalization_prim_part is_unit_or_eq_zero_of_is_unit_integer_normalization_prim_part\n\n",
 "is_unit_iff_is_unit_map_of_injective":
 "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem is_primitive.is_unit_iff_is_unit_map_of_injective : is_unit f ↔ is_unit (map φ f) :=\n  by\n  refine' ⟨(map_ring_hom φ).is_unit_map, fun h => _⟩\n  rcases is_unit_iff.1 h with ⟨_, ⟨u, rfl⟩, hu⟩\n  have hdeg := degree_C u.ne_zero\n  rw [hu, degree_map_eq_of_injective hinj] at hdeg\n  rw [eq_C_of_degree_eq_zero hdeg] at hf⊢\n  exact is_unit_C.mpr (is_primitive_iff_is_unit_of_C_dvd.mp hf (f.coeff 0) dvd_rfl)\n#align is_primitive.is_unit_iff_is_unit_map_of_injective is_primitive.is_unit_iff_is_unit_map_of_injective\n\n",
 "is_unit_iff_is_unit_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_primitive.is_unit_iff_is_unit_map {p : polynomial R} (hp : p.is_primitive) :\n    is_unit p ↔ is_unit (p.map (algebra_map R K)) :=\n  hp.is_unit_iff_is_unit_map_of_injective (is_fraction_ring.injective _ _)\n#align is_primitive.is_unit_iff_is_unit_map is_primitive.is_unit_iff_is_unit_map\n\n",
 "is_integrally_closed_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Integrally closed domains are precisely the domains for in which Gauss's lemma holds\n    for monic polynomials -/\ntheorem is_integrally_closed_iff' :\n    is_integrally_closed R ↔ ∀ p : polynomial R, p.monic → (Irreducible p ↔ Irreducible (p.map <| algebra_map R K)) :=\n  by\n  constructor\n  · intro hR p hp\n    letI := hR\n    exact monic.irreducible_iff_irreducible_map_fraction_map hp\n  · intro H\n    refine'\n      (is_integrally_closed_iff K).mpr fun x hx => ring_hom.mem_range.mp <| minpoly.mem_range_of_degree_eq_one R x _\n    rw [← monic.degree_map (minpoly.monic hx) (algebra_map R K)]\n    apply degree_eq_one_of_irreducible_of_root ((H _ <| minpoly.monic hx).mp (minpoly.irreducible hx))\n    rw [is_root, eval_map, ← aeval_def, minpoly.aeval R x]\n#align is_integrally_closed_iff' is_integrally_closed_iff'\n\n",
 "irreducible_of_irreducible_map_of_injective":
 "theorem is_primitive.irreducible_of_irreducible_map_of_injective (h_irr : Irreducible (map φ f)) : Irreducible f :=\n  by\n  refine'\n    ⟨fun h => h_irr.not_unit (IsUnit.map (map_ring_hom φ) h), fun a b h =>\n      (h_irr.is_unit_or_is_unit <| by rw [h, polynomial.map_mul]).imp _ _⟩\n  all_goals apply ((is_primitive_of_dvd hf _).is_unit_iff_is_unit_map_of_injective hinj).mpr\n  exacts[Dvd.intro _ h.symm, Dvd.intro_left _ h.symm]\n#align is_primitive.irreducible_of_irreducible_map_of_injective is_primitive.irreducible_of_irreducible_map_of_injective\n\n",
 "irreducible_iff_irreducible_map_fraction_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\n  irreducible in the fraction field. -/\ntheorem is_primitive.irreducible_iff_irreducible_map_fraction_map {p : polynomial R} (hp : p.is_primitive) :\n    Irreducible p ↔ Irreducible (p.map (algebra_map R K)) :=\n  by\n  refine'\n    ⟨fun hi => ⟨fun h => hi.not_unit (hp.is_unit_iff_is_unit_map.2 h), fun a b hab => _⟩,\n      hp.irreducible_of_irreducible_map_of_injective (is_fraction_ring.injective _ _)⟩\n  obtain ⟨⟨c, c0⟩, hc⟩ := integer_normalization_map_to_map (non_zero_divisors R) a\n  obtain ⟨⟨d, d0⟩, hd⟩ := integer_normalization_map_to_map (non_zero_divisors R) b\n  rw [algebra.smul_def, algebra_map_apply, subtype.coe_mk] at hc hd\n  rw [mem_non_zero_divisors_iff_ne_zero] at c0 d0\n  have hcd0 : c * d ≠ 0 := mul_ne_zero c0 d0\n  rw [ne.def, ← C_eq_zero] at hcd0\n  have h1 :\n    C c * C d * p = integer_normalization (non_zero_divisors R) a * integer_normalization (non_zero_divisors R) b :=\n    by\n    apply map_injective (algebra_map R K) (is_fraction_ring.injective _ _) _\n    rw [polynomial.map_mul, polynomial.map_mul, polynomial.map_mul, hc, hd, map_C, map_C, hab]\n    ring\n  obtain ⟨u, hu⟩ :\n    Associated (c * d)\n      (content (integer_normalization (non_zero_divisors R) a) *\n        content (integer_normalization (non_zero_divisors R) b)) :=\n    by\n    rw [← dvd_dvd_iff_associated, ← normalize_eq_normalize_iff, normalize.map_mul, normalize.map_mul, normalize_content,\n      normalize_content, ← mul_one (normalize c * normalize d), ← hp.content_eq_one, ← content_C, ← content_C, ←\n      content_mul, ← content_mul, ← content_mul, h1]\n  rw [← RingHom.map_mul, eq_comm, (integer_normalization (non_zero_divisors R) a).eq_C_content_mul_prim_part,\n    (integer_normalization (non_zero_divisors R) b).eq_C_content_mul_prim_part, mul_assoc, mul_comm _ (C _ * _), ←\n    mul_assoc, ← mul_assoc, ← RingHom.map_mul, ← hu, RingHom.map_mul, mul_assoc, mul_assoc, ← mul_assoc (C ↑u)] at h1\n  have h0 : a ≠ 0 ∧ b ≠ 0 := by\n    classical\n      rw [ne.def, ne.def, ← decidable.not_or_iff_and_not, ← mul_eq_zero, ← hab]\n      intro con\n      apply hp.ne_zero (map_injective (algebra_map R K) (is_fraction_ring.injective _ _) _)\n      simp [con]\n  rcases hi.is_unit_or_is_unit (mul_left_cancel₀ hcd0 h1).symm with (h | h)\n  · right\n    apply is_unit_or_eq_zero_of_is_unit_integer_normalization_prim_part h0.2 (isUnit_of_mul_isUnit_right h)\n  · left\n    apply is_unit_or_eq_zero_of_is_unit_integer_normalization_prim_part h0.1 h\n#align\n  is_primitive.irreducible_iff_irreducible_map_fraction_map is_primitive.irreducible_iff_irreducible_map_fraction_map\n\n",
 "irreducible_iff_irreducible_map_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\n  irreducible over `ℚ`. -/\ntheorem is_primitive.int.irreducible_iff_irreducible_map_cast {p : polynomial ℤ} (hp : p.is_primitive) :\n    Irreducible p ↔ Irreducible (p.map (Int.castRingHom (exprℚ))) :=\n  hp.irreducible_iff_irreducible_map_fraction_map\n#align is_primitive.int.irreducible_iff_irreducible_map_cast is_primitive.int.irreducible_iff_irreducible_map_cast\n\n",
 "dvd_of_fraction_map_dvd_fraction_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_primitive.dvd_of_fraction_map_dvd_fraction_map {p q : polynomial R} (hp : p.is_primitive)\n    (hq : q.is_primitive) (h_dvd : p.map (algebra_map R K) ∣ q.map (algebra_map R K)) : p ∣ q :=\n  by\n  rcases h_dvd with ⟨r, hr⟩\n  obtain ⟨⟨s, s0⟩, hs⟩ := integer_normalization_map_to_map (non_zero_divisors R) r\n  rw [subtype.coe_mk, algebra.smul_def, algebra_map_apply] at hs\n  have h : p ∣ q * C s := by\n    use integer_normalization (non_zero_divisors R) r\n    apply map_injective (algebra_map R K) (is_fraction_ring.injective _ _)\n    rw [polynomial.map_mul, polynomial.map_mul, hs, hr, mul_assoc, mul_comm r]\n    simp\n  rw [← hp.dvd_prim_part_iff_dvd, prim_part_mul, hq.prim_part_eq, Associated.dvd_iff_dvd_right] at h\n  · exact h\n  · symm\n    rcases is_unit_prim_part_C s with ⟨u, hu⟩\n    use u\n    rw [hu]\n  iterate 2 \n    apply mul_ne_zero hq.ne_zero\n    rw [ne.def, C_eq_zero]\n    contrapose! s0\n    simp [s0, mem_non_zero_divisors_iff_ne_zero]\n#align is_primitive.dvd_of_fraction_map_dvd_fraction_map is_primitive.dvd_of_fraction_map_dvd_fraction_map\n\n",
 "dvd_iff_map_cast_dvd_map_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem is_primitive.int.dvd_iff_map_cast_dvd_map_cast (p q : polynomial ℤ) (hp : p.is_primitive)\n    (hq : q.is_primitive) : p ∣ q ↔ p.map (Int.castRingHom (exprℚ)) ∣ q.map (Int.castRingHom (exprℚ)) :=\n  hp.dvd_iff_fraction_map_dvd_fraction_map (exprℚ) hq\n#align is_primitive.int.dvd_iff_map_cast_dvd_map_cast is_primitive.int.dvd_iff_map_cast_dvd_map_cast\n\n",
 "dvd_iff_fraction_map_dvd_fraction_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_primitive.dvd_iff_fraction_map_dvd_fraction_map {p q : polynomial R} (hp : p.is_primitive)\n    (hq : q.is_primitive) : p ∣ q ↔ p.map (algebra_map R K) ∣ q.map (algebra_map R K) :=\n  ⟨fun ⟨a, b⟩ => ⟨a.map (algebra_map R K), b.symm ▸ polynomial.map_mul (algebra_map R K)⟩, fun h =>\n    hp.dvd_of_fraction_map_dvd_fraction_map hq h⟩\n#align is_primitive.dvd_iff_fraction_map_dvd_fraction_map is_primitive.dvd_iff_fraction_map_dvd_fraction_map\n\n"}