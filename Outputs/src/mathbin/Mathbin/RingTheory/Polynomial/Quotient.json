{"quotient_span_X_sub_C_alg_equiv_symm_apply":
 "@[simp]\ntheorem quotient_span_X_sub_C_alg_equiv_symm_apply (x : R) (y : R) :\n    (quotient_span_X_sub_C_alg_equiv x).symm y = algebraMap R _ y :=\n  rfl\n#align quotient_span_X_sub_C_alg_equiv_symm_apply quotient_span_X_sub_C_alg_equiv_symm_apply\n\n",
 "quotient_span_X_sub_C_alg_equiv_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2019 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, David Kurniadi Angdinata, Devon Tuma, Riccardo Brasca\n-/\n@[simp]\ntheorem quotient_span_X_sub_C_alg_equiv_mk (x : R) (p : polynomial R) :\n    quotient_span_X_sub_C_alg_equiv x (Ideal.Quotient.mk _ p) = p.eval x :=\n  rfl\n#align quotient_span_X_sub_C_alg_equiv_mk quotient_span_X_sub_C_alg_equiv_mk\n\n",
 "quotient_map_C_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem quotient_map_C_eq_zero {I : Ideal R} {i : R} (hi : i ∈ I) :\n    (Ideal.Quotient.mk (Ideal.map (C : «expr →+* » R (MvPolynomial σ R)) I : Ideal (MvPolynomial σ R))).comp C i = 0 :=\n  by\n  simp only [Function.comp_apply, RingHom.coe_comp, Ideal.Quotient.eq_zero_iff_mem]\n  exact Ideal.mem_map_of_mem _ hi\n#align quotient_map_C_eq_zero quotient_map_C_eq_zero\n\n",
 "polynomial_quotient_equiv_quotient_polynomial_symm_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem polynomial_quotient_equiv_quotient_polynomial_symm_mk (I : Ideal R) (f : polynomial R) :\n    I.polynomial_quotient_equiv_quotient_polynomial.symm (Quotient.mk _ f) = f.map (Quotient.mk I) := by\n  rw [polynomial_quotient_equiv_quotient_polynomial, RingEquiv.symm_mk, RingEquiv.coe_mk, Ideal.Quotient.lift_mk,\n    coe_eval₂_ring_hom, eval₂_eq_eval_map, ← Polynomial.map_map, ← eval₂_eq_eval_map, Polynomial.eval₂_C_X]\n#align polynomial_quotient_equiv_quotient_polynomial_symm_mk polynomial_quotient_equiv_quotient_polynomial_symm_mk\n\n",
 "polynomial_quotient_equiv_quotient_polynomial_map_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem polynomial_quotient_equiv_quotient_polynomial_map_mk (I : Ideal R) (f : polynomial R) :\n    I.polynomial_quotient_equiv_quotient_polynomial (f.map I.quotient.mk) = Quotient.mk _ f :=\n  by\n  apply (polynomial_quotient_equiv_quotient_polynomial I).symm.injective\n  rw [RingEquiv.symm_apply_apply, polynomial_quotient_equiv_quotient_polynomial_symm_mk]\n#align polynomial_quotient_equiv_quotient_polynomial_map_mk polynomial_quotient_equiv_quotient_polynomial_map_mk\n\n",
 "is_domain_map_C_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem is_domain_map_C_quotient {P : Ideal R} (H : IsPrime P) :\n    IsDomain («expr ⧸ » (polynomial R) (map (C : «expr →+* » R (polynomial R)) P : Ideal (polynomial R))) :=\n  RingEquiv.isDomain (Polynomial («expr ⧸ » R P)) (polynomial_quotient_equiv_quotient_polynomial P).symm\n#align is_domain_map_C_quotient is_domain_map_C_quotient\n\n",
 "eval₂_C_mk_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_C_mk_eq_zero {I : Ideal R} {a : MvPolynomial σ R}\n    (ha : a ∈ (Ideal.map (C : «expr →+* » R (MvPolynomial σ R)) I : Ideal (MvPolynomial σ R))) :\n    eval₂Hom (C.comp (Ideal.Quotient.mk I)) X a = 0 :=\n  by\n  rw [as_sum a]\n  rw [coe_eval₂_hom, eval₂_sum]\n  refine' Finset.sum_eq_zero fun n hn => _\n  simp only [eval₂_monomial, Function.comp_apply, RingHom.coe_comp]\n  refine' mul_eq_zero_of_left _ _\n  suffices coeff n a ∈ I by\n    rw [← @Ideal.mk_ker R _ I, RingHom.mem_ker] at this\n    simp only [this, C_0]\n  exact mem_map_C_iff.1 ha n\n#align eval₂_C_mk_eq_zero eval₂_C_mk_eq_zero\n\n",
 "eq_zero_of_polynomial_mem_map_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\n  If we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\n  In particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\n  This theorem shows `I'` will not contain any non-zero constant polynomials\n  -/\ntheorem eq_zero_of_polynomial_mem_map_range (I : Ideal (polynomial R)) (x : ((Quotient.mk I).comp C).range)\n    (hx : C x ∈ I.map (Polynomial.mapRingHom ((Quotient.mk I).comp C).range_restrict)) : x = 0 :=\n  by\n  let i := ((Quotient.mk' I).comp C).range_restrict\n  have hi' : (Polynomial.mapRingHom i).ker ≤ I :=\n    by\n    refine' fun f hf => polynomial_mem_ideal_of_coeff_mem_ideal I f fun n => _\n    rw [mem_comap, ← quotient.eq_zero_iff_mem, ← RingHom.comp_apply]\n    rw [RingHom.mem_ker, coe_map_ring_hom] at hf\n    replace hf := congr_arg (fun f : Polynomial _ => f.coeff n) hf\n    simp only [coeff_map, coeff_zero] at hf\n    rwa [Subtype.ext_iff, RingHom.coe_rangeRestrict] at hf\n  obtain ⟨x, hx'⟩ := x\n  obtain ⟨y, rfl⟩ := RingHom.mem_range.1 hx'\n  refine' Subtype.eq _\n  simp only [RingHom.comp_apply, quotient.eq_zero_iff_mem, ZeroMemClass.coe_zero, subtype.val_eq_coe]\n  suffices C (i y) ∈ I.map (Polynomial.mapRingHom i)\n    by\n    obtain ⟨f, hf⟩ :=\n      mem_image_of_mem_map_of_surjective (Polynomial.mapRingHom i)\n        (Polynomial.map_surjective _ ((Quotient.mk' I).comp C).range_restrict_surjective) this\n    refine' sub_add_cancel (C y) f ▸ I.add_mem (hi' _ : C y - f ∈ I) hf.1\n    rw [RingHom.mem_ker, RingHom.map_sub, hf.2, sub_eq_zero, coe_map_ring_hom, map_C]\n  exact hx\n#align eq_zero_of_polynomial_mem_map_range eq_zero_of_polynomial_mem_map_range\n\n"}