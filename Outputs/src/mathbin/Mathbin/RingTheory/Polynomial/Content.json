{"prim_part_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem prim_part_zero : prim_part (0 : polynomial R) = 1 :=\n  if_pos rfl\n#align prim_part_zero prim_part_zero\n\n",
 "prim_part_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem prim_part_ne_zero (p : polynomial R) : p.prim_part ≠ 0 :=\n  p.is_primitive_prim_part.ne_zero\n#align prim_part_ne_zero prim_part_ne_zero\n\n",
 "prim_part_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem prim_part_mul {p q : polynomial R} (h0 : p * q ≠ 0) : (p * q).prim_part = p.prim_part * q.prim_part :=\n  by\n  rw [ne.def, ← content_eq_zero_iff, ← C_eq_zero] at h0\n  apply mul_left_cancel₀ h0\n  conv_lhs => rw [← (p * q).eq_C_content_mul_prim_part, p.eq_C_content_mul_prim_part, q.eq_C_content_mul_prim_part]\n  rw [content_mul, RingHom.map_mul]\n  ring\n#align prim_part_mul prim_part_mul\n\n",
 "prim_part_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem is_primitive.prim_part_eq {p : polynomial R} (hp : p.is_primitive) : p.prim_part = p := by\n  rw [← one_mul p.prim_part, ← C_1, ← hp.content_eq_one, ← p.eq_C_content_mul_prim_part]\n#align is_primitive.prim_part_eq is_primitive.prim_part_eq\n\n",
 "prim_part_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem prim_part_dvd (p : polynomial R) : p.prim_part ∣ p :=\n  Dvd.intro_left (C p.content) p.eq_C_content_mul_prim_part.symm\n#align prim_part_dvd prim_part_dvd\n\n",
 "normalize_content":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem normalize_content {p : polynomial R} : normalize p.content = p.content :=\n  finset.normalize_gcd\n#align normalize_content normalize_content\n\n",
 "ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_primitive.ne_zero [nontrivial R] {p : polynomial R} (hp : p.is_primitive) : p ≠ 0 :=\n  by\n  rintro rfl\n  exact (hp 0 (dvd_zero (C 0))).ne_zero rfl\n#align is_primitive.ne_zero is_primitive.ne_zero\n\n",
 "nat_degree_prim_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_prim_part (p : polynomial R) : p.prim_part.nat_degree = p.nat_degree :=\n  by\n  by_cases h : C p.content = 0\n  · rw [C_eq_zero, content_eq_zero_iff] at h\n    simp [h]\n  conv_rhs => rw [p.eq_C_content_mul_prim_part, nat_degree_mul h p.prim_part_ne_zero, nat_degree_C, zero_add]\n#align nat_degree_prim_part nat_degree_prim_part\n\n",
 "mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_primitive.mul {p q : polynomial R} (hp : p.is_primitive) (hq : q.is_primitive) : (p * q).is_primitive := by\n  rw [is_primitive_iff_content_eq_one, content_mul, hp.content_eq_one, hq.content_eq_one, mul_one]\n#align is_primitive.mul is_primitive.mul\n\n",
 "is_unit_prim_part_C":
 "theorem is_unit_prim_part_C (r : R) : is_unit (C r).prim_part :=\n  by\n  by_cases h0 : r = 0\n  · simp [h0]\n  unfold is_unit\n  refine'\n    ⟨⟨C ↑(norm_unit r)⁻¹, C ↑(norm_unit r), by rw [← RingHom.map_mul, Units.inv_mul, C_1], by\n        rw [← RingHom.map_mul, Units.mul_inv, C_1]⟩,\n      _⟩\n  rw [← normalize_eq_zero, ← C_eq_zero] at h0\n  apply mul_left_cancel₀ h0\n  conv_rhs => rw [← content_C, ← (C r).eq_C_content_mul_prim_part]\n  simp only [Units.val_mk, normalize_apply, RingHom.map_mul]\n  rw [mul_assoc, ← RingHom.map_mul, Units.mul_inv, C_1, mul_one]\n#align is_unit_prim_part_C is_unit_prim_part_C\n\n",
 "is_primitive_prim_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_primitive_prim_part (p : polynomial R) : p.prim_part.is_primitive :=\n  by\n  by_cases h : p = 0; · simp [h]\n  rw [← content_eq_zero_iff] at h\n  rw [is_primitive_iff_content_eq_one]\n  apply mul_left_cancel₀ h\n  conv_rhs => rw [p.eq_C_content_mul_prim_part, mul_one, content_C_mul, normalize_content]\n#align is_primitive_prim_part is_primitive_prim_part\n\n",
 "is_primitive_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem is_primitive_one : is_primitive (1 : polynomial R) := fun r h => is_unit_C.mp (isUnit_of_dvd_one (C r) h)\n#align is_primitive_one is_primitive_one\n\n",
 "is_primitive_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_primitive_of_dvd {p q : polynomial R} (hp : is_primitive p) (hq : q ∣ p) : is_primitive q := fun a ha =>\n  is_primitive_iff_is_unit_of_C_dvd.mp hp a (dvd_trans ha hq)\n#align is_primitive_of_dvd is_primitive_of_dvd\n\n",
 "is_primitive_iff_is_unit_of_C_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem is_primitive_iff_is_unit_of_C_dvd {p : polynomial R} : p.is_primitive ↔ ∀ r : R, C r ∣ p → is_unit r :=\n  iff.rfl\n#align is_primitive_iff_is_unit_of_C_dvd is_primitive_iff_is_unit_of_C_dvd\n\n",
 "is_primitive_iff_content_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_primitive_iff_content_eq_one {p : polynomial R} : p.is_primitive ↔ p.content = 1 :=\n  by\n  rw [← normalize_content, normalize_eq_one, is_primitive]\n  simp_rw [← dvd_content_iff_C_dvd]\n  exact ⟨fun h => h p.content (dvd_refl p.content), fun h r hdvd => isUnit_of_dvd_unit hdvd h⟩\n#align is_primitive_iff_content_eq_one is_primitive_iff_content_eq_one\n\n",
 "is_primitive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.is_primitive {p : polynomial R} (hp : p.monic) : p.is_primitive :=\n  by\n  rintro r ⟨q, h⟩\n  exact isUnit_of_mul_eq_one r (q.coeff p.nat_degree) (by rwa [← coeff_C_mul, ← h])\n#align monic.is_primitive monic.is_primitive\n\n",
 "gcd_content_eq_of_dvd_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gcd_content_eq_of_dvd_sub {a : R} {p q : polynomial R} (h : C a ∣ p - q) :\n    gcd_monoid.gcd a p.content = gcd_monoid.gcd a q.content :=\n  by\n  rw [content_eq_gcd_range_of_lt p (max p.nat_degree q.nat_degree).succ\n      (lt_of_le_of_lt (le_max_left _ _) (nat.lt_succ_self _))]\n  rw [content_eq_gcd_range_of_lt q (max p.nat_degree q.nat_degree).succ\n      (lt_of_le_of_lt (le_max_right _ _) (nat.lt_succ_self _))]\n  apply finset.gcd_eq_of_dvd_sub\n  intro x hx\n  cases' h with w hw\n  use w.coeff x\n  rw [← coeff_sub, hw, coeff_C_mul]\n#align gcd_content_eq_of_dvd_sub gcd_content_eq_of_dvd_sub\n\n",
 "exists_primitive_lcm_of_is_primitive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_primitive_lcm_of_is_primitive {p q : polynomial R} (hp : p.is_primitive) (hq : q.is_primitive) :\n    ∃ r : polynomial R, r.is_primitive ∧ ∀ s : polynomial R, p ∣ s ∧ q ∣ s ↔ r ∣ s := by\n  classical\n    have h : ∃ (n : ℕ)(r : polynomial R), r.nat_degree = n ∧ r.is_primitive ∧ p ∣ r ∧ q ∣ r :=\n      ⟨(p * q).nat_degree, p * q, rfl, hp.mul hq, dvd_mul_right _ _, dvd_mul_left _ _⟩\n    rcases nat.find_spec h with ⟨r, rdeg, rprim, pr, qr⟩\n    refine' ⟨r, rprim, fun s => ⟨_, fun rs => ⟨pr.trans rs, qr.trans rs⟩⟩⟩\n    suffices hs : ∀ (n : ℕ) (s : polynomial R), s.nat_degree = n → p ∣ s ∧ q ∣ s → r ∣ s\n    · apply hs s.nat_degree s rfl\n    clear s\n    by_contra' con\n    rcases nat.find_spec con with ⟨s, sdeg, ⟨ps, qs⟩, rs⟩\n    have s0 : s ≠ 0 := by\n      contrapose! rs\n      simp [rs]\n    have hs :=\n      nat.find_min' h\n        ⟨_, s.nat_degree_prim_part, s.is_primitive_prim_part, (hp.dvd_prim_part_iff_dvd s0).2 ps,\n          (hq.dvd_prim_part_iff_dvd s0).2 qs⟩\n    rw [← rdeg] at hs\n    by_cases sC : s.nat_degree ≤ 0\n    · rw [eq_C_of_nat_degree_le_zero (le_trans hs sC), is_primitive_iff_content_eq_one, content_C, normalize_eq_one] at\n        rprim\n      rw [eq_C_of_nat_degree_le_zero (le_trans hs sC), ← dvd_content_iff_C_dvd] at rs\n      apply rs rprim.dvd\n    have hcancel := nat_degree_cancel_leads_lt_of_nat_degree_le_nat_degree hs (lt_of_not_ge sC)\n    rw [sdeg] at hcancel\n    apply nat.find_min con hcancel\n    refine' ⟨_, rfl, ⟨dvd_cancel_leads_of_dvd_of_dvd pr ps, dvd_cancel_leads_of_dvd_of_dvd qr qs⟩, fun rcs => rs _⟩\n    rw [← rprim.dvd_prim_part_iff_dvd s0]\n    rw [cancel_leads, tsub_eq_zero_iff_le.mpr hs, pow_zero, mul_one] at rcs\n    have h := dvd_add rcs (Dvd.intro_left _ rfl)\n    have hC0 := rprim.ne_zero\n    rw [ne.def, ← leading_coeff_eq_zero, ← C_eq_zero] at hC0\n    rw [sub_add_cancel, ← rprim.dvd_prim_part_iff_dvd (mul_ne_zero hC0 s0)] at h\n    rcases is_unit_prim_part_C r.leading_coeff with ⟨u, hu⟩\n    apply h.trans (Associated.symm ⟨u, _⟩).dvd\n    rw [prim_part_mul (mul_ne_zero hC0 s0), hu, mul_comm]\n#align exists_primitive_lcm_of_is_primitive exists_primitive_lcm_of_is_primitive\n\n",
 "eval₂_prim_part_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_prim_part_eq_zero {S : Type _} [CommRing S] [IsDomain S] {f : «expr →+* » R S}\n    (hinj : function.injective f) {p : polynomial R} {s : S} (hpzero : p ≠ 0) (hp : eval₂ f s p = 0) :\n    eval₂ f s p.prim_part = 0 :=\n  by\n  rw [eq_C_content_mul_prim_part p, eval₂_mul, eval₂_C] at hp\n  have hcont : p.content ≠ 0 := fun h => hpzero (content_eq_zero_iff.1 h)\n  replace hcont := Function.Injective.ne hinj hcont\n  rw [map_zero] at hcont\n  exact eq_zero_of_ne_zero_of_mul_left_eq_zero hcont hp\n#align eval₂_prim_part_eq_zero eval₂_prim_part_eq_zero\n\n",
 "eq_C_content_mul_prim_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_C_content_mul_prim_part (p : polynomial R) : p = C p.content * p.prim_part :=\n  by\n  by_cases h : p = 0; · simp [h]\n  rw [prim_part, if_neg h, ← Classical.choose_spec (C_content_dvd p)]\n#align eq_C_content_mul_prim_part eq_C_content_mul_prim_part\n\n",
 "dvd_prim_part_iff_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_primitive.dvd_prim_part_iff_dvd {p q : polynomial R} (hp : p.is_primitive) (hq : q ≠ 0) :\n    p ∣ q.prim_part ↔ p ∣ q :=\n  by\n  refine' ⟨fun h => h.trans (Dvd.intro_left _ q.eq_C_content_mul_prim_part.symm), fun h => _⟩\n  rcases h with ⟨r, rfl⟩\n  apply Dvd.intro _\n  rw [prim_part_mul hq, hp.prim_part_eq]\n#align is_primitive.dvd_prim_part_iff_dvd is_primitive.dvd_prim_part_iff_dvd\n\n",
 "dvd_iff_content_dvd_content_and_prim_part_dvd_prim_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem dvd_iff_content_dvd_content_and_prim_part_dvd_prim_part {p q : polynomial R} (hq : q ≠ 0) :\n    p ∣ q ↔ p.content ∣ q.content ∧ p.prim_part ∣ q.prim_part :=\n  by\n  constructor <;> intro h\n  · rcases h with ⟨r, rfl⟩\n    rw [content_mul, p.is_primitive_prim_part.dvd_prim_part_iff_dvd hq]\n    exact ⟨Dvd.intro _ rfl, p.prim_part_dvd.trans (Dvd.intro _ rfl)⟩\n  · rw [p.eq_C_content_mul_prim_part, q.eq_C_content_mul_prim_part]\n    exact mul_dvd_mul (RingHom.map_dvd C h.1) h.2\n#align dvd_iff_content_dvd_content_and_prim_part_dvd_prim_part dvd_iff_content_dvd_content_and_prim_part_dvd_prim_part\n\n",
 "dvd_content_iff_C_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem dvd_content_iff_C_dvd {p : polynomial R} {r : R} : r ∣ p.content ↔ C r ∣ p :=\n  by\n  rw [C_dvd_iff_dvd_coeff]\n  constructor\n  · intro h i\n    apply h.trans (content_dvd_coeff _)\n  · intro h\n    rw [content, finset.dvd_gcd_iff]\n    intro i hi\n    apply h i\n#align dvd_content_iff_C_dvd dvd_content_iff_C_dvd\n\n",
 "degree_gcd_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_gcd_le_right (p) {q : polynomial R} (hq : q ≠ 0) : (gcd p q).degree ≤ q.degree :=\n  by\n  rw [gcd_comm]\n  exact degree_gcd_le_left hq p\n#align degree_gcd_le_right degree_gcd_le_right\n\n",
 "degree_gcd_le_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_gcd_le_left {p : polynomial R} (hp : p ≠ 0) (q) : (gcd p q).degree ≤ p.degree :=\n  by\n  have := nat_degree_le_iff_degree_le.mp (nat_degree_le_of_dvd (gcd_dvd_left p q) hp)\n  rwa [degree_eq_nat_degree hp]\n#align degree_gcd_le_left degree_gcd_le_left\n\n",
 "content_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem content_zero : content (0 : polynomial R) = 0 := by rw [← C_0, content_C, normalize_zero]\n#align content_zero content_zero\n\n",
 "content_prim_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem content_prim_part (p : polynomial R) : p.prim_part.content = 1 :=\n  p.is_primitive_prim_part.content_eq_one\n#align content_prim_part content_prim_part\n\n",
 "content_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem content_one : content (1 : polynomial R) = 1 := by rw [← C_1, content_C, normalize_one]\n#align content_one content_one\n\n",
 "content_mul_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem content_mul_aux {p q : polynomial R} :\n    gcd_monoid.gcd (p * q).erase_lead.content p.leading_coeff =\n      gcd_monoid.gcd (p.erase_lead * q).content p.leading_coeff :=\n  by\n  rw [gcd_comm (content _) _, gcd_comm (content _) _]\n  apply gcd_content_eq_of_dvd_sub\n  rw [← self_sub_C_mul_X_pow, ← self_sub_C_mul_X_pow, sub_mul, sub_sub, add_comm, sub_add, sub_sub_cancel,\n    leading_coeff_mul, RingHom.map_mul, mul_assoc, mul_assoc]\n  apply dvd_sub (Dvd.intro _ rfl) (Dvd.intro _ rfl)\n#align content_mul_aux content_mul_aux\n\n",
 "content_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem content_mul {p q : polynomial R} : (p * q).content = p.content * q.content := by\n  classical\n    suffices h : ∀ (n : ℕ) (p q : polynomial R), (p * q).degree < n → (p * q).content = p.content * q.content\n    · apply h\n      apply lt_of_le_of_lt degree_le_nat_degree (WithBot.coe_lt_coe.2 (nat.lt_succ_self _))\n    intro n\n    induction' n with n ih\n    · intro p q hpq\n      rw [with_bot.coe_zero, Nat.WithBot.lt_zero_iff, degree_eq_bot, mul_eq_zero] at hpq\n      rcases hpq with (rfl | rfl) <;> simp\n    intro p q hpq\n    by_cases p0 : p = 0\n    · simp [p0]\n    by_cases q0 : q = 0\n    · simp [q0]\n    rw [degree_eq_nat_degree (mul_ne_zero p0 q0), WithBot.coe_lt_coe, Nat.lt_succ_iff_lt_or_eq, ← WithBot.coe_lt_coe, ←\n      degree_eq_nat_degree (mul_ne_zero p0 q0), nat_degree_mul p0 q0] at hpq\n    rcases hpq with (hlt | heq)\n    · apply ih _ _ hlt\n    rw [← p.nat_degree_prim_part, ← q.nat_degree_prim_part, ← WithBot.coe_eq_coe, WithBot.coe_add, ←\n      degree_eq_nat_degree p.prim_part_ne_zero, ← degree_eq_nat_degree q.prim_part_ne_zero] at heq\n    rw [p.eq_C_content_mul_prim_part, q.eq_C_content_mul_prim_part]\n    suffices h : (q.prim_part * p.prim_part).content = 1\n    ·\n      rw [mul_assoc, content_C_mul, content_C_mul, mul_comm p.prim_part, mul_assoc, content_C_mul, content_C_mul, h,\n        mul_one, content_prim_part, content_prim_part, mul_one, mul_one]\n    rw [← normalize_content, normalize_eq_one, isUnit_iff_dvd_one, content_eq_gcd_leading_coeff_content_erase_lead,\n      leading_coeff_mul, gcd_comm]\n    apply (gcd_mul_dvd_mul_gcd _ _ _).trans\n    rw [content_mul_aux, ih, content_prim_part, mul_one, gcd_comm, ← content_eq_gcd_leading_coeff_content_erase_lead,\n      content_prim_part, one_mul, mul_comm q.prim_part, content_mul_aux, ih, content_prim_part, mul_one, gcd_comm, ←\n      content_eq_gcd_leading_coeff_content_erase_lead, content_prim_part]\n    · rw [← HEq, degree_mul, WithBot.add_lt_add_iff_right]\n      · apply degree_erase_lt p.prim_part_ne_zero\n      · rw [ne.def, degree_eq_bot]\n        apply q.prim_part_ne_zero\n    · rw [mul_comm, ← HEq, degree_mul, WithBot.add_lt_add_iff_left]\n      · apply degree_erase_lt q.prim_part_ne_zero\n      · rw [ne.def, degree_eq_bot]\n        apply p.prim_part_ne_zero\n#align content_mul content_mul\n\n",
 "content_monomial":
 "@[simp]\ntheorem content_monomial {r : R} {k : ℕ} : content (monomial k r) = normalize r := by\n  rw [← C_mul_X_pow_eq_monomial, content_C_mul, content_X_pow, mul_one]\n#align content_monomial content_monomial\n\n",
 "content_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem content_eq_zero_iff {p : polynomial R} : content p = 0 ↔ p = 0 :=\n  by\n  rw [content, finset.gcd_eq_zero_iff]\n  constructor <;> intro h\n  · ext n\n    by_cases h0 : n ∈ p.support\n    · rw [h n h0, coeff_zero]\n    · rw [mem_support_iff] at h0\n      push_neg  at h0\n      simp [h0]\n  · intro x h0\n    simp [h]\n#align content_eq_zero_iff content_eq_zero_iff\n\n",
 "content_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_primitive.content_eq_one {p : polynomial R} (hp : p.is_primitive) : p.content = 1 :=\n  is_primitive_iff_content_eq_one.mp hp\n#align is_primitive.content_eq_one is_primitive.content_eq_one\n\n",
 "content_eq_gcd_range_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem content_eq_gcd_range_succ (p : polynomial R) : p.content = (Finset.range p.nat_degree.succ).gcd p.coeff :=\n  content_eq_gcd_range_of_lt _ _ (nat.lt_succ_self _)\n#align content_eq_gcd_range_succ content_eq_gcd_range_succ\n\n",
 "content_eq_gcd_range_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem content_eq_gcd_range_of_lt (p : polynomial R) (n : ℕ) (h : p.nat_degree < n) :\n    p.content = (Finset.range n).gcd p.coeff :=\n  by\n  apply dvd_antisymm_of_normalize_eq normalize_content finset.normalize_gcd\n  · rw [finset.dvd_gcd_iff]\n    intro i hi\n    apply content_dvd_coeff _\n  · apply finset.gcd_mono\n    intro i\n    simp only [Nat.lt_succ_iff, mem_support_iff, ne.def, Finset.mem_range]\n    contrapose!\n    intro h1\n    apply coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le h h1)\n#align content_eq_gcd_range_of_lt content_eq_gcd_range_of_lt\n\n",
 "content_eq_gcd_leading_coeff_content_erase_lead":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem content_eq_gcd_leading_coeff_content_erase_lead (p : polynomial R) :\n    p.content = gcd_monoid.gcd p.leading_coeff (erase_lead p).content :=\n  by\n  by_cases h : p = 0\n  · simp [h]\n  rw [← leading_coeff_eq_zero, leading_coeff, ← ne.def, ← mem_support_iff] at h\n  rw [content, ← Finset.insert_erase h, finset.gcd_insert, leading_coeff, content, erase_lead_support]\n  refine' congr rfl (finset.gcd_congr rfl fun i hi => _)\n  rw [Finset.mem_erase] at hi\n  rw [erase_lead_coeff, if_neg hi.1]\n#align content_eq_gcd_leading_coeff_content_erase_lead content_eq_gcd_leading_coeff_content_erase_lead\n\n",
 "content_dvd_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem content_dvd_coeff {p : polynomial R} (n : ℕ) : p.content ∣ p.coeff n :=\n  by\n  by_cases h : n ∈ p.support\n  · apply finset.gcd_dvd h\n  rw [mem_support_iff, not_not] at h\n  rw [h]\n  apply dvd_zero\n#align content_dvd_coeff content_dvd_coeff\n\n",
 "content_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem content_X_pow {k : ℕ} : content ((X : polynomial R) ^ k) = 1 :=\n  by\n  induction' k with k hi\n  · simp\n  rw [pow_succ, content_X_mul, hi]\n#align content_X_pow content_X_pow\n\n",
 "content_X_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem content_X_mul {p : polynomial R} : content (X * p) = content p :=\n  by\n  rw [content, content, finset.gcd_def, finset.gcd_def]\n  refine' congr rfl _\n  have h : (X * p).support = p.support.map ⟨nat.succ, Nat.succ_injective⟩ :=\n    by\n    ext a\n    simp only [exists_prop, Finset.mem_map, Function.Embedding.coeFn_mk, ne.def, mem_support_iff]\n    cases a\n    · simp [coeff_X_mul_zero, nat.succ_ne_zero]\n    rw [mul_comm, coeff_mul_X]\n    constructor\n    · intro h\n      use a\n      simp [h]\n    · rintro ⟨b, ⟨h1, h2⟩⟩\n      rw [← Nat.succ_injective h2]\n      apply h1\n  rw [h]\n  simp only [Finset.map_val, Function.comp_apply, Function.Embedding.coeFn_mk, Multiset.map_map]\n  refine' congr (congr rfl _) rfl\n  ext a\n  rw [mul_comm]\n  simp [coeff_mul_X]\n#align content_X_mul content_X_mul\n\n",
 "content_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem content_X : content (X : polynomial R) = 1 := by rw [← mul_one X, content_X_mul, content_one]\n#align content_X content_X\n\n",
 "content_C_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem content_C_mul (r : R) (p : polynomial R) : (C r * p).content = normalize r * p.content :=\n  by\n  by_cases h0 : r = 0; · simp [h0]\n  rw [content]; rw [content]; rw [← finset.gcd_mul_left]\n  refine' congr (congr rfl _) _ <;> ext <;> simp [h0, mem_support_iff]\n#align content_C_mul content_C_mul\n\n",
 "content_C":
 "@[simp]\ntheorem content_C {r : R} : (C r).content = normalize r :=\n  by\n  rw [content]\n  by_cases h0 : r = 0\n  · simp [h0]\n  have h : (C r).support = {0} := support_monomial _ h0\n  simp [h]\n#align content_C content_C\n\n",
 "aeval_prim_part_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem aeval_prim_part_eq_zero {S : Type _} [Ring S] [IsDomain S] [algebra R S] [NoZeroSMulDivisors R S]\n    {p : polynomial R} {s : S} (hpzero : p ≠ 0) (hp : aeval s p = 0) : aeval s p.prim_part = 0 :=\n  by\n  rw [eq_C_content_mul_prim_part p, map_mul, aeval_C] at hp\n  have hcont : p.content ≠ 0 := fun h => hpzero (content_eq_zero_iff.1 h)\n  replace hcont := Function.Injective.ne (no_zero_smul_divisors.algebra_map_injective R S) hcont\n  rw [map_zero] at hcont\n  exact eq_zero_of_ne_zero_of_mul_left_eq_zero hcont hp\n#align aeval_prim_part_eq_zero aeval_prim_part_eq_zero\n\n",
 "C_content_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem C_content_dvd (p : polynomial R) : C p.content ∣ p :=\n  dvd_content_iff_C_dvd.1 dvd_rfl\n#align C_content_dvd C_content_dvd\n\n"}