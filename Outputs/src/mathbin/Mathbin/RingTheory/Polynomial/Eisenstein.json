{"pow_nat_degree_le_of_root_of_monic_mem":
 "theorem pow_nat_degree_le_of_root_of_monic_mem {x : R} (hroot : is_root f x) (hmo : f.monic) :\n    âˆ€ i, f.nat_degree â‰¤ i â†’ x ^ i âˆˆ ğ“Ÿ := by\n  intro i hi\n  obtain âŸ¨k, hkâŸ© := exists_add_of_le hi\n  rw [hk, pow_add]\n  suffices x ^ f.nat_degree âˆˆ ğ“Ÿ by exact mul_mem_right (x ^ k) ğ“Ÿ this\n  rw [is_root.def, eval_eq_sum_range, Finset.range_add_one, finset.sum_insert Finset.not_mem_range_self,\n    finset.sum_range, hmo.coeff_nat_degree, one_mul] at hroot\n  rw [eq_neg_of_add_eq_zero_left hroot, neg_mem_iff]\n  refine' submodule.sum_mem _ fun i hi => mul_mem_right _ _ (hf.mem (Fin.is_lt i))\n#align pow_nat_degree_le_of_root_of_monic_mem pow_nat_degree_le_of_root_of_monic_mem\n\n",
 "pow_nat_degree_le_of_aeval_zero_of_monic_mem_map":
 "theorem pow_nat_degree_le_of_aeval_zero_of_monic_mem_map {x : S} (hx : aeval x f = 0) (hmo : f.monic) :\n    âˆ€ i, (f.map (algebra_map R S)).nat_degree â‰¤ i â†’ x ^ i âˆˆ ğ“Ÿ.map (algebra_map R S) :=\n  by\n  suffices x ^ (f.map (algebra_map R S)).nat_degree âˆˆ ğ“Ÿ.map (algebra_map R S)\n    by\n    intro i hi\n    obtain âŸ¨k, hkâŸ© := exists_add_of_le hi\n    rw [hk, pow_add]\n    refine' mul_mem_right _ _ this\n  rw [aeval_def, evalâ‚‚_eq_eval_map, â† is_root.def] at hx\n  refine' pow_nat_degree_le_of_root_of_monic_mem (hf.map _) hx (hmo.map _) _ rfl.le\n#align pow_nat_degree_le_of_aeval_zero_of_monic_mem_map pow_nat_degree_le_of_aeval_zero_of_monic_mem_map\n\n",
 "mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr %â‚˜ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ“Ÿ -/\n/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p â€¢ z âˆˆ adjoin R {B.gen}`, then\n`z âˆˆ adjoin R {B.gen}`. -/\ntheorem mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at {B : power_basis K L} (hp : Prime p)\n    (hBint : is_integral R B.gen) {z : L} (hzint : is_integral R z) (hz : Â«expr â€¢ Â» p z âˆˆ adjoin R ({B.gen} : set L))\n    (hei : (minpoly R B.gen).is_eisenstein_at (exprğ“Ÿ)) : z âˆˆ adjoin R ({B.gen} : set L) :=\n  by\n  -- First define some abbreviations.\n  have hndiv : Â¬p ^ 2 âˆ£ (minpoly R B.gen).coeff 0 := fun h =>\n    hei.not_mem ((span_singleton_pow p 2).symm â–¸ ideal.mem_span_singleton.2 h)\n  letI := finite_dimensional B\n  set P := minpoly R B.gen with hP\n  obtain âŸ¨n, hnâŸ© := nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'\n  haveI : NoZeroSMulDivisors R L := no_zero_smul_divisors.trans R K L\n  let Pâ‚ := P.map (algebra_map R L)\n  -- There is a polynomial `Q` such that `p â€¢ z = aeval B.gen Q`. We can assume that\n  -- `Q.degree < P.degree` and `Q â‰  0`.\n  rw [adjoin_singleton_eq_range_aeval] at hz\n  obtain âŸ¨Qâ‚, hQâŸ© := hz\n  set Q := Â«expr %â‚˜ Â» Qâ‚ P with hQâ‚\n  replace hQ : aeval B.gen Q = Â«expr â€¢ Â» p z\n  Â· rw [â† mod_by_monic_add_div Qâ‚ (minpoly.monic hBint)] at hQ\n    simpa using hQ\n  by_cases hQzero : Q = 0\n  Â· simp only [hQzero, algebra.smul_def, zero_eq_mul, aeval_zero] at hQ\n    cases' hQ with H Hâ‚\n    Â· have : function.injective (algebra_map R L) :=\n        by\n        rw [algebra_map_eq R K L]\n        exact (algebra_map K L).injective.comp (is_fraction_ring.injective R K)\n      exfalso\n      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)\n    Â· rw [Hâ‚]\n      exact subalgebra.zero_mem _\n  -- It is enough to prove that all coefficients of `Q` are divisible by `p`, by induction.\n  -- The base case is `dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at`.\n  refine' mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => _) hQ\n  refine' nat.case_strong_induction_on i _ fun j hind => _\n  Â· intro H\n    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at hp hBint hQ hzint hei\n  Â· intro hj\n    refine' hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd _ hndiv\n    exact n\n    -- Two technical results we will need about `P.nat_degree` and `Q.nat_degree`.\n    have H := degree_mod_by_monic_lt Qâ‚ (minpoly.monic hBint)\n    rw [â† hQâ‚, â† hP] at H\n    replace H :=\n      Nat.lt_iff_add_one_le.1\n        (lt_of_lt_of_le\n          (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (nat.lt_of_succ_lt_succ (mem_range.1 hj))) (lt_succ_self _))\n          (Nat.lt_iff_add_one_le.1 ((nat_degree_lt_nat_degree_iff hQzero).2 H)))\n    rw [add_assoc] at H\n    have Hj : Q.nat_degree + 1 = j + 1 + (Q.nat_degree - j) := by\n      rw [â† add_comm 1, â† add_comm 1, add_assoc, add_right_inj, â†\n        nat.add_sub_assoc (nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm, nat.add_sub_cancel]\n    -- By induction hypothesis we can find `g : â„• â†’ R` such that\n    -- `k âˆˆ range (j + 1) â†’ Q.coeff k â€¢ B.gen ^ k = (algebra_map R L) p * g k â€¢ B.gen ^ k`-\n    choose! g hg using hind\n    replace hg :\n      âˆ€ k âˆˆ range (j + 1), Â«expr â€¢ Â» (Q.coeff k) (B.gen ^ k) = algebra_map R L p * Â«expr â€¢ Â» (g k) (B.gen ^ k)\n    Â· intro k hk\n      rw [hg k (mem_range_succ_iff.1 hk)\n          (mem_range_succ_iff.2 (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),\n        algebra.smul_def, algebra.smul_def, RingHom.map_mul, mul_assoc]\n    -- Since `minpoly R B.gen` is Eiseinstein, we can find `f : â„• â†’ L` such that\n    -- `(map (algebra_map R L) (minpoly R B.gen)).nat_degree â‰¤ i` implies `f i âˆˆ adjoin R {B.gen}`\n    -- and `(algebra_map R L) p * f i = B.gen ^ i`. We will also need `hfâ‚`, a reformulation of this\n    -- property.\n    choose! f hf using\n      is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le (minpoly.aeval R B.gen) (minpoly.monic hBint)\n        hei.is_weakly_eisenstein_at\n    have hfâ‚ :\n      âˆ€ k âˆˆ (range (Q.nat_degree - j)).erase 0,\n        Â«expr â€¢ Â» (Q.coeff (j + 1 + k)) (B.gen ^ (j + 1 + k)) * B.gen ^ (P.nat_degree - (j + 2)) =\n          (algebra_map R L) p * Â«expr â€¢ Â» (Q.coeff (j + 1 + k)) (f (k + P.nat_degree - 1)) :=\n      by\n      intro k hk\n      rw [smul_mul_assoc, â† pow_add, â† nat.add_sub_assoc H, â† add_assoc j 1 1, add_comm (j + 1) 1, add_assoc (j + 1),\n        add_comm _ (k + P.nat_degree), nat.add_sub_add_right, â† (hf (k + P.nat_degree - 1) _).2, mul_smul_comm]\n      rw [(minpoly.monic hBint).nat_degree_map, add_comm, nat.add_sub_assoc, le_add_iff_nonneg_right]\n      Â· exact nat.zero_le _\n      Â· refine' one_le_iff_ne_zero.2 fun h => _\n        rw [h] at hk\n        simpa using hk\n      Â· infer_instance\n    -- The Eisenstein condition shows that `p` divides `Q.coeff j`\n    -- if `p^n.succ` divides the following multiple of `Q.coeff (succ j)^n.succ`:\n    suffices p ^ n.succ âˆ£ Q.coeff (succ j) ^ n.succ * (minpoly R B.gen).coeff 0 ^ (succ j + (P.nat_degree - (j + 2)))\n      by\n      convert this\n      rw [nat.succ_eq_add_one, add_assoc, â† nat.add_sub_assoc H, â† add_assoc, add_comm (j + 1), nat.add_sub_add_left, â†\n        nat.add_sub_assoc, nat.add_sub_add_left, hP, â† (minpoly.monic hBint).nat_degree_map (algebra_map R K), â†\n        minpoly.gcd_domain_eq_field_fractions' K hBint, nat_degree_minpoly, hn, nat.sub_one, nat.pred_succ]\n      linarith\n    -- Using `hQ : aeval B.gen Q = p â€¢ z`, we write `p â€¢ z` as a sum of terms of degree less than\n    -- `j+1`, that are multiples of `p` by induction, and terms of degree at least `j+1`.\n    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_add_left_embedding _ _), sum_congr rfl hg,\n      add_comm] at hQ\n    -- We multiply this equality by `B.gen ^ (P.nat_degree-(j+2))`, so we can use `hfâ‚` on the terms\n    -- we didn't know were multiples of `p`, and we take the norm on both sides.\n    replace hQ := congr_arg (fun x => x * B.gen ^ (P.nat_degree - (j + 2))) hQ\n    simp_rw [sum_map, add_left_embedding_apply, add_mul, sum_mul, mul_assoc] at hQ\n    rw [â† insert_erase (mem_range.2 (tsub_pos_iff_lt.2 <| nat.lt_of_succ_lt_succ <| mem_range.1 hj)),\n      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hfâ‚, â† mul_sum, â† mul_sum, add_assoc, â† mul_add,\n      smul_mul_assoc, â† pow_add, algebra.smul_def] at hQ\n    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)\n    -- We obtain an equality of elements of `K`, but everything is integral, so we can move to `R`\n    -- and simplify `hQ`.\n    have hintsum :\n      is_integral R\n        (z * B.gen ^ (P.nat_degree - (j + 2)) -\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree - j)).erase 0) (Â«expr â€¢ Â» (Q.coeff (j + 1 + x)) (f (x + P.nat_degree - 1))) +\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (range (j + 1)) (Â«expr â€¢ Â» (g x) (B.gen ^ x) * B.gen ^ (P.nat_degree - (j + 2))))) :=\n      by\n      refine'\n        is_integral_sub (is_integral_mul hzint (is_integral.pow hBint _))\n          (is_integral_add (is_integral.sum _ fun k hk => is_integral_smul _ _)\n            (is_integral.sum _ fun k hk =>\n              is_integral_mul (is_integral_smul _ (is_integral.pow hBint _)) (is_integral.pow hBint _)))\n      refine' adjoin_le_integral_closure hBint (hf _ _).1\n      rw [(minpoly.monic hBint).nat_degree_map (algebra_map R L)]\n      rw [add_comm, nat.add_sub_assoc, le_add_iff_nonneg_right]\n      Â· exact zero_le _\n      Â· refine' one_le_iff_ne_zero.2 fun h => _\n        rw [h] at hk\n        simpa using hk\n    obtain âŸ¨r, hrâŸ© := is_integral_iff.1 (is_integral_norm K hintsum)\n    rw [algebra.smul_def, mul_assoc, â† mul_sub, _root_.map_mul, algebra_map_apply R K L, map_pow,\n      algebra.norm_algebra_map, _root_.map_mul, algebra_map_apply R K L, algebra.norm_algebra_map, finrank B, â† hr,\n      power_basis.norm_gen_eq_coeff_zero_minpoly, minpoly.gcd_domain_eq_field_fractions' K hBint, coeff_map,\n      show (-1 : K) = algebra_map R K (-1) by simp, â† map_pow, â† map_pow, â† _root_.map_mul, â† map_pow, â† _root_.map_mul,\n      â† map_pow, â† _root_.map_mul] at hQ\n    -- We can now finish the proof.\n    have hppdiv : p ^ B.dim âˆ£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _\n    rwa [â† is_fraction_ring.injective R K hQ, mul_comm, â† Units.coe_neg_one, mul_pow, â† Units.val_pow_eq_pow_val, â†\n      Units.val_pow_eq_pow_val, mul_assoc, is_unit.dvd_mul_left _ _ _ âŸ¨_, rflâŸ©, mul_comm, â† nat.succ_eq_add_one, hn] at\n      hppdiv\n#align\n  mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at\n\n",
 "mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ“Ÿ -/\n/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p ^ n â€¢ z âˆˆ adjoin R {B.gen}`,\nthen `z âˆˆ adjoin R {B.gen}`. Together with `algebra.discr_mul_is_integral_mem_adjoin` this result\noften allows to compute the ring of integers of `L`. -/\ntheorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at {B : power_basis K L} (hp : Prime p)\n    (hBint : is_integral R B.gen) {n : â„•} {z : L} (hzint : is_integral R z)\n    (hz : Â«expr â€¢ Â» (p ^ n) z âˆˆ adjoin R ({B.gen} : set L)) (hei : (minpoly R B.gen).is_eisenstein_at (exprğ“Ÿ)) :\n    z âˆˆ adjoin R ({B.gen} : set L) := by\n  induction' n with n hn\n  Â· simpa using hz\n  Â· rw [pow_succ, mul_smul] at hz\n    exact hn (mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at hp hBint (is_integral_smul _ hzint) hz hei)\n#align\n  mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at\n\n",
 "mem_adjoin_of_dvd_coeff_of_dvd_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem mem_adjoin_of_dvd_coeff_of_dvd_aeval {A B : Type _} [CommSemiring A] [CommRing B] [algebra A B]\n    [NoZeroSMulDivisors A B] {Q : polynomial A} {p : A} {x z : B} (hp : p â‰  0)\n    (hQ : âˆ€ i âˆˆ range (Q.nat_degree + 1), p âˆ£ Q.coeff i) (hz : aeval x Q = Â«expr â€¢ Â» p z) :\n    z âˆˆ adjoin A ({x} : set B) := by\n  choose! f hf using hQ\n  rw [aeval_eq_sum_range, sum_range] at hz\n  conv_lhs at hz =>\n    congr\n    skip\n    ext\n    rw [hf i (mem_range.2 (Fin.is_lt i)), â† smul_smul]\n  rw [â† smul_sum] at hz\n  rw [â† smul_right_injective _ hp hz]\n  exact\n    subalgebra.sum_mem _ fun _ _ =>\n      subalgebra.smul_mem _ (subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _) _\n#align mem_adjoin_of_dvd_coeff_of_dvd_aeval mem_adjoin_of_dvd_coeff_of_dvd_aeval\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/-\nCopyright (c) 2022 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\ntheorem map {A : Type v} [CommRing A] (Ï† : Â«expr â†’+* Â» R A) : (f.map Ï†).is_weakly_eisenstein_at (ğ“Ÿ.map Ï†) :=\n  by\n  refine' (is_weakly_eisenstein_at_iff _ _).2 fun n hn => _\n  rw [coeff_map]\n  exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_le hn (nat_degree_map_le _ _)))\n#align map map\n\n",
 "leading_coeff_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem _root_.polynomial.monic.leading_coeff_not_mem (hf : f.monic) (h : ğ“Ÿ â‰  Â«exprâŠ¤Â») : Â¬f.leading_coeff âˆˆ ğ“Ÿ :=\n  hf.leading_coeff.symm â–¸ (ideal.ne_top_iff_one _).1 h\n#align polynomial.monic.leading_coeff_not_mem polynomial.monic.leading_coeff_not_mem\n\n",
 "is_weakly_eisenstein_at":
 "theorem is_weakly_eisenstein_at : is_weakly_eisenstein_at f ğ“Ÿ :=\n  âŸ¨fun _ => hf.memâŸ©\n#align is_weakly_eisenstein_at is_weakly_eisenstein_at\n\n",
 "is_eisenstein_at_of_mem_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem _root_.polynomial.monic.is_eisenstein_at_of_mem_of_not_mem (hf : f.monic) (h : ğ“Ÿ â‰  Â«exprâŠ¤Â»)\n    (hmem : âˆ€ {n}, n < f.nat_degree â†’ f.coeff n âˆˆ ğ“Ÿ) (hnot_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2) : f.is_eisenstein_at ğ“Ÿ :=\n  { leading := hf.leading_coeff_not_mem h\n    mem := fun n hn => hmem hn\n    not_mem := hnot_mem }\n#align polynomial.monic.is_eisenstein_at_of_mem_of_not_mem polynomial.monic.is_eisenstein_at_of_mem_of_not_mem\n\n",
 "exists_mem_adjoin_mul_eq_pow_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprP -/\ntheorem exists_mem_adjoin_mul_eq_pow_nat_degree_le {x : S} (hx : aeval x f = 0) (hmo : f.monic)\n    (hf : f.is_weakly_eisenstein_at (exprP)) :\n    âˆ€ i, (f.map (algebra_map R S)).nat_degree â‰¤ i â†’ âˆƒ y âˆˆ adjoin R ({x} : set S), (algebra_map R S) p * y = x ^ i :=\n  by\n  intro i hi\n  obtain âŸ¨k, hkâŸ© := exists_add_of_le hi\n  rw [hk, pow_add]\n  obtain âŸ¨y, hy, HâŸ© := exists_mem_adjoin_mul_eq_pow_nat_degree hx hmo hf\n  refine' âŸ¨y * x ^ k, _, _âŸ©\n  Â· exact subalgebra.mul_mem _ hy (subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _)\n  Â· rw [â† mul_assoc _ y, H]\n#align exists_mem_adjoin_mul_eq_pow_nat_degree_le exists_mem_adjoin_mul_eq_pow_nat_degree_le\n\n",
 "exists_mem_adjoin_mul_eq_pow_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprP -/\ntheorem exists_mem_adjoin_mul_eq_pow_nat_degree {x : S} (hx : aeval x f = 0) (hmo : f.monic)\n    (hf : f.is_weakly_eisenstein_at (exprP)) :\n    âˆƒ y âˆˆ adjoin R ({x} : set S), (algebra_map R S) p * y = x ^ (f.map (algebra_map R S)).nat_degree :=\n  by\n  rw [aeval_def, polynomial.evalâ‚‚_eq_eval_map, eval_eq_sum_range, range_add_one, sum_insert not_mem_range_self,\n    sum_range, (hmo.map (algebra_map R S)).coeff_nat_degree, one_mul] at hx\n  replace hx := eq_neg_of_add_eq_zero_left hx\n  have : âˆ€ n < f.nat_degree, p âˆ£ f.coeff n := by\n    intro n hn\n    refine' mem_span_singleton.1 (by simpa using hf.mem hn)\n  choose! Ï† hÏ† using this\n  conv_rhs at hx =>\n    congr\n    congr\n    skip\n    ext\n    rw [[anonymous], coeff_map, hÏ† i.1 (lt_of_lt_of_le i.2 (nat_degree_map_le _ _)), RingHom.map_mul, mul_assoc]\n  rw [hx, â† mul_sum, neg_eq_neg_one_mul, â† mul_assoc (-1 : S), mul_comm (-1 : S), mul_assoc]\n  refine'\n    âŸ¨-1 *\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          ((algebra_map R S) (Ï† i.1) * x ^ i.1),\n      _, rflâŸ©\n  exact\n    subalgebra.mul_mem _ (subalgebra.neg_mem _ (subalgebra.one_mem _))\n      (subalgebra.sum_mem _ fun i hi =>\n        subalgebra.mul_mem _ (subalgebra.algebra_map_mem _ _)\n          (subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _))\n#align exists_mem_adjoin_mul_eq_pow_nat_degree exists_mem_adjoin_mul_eq_pow_nat_degree\n\n",
 "dvd_pow_nat_degree_of_evalâ‚‚_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem dvd_pow_nat_degree_of_evalâ‚‚_eq_zero {f : Â«expr â†’+* Â» R A} (hf : function.injective f) {p : polynomial R}\n    (hp : p.monic) (x y : R) (z : A) (h : p.evalâ‚‚ f z = 0) (hz : f x * z = f y) : x âˆ£ y ^ p.nat_degree :=\n  by\n  rw [â† nat_degree_scale_roots p x, â† ideal.mem_span_singleton]\n  refine'\n    (scale_roots.is_weakly_eisenstein_at _\n          (ideal.mem_span_singleton.mpr <| dvd_refl x)).pow_nat_degree_le_of_root_of_monic_mem\n      _ ((monic_scale_roots_iff x).mpr hp) _ le_rfl\n  rw [injective_iff_map_eq_zero'] at hf\n  have := scale_roots_evalâ‚‚_eq_zero f h\n  rwa [hz, polynomial.evalâ‚‚_at_apply, hf] at this\n#align dvd_pow_nat_degree_of_evalâ‚‚_eq_zero dvd_pow_nat_degree_of_evalâ‚‚_eq_zero\n\n",
 "dvd_pow_nat_degree_of_aeval_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem dvd_pow_nat_degree_of_aeval_eq_zero [algebra R A] [nontrivial A] [NoZeroSMulDivisors R A] {p : polynomial R}\n    (hp : p.monic) (x y : R) (z : A) (h : polynomial.aeval z p = 0) (hz : z * algebra_map R A x = algebra_map R A y) :\n    x âˆ£ y ^ p.nat_degree :=\n  dvd_pow_nat_degree_of_evalâ‚‚_eq_zero (no_zero_smul_divisors.algebra_map_injective R A) hp x y z h\n    ((mul_comm _ _).trans hz)\n#align dvd_pow_nat_degree_of_aeval_eq_zero dvd_pow_nat_degree_of_aeval_eq_zero\n\n",
 "dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ“Ÿ -/\n/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `Q : R[X]` is such that\n`aeval B.gen Q = p â€¢ z`, then `p âˆ£ Q.coeff 0`. -/\ntheorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at {B : power_basis K L} (hp : Prime p)\n    (hBint : is_integral R B.gen) {z : L} {Q : polynomial R} (hQ : aeval B.gen Q = Â«expr â€¢ Â» p z)\n    (hzint : is_integral R z) (hei : (minpoly R B.gen).is_eisenstein_at (exprğ“Ÿ)) : p âˆ£ Q.coeff 0 :=\n  by\n  -- First define some abbreviations.\n  letI := B.finite_dimensional\n  let P := minpoly R B.gen\n  obtain âŸ¨n, hnâŸ© := nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'\n  have finrank_K_L : finite_dimensional.finrank K L = B.dim := B.finrank\n  have deg_K_P : (minpoly K B.gen).nat_degree = B.dim := B.nat_degree_minpoly\n  have deg_R_P : P.nat_degree = B.dim := by\n    rw [â† deg_K_P, minpoly.gcd_domain_eq_field_fractions' K hBint,\n      (minpoly.monic hBint).nat_degree_map (algebra_map R K)]\n  choose! f hf using\n    hei.is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le (minpoly.aeval R B.gen) (minpoly.monic hBint)\n  simp only [(minpoly.monic hBint).nat_degree_map, deg_R_P] at hf\n  -- The Eisenstein condition shows that `p` divides `Q.coeff 0`\n  -- if `p^n.succ` divides the following multiple of `Q.coeff 0^n.succ`:\n  suffices p ^ n.succ âˆ£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n)\n    by\n    have hndiv : Â¬p ^ 2 âˆ£ (minpoly R B.gen).coeff 0 := fun h =>\n      hei.not_mem ((span_singleton_pow p 2).symm â–¸ ideal.mem_span_singleton.2 h)\n    refine' Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd hp (_ : _ ^ n.succ âˆ£ _) hndiv\n    convert (is_unit.dvd_mul_right âŸ¨(-1) ^ (n.succ * n), rflâŸ©).mpr this using 1\n    push_cast\n    ring_nf\n    simp [pow_right_comm _ _ 2]\n  -- We claim the quotient of `Q^n * _` by `p^n` is the following `r`:\n  have aux : âˆ€ i âˆˆ (range (Q.nat_degree + 1)).erase 0, B.dim â‰¤ i + n :=\n    by\n    intro i hi\n    simp only [mem_range, mem_erase] at hi\n    rw [hn]\n    exact le_add_pred_of_pos _ hi.1\n  have hintsum :\n    is_integral R\n      (z * B.gen ^ n -\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          ((range (Q.nat_degree + 1)).erase 0) (Â«expr â€¢ Â» (Q.coeff x) (f (x + n)))) :=\n    by\n    refine'\n      is_integral_sub (is_integral_mul hzint (is_integral.pow hBint _))\n        (is_integral.sum _ fun i hi => is_integral_smul _ _)\n    exact adjoin_le_integral_closure hBint (hf _ (aux i hi)).1\n  obtain âŸ¨r, hrâŸ© := is_integral_iff.1 (is_integral_norm K hintsum)\n  use r\n  -- Do the computation in `K` so we can work in terms of `z` instead of `r`.\n  apply is_fraction_ring.injective R K\n  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]\n  -- Both sides are actually norms:\n  calc\n    _ = norm K (Â«expr â€¢ Â» (Q.coeff 0) (B.gen ^ n)) := _\n    _ =\n        norm K\n          (Â«expr â€¢ Â» p (z * B.gen ^ n) -\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree + 1)).erase 0) (Â«expr â€¢ Â» p (Â«expr â€¢ Â» (Q.coeff x) (f (x + n))))) :=\n      congr_arg (norm K) (eq_sub_of_add_eq _)\n    _ = _ := _\n    \n  Â· simp only [algebra.smul_def, algebra_map_apply R K L, algebra.norm_algebra_map, _root_.map_mul, _root_.map_pow,\n      finrank_K_L, power_basis.norm_gen_eq_coeff_zero_minpoly, minpoly.gcd_domain_eq_field_fractions' K hBint,\n      coeff_map, â† hn]\n    ring\n  swap\n  Â·\n    simp_rw [â† smul_sum, â† smul_sub, algebra.smul_def p, algebra_map_apply R K L, _root_.map_mul,\n      algebra.norm_algebra_map, finrank_K_L, hr, â† hn]\n  calc\n    _ =\n        (Â«expr â€¢ Â» (Q.coeff 0) 1 +\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree + 1)).erase 0) (Â«expr â€¢ Â» (Q.coeff x) (B.gen ^ x))) *\n          B.gen ^ n :=\n      _\n    _ =\n        (Â«expr â€¢ Â» (Q.coeff 0) (B.gen ^ 0) +\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree + 1)).erase 0) (Â«expr â€¢ Â» (Q.coeff x) (B.gen ^ x))) *\n          B.gen ^ n :=\n      by rw [pow_zero]\n    _ = aeval B.gen Q * B.gen ^ n := _\n    _ = _ := by rw [hQ, algebra.smul_mul_assoc]\n    \n  Â· have :\n      âˆ€ i âˆˆ (range (Q.nat_degree + 1)).erase 0,\n        Â«expr â€¢ Â» (Q.coeff i) (B.gen ^ i * B.gen ^ n) = Â«expr â€¢ Â» p (Â«expr â€¢ Â» (Q.coeff i) (f (i + n))) :=\n      by\n      intro i hi\n      rw [â† pow_add, â† (hf _ (aux i hi)).2, â† algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]\n    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]\n  Â· rw [aeval_eq_sum_range, finset.add_sum_erase (range (Q.nat_degree + 1)) fun i => Â«expr â€¢ Â» (Q.coeff i) (B.gen ^ i)]\n    simp\n#align\n  dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at\n\n",
 "cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ“Ÿ -/\ntheorem cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at [hp : fact p.prime] (n : â„•) :\n    ((cyclotomic (p ^ (n + 1)) â„¤).comp (X + 1)).is_eisenstein_at (exprğ“Ÿ) :=\n  by\n  refine'\n    monic.is_eisenstein_at_of_mem_of_not_mem _\n      (ideal.is_prime.ne_top <|\n        (ideal.span_singleton_prime (by exact_mod_cast hp.out.ne_zero)).2 <| Nat.prime_iff_prime_int.1 hp.out)\n      _ _\n  Â· rw [show (X + 1 : polynomial â„¤) = X + C 1 by simp]\n    refine' (cyclotomic.monic _ â„¤).comp (monic_X_add_C 1) fun h => _\n    rw [nat_degree_X_add_C] at h\n    exact zero_ne_one h.symm\n  Â· induction' n with n hn\n    Â· intro i hi\n      rw [zero_add, pow_one] at hiâŠ¢\n      exact (cyclotomic_comp_X_add_one_is_eisenstein_at p).mem hi\n    Â· intro i hi\n      rw [ideal.submodule_span_eq, ideal.mem_span_singleton, â† zmod.int_coe_zmod_eq_zero_iff_dvd, â† Int.coe_castRingHom,\n        â† coeff_map, map_comp, map_cyclotomic, polynomial.map_add, map_X, polynomial.map_one, pow_add, pow_one,\n        cyclotomic_mul_prime_dvd_eq_pow, pow_comp, â† zmod.expand_card, coeff_expand hp.out.pos]\n      Â· simp only [ite_eq_right_iff]\n        rintro âŸ¨k, hkâŸ©\n        rw [nat_degree_comp, show (X + 1 : polynomial â„¤) = X + C 1 by simp, nat_degree_X_add_C, mul_one,\n          nat_degree_cyclotomic, nat.totient_prime_pow hp.out (nat.succ_pos _), nat.succ_sub_one] at hn hi\n        rw [hk, pow_succ, mul_assoc] at hi\n        rw [hk, mul_comm, nat.mul_div_cancel _ hp.out.pos]\n        replace hn := hn (lt_of_mul_lt_mul_left' hi)\n        rw [ideal.submodule_span_eq, ideal.mem_span_singleton, â† zmod.int_coe_zmod_eq_zero_iff_dvd, â†\n          Int.coe_castRingHom, â† coeff_map] at hn\n        simpa [map_comp] using hn\n      Â· exact âŸ¨p ^ n, by rw [pow_succ]âŸ©\n  Â· rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime_pow_eq_geom_sum hp.out, eval_add, eval_X, eval_one,\n      zero_add, eval_finset_sum]\n    simp only [eval_pow, eval_X, one_pow, sum_const, card_range, Nat.smul_one_eq_coe, submodule_span_eq,\n      ideal.submodule_span_eq, ideal.span_singleton_pow, ideal.mem_span_singleton]\n    intro h\n    obtain âŸ¨k, hkâŸ© := Int.coe_nat_dvd.1 h\n    rw [â† mul_assoc, mul_one, mul_assoc] at hk\n    nth_rw 1 [â† nat.mul_one p] at hk\n    rw [mul_right_inj' hp.out.ne_zero] at hk\n    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)\n#align cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at\n\n",
 "cyclotomic_comp_X_add_one_is_eisenstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ“Ÿ -/\ntheorem cyclotomic_comp_X_add_one_is_eisenstein_at [hp : fact p.prime] :\n    ((cyclotomic p â„¤).comp (X + 1)).is_eisenstein_at (exprğ“Ÿ) :=\n  by\n  refine'\n    monic.is_eisenstein_at_of_mem_of_not_mem _\n      (ideal.is_prime.ne_top <|\n        (ideal.span_singleton_prime (by exact_mod_cast hp.out.ne_zero)).2 <| Nat.prime_iff_prime_int.1 hp.out)\n      (fun i hi => _) _\n  Â· rw [show (X + 1 : polynomial â„¤) = X + C 1 by simp]\n    refine' (cyclotomic.monic p â„¤).comp (monic_X_add_C 1) fun h => _\n    rw [nat_degree_X_add_C] at h\n    exact zero_ne_one h.symm\n  Â· rw [cyclotomic_prime, geom_sum_X_comp_X_add_one_eq_sum, â† lcoeff_apply, linear_map.map_sum]\n    conv =>\n      congr\n      congr\n      skip\n      ext\n      rw [lcoeff_apply, â† C_eq_nat_cast, C_mul_X_pow_eq_monomial, coeff_monomial]\n    rw [nat_degree_comp, show (X + 1 : polynomial â„¤) = X + C 1 by simp, nat_degree_X_add_C, mul_one,\n      nat_degree_cyclotomic, nat.totient_prime hp.out] at hi\n    simp only [lt_of_lt_of_le hi (nat.sub_le _ _), sum_ite_eq', mem_range, if_true, ideal.submodule_span_eq,\n      ideal.mem_span_singleton]\n    exact Int.coe_nat_dvd.2 (Nat.Prime.dvd_choose_self (nat.succ_pos i) (lt_tsub_iff_right.1 hi) hp.out)\n  Â· rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime, eval_add, eval_X, eval_one, zero_add, eval_geom_sum,\n      one_geom_sum, ideal.submodule_span_eq, ideal.span_singleton_pow, ideal.mem_span_singleton]\n    intro h\n    obtain âŸ¨k, hkâŸ© := Int.coe_nat_dvd.1 h\n    rw [â† mul_assoc, mul_one, mul_assoc] at hk\n    nth_rw 1 [â† nat.mul_one p] at hk\n    rw [mul_right_inj' hp.out.ne_zero] at hk\n    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)\n#align cyclotomic_comp_X_add_one_is_eisenstein_at cyclotomic_comp_X_add_one_is_eisenstein_at\n\n",
 "coeff_mem":
 "theorem coeff_mem {n : â„•} (hn : n â‰  f.nat_degree) : f.coeff n âˆˆ ğ“Ÿ :=\n  by\n  cases ne_iff_lt_or_gt.1 hn\n  Â· exact hf.mem h\n  Â· rw [coeff_eq_zero_of_nat_degree_lt h]\n    exact ideal.zero_mem _\n#align coeff_mem coeff_mem\n\n",
 "Irreducible":
 "#print Irreducible /-\n/-- If a primitive `f` satisfies `f.is_eisenstein_at ğ“Ÿ`, where `ğ“Ÿ.is_prime`, then `f` is\nirreducible. -/\ntheorem Irreducible (hprime : ğ“Ÿ.is_prime) (hu : f.is_primitive) (hfd0 : 0 < f.nat_degree) : Irreducible f :=\n  irreducible_of_eisenstein_criterion hprime hf.leading (fun n hn => hf.mem (coe_lt_degree.1 hn))\n    (nat_degree_pos_iff_degree_pos.1 hfd0) hf.not_mem hu\n#align irreducible Irreducible\n-/\n\n"}