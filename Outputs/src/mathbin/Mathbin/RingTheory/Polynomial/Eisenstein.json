{"pow_nat_degree_le_of_root_of_monic_mem":
 "theorem pow_nat_degree_le_of_root_of_monic_mem {x : R} (hroot : is_root f x) (hmo : f.monic) :\n    ‚àÄ i, f.nat_degree ‚â§ i ‚Üí x ^ i ‚àà ùìü := by\n  intro i hi\n  obtain ‚ü®k, hk‚ü© := exists_add_of_le hi\n  rw [hk, pow_add]\n  suffices x ^ f.nat_degree ‚àà ùìü by exact mul_mem_right (x ^ k) ùìü this\n  rw [is_root.def, eval_eq_sum_range, Finset.range_add_one, finset.sum_insert Finset.not_mem_range_self,\n    finset.sum_range, hmo.coeff_nat_degree, one_mul] at hroot\n  rw [eq_neg_of_add_eq_zero_left hroot, neg_mem_iff]\n  refine' submodule.sum_mem _ fun i hi => mul_mem_right _ _ (hf.mem (Fin.is_lt i))\n#align pow_nat_degree_le_of_root_of_monic_mem pow_nat_degree_le_of_root_of_monic_mem\n\n",
 "pow_nat_degree_le_of_aeval_zero_of_monic_mem_map":
 "theorem pow_nat_degree_le_of_aeval_zero_of_monic_mem_map {x : S} (hx : aeval x f = 0) (hmo : f.monic) :\n    ‚àÄ i, (f.map (algebra_map R S)).nat_degree ‚â§ i ‚Üí x ^ i ‚àà ùìü.map (algebra_map R S) :=\n  by\n  suffices x ^ (f.map (algebra_map R S)).nat_degree ‚àà ùìü.map (algebra_map R S)\n    by\n    intro i hi\n    obtain ‚ü®k, hk‚ü© := exists_add_of_le hi\n    rw [hk, pow_add]\n    refine' mul_mem_right _ _ this\n  rw [aeval_def, eval‚ÇÇ_eq_eval_map, ‚Üê is_root.def] at hx\n  refine' pow_nat_degree_le_of_root_of_monic_mem (hf.map _) hx (hmo.map _) _ rfl.le\n#align pow_nat_degree_le_of_aeval_zero_of_monic_mem_map pow_nat_degree_le_of_aeval_zero_of_monic_mem_map\n\n",
 "mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr %‚Çò ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùìü -/\n/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p ‚Ä¢ z ‚àà adjoin R {B.gen}`, then\n`z ‚àà adjoin R {B.gen}`. -/\ntheorem mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at {B : power_basis K L} (hp : Prime p)\n    (hBint : is_integral R B.gen) {z : L} (hzint : is_integral R z) (hz : ¬´expr ‚Ä¢ ¬ª p z ‚àà adjoin R ({B.gen} : set L))\n    (hei : (minpoly R B.gen).is_eisenstein_at (exprùìü)) : z ‚àà adjoin R ({B.gen} : set L) :=\n  by\n  -- First define some abbreviations.\n  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>\n    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ ideal.mem_span_singleton.2 h)\n  letI := finite_dimensional B\n  set P := minpoly R B.gen with hP\n  obtain ‚ü®n, hn‚ü© := nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'\n  haveI : NoZeroSMulDivisors R L := no_zero_smul_divisors.trans R K L\n  let P‚ÇÅ := P.map (algebra_map R L)\n  -- There is a polynomial `Q` such that `p ‚Ä¢ z = aeval B.gen Q`. We can assume that\n  -- `Q.degree < P.degree` and `Q ‚â† 0`.\n  rw [adjoin_singleton_eq_range_aeval] at hz\n  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz\n  set Q := ¬´expr %‚Çò ¬ª Q‚ÇÅ P with hQ‚ÇÅ\n  replace hQ : aeval B.gen Q = ¬´expr ‚Ä¢ ¬ª p z\n  ¬∑ rw [‚Üê mod_by_monic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ\n    simpa using hQ\n  by_cases hQzero : Q = 0\n  ¬∑ simp only [hQzero, algebra.smul_def, zero_eq_mul, aeval_zero] at hQ\n    cases' hQ with H H‚ÇÅ\n    ¬∑ have : function.injective (algebra_map R L) :=\n        by\n        rw [algebra_map_eq R K L]\n        exact (algebra_map K L).injective.comp (is_fraction_ring.injective R K)\n      exfalso\n      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)\n    ¬∑ rw [H‚ÇÅ]\n      exact subalgebra.zero_mem _\n  -- It is enough to prove that all coefficients of `Q` are divisible by `p`, by induction.\n  -- The base case is `dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at`.\n  refine' mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => _) hQ\n  refine' nat.case_strong_induction_on i _ fun j hind => _\n  ¬∑ intro H\n    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at hp hBint hQ hzint hei\n  ¬∑ intro hj\n    refine' hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd _ hndiv\n    exact n\n    -- Two technical results we will need about `P.nat_degree` and `Q.nat_degree`.\n    have H := degree_mod_by_monic_lt Q‚ÇÅ (minpoly.monic hBint)\n    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H\n    replace H :=\n      Nat.lt_iff_add_one_le.1\n        (lt_of_lt_of_le\n          (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (nat.lt_of_succ_lt_succ (mem_range.1 hj))) (lt_succ_self _))\n          (Nat.lt_iff_add_one_le.1 ((nat_degree_lt_nat_degree_iff hQzero).2 H)))\n    rw [add_assoc] at H\n    have Hj : Q.nat_degree + 1 = j + 1 + (Q.nat_degree - j) := by\n      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj, ‚Üê\n        nat.add_sub_assoc (nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm, nat.add_sub_cancel]\n    -- By induction hypothesis we can find `g : ‚Ñï ‚Üí R` such that\n    -- `k ‚àà range (j + 1) ‚Üí Q.coeff k ‚Ä¢ B.gen ^ k = (algebra_map R L) p * g k ‚Ä¢ B.gen ^ k`-\n    choose! g hg using hind\n    replace hg :\n      ‚àÄ k ‚àà range (j + 1), ¬´expr ‚Ä¢ ¬ª (Q.coeff k) (B.gen ^ k) = algebra_map R L p * ¬´expr ‚Ä¢ ¬ª (g k) (B.gen ^ k)\n    ¬∑ intro k hk\n      rw [hg k (mem_range_succ_iff.1 hk)\n          (mem_range_succ_iff.2 (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),\n        algebra.smul_def, algebra.smul_def, RingHom.map_mul, mul_assoc]\n    -- Since `minpoly R B.gen` is Eiseinstein, we can find `f : ‚Ñï ‚Üí L` such that\n    -- `(map (algebra_map R L) (minpoly R B.gen)).nat_degree ‚â§ i` implies `f i ‚àà adjoin R {B.gen}`\n    -- and `(algebra_map R L) p * f i = B.gen ^ i`. We will also need `hf‚ÇÅ`, a reformulation of this\n    -- property.\n    choose! f hf using\n      is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le (minpoly.aeval R B.gen) (minpoly.monic hBint)\n        hei.is_weakly_eisenstein_at\n    have hf‚ÇÅ :\n      ‚àÄ k ‚àà (range (Q.nat_degree - j)).erase 0,\n        ¬´expr ‚Ä¢ ¬ª (Q.coeff (j + 1 + k)) (B.gen ^ (j + 1 + k)) * B.gen ^ (P.nat_degree - (j + 2)) =\n          (algebra_map R L) p * ¬´expr ‚Ä¢ ¬ª (Q.coeff (j + 1 + k)) (f (k + P.nat_degree - 1)) :=\n      by\n      intro k hk\n      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê nat.add_sub_assoc H, ‚Üê add_assoc j 1 1, add_comm (j + 1) 1, add_assoc (j + 1),\n        add_comm _ (k + P.nat_degree), nat.add_sub_add_right, ‚Üê (hf (k + P.nat_degree - 1) _).2, mul_smul_comm]\n      rw [(minpoly.monic hBint).nat_degree_map, add_comm, nat.add_sub_assoc, le_add_iff_nonneg_right]\n      ¬∑ exact nat.zero_le _\n      ¬∑ refine' one_le_iff_ne_zero.2 fun h => _\n        rw [h] at hk\n        simpa using hk\n      ¬∑ infer_instance\n    -- The Eisenstein condition shows that `p` divides `Q.coeff j`\n    -- if `p^n.succ` divides the following multiple of `Q.coeff (succ j)^n.succ`:\n    suffices p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ * (minpoly R B.gen).coeff 0 ^ (succ j + (P.nat_degree - (j + 2)))\n      by\n      convert this\n      rw [nat.succ_eq_add_one, add_assoc, ‚Üê nat.add_sub_assoc H, ‚Üê add_assoc, add_comm (j + 1), nat.add_sub_add_left, ‚Üê\n        nat.add_sub_assoc, nat.add_sub_add_left, hP, ‚Üê (minpoly.monic hBint).nat_degree_map (algebra_map R K), ‚Üê\n        minpoly.gcd_domain_eq_field_fractions' K hBint, nat_degree_minpoly, hn, nat.sub_one, nat.pred_succ]\n      linarith\n    -- Using `hQ : aeval B.gen Q = p ‚Ä¢ z`, we write `p ‚Ä¢ z` as a sum of terms of degree less than\n    -- `j+1`, that are multiples of `p` by induction, and terms of degree at least `j+1`.\n    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_add_left_embedding _ _), sum_congr rfl hg,\n      add_comm] at hQ\n    -- We multiply this equality by `B.gen ^ (P.nat_degree-(j+2))`, so we can use `hf‚ÇÅ` on the terms\n    -- we didn't know were multiples of `p`, and we take the norm on both sides.\n    replace hQ := congr_arg (fun x => x * B.gen ^ (P.nat_degree - (j + 2))) hQ\n    simp_rw [sum_map, add_left_embedding_apply, add_mul, sum_mul, mul_assoc] at hQ\n    rw [‚Üê insert_erase (mem_range.2 (tsub_pos_iff_lt.2 <| nat.lt_of_succ_lt_succ <| mem_range.1 hj)),\n      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc, ‚Üê mul_add,\n      smul_mul_assoc, ‚Üê pow_add, algebra.smul_def] at hQ\n    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)\n    -- We obtain an equality of elements of `K`, but everything is integral, so we can move to `R`\n    -- and simplify `hQ`.\n    have hintsum :\n      is_integral R\n        (z * B.gen ^ (P.nat_degree - (j + 2)) -\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree - j)).erase 0) (¬´expr ‚Ä¢ ¬ª (Q.coeff (j + 1 + x)) (f (x + P.nat_degree - 1))) +\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (range (j + 1)) (¬´expr ‚Ä¢ ¬ª (g x) (B.gen ^ x) * B.gen ^ (P.nat_degree - (j + 2))))) :=\n      by\n      refine'\n        is_integral_sub (is_integral_mul hzint (is_integral.pow hBint _))\n          (is_integral_add (is_integral.sum _ fun k hk => is_integral_smul _ _)\n            (is_integral.sum _ fun k hk =>\n              is_integral_mul (is_integral_smul _ (is_integral.pow hBint _)) (is_integral.pow hBint _)))\n      refine' adjoin_le_integral_closure hBint (hf _ _).1\n      rw [(minpoly.monic hBint).nat_degree_map (algebra_map R L)]\n      rw [add_comm, nat.add_sub_assoc, le_add_iff_nonneg_right]\n      ¬∑ exact zero_le _\n      ¬∑ refine' one_le_iff_ne_zero.2 fun h => _\n        rw [h] at hk\n        simpa using hk\n    obtain ‚ü®r, hr‚ü© := is_integral_iff.1 (is_integral_norm K hintsum)\n    rw [algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebra_map_apply R K L, map_pow,\n      algebra.norm_algebra_map, _root_.map_mul, algebra_map_apply R K L, algebra.norm_algebra_map, finrank B, ‚Üê hr,\n      power_basis.norm_gen_eq_coeff_zero_minpoly, minpoly.gcd_domain_eq_field_fractions' K hBint, coeff_map,\n      show (-1 : K) = algebra_map R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul,\n      ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ\n    -- We can now finish the proof.\n    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _\n    rwa [‚Üê is_fraction_ring.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê Units.val_pow_eq_pow_val, ‚Üê\n      Units.val_pow_eq_pow_val, mul_assoc, is_unit.dvd_mul_left _ _ _ ‚ü®_, rfl‚ü©, mul_comm, ‚Üê nat.succ_eq_add_one, hn] at\n      hppdiv\n#align\n  mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at\n\n",
 "mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùìü -/\n/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p ^ n ‚Ä¢ z ‚àà adjoin R {B.gen}`,\nthen `z ‚àà adjoin R {B.gen}`. Together with `algebra.discr_mul_is_integral_mem_adjoin` this result\noften allows to compute the ring of integers of `L`. -/\ntheorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at {B : power_basis K L} (hp : Prime p)\n    (hBint : is_integral R B.gen) {n : ‚Ñï} {z : L} (hzint : is_integral R z)\n    (hz : ¬´expr ‚Ä¢ ¬ª (p ^ n) z ‚àà adjoin R ({B.gen} : set L)) (hei : (minpoly R B.gen).is_eisenstein_at (exprùìü)) :\n    z ‚àà adjoin R ({B.gen} : set L) := by\n  induction' n with n hn\n  ¬∑ simpa using hz\n  ¬∑ rw [pow_succ, mul_smul] at hz\n    exact hn (mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at hp hBint (is_integral_smul _ hzint) hz hei)\n#align\n  mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at\n\n",
 "mem_adjoin_of_dvd_coeff_of_dvd_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem mem_adjoin_of_dvd_coeff_of_dvd_aeval {A B : Type _} [CommSemiring A] [CommRing B] [algebra A B]\n    [NoZeroSMulDivisors A B] {Q : polynomial A} {p : A} {x z : B} (hp : p ‚â† 0)\n    (hQ : ‚àÄ i ‚àà range (Q.nat_degree + 1), p ‚à£ Q.coeff i) (hz : aeval x Q = ¬´expr ‚Ä¢ ¬ª p z) :\n    z ‚àà adjoin A ({x} : set B) := by\n  choose! f hf using hQ\n  rw [aeval_eq_sum_range, sum_range] at hz\n  conv_lhs at hz =>\n    congr\n    skip\n    ext\n    rw [hf i (mem_range.2 (Fin.is_lt i)), ‚Üê smul_smul]\n  rw [‚Üê smul_sum] at hz\n  rw [‚Üê smul_right_injective _ hp hz]\n  exact\n    subalgebra.sum_mem _ fun _ _ =>\n      subalgebra.smul_mem _ (subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _) _\n#align mem_adjoin_of_dvd_coeff_of_dvd_aeval mem_adjoin_of_dvd_coeff_of_dvd_aeval\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\n/-\nCopyright (c) 2022 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\ntheorem map {A : Type v} [CommRing A] (œÜ : ¬´expr ‚Üí+* ¬ª R A) : (f.map œÜ).is_weakly_eisenstein_at (ùìü.map œÜ) :=\n  by\n  refine' (is_weakly_eisenstein_at_iff _ _).2 fun n hn => _\n  rw [coeff_map]\n  exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_le hn (nat_degree_map_le _ _)))\n#align map map\n\n",
 "leading_coeff_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\ntheorem _root_.polynomial.monic.leading_coeff_not_mem (hf : f.monic) (h : ùìü ‚â† ¬´expr‚ä§¬ª) : ¬¨f.leading_coeff ‚àà ùìü :=\n  hf.leading_coeff.symm ‚ñ∏ (ideal.ne_top_iff_one _).1 h\n#align polynomial.monic.leading_coeff_not_mem polynomial.monic.leading_coeff_not_mem\n\n",
 "is_weakly_eisenstein_at":
 "theorem is_weakly_eisenstein_at : is_weakly_eisenstein_at f ùìü :=\n  ‚ü®fun _ => hf.mem‚ü©\n#align is_weakly_eisenstein_at is_weakly_eisenstein_at\n\n",
 "is_eisenstein_at_of_mem_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\ntheorem _root_.polynomial.monic.is_eisenstein_at_of_mem_of_not_mem (hf : f.monic) (h : ùìü ‚â† ¬´expr‚ä§¬ª)\n    (hmem : ‚àÄ {n}, n < f.nat_degree ‚Üí f.coeff n ‚àà ùìü) (hnot_mem : f.coeff 0 ‚àâ ùìü ^ 2) : f.is_eisenstein_at ùìü :=\n  { leading := hf.leading_coeff_not_mem h\n    mem := fun n hn => hmem hn\n    not_mem := hnot_mem }\n#align polynomial.monic.is_eisenstein_at_of_mem_of_not_mem polynomial.monic.is_eisenstein_at_of_mem_of_not_mem\n\n",
 "exists_mem_adjoin_mul_eq_pow_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprP -/\ntheorem exists_mem_adjoin_mul_eq_pow_nat_degree_le {x : S} (hx : aeval x f = 0) (hmo : f.monic)\n    (hf : f.is_weakly_eisenstein_at (exprP)) :\n    ‚àÄ i, (f.map (algebra_map R S)).nat_degree ‚â§ i ‚Üí ‚àÉ y ‚àà adjoin R ({x} : set S), (algebra_map R S) p * y = x ^ i :=\n  by\n  intro i hi\n  obtain ‚ü®k, hk‚ü© := exists_add_of_le hi\n  rw [hk, pow_add]\n  obtain ‚ü®y, hy, H‚ü© := exists_mem_adjoin_mul_eq_pow_nat_degree hx hmo hf\n  refine' ‚ü®y * x ^ k, _, _‚ü©\n  ¬∑ exact subalgebra.mul_mem _ hy (subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _)\n  ¬∑ rw [‚Üê mul_assoc _ y, H]\n#align exists_mem_adjoin_mul_eq_pow_nat_degree_le exists_mem_adjoin_mul_eq_pow_nat_degree_le\n\n",
 "exists_mem_adjoin_mul_eq_pow_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprP -/\ntheorem exists_mem_adjoin_mul_eq_pow_nat_degree {x : S} (hx : aeval x f = 0) (hmo : f.monic)\n    (hf : f.is_weakly_eisenstein_at (exprP)) :\n    ‚àÉ y ‚àà adjoin R ({x} : set S), (algebra_map R S) p * y = x ^ (f.map (algebra_map R S)).nat_degree :=\n  by\n  rw [aeval_def, polynomial.eval‚ÇÇ_eq_eval_map, eval_eq_sum_range, range_add_one, sum_insert not_mem_range_self,\n    sum_range, (hmo.map (algebra_map R S)).coeff_nat_degree, one_mul] at hx\n  replace hx := eq_neg_of_add_eq_zero_left hx\n  have : ‚àÄ n < f.nat_degree, p ‚à£ f.coeff n := by\n    intro n hn\n    refine' mem_span_singleton.1 (by simpa using hf.mem hn)\n  choose! œÜ hœÜ using this\n  conv_rhs at hx =>\n    congr\n    congr\n    skip\n    ext\n    rw [[anonymous], coeff_map, hœÜ i.1 (lt_of_lt_of_le i.2 (nat_degree_map_le _ _)), RingHom.map_mul, mul_assoc]\n  rw [hx, ‚Üê mul_sum, neg_eq_neg_one_mul, ‚Üê mul_assoc (-1 : S), mul_comm (-1 : S), mul_assoc]\n  refine'\n    ‚ü®-1 *\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          ((algebra_map R S) (œÜ i.1) * x ^ i.1),\n      _, rfl‚ü©\n  exact\n    subalgebra.mul_mem _ (subalgebra.neg_mem _ (subalgebra.one_mem _))\n      (subalgebra.sum_mem _ fun i hi =>\n        subalgebra.mul_mem _ (subalgebra.algebra_map_mem _ _)\n          (subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _))\n#align exists_mem_adjoin_mul_eq_pow_nat_degree exists_mem_adjoin_mul_eq_pow_nat_degree\n\n",
 "dvd_pow_nat_degree_of_eval‚ÇÇ_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem dvd_pow_nat_degree_of_eval‚ÇÇ_eq_zero {f : ¬´expr ‚Üí+* ¬ª R A} (hf : function.injective f) {p : polynomial R}\n    (hp : p.monic) (x y : R) (z : A) (h : p.eval‚ÇÇ f z = 0) (hz : f x * z = f y) : x ‚à£ y ^ p.nat_degree :=\n  by\n  rw [‚Üê nat_degree_scale_roots p x, ‚Üê ideal.mem_span_singleton]\n  refine'\n    (scale_roots.is_weakly_eisenstein_at _\n          (ideal.mem_span_singleton.mpr <| dvd_refl x)).pow_nat_degree_le_of_root_of_monic_mem\n      _ ((monic_scale_roots_iff x).mpr hp) _ le_rfl\n  rw [injective_iff_map_eq_zero'] at hf\n  have := scale_roots_eval‚ÇÇ_eq_zero f h\n  rwa [hz, polynomial.eval‚ÇÇ_at_apply, hf] at this\n#align dvd_pow_nat_degree_of_eval‚ÇÇ_eq_zero dvd_pow_nat_degree_of_eval‚ÇÇ_eq_zero\n\n",
 "dvd_pow_nat_degree_of_aeval_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem dvd_pow_nat_degree_of_aeval_eq_zero [algebra R A] [nontrivial A] [NoZeroSMulDivisors R A] {p : polynomial R}\n    (hp : p.monic) (x y : R) (z : A) (h : polynomial.aeval z p = 0) (hz : z * algebra_map R A x = algebra_map R A y) :\n    x ‚à£ y ^ p.nat_degree :=\n  dvd_pow_nat_degree_of_eval‚ÇÇ_eq_zero (no_zero_smul_divisors.algebra_map_injective R A) hp x y z h\n    ((mul_comm _ _).trans hz)\n#align dvd_pow_nat_degree_of_aeval_eq_zero dvd_pow_nat_degree_of_aeval_eq_zero\n\n",
 "dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùìü -/\n/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `Q : R[X]` is such that\n`aeval B.gen Q = p ‚Ä¢ z`, then `p ‚à£ Q.coeff 0`. -/\ntheorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at {B : power_basis K L} (hp : Prime p)\n    (hBint : is_integral R B.gen) {z : L} {Q : polynomial R} (hQ : aeval B.gen Q = ¬´expr ‚Ä¢ ¬ª p z)\n    (hzint : is_integral R z) (hei : (minpoly R B.gen).is_eisenstein_at (exprùìü)) : p ‚à£ Q.coeff 0 :=\n  by\n  -- First define some abbreviations.\n  letI := B.finite_dimensional\n  let P := minpoly R B.gen\n  obtain ‚ü®n, hn‚ü© := nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'\n  have finrank_K_L : finite_dimensional.finrank K L = B.dim := B.finrank\n  have deg_K_P : (minpoly K B.gen).nat_degree = B.dim := B.nat_degree_minpoly\n  have deg_R_P : P.nat_degree = B.dim := by\n    rw [‚Üê deg_K_P, minpoly.gcd_domain_eq_field_fractions' K hBint,\n      (minpoly.monic hBint).nat_degree_map (algebra_map R K)]\n  choose! f hf using\n    hei.is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le (minpoly.aeval R B.gen) (minpoly.monic hBint)\n  simp only [(minpoly.monic hBint).nat_degree_map, deg_R_P] at hf\n  -- The Eisenstein condition shows that `p` divides `Q.coeff 0`\n  -- if `p^n.succ` divides the following multiple of `Q.coeff 0^n.succ`:\n  suffices p ^ n.succ ‚à£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n)\n    by\n    have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>\n      hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ ideal.mem_span_singleton.2 h)\n    refine' Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd hp (_ : _ ^ n.succ ‚à£ _) hndiv\n    convert (is_unit.dvd_mul_right ‚ü®(-1) ^ (n.succ * n), rfl‚ü©).mpr this using 1\n    push_cast\n    ring_nf\n    simp [pow_right_comm _ _ 2]\n  -- We claim the quotient of `Q^n * _` by `p^n` is the following `r`:\n  have aux : ‚àÄ i ‚àà (range (Q.nat_degree + 1)).erase 0, B.dim ‚â§ i + n :=\n    by\n    intro i hi\n    simp only [mem_range, mem_erase] at hi\n    rw [hn]\n    exact le_add_pred_of_pos _ hi.1\n  have hintsum :\n    is_integral R\n      (z * B.gen ^ n -\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          ((range (Q.nat_degree + 1)).erase 0) (¬´expr ‚Ä¢ ¬ª (Q.coeff x) (f (x + n)))) :=\n    by\n    refine'\n      is_integral_sub (is_integral_mul hzint (is_integral.pow hBint _))\n        (is_integral.sum _ fun i hi => is_integral_smul _ _)\n    exact adjoin_le_integral_closure hBint (hf _ (aux i hi)).1\n  obtain ‚ü®r, hr‚ü© := is_integral_iff.1 (is_integral_norm K hintsum)\n  use r\n  -- Do the computation in `K` so we can work in terms of `z` instead of `r`.\n  apply is_fraction_ring.injective R K\n  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]\n  -- Both sides are actually norms:\n  calc\n    _ = norm K (¬´expr ‚Ä¢ ¬ª (Q.coeff 0) (B.gen ^ n)) := _\n    _ =\n        norm K\n          (¬´expr ‚Ä¢ ¬ª p (z * B.gen ^ n) -\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree + 1)).erase 0) (¬´expr ‚Ä¢ ¬ª p (¬´expr ‚Ä¢ ¬ª (Q.coeff x) (f (x + n))))) :=\n      congr_arg (norm K) (eq_sub_of_add_eq _)\n    _ = _ := _\n    \n  ¬∑ simp only [algebra.smul_def, algebra_map_apply R K L, algebra.norm_algebra_map, _root_.map_mul, _root_.map_pow,\n      finrank_K_L, power_basis.norm_gen_eq_coeff_zero_minpoly, minpoly.gcd_domain_eq_field_fractions' K hBint,\n      coeff_map, ‚Üê hn]\n    ring\n  swap\n  ¬∑\n    simp_rw [‚Üê smul_sum, ‚Üê smul_sub, algebra.smul_def p, algebra_map_apply R K L, _root_.map_mul,\n      algebra.norm_algebra_map, finrank_K_L, hr, ‚Üê hn]\n  calc\n    _ =\n        (¬´expr ‚Ä¢ ¬ª (Q.coeff 0) 1 +\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree + 1)).erase 0) (¬´expr ‚Ä¢ ¬ª (Q.coeff x) (B.gen ^ x))) *\n          B.gen ^ n :=\n      _\n    _ =\n        (¬´expr ‚Ä¢ ¬ª (Q.coeff 0) (B.gen ^ 0) +\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree + 1)).erase 0) (¬´expr ‚Ä¢ ¬ª (Q.coeff x) (B.gen ^ x))) *\n          B.gen ^ n :=\n      by rw [pow_zero]\n    _ = aeval B.gen Q * B.gen ^ n := _\n    _ = _ := by rw [hQ, algebra.smul_mul_assoc]\n    \n  ¬∑ have :\n      ‚àÄ i ‚àà (range (Q.nat_degree + 1)).erase 0,\n        ¬´expr ‚Ä¢ ¬ª (Q.coeff i) (B.gen ^ i * B.gen ^ n) = ¬´expr ‚Ä¢ ¬ª p (¬´expr ‚Ä¢ ¬ª (Q.coeff i) (f (i + n))) :=\n      by\n      intro i hi\n      rw [‚Üê pow_add, ‚Üê (hf _ (aux i hi)).2, ‚Üê algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]\n    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]\n  ¬∑ rw [aeval_eq_sum_range, finset.add_sum_erase (range (Q.nat_degree + 1)) fun i => ¬´expr ‚Ä¢ ¬ª (Q.coeff i) (B.gen ^ i)]\n    simp\n#align\n  dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at\n\n",
 "cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùìü -/\ntheorem cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at [hp : fact p.prime] (n : ‚Ñï) :\n    ((cyclotomic (p ^ (n + 1)) ‚Ñ§).comp (X + 1)).is_eisenstein_at (exprùìü) :=\n  by\n  refine'\n    monic.is_eisenstein_at_of_mem_of_not_mem _\n      (ideal.is_prime.ne_top <|\n        (ideal.span_singleton_prime (by exact_mod_cast hp.out.ne_zero)).2 <| Nat.prime_iff_prime_int.1 hp.out)\n      _ _\n  ¬∑ rw [show (X + 1 : polynomial ‚Ñ§) = X + C 1 by simp]\n    refine' (cyclotomic.monic _ ‚Ñ§).comp (monic_X_add_C 1) fun h => _\n    rw [nat_degree_X_add_C] at h\n    exact zero_ne_one h.symm\n  ¬∑ induction' n with n hn\n    ¬∑ intro i hi\n      rw [zero_add, pow_one] at hi‚ä¢\n      exact (cyclotomic_comp_X_add_one_is_eisenstein_at p).mem hi\n    ¬∑ intro i hi\n      rw [ideal.submodule_span_eq, ideal.mem_span_singleton, ‚Üê zmod.int_coe_zmod_eq_zero_iff_dvd, ‚Üê Int.coe_castRingHom,\n        ‚Üê coeff_map, map_comp, map_cyclotomic, polynomial.map_add, map_X, polynomial.map_one, pow_add, pow_one,\n        cyclotomic_mul_prime_dvd_eq_pow, pow_comp, ‚Üê zmod.expand_card, coeff_expand hp.out.pos]\n      ¬∑ simp only [ite_eq_right_iff]\n        rintro ‚ü®k, hk‚ü©\n        rw [nat_degree_comp, show (X + 1 : polynomial ‚Ñ§) = X + C 1 by simp, nat_degree_X_add_C, mul_one,\n          nat_degree_cyclotomic, nat.totient_prime_pow hp.out (nat.succ_pos _), nat.succ_sub_one] at hn hi\n        rw [hk, pow_succ, mul_assoc] at hi\n        rw [hk, mul_comm, nat.mul_div_cancel _ hp.out.pos]\n        replace hn := hn (lt_of_mul_lt_mul_left' hi)\n        rw [ideal.submodule_span_eq, ideal.mem_span_singleton, ‚Üê zmod.int_coe_zmod_eq_zero_iff_dvd, ‚Üê\n          Int.coe_castRingHom, ‚Üê coeff_map] at hn\n        simpa [map_comp] using hn\n      ¬∑ exact ‚ü®p ^ n, by rw [pow_succ]‚ü©\n  ¬∑ rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime_pow_eq_geom_sum hp.out, eval_add, eval_X, eval_one,\n      zero_add, eval_finset_sum]\n    simp only [eval_pow, eval_X, one_pow, sum_const, card_range, Nat.smul_one_eq_coe, submodule_span_eq,\n      ideal.submodule_span_eq, ideal.span_singleton_pow, ideal.mem_span_singleton]\n    intro h\n    obtain ‚ü®k, hk‚ü© := Int.coe_nat_dvd.1 h\n    rw [‚Üê mul_assoc, mul_one, mul_assoc] at hk\n    nth_rw 1 [‚Üê nat.mul_one p] at hk\n    rw [mul_right_inj' hp.out.ne_zero] at hk\n    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)\n#align cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at\n\n",
 "cyclotomic_comp_X_add_one_is_eisenstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùìü -/\ntheorem cyclotomic_comp_X_add_one_is_eisenstein_at [hp : fact p.prime] :\n    ((cyclotomic p ‚Ñ§).comp (X + 1)).is_eisenstein_at (exprùìü) :=\n  by\n  refine'\n    monic.is_eisenstein_at_of_mem_of_not_mem _\n      (ideal.is_prime.ne_top <|\n        (ideal.span_singleton_prime (by exact_mod_cast hp.out.ne_zero)).2 <| Nat.prime_iff_prime_int.1 hp.out)\n      (fun i hi => _) _\n  ¬∑ rw [show (X + 1 : polynomial ‚Ñ§) = X + C 1 by simp]\n    refine' (cyclotomic.monic p ‚Ñ§).comp (monic_X_add_C 1) fun h => _\n    rw [nat_degree_X_add_C] at h\n    exact zero_ne_one h.symm\n  ¬∑ rw [cyclotomic_prime, geom_sum_X_comp_X_add_one_eq_sum, ‚Üê lcoeff_apply, linear_map.map_sum]\n    conv =>\n      congr\n      congr\n      skip\n      ext\n      rw [lcoeff_apply, ‚Üê C_eq_nat_cast, C_mul_X_pow_eq_monomial, coeff_monomial]\n    rw [nat_degree_comp, show (X + 1 : polynomial ‚Ñ§) = X + C 1 by simp, nat_degree_X_add_C, mul_one,\n      nat_degree_cyclotomic, nat.totient_prime hp.out] at hi\n    simp only [lt_of_lt_of_le hi (nat.sub_le _ _), sum_ite_eq', mem_range, if_true, ideal.submodule_span_eq,\n      ideal.mem_span_singleton]\n    exact Int.coe_nat_dvd.2 (Nat.Prime.dvd_choose_self (nat.succ_pos i) (lt_tsub_iff_right.1 hi) hp.out)\n  ¬∑ rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime, eval_add, eval_X, eval_one, zero_add, eval_geom_sum,\n      one_geom_sum, ideal.submodule_span_eq, ideal.span_singleton_pow, ideal.mem_span_singleton]\n    intro h\n    obtain ‚ü®k, hk‚ü© := Int.coe_nat_dvd.1 h\n    rw [‚Üê mul_assoc, mul_one, mul_assoc] at hk\n    nth_rw 1 [‚Üê nat.mul_one p] at hk\n    rw [mul_right_inj' hp.out.ne_zero] at hk\n    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)\n#align cyclotomic_comp_X_add_one_is_eisenstein_at cyclotomic_comp_X_add_one_is_eisenstein_at\n\n",
 "coeff_mem":
 "theorem coeff_mem {n : ‚Ñï} (hn : n ‚â† f.nat_degree) : f.coeff n ‚àà ùìü :=\n  by\n  cases ne_iff_lt_or_gt.1 hn\n  ¬∑ exact hf.mem h\n  ¬∑ rw [coeff_eq_zero_of_nat_degree_lt h]\n    exact ideal.zero_mem _\n#align coeff_mem coeff_mem\n\n",
 "Irreducible":
 "#print Irreducible /-\n/-- If a primitive `f` satisfies `f.is_eisenstein_at ùìü`, where `ùìü.is_prime`, then `f` is\nirreducible. -/\ntheorem Irreducible (hprime : ùìü.is_prime) (hu : f.is_primitive) (hfd0 : 0 < f.nat_degree) : Irreducible f :=\n  irreducible_of_eisenstein_criterion hprime hf.leading (fun n hn => hf.mem (coe_lt_degree.1 hn))\n    (nat_degree_pos_iff_degree_pos.1 hfd0) hf.not_mem hu\n#align irreducible Irreducible\n-/\n\n"}