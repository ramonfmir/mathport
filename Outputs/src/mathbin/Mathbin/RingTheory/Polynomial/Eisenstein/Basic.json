{"pow_nat_degree_le_of_root_of_monic_mem":
 "theorem pow_nat_degree_le_of_root_of_monic_mem {x : R} (hroot : IsRoot f x) (hmo : f.monic) :\n    âˆ€ i, f.nat_degree â‰¤ i â†’ x ^ i âˆˆ ğ“Ÿ := by\n  intro i hi\n  obtain âŸ¨k, hkâŸ© := exists_add_of_le hi\n  rw [hk, pow_add]\n  suffices x ^ f.nat_degree âˆˆ ğ“Ÿ by exact mul_mem_right (x ^ k) ğ“Ÿ this\n  rw [is_root.def, eval_eq_sum_range, Finset.range_add_one, Finset.sum_insert Finset.not_mem_range_self,\n    Finset.sum_range, hmo.coeff_nat_degree, one_mul] at hroot\n  rw [eq_neg_of_add_eq_zero_left hroot, neg_mem_iff]\n  refine' Submodule.sum_mem _ fun i hi => mul_mem_right _ _ (hf.mem (Fin.is_lt i))\n#align pow_nat_degree_le_of_root_of_monic_mem pow_nat_degree_le_of_root_of_monic_mem\n\n",
 "pow_nat_degree_le_of_aeval_zero_of_monic_mem_map":
 "theorem pow_nat_degree_le_of_aeval_zero_of_monic_mem_map {x : S} (hx : aeval x f = 0) (hmo : f.monic) :\n    âˆ€ i, (f.map (algebraMap R S)).nat_degree â‰¤ i â†’ x ^ i âˆˆ ğ“Ÿ.map (algebraMap R S) :=\n  by\n  suffices x ^ (f.map (algebraMap R S)).nat_degree âˆˆ ğ“Ÿ.map (algebraMap R S)\n    by\n    intro i hi\n    obtain âŸ¨k, hkâŸ© := exists_add_of_le hi\n    rw [hk, pow_add]\n    refine' mul_mem_right _ _ this\n  rw [aeval_def, evalâ‚‚_eq_eval_map, â† is_root.def] at hx\n  refine' pow_nat_degree_le_of_root_of_monic_mem (hf.map _) hx (hmo.map _) _ rfl.le\n#align pow_nat_degree_le_of_aeval_zero_of_monic_mem_map pow_nat_degree_le_of_aeval_zero_of_monic_mem_map\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/-\nCopyright (c) 2022 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\ntheorem map {A : Type v} [CommRing A] (Ï† : Â«expr â†’+* Â» R A) : (f.map Ï†).is_weakly_eisenstein_at (ğ“Ÿ.map Ï†) :=\n  by\n  refine' (is_weakly_eisenstein_at_iff _ _).2 fun n hn => _\n  rw [coeff_map]\n  exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_le hn (nat_degree_map_le _ _)))\n#align map map\n\n",
 "leading_coeff_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n#print Polynomial.IsEisensteinAt.Polynomial.Monic.leadingCoeff_not_mem /-\ntheorem Polynomial.IsEisensteinAt.Polynomial.Monic.leadingCoeff_not_mem (hf : f.monic) (h : ğ“Ÿ â‰  Â«exprâŠ¤Â») :\n    Â¬f.leading_coeff âˆˆ ğ“Ÿ :=\n  hf.leading_coeff.symm â–¸ (Ideal.ne_top_iff_one _).1 h\n#align polynomial.monic.leading_coeff_not_mem Polynomial.IsEisensteinAt.Polynomial.Monic.leadingCoeff_not_mem\n-/\n\n",
 "is_weakly_eisenstein_at":
 "theorem is_weakly_eisenstein_at : IsWeaklyEisensteinAt f ğ“Ÿ :=\n  âŸ¨fun _ => hf.memâŸ©\n#align is_weakly_eisenstein_at is_weakly_eisenstein_at\n\n",
 "is_eisenstein_at_of_mem_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n#print Polynomial.IsEisensteinAt.Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem /-\ntheorem Polynomial.IsEisensteinAt.Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem (hf : f.monic) (h : ğ“Ÿ â‰  Â«exprâŠ¤Â»)\n    (hmem : âˆ€ {n}, n < f.nat_degree â†’ f.coeff n âˆˆ ğ“Ÿ) (hnot_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2) : f.is_eisenstein_at ğ“Ÿ :=\n  { leading := hf.leading_coeff_not_mem h\n    mem := fun n hn => hmem hn\n    not_mem := hnot_mem }\n#align polynomial.monic.is_eisenstein_at_of_mem_of_not_mem Polynomial.IsEisensteinAt.Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem\n-/\n\n",
 "exists_mem_adjoin_mul_eq_pow_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprP -/\ntheorem exists_mem_adjoin_mul_eq_pow_nat_degree_le {x : S} (hx : aeval x f = 0) (hmo : f.monic)\n    (hf : f.is_weakly_eisenstein_at (exprP)) :\n    âˆ€ i, (f.map (algebraMap R S)).nat_degree â‰¤ i â†’ âˆƒ y âˆˆ adjoin R ({x} : Set S), (algebraMap R S) p * y = x ^ i :=\n  by\n  intro i hi\n  obtain âŸ¨k, hkâŸ© := exists_add_of_le hi\n  rw [hk, pow_add]\n  obtain âŸ¨y, hy, HâŸ© := exists_mem_adjoin_mul_eq_pow_nat_degree hx hmo hf\n  refine' âŸ¨y * x ^ k, _, _âŸ©\n  Â· exact Subalgebra.mul_mem _ hy (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _)\n  Â· rw [â† mul_assoc _ y, H]\n#align exists_mem_adjoin_mul_eq_pow_nat_degree_le exists_mem_adjoin_mul_eq_pow_nat_degree_le\n\n",
 "exists_mem_adjoin_mul_eq_pow_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprP -/\ntheorem exists_mem_adjoin_mul_eq_pow_nat_degree {x : S} (hx : aeval x f = 0) (hmo : f.monic)\n    (hf : f.is_weakly_eisenstein_at (exprP)) :\n    âˆƒ y âˆˆ adjoin R ({x} : Set S), (algebraMap R S) p * y = x ^ (f.map (algebraMap R S)).nat_degree :=\n  by\n  rw [aeval_def, Polynomial.evalâ‚‚_eq_eval_map, eval_eq_sum_range, range_add_one, sum_insert not_mem_range_self,\n    sum_range, (hmo.map (algebraMap R S)).coeff_nat_degree, one_mul] at hx\n  replace hx := eq_neg_of_add_eq_zero_left hx\n  have : âˆ€ n < f.nat_degree, p âˆ£ f.coeff n := by\n    intro n hn\n    refine' mem_span_singleton.1 (by simpa using hf.mem hn)\n  choose! Ï† hÏ† using this\n  conv_rhs at hx =>\n    congr\n    congr\n    skip\n    ext\n    rw [[anonymous], coeff_map, hÏ† i.1 (lt_of_lt_of_le i.2 (nat_degree_map_le _ _)), RingHom.map_mul, mul_assoc]\n  rw [hx, â† mul_sum, neg_eq_neg_one_mul, â† mul_assoc (-1 : S), mul_comm (-1 : S), mul_assoc]\n  refine'\n    âŸ¨-1 *\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          ((algebraMap R S) (Ï† i.1) * x ^ i.1),\n      _, rflâŸ©\n  exact\n    Subalgebra.mul_mem _ (Subalgebra.neg_mem _ (Subalgebra.one_mem _))\n      (Subalgebra.sum_mem _ fun i hi =>\n        Subalgebra.mul_mem _ (Subalgebra.algebraMap_mem _ _)\n          (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _))\n#align exists_mem_adjoin_mul_eq_pow_nat_degree exists_mem_adjoin_mul_eq_pow_nat_degree\n\n",
 "dvd_pow_nat_degree_of_evalâ‚‚_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem dvd_pow_nat_degree_of_evalâ‚‚_eq_zero {f : Â«expr â†’+* Â» R A} (hf : function.injective f) {p : polynomial R}\n    (hp : p.monic) (x y : R) (z : A) (h : p.evalâ‚‚ f z = 0) (hz : f x * z = f y) : x âˆ£ y ^ p.nat_degree :=\n  by\n  rw [â† nat_degree_scale_roots p x, â† Ideal.mem_span_singleton]\n  refine'\n    (scale_roots.is_weakly_eisenstein_at _\n          (ideal.mem_span_singleton.mpr <| dvd_refl x)).pow_nat_degree_le_of_root_of_monic_mem\n      _ ((monic_scale_roots_iff x).mpr hp) _ le_rfl\n  rw [injective_iff_map_eq_zero'] at hf\n  have := scale_roots_evalâ‚‚_eq_zero f h\n  rwa [hz, Polynomial.evalâ‚‚_at_apply, hf] at this\n#align dvd_pow_nat_degree_of_evalâ‚‚_eq_zero dvd_pow_nat_degree_of_evalâ‚‚_eq_zero\n\n",
 "dvd_pow_nat_degree_of_aeval_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem dvd_pow_nat_degree_of_aeval_eq_zero [Algebra R A] [Nontrivial A] [NoZeroSMulDivisors R A] {p : polynomial R}\n    (hp : p.monic) (x y : R) (z : A) (h : Polynomial.aeval z p = 0) (hz : z * algebraMap R A x = algebraMap R A y) :\n    x âˆ£ y ^ p.nat_degree :=\n  dvd_pow_natDegree_of_evalâ‚‚_eq_zero (NoZeroSMulDivisors.algebraMap_injective R A) hp x y z h ((mul_comm _ _).trans hz)\n#align dvd_pow_nat_degree_of_aeval_eq_zero dvd_pow_nat_degree_of_aeval_eq_zero\n\n",
 "coeff_mem":
 "theorem coeff_mem {n : â„•} (hn : n â‰  f.nat_degree) : f.coeff n âˆˆ ğ“Ÿ :=\n  by\n  cases ne_iff_lt_or_gt.1 hn\n  Â· exact hf.mem h\n  Â· rw [coeff_eq_zero_of_nat_degree_lt h]\n    exact Ideal.zero_mem _\n#align coeff_mem coeff_mem\n\n",
 "Irreducible":
 "#print Irreducible /-\n/-- If a primitive `f` satisfies `f.is_eisenstein_at ğ“Ÿ`, where `ğ“Ÿ.is_prime`, then `f` is\nirreducible. -/\ntheorem Irreducible (hprime : ğ“Ÿ.is_prime) (hu : f.is_primitive) (hfd0 : 0 < f.nat_degree) : Irreducible f :=\n  irreducible_of_eisenstein_criterion hprime hf.leading (fun n hn => hf.mem (coe_lt_degree.1 hn))\n    (natDegree_pos_iff_degree_pos.1 hfd0) hf.not_mem hu\n#align irreducible Irreducible\n-/\n\n"}