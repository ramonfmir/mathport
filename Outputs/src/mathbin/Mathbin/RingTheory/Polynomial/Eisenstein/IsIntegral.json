{"mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr %‚Çò ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùìü -/\n/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p ‚Ä¢ z ‚àà adjoin R {B.gen}`, then\n`z ‚àà adjoin R {B.gen}`. -/\ntheorem mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at {B : power_basis K L} (hp : Prime p)\n    (hBint : is_integral R B.gen) {z : L} (hzint : is_integral R z) (hz : ¬´expr ‚Ä¢ ¬ª p z ‚àà adjoin R ({B.gen} : Set L))\n    (hei : (minpoly R B.gen).is_eisenstein_at (exprùìü)) : z ‚àà adjoin R ({B.gen} : Set L) :=\n  by\n  -- First define some abbreviations.\n  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>\n    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)\n  letI := FiniteDimensional B\n  set P := minpoly R B.gen with hP\n  obtain ‚ü®n, hn‚ü© := nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'\n  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans R K L\n  let P‚ÇÅ := P.map (algebraMap R L)\n  -- There is a polynomial `Q` such that `p ‚Ä¢ z = aeval B.gen Q`. We can assume that\n  -- `Q.degree < P.degree` and `Q ‚â† 0`.\n  rw [adjoin_singleton_eq_range_aeval] at hz\n  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz\n  set Q := ¬´expr %‚Çò ¬ª Q‚ÇÅ P with hQ‚ÇÅ\n  replace hQ : aeval B.gen Q = ¬´expr ‚Ä¢ ¬ª p z\n  ¬∑ rw [‚Üê mod_by_monic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ\n    simpa using hQ\n  by_cases hQzero : Q = 0\n  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ\n    cases' hQ with H H‚ÇÅ\n    ¬∑ have : function.injective (algebraMap R L) :=\n        by\n        rw [algebra_map_eq R K L]\n        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)\n      exfalso\n      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)\n    ¬∑ rw [H‚ÇÅ]\n      exact Subalgebra.zero_mem _\n  -- It is enough to prove that all coefficients of `Q` are divisible by `p`, by induction.\n  -- The base case is `dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at`.\n  refine' mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => _) hQ\n  refine' nat.case_strong_induction_on i _ fun j hind => _\n  ¬∑ intro H\n    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at hp hBint hQ hzint hei\n  ¬∑ intro hj\n    refine' hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd _ hndiv\n    exact n\n    -- Two technical results we will need about `P.nat_degree` and `Q.nat_degree`.\n    have H := degree_mod_by_monic_lt Q‚ÇÅ (minpoly.monic hBint)\n    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H\n    replace H :=\n      Nat.lt_iff_add_one_le.1\n        (lt_of_lt_of_le\n          (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (nat.lt_of_succ_lt_succ (mem_range.1 hj))) (lt_succ_self _))\n          (Nat.lt_iff_add_one_le.1 ((nat_degree_lt_nat_degree_iff hQzero).2 H)))\n    rw [add_assoc] at H\n    have Hj : Q.nat_degree + 1 = j + 1 + (Q.nat_degree - j) := by\n      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj, ‚Üê\n        nat.add_sub_assoc (nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm, nat.add_sub_cancel]\n    -- By induction hypothesis we can find `g : ‚Ñï ‚Üí R` such that\n    -- `k ‚àà range (j + 1) ‚Üí Q.coeff k ‚Ä¢ B.gen ^ k = (algebra_map R L) p * g k ‚Ä¢ B.gen ^ k`-\n    choose! g hg using hind\n    replace hg : ‚àÄ k ‚àà range (j + 1), ¬´expr ‚Ä¢ ¬ª (Q.coeff k) (B.gen ^ k) = algebraMap R L p * ¬´expr ‚Ä¢ ¬ª (g k) (B.gen ^ k)\n    ¬∑ intro k hk\n      rw [hg k (mem_range_succ_iff.1 hk)\n          (mem_range_succ_iff.2 (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),\n        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]\n    -- Since `minpoly R B.gen` is Eiseinstein, we can find `f : ‚Ñï ‚Üí L` such that\n    -- `(map (algebra_map R L) (minpoly R B.gen)).nat_degree ‚â§ i` implies `f i ‚àà adjoin R {B.gen}`\n    -- and `(algebra_map R L) p * f i = B.gen ^ i`. We will also need `hf‚ÇÅ`, a reformulation of this\n    -- property.\n    choose! f hf using\n      is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le (minpoly.aeval R B.gen) (minpoly.monic hBint)\n        hei.is_weakly_eisenstein_at\n    have hf‚ÇÅ :\n      ‚àÄ k ‚àà (range (Q.nat_degree - j)).erase 0,\n        ¬´expr ‚Ä¢ ¬ª (Q.coeff (j + 1 + k)) (B.gen ^ (j + 1 + k)) * B.gen ^ (P.nat_degree - (j + 2)) =\n          (algebraMap R L) p * ¬´expr ‚Ä¢ ¬ª (Q.coeff (j + 1 + k)) (f (k + P.nat_degree - 1)) :=\n      by\n      intro k hk\n      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê nat.add_sub_assoc H, ‚Üê add_assoc j 1 1, add_comm (j + 1) 1, add_assoc (j + 1),\n        add_comm _ (k + P.nat_degree), nat.add_sub_add_right, ‚Üê (hf (k + P.nat_degree - 1) _).2, mul_smul_comm]\n      rw [(minpoly.monic hBint).nat_degree_map, add_comm, nat.add_sub_assoc, le_add_iff_nonneg_right]\n      ¬∑ exact nat.zero_le _\n      ¬∑ refine' one_le_iff_ne_zero.2 fun h => _\n        rw [h] at hk\n        simpa using hk\n      ¬∑ infer_instance\n    -- The Eisenstein condition shows that `p` divides `Q.coeff j`\n    -- if `p^n.succ` divides the following multiple of `Q.coeff (succ j)^n.succ`:\n    suffices p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ * (minpoly R B.gen).coeff 0 ^ (succ j + (P.nat_degree - (j + 2)))\n      by\n      convert this\n      rw [nat.succ_eq_add_one, add_assoc, ‚Üê nat.add_sub_assoc H, ‚Üê add_assoc, add_comm (j + 1), nat.add_sub_add_left, ‚Üê\n        nat.add_sub_assoc, nat.add_sub_add_left, hP, ‚Üê (minpoly.monic hBint).nat_degree_map (algebraMap R K), ‚Üê\n        minpoly.is_integrally_closed_eq_field_fractions' K hBint, nat_degree_minpoly, hn, nat.sub_one, nat.pred_succ]\n      linarith\n    -- Using `hQ : aeval B.gen Q = p ‚Ä¢ z`, we write `p ‚Ä¢ z` as a sum of terms of degree less than\n    -- `j+1`, that are multiples of `p` by induction, and terms of degree at least `j+1`.\n    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_add_left_embedding _ _), sum_congr rfl hg,\n      add_comm] at hQ\n    -- We multiply this equality by `B.gen ^ (P.nat_degree-(j+2))`, so we can use `hf‚ÇÅ` on the terms\n    -- we didn't know were multiples of `p`, and we take the norm on both sides.\n    replace hQ := congr_arg (fun x => x * B.gen ^ (P.nat_degree - (j + 2))) hQ\n    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ\n    rw [‚Üê insert_erase (mem_range.2 (tsub_pos_iff_lt.2 <| nat.lt_of_succ_lt_succ <| mem_range.1 hj)),\n      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc, ‚Üê mul_add,\n      smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ\n    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)\n    -- We obtain an equality of elements of `K`, but everything is integral, so we can move to `R`\n    -- and simplify `hQ`.\n    have hintsum :\n      is_integral R\n        (z * B.gen ^ (P.nat_degree - (j + 2)) -\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree - j)).erase 0) (¬´expr ‚Ä¢ ¬ª (Q.coeff (j + 1 + x)) (f (x + P.nat_degree - 1))) +\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (range (j + 1)) (¬´expr ‚Ä¢ ¬ª (g x) (B.gen ^ x) * B.gen ^ (P.nat_degree - (j + 2))))) :=\n      by\n      refine'\n        is_integral_sub (is_integral_mul hzint (is_integral.pow hBint _))\n          (is_integral_add (is_integral.sum _ fun k hk => is_integral_smul _ _)\n            (is_integral.sum _ fun k hk =>\n              is_integral_mul (is_integral_smul _ (is_integral.pow hBint _)) (is_integral.pow hBint _)))\n      refine' adjoin_le_integral_closure hBint (hf _ _).1\n      rw [(minpoly.monic hBint).nat_degree_map (algebraMap R L)]\n      rw [add_comm, nat.add_sub_assoc, le_add_iff_nonneg_right]\n      ¬∑ exact zero_le _\n      ¬∑ refine' one_le_iff_ne_zero.2 fun h => _\n        rw [h] at hk\n        simpa using hk\n    obtain ‚ü®r, hr‚ü© := is_integral_iff.1 (is_integral_norm K hintsum)\n    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebraMap_apply R K L, map_pow,\n      algebra.norm_algebra_map, _root_.map_mul, algebraMap_apply R K L, algebra.norm_algebra_map, finrank B, ‚Üê hr,\n      power_basis.norm_gen_eq_coeff_zero_minpoly, minpoly.is_integrally_closed_eq_field_fractions' K hBint, coeff_map,\n      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul,\n      ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ\n    -- We can now finish the proof.\n    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _\n    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê Units.val_pow_eq_pow_val, ‚Üê\n      Units.val_pow_eq_pow_val, mul_assoc, IsUnit.dvd_mul_left _ _ _ ‚ü®_, rfl‚ü©, mul_comm, ‚Üê nat.succ_eq_add_one, hn] at\n      hppdiv\n#align mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at\n\n",
 "mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùìü -/\n/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p ^ n ‚Ä¢ z ‚àà adjoin R {B.gen}`,\nthen `z ‚àà adjoin R {B.gen}`. Together with `algebra.discr_mul_is_integral_mem_adjoin` this result\noften allows to compute the ring of integers of `L`. -/\ntheorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at {B : power_basis K L} (hp : Prime p)\n    (hBint : is_integral R B.gen) {n : ‚Ñï} {z : L} (hzint : is_integral R z)\n    (hz : ¬´expr ‚Ä¢ ¬ª (p ^ n) z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).is_eisenstein_at (exprùìü)) :\n    z ‚àà adjoin R ({B.gen} : Set L) := by\n  induction' n with n hn\n  ¬∑ simpa using hz\n  ¬∑ rw [pow_succ, mul_smul] at hz\n    exact hn (mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at hp hBint (is_integral_smul _ hzint) hz hei)\n#align mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at\n\n",
 "mem_adjoin_of_dvd_coeff_of_dvd_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem mem_adjoin_of_dvd_coeff_of_dvd_aeval {A B : Type _} [CommSemiring A] [CommRing B] [Algebra A B]\n    [NoZeroSMulDivisors A B] {Q : polynomial A} {p : A} {x z : B} (hp : p ‚â† 0)\n    (hQ : ‚àÄ i ‚àà range (Q.nat_degree + 1), p ‚à£ Q.coeff i) (hz : aeval x Q = ¬´expr ‚Ä¢ ¬ª p z) :\n    z ‚àà adjoin A ({x} : Set B) := by\n  choose! f hf using hQ\n  rw [aeval_eq_sum_range, sum_range] at hz\n  conv_lhs at hz =>\n    congr\n    skip\n    ext\n    rw [hf i (mem_range.2 (Fin.is_lt i)), ‚Üê smul_smul]\n  rw [‚Üê smul_sum] at hz\n  rw [‚Üê smul_right_injective _ hp hz]\n  exact\n    Subalgebra.sum_mem _ fun _ _ =>\n      Subalgebra.smul_mem _ (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _) _\n#align mem_adjoin_of_dvd_coeff_of_dvd_aeval mem_adjoin_of_dvd_coeff_of_dvd_aeval\n\n",
 "dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùìü -/\n/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `Q : R[X]` is such that\n`aeval B.gen Q = p ‚Ä¢ z`, then `p ‚à£ Q.coeff 0`. -/\ntheorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at {B : power_basis K L} (hp : Prime p)\n    (hBint : is_integral R B.gen) {z : L} {Q : polynomial R} (hQ : aeval B.gen Q = ¬´expr ‚Ä¢ ¬ª p z)\n    (hzint : is_integral R z) (hei : (minpoly R B.gen).is_eisenstein_at (exprùìü)) : p ‚à£ Q.coeff 0 :=\n  by\n  -- First define some abbreviations.\n  letI := B.finite_dimensional\n  let P := minpoly R B.gen\n  obtain ‚ü®n, hn‚ü© := nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'\n  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank\n  have deg_K_P : (minpoly K B.gen).nat_degree = B.dim := B.nat_degree_minpoly\n  have deg_R_P : P.nat_degree = B.dim := by\n    rw [‚Üê deg_K_P, minpoly.is_integrally_closed_eq_field_fractions' K hBint,\n      (minpoly.monic hBint).nat_degree_map (algebraMap R K)]\n  choose! f hf using\n    hei.is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le (minpoly.aeval R B.gen) (minpoly.monic hBint)\n  simp only [(minpoly.monic hBint).nat_degree_map, deg_R_P] at hf\n  -- The Eisenstein condition shows that `p` divides `Q.coeff 0`\n  -- if `p^n.succ` divides the following multiple of `Q.coeff 0^n.succ`:\n  suffices p ^ n.succ ‚à£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n)\n    by\n    have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>\n      hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)\n    refine' Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd hp (_ : _ ^ n.succ ‚à£ _) hndiv\n    convert(IsUnit.dvd_mul_right ‚ü®(-1) ^ (n.succ * n), rfl‚ü©).mpr this using 1\n    push_cast\n    ring_nf\n    simp [pow_right_comm _ _ 2]\n  -- We claim the quotient of `Q^n * _` by `p^n` is the following `r`:\n  have aux : ‚àÄ i ‚àà (range (Q.nat_degree + 1)).erase 0, B.dim ‚â§ i + n :=\n    by\n    intro i hi\n    simp only [mem_range, mem_erase] at hi\n    rw [hn]\n    exact le_add_pred_of_pos _ hi.1\n  have hintsum :\n    is_integral R\n      (z * B.gen ^ n -\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          ((range (Q.nat_degree + 1)).erase 0) (¬´expr ‚Ä¢ ¬ª (Q.coeff x) (f (x + n)))) :=\n    by\n    refine'\n      is_integral_sub (is_integral_mul hzint (is_integral.pow hBint _))\n        (is_integral.sum _ fun i hi => is_integral_smul _ _)\n    exact adjoin_le_integral_closure hBint (hf _ (aux i hi)).1\n  obtain ‚ü®r, hr‚ü© := is_integral_iff.1 (is_integral_norm K hintsum)\n  use r\n  -- Do the computation in `K` so we can work in terms of `z` instead of `r`.\n  apply IsFractionRing.injective R K\n  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]\n  -- Both sides are actually norms:\n  calc\n    _ = norm K (¬´expr ‚Ä¢ ¬ª (Q.coeff 0) (B.gen ^ n)) := _\n    _ =\n        norm K\n          (¬´expr ‚Ä¢ ¬ª p (z * B.gen ^ n) -\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree + 1)).erase 0) (¬´expr ‚Ä¢ ¬ª p (¬´expr ‚Ä¢ ¬ª (Q.coeff x) (f (x + n))))) :=\n      (congr_arg (norm K) (eq_sub_of_add_eq _))\n    _ = _ := _\n    \n  ¬∑ simp only [Algebra.smul_def, algebraMap_apply R K L, algebra.norm_algebra_map, _root_.map_mul, _root_.map_pow,\n      finrank_K_L, power_basis.norm_gen_eq_coeff_zero_minpoly, minpoly.is_integrally_closed_eq_field_fractions' K hBint,\n      coeff_map, ‚Üê hn]\n    ring\n  swap\n  ¬∑\n    simp_rw [‚Üê smul_sum, ‚Üê smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,\n      algebra.norm_algebra_map, finrank_K_L, hr, ‚Üê hn]\n  calc\n    _ =\n        (¬´expr ‚Ä¢ ¬ª (Q.coeff 0) 1 +\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree + 1)).erase 0) (¬´expr ‚Ä¢ ¬ª (Q.coeff x) (B.gen ^ x))) *\n          B.gen ^ n :=\n      _\n    _ =\n        (¬´expr ‚Ä¢ ¬ª (Q.coeff 0) (B.gen ^ 0) +\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              ((range (Q.nat_degree + 1)).erase 0) (¬´expr ‚Ä¢ ¬ª (Q.coeff x) (B.gen ^ x))) *\n          B.gen ^ n :=\n      by rw [pow_zero]\n    _ = aeval B.gen Q * B.gen ^ n := _\n    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]\n    \n  ¬∑ have :\n      ‚àÄ i ‚àà (range (Q.nat_degree + 1)).erase 0,\n        ¬´expr ‚Ä¢ ¬ª (Q.coeff i) (B.gen ^ i * B.gen ^ n) = ¬´expr ‚Ä¢ ¬ª p (¬´expr ‚Ä¢ ¬ª (Q.coeff i) (f (i + n))) :=\n      by\n      intro i hi\n      rw [‚Üê pow_add, ‚Üê (hf _ (aux i hi)).2, ‚Üê Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]\n    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]\n  ¬∑ rw [aeval_eq_sum_range, Finset.add_sum_erase (range (Q.nat_degree + 1)) fun i => ¬´expr ‚Ä¢ ¬ª (Q.coeff i) (B.gen ^ i)]\n    simp\n#align dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at\n\n",
 "cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùìü -/\ntheorem cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at [hp : Fact p.prime] (n : ‚Ñï) :\n    ((cyclotomic (p ^ (n + 1)) ‚Ñ§).comp (X + 1)).is_eisenstein_at (exprùìü) :=\n  by\n  refine'\n    monic.is_eisenstein_at_of_mem_of_not_mem _\n      (Ideal.IsPrime.ne_top <|\n        (Ideal.span_singleton_prime (by exact_mod_cast hp.out.ne_zero)).2 <| Nat.prime_iff_prime_int.1 hp.out)\n      _ _\n  ¬∑ rw [show (X + 1 : polynomial ‚Ñ§) = X + C 1 by simp]\n    refine' (cyclotomic.monic _ ‚Ñ§).comp (monic_X_add_C 1) fun h => _\n    rw [nat_degree_X_add_C] at h\n    exact zero_ne_one h.symm\n  ¬∑ induction' n with n hn\n    ¬∑ intro i hi\n      rw [zero_add, pow_one] at hi‚ä¢\n      exact (cyclotomic_comp_X_add_one_is_eisenstein_at p).mem hi\n    ¬∑ intro i hi\n      rw [Ideal.submodule_span_eq, Ideal.mem_span_singleton, ‚Üê ZMod.int_cast_zmod_eq_zero_iff_dvd, ‚Üê\n        Int.coe_castRingHom, ‚Üê coeff_map, map_comp, map_cyclotomic, Polynomial.map_add, map_X, Polynomial.map_one,\n        pow_add, pow_one, cyclotomic_mul_prime_dvd_eq_pow, pow_comp, ‚Üê zmod.expand_card, coeff_expand hp.out.pos]\n      ¬∑ simp only [ite_eq_right_iff]\n        rintro ‚ü®k, hk‚ü©\n        rw [nat_degree_comp, show (X + 1 : polynomial ‚Ñ§) = X + C 1 by simp, nat_degree_X_add_C, mul_one,\n          nat_degree_cyclotomic, Nat.totient_prime_pow hp.out (nat.succ_pos _), nat.succ_sub_one] at hn hi\n        rw [hk, pow_succ, mul_assoc] at hi\n        rw [hk, mul_comm, nat.mul_div_cancel _ hp.out.pos]\n        replace hn := hn (lt_of_mul_lt_mul_left' hi)\n        rw [Ideal.submodule_span_eq, Ideal.mem_span_singleton, ‚Üê ZMod.int_cast_zmod_eq_zero_iff_dvd, ‚Üê\n          Int.coe_castRingHom, ‚Üê coeff_map] at hn\n        simpa [map_comp] using hn\n      ¬∑ exact ‚ü®p ^ n, by rw [pow_succ]‚ü©\n  ¬∑ rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime_pow_eq_geom_sum hp.out, eval_add, eval_X, eval_one,\n      zero_add, eval_finset_sum]\n    simp only [eval_pow, eval_X, one_pow, sum_const, card_range, Nat.smul_one_eq_coe, submodule_span_eq,\n      Ideal.submodule_span_eq, Ideal.span_singleton_pow, Ideal.mem_span_singleton]\n    intro h\n    obtain ‚ü®k, hk‚ü© := Int.coe_nat_dvd.1 h\n    rw [‚Üê mul_assoc, mul_one, mul_assoc] at hk\n    nth_rw 1 [‚Üê nat.mul_one p] at hk\n    rw [mul_right_inj' hp.out.ne_zero] at hk\n    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)\n#align cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at\n\n",
 "cyclotomic_comp_X_add_one_is_eisenstein_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùìü -/\n/-\nCopyright (c) 2022 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\ntheorem cyclotomic_comp_X_add_one_is_eisenstein_at [hp : Fact p.prime] :\n    ((cyclotomic p ‚Ñ§).comp (X + 1)).is_eisenstein_at (exprùìü) :=\n  by\n  refine'\n    monic.is_eisenstein_at_of_mem_of_not_mem _\n      (Ideal.IsPrime.ne_top <|\n        (Ideal.span_singleton_prime (by exact_mod_cast hp.out.ne_zero)).2 <| Nat.prime_iff_prime_int.1 hp.out)\n      (fun i hi => _) _\n  ¬∑ rw [show (X + 1 : polynomial ‚Ñ§) = X + C 1 by simp]\n    refine' (cyclotomic.monic p ‚Ñ§).comp (monic_X_add_C 1) fun h => _\n    rw [nat_degree_X_add_C] at h\n    exact zero_ne_one h.symm\n  ¬∑ rw [cyclotomic_prime, geom_sum_X_comp_X_add_one_eq_sum, ‚Üê lcoeff_apply, LinearMap.map_sum]\n    conv =>\n      congr\n      congr\n      skip\n      ext\n      rw [lcoeff_apply, ‚Üê C_eq_nat_cast, C_mul_X_pow_eq_monomial, coeff_monomial]\n    rw [nat_degree_comp, show (X + 1 : polynomial ‚Ñ§) = X + C 1 by simp, nat_degree_X_add_C, mul_one,\n      nat_degree_cyclotomic, Nat.totient_prime hp.out] at hi\n    simp only [hi.trans_le (nat.sub_le _ _), sum_ite_eq', mem_range, if_true, Ideal.submodule_span_eq,\n      Ideal.mem_span_singleton, Int.coe_nat_dvd]\n    exact hp.out.dvd_choose_self i.succ_ne_zero (lt_tsub_iff_right.1 hi)\n  ¬∑ rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime, eval_add, eval_X, eval_one, zero_add, eval_geom_sum,\n      one_geom_sum, Ideal.submodule_span_eq, Ideal.span_singleton_pow, Ideal.mem_span_singleton]\n    intro h\n    obtain ‚ü®k, hk‚ü© := Int.coe_nat_dvd.1 h\n    rw [‚Üê mul_assoc, mul_one, mul_assoc] at hk\n    nth_rw 1 [‚Üê nat.mul_one p] at hk\n    rw [mul_right_inj' hp.out.ne_zero] at hk\n    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)\n#align cyclotomic_comp_X_add_one_is_eisenstein_at cyclotomic_comp_X_add_one_is_eisenstein_at\n\n"}