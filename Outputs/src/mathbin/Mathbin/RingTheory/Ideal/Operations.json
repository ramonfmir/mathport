{"zero_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem zero_eq_bot : (0 : Ideal R) = «expr⊥» :=\n  rfl\n#align zero_eq_bot zero_eq_bot\n\n",
 "top_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_smul : «expr • » («expr⊤» : Ideal R) N = N :=\n  le_antisymm smul_le_right fun r hri => one_smul R r ▸ smul_mem_smul mem_top hri\n#align top_smul top_smul\n\n",
 "top_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem top_pow (n : ℕ) : («expr⊤» ^ n : Ideal R) = «expr⊤» :=\n  nat.rec_on n one_eq_top fun n ih => by rw [pow_succ, ih, top_mul]\n#align top_pow top_pow\n\n",
 "top_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_mul : «expr⊤» * I = I :=\n  Submodule.top_smul I\n#align top_mul top_mul\n\n",
 "sup_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sup_smul : «expr • » («expr ⊔ » I J) N = «expr ⊔ » («expr • » I N) («expr • » J N) :=\n  map₂_sup_left _ _ _ _\n#align sup_smul sup_smul\n\n",
 "sup_prod_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem sup_prod_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → «expr ⊔ » I (J i) = «expr⊤») :\n    «expr ⊔ » I\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (J i)) =\n      «expr⊤» :=\n  Finset.prod_induction _ (fun J => «expr ⊔ » I J = «expr⊤») (fun J K hJ hK => (sup_mul_eq_of_coprime_left hJ).trans hK)\n    (by rw [one_eq_top, sup_top_eq]) h\n#align sup_prod_eq_top sup_prod_eq_top\n\n",
 "sup_pow_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem sup_pow_eq_top {n : ℕ} (h : «expr ⊔ » I J = «expr⊤») : «expr ⊔ » I (J ^ n) = «expr⊤» :=\n  by\n  rw [← Finset.card_range n, ← Finset.prod_const]\n  exact sup_prod_eq_top fun _ _ => h\n#align sup_pow_eq_top sup_pow_eq_top\n\n",
 "sup_mul_right_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_mul_right_self : «expr ⊔ » I (I * J) = I :=\n  sup_eq_left.2 Ideal.mul_le_right\n#align sup_mul_right_self sup_mul_right_self\n\n",
 "sup_mul_left_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_mul_left_self : «expr ⊔ » I (J * I) = I :=\n  sup_eq_left.2 Ideal.mul_le_left\n#align sup_mul_left_self sup_mul_left_self\n\n",
 "sup_mul_eq_of_coprime_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_mul_eq_of_coprime_right (h : «expr ⊔ » I K = «expr⊤») : «expr ⊔ » I (J * K) = «expr ⊔ » I J :=\n  by\n  rw [mul_comm]\n  exact sup_mul_eq_of_coprime_left h\n#align sup_mul_eq_of_coprime_right sup_mul_eq_of_coprime_right\n\n",
 "sup_mul_eq_of_coprime_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_mul_eq_of_coprime_left (h : «expr ⊔ » I J = «expr⊤») : «expr ⊔ » I (J * K) = «expr ⊔ » I K :=\n  le_antisymm (sup_le_sup_left mul_le_left _) fun i hi =>\n    by\n    rw [eq_top_iff_one] at h; rw [Submodule.mem_sup] at h hi⊢\n    obtain ⟨i1, hi1, j, hj, h⟩ := h; obtain ⟨i', hi', k, hk, hi⟩ := hi\n    refine' ⟨_, add_mem hi' (mul_mem_right k _ hi1), _, mul_mem_mul hj hk, _⟩\n    rw [add_assoc, ← add_mul, h, one_mul, hi]\n#align sup_mul_eq_of_coprime_left sup_mul_eq_of_coprime_left\n\n",
 "sup_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print sup_mul /-\ntheorem sup_mul : «expr ⊔ » I J * K = «expr ⊔ » (I * K) (J * K) :=\n  Submodule.sup_smul I J K\n#align sup_mul sup_mul\n-/\n\n",
 "sup_infi_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem sup_infi_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → «expr ⊔ » I (J i) = «expr⊤») :\n    «expr ⊔ » I\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (J i)) =\n      «expr⊤» :=\n  eq_top_iff.mpr <|\n    le_of_eq_of_le (sup_prod_eq_top h).symm <| sup_le_sup_left (le_of_le_of_eq prod_le_inf <| Finset.inf_eq_infᵢ _ _) _\n#align sup_infi_eq_top sup_infi_eq_top\n\n",
 "sup_eq_top_iff_is_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem sup_eq_top_iff_is_coprime {R : Type _} [CommSemiring R] (x y : R) :\n    «expr ⊔ » (span ({x} : Set R)) (span {y}) = «expr⊤» ↔ IsCoprime x y :=\n  by\n  rw [eq_top_iff_one, Submodule.mem_sup]\n  constructor\n  · rintro ⟨u, hu, v, hv, h1⟩\n    rw [mem_span_singleton'] at hu hv\n    rw [← hu.some_spec, ← hv.some_spec] at h1\n    exact ⟨_, _, h1⟩\n  · exact fun ⟨u, v, h1⟩ => ⟨_, mem_span_singleton'.mpr ⟨_, rfl⟩, _, mem_span_singleton'.mpr ⟨_, rfl⟩, h1⟩\n#align sup_eq_top_iff_is_coprime sup_eq_top_iff_is_coprime\n\n",
 "sum_eq_sup":
 "@[simp]\ntheorem sum_eq_sup {ι : Type _} (s : Finset ι) (f : ι → Ideal R) : s.sum f = s.sup f :=\n  rfl\n#align sum_eq_sup sum_eq_sup\n\n",
 "subset_union_prime'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:564:6: unsupported: specialize @hyp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:564:6: unsupported: specialize @hyp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:564:6: unsupported: specialize @hyp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} {a b : ι}\n    (hp : ∀ i ∈ s, IsPrime (f i)) {I : Ideal R} :\n    (I : Set R) ⊆\n        f a ∪ f b ∪\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i) ↔\n      I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i :=\n  by\n  suffices\n    (I : Set R) ⊆\n        f a ∪ f b ∪\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i) →\n      I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i\n    from\n    ⟨this, fun h =>\n      or.cases_on h\n        (fun h => Set.Subset.trans h <| Set.Subset.trans (Set.subset_union_left _ _) (Set.subset_union_left _ _))\n        fun h =>\n        or.cases_on h\n          (fun h => Set.Subset.trans h <| Set.Subset.trans (Set.subset_union_right _ _) (Set.subset_union_left _ _))\n          fun ⟨i, his, hi⟩ => by\n          refine' Set.Subset.trans hi <| Set.Subset.trans _ <| Set.subset_union_right _ _ <;>\n            exact Set.subset_bunionᵢ_of_mem (Finset.mem_coe.2 his)⟩\n  generalize hn : s.card = n; intro h\n  induction' n with n ih generalizing a b s\n  · clear hp\n    rw [Finset.card_eq_zero] at hn\n    subst hn\n    rw [Finset.coe_empty, Set.bunionᵢ_empty, Set.union_empty, subset_union] at h\n    simpa only [exists_prop, Finset.not_mem_empty, false_and_iff, exists_false, or_false_iff]\n  classical\n    replace hn : ∃ (i : ι)(t : Finset ι), i ∉ t ∧ insert i t = s ∧ t.card = n := Finset.card_eq_succ.1 hn\n    rcases hn with ⟨i, t, hit, rfl, hn⟩\n    replace hp : is_prime (f i) ∧ ∀ x ∈ t, is_prime (f x) := (t.forall_mem_insert _ _).1 hp\n    by_cases Ht : ∃ j ∈ t, f j ≤ f i\n    · obtain ⟨j, hjt, hfji⟩ : ∃ j ∈ t, f j ≤ f i := Ht\n      obtain ⟨u, hju, rfl⟩ : ∃ u, j ∉ u ∧ insert j u = t := ⟨t.erase j, t.not_mem_erase j, Finset.insert_erase hjt⟩\n      have hp' : ∀ k ∈ insert i u, is_prime (f k) :=\n        by\n        rw [Finset.forall_mem_insert] at hp⊢\n        exact ⟨hp.1, hp.2.2⟩\n      have hiu : i ∉ u := mt Finset.mem_insert_of_mem hit\n      have hn' : (insert i u).card = n :=\n        by\n        rwa [Finset.card_insert_of_not_mem] at hn⊢\n        exacts[hiu, hju]\n      have h' :\n        (I : Set R) ⊆\n          f a ∪ f b ∪\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f k) :=\n        by\n        rw [Finset.coe_insert] at h⊢\n        rw [Finset.coe_insert] at h\n        simp only [Set.bunionᵢ_insert] at h⊢\n        rw [← Set.union_assoc ↑(f i)] at h\n        erw [Set.union_eq_self_of_subset_right hfji] at h\n        exact h\n      specialize ih a b (insert i u) hp' hn' h'\n      refine' ih.imp id (Or.imp id (Exists.imp fun k => _))\n      simp only [exists_prop]\n      exact and.imp (fun hk => Finset.insert_subset_insert i (Finset.subset_insert j u) hk) id\n    by_cases Ha : f a ≤ f i\n    · have h' :\n        (I : Set R) ⊆\n          f i ∪ f b ∪\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f j) :=\n        by\n        rw [Finset.coe_insert, Set.bunionᵢ_insert, ← Set.union_assoc, Set.union_right_comm ↑(f a)] at h\n        erw [Set.union_eq_self_of_subset_left Ha] at h\n        exact h\n      specialize ih i b t hp.2 hn h'\n      right\n      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)\n      · exact or.inr ⟨i, Finset.mem_insert_self i t, ih⟩\n      · exact or.inl ih\n      · exact or.inr ⟨k, Finset.mem_insert_of_mem hkt, ih⟩\n    by_cases Hb : f b ≤ f i\n    · have h' :\n        (I : Set R) ⊆\n          f a ∪ f i ∪\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f j) :=\n        by\n        rw [Finset.coe_insert, Set.bunionᵢ_insert, ← Set.union_assoc, Set.union_assoc ↑(f a)] at h\n        erw [Set.union_eq_self_of_subset_left Hb] at h\n        exact h\n      specialize ih a i t hp.2 hn h'\n      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)\n      · exact or.inl ih\n      · exact or.inr (or.inr ⟨i, Finset.mem_insert_self i t, ih⟩)\n      · exact or.inr (or.inr ⟨k, Finset.mem_insert_of_mem hkt, ih⟩)\n    by_cases Hi : I ≤ f i\n    · exact or.inr (or.inr ⟨i, Finset.mem_insert_self i t, Hi⟩)\n    have : ¬«expr ⊓ » («expr ⊓ » («expr ⊓ » I (f a)) (f b)) (t.inf f) ≤ f i :=\n      by\n      rcases t.eq_empty_or_nonempty with (rfl | hsne)\n      · rw [Finset.inf_empty, inf_top_eq, hp.1.inf_le, hp.1.inf_le, not_or, not_or]\n        exact ⟨⟨Hi, Ha⟩, Hb⟩\n      simp only [hp.1.inf_le, hp.1.inf_le' hsne, not_or]\n      exact ⟨⟨⟨Hi, Ha⟩, Hb⟩, Ht⟩\n    rcases Set.not_subset.1 this with ⟨r, ⟨⟨⟨hrI, hra⟩, hrb⟩, hr⟩, hri⟩\n    by_cases HI :\n      (I : Set R) ⊆\n        f a ∪ f b ∪\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f j)\n    · specialize ih hp.2 hn HI\n      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)\n      · left\n        exact ih\n      · right\n        left\n        exact ih\n      · right\n        right\n        exact ⟨k, Finset.mem_insert_of_mem hkt, ih⟩\n    exfalso\n    rcases Set.not_subset.1 HI with ⟨s, hsI, hs⟩\n    rw [Finset.coe_insert, Set.bunionᵢ_insert] at h\n    have hsi : s ∈ f i := ((h hsI).resolve_left (mt or.inl hs)).resolve_right (mt or.inr hs)\n    rcases h (I.add_mem hrI hsI) with (⟨ha | hb⟩ | hi | ht)\n    · exact hs (or.inl <| or.inl <| add_sub_cancel' r s ▸ (f a).sub_mem ha hra)\n    · exact hs (or.inl <| or.inr <| add_sub_cancel' r s ▸ (f b).sub_mem hb hrb)\n    · exact hri (add_sub_cancel r s ▸ (f i).sub_mem hi hsi)\n    · rw [Set.mem_unionᵢ₂] at ht\n      rcases ht with ⟨j, hjt, hj⟩\n      simp only [Finset.inf_eq_infᵢ, SetLike.mem_coe, Submodule.mem_infᵢ] at hr\n      exact hs (or.inr <| Set.mem_bunionᵢ hjt <| add_sub_cancel' r s ▸ (f j).sub_mem hj <| hr j hjt)\n#align subset_union_prime' subset_union_prime'\n\n",
 "subset_union_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Prime avoidance. Atiyah-Macdonald 1.11, Eisenbud 3.3, Stacks 00DS, Matsumura Ex.1.6. -/\ntheorem subset_union_prime {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} (a b : ι)\n    (hp : ∀ i ∈ s, i ≠ a → i ≠ b → IsPrime (f i)) {I : Ideal R} :\n    (I : Set R) ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i) ↔\n      ∃ i ∈ s, I ≤ f i :=\n  suffices\n    (I : Set R) ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i) →\n      ∃ i, i ∈ s ∧ I ≤ f i\n    from\n    ⟨fun h => bex_def.2 <| this h, fun ⟨i, his, hi⟩ =>\n      Set.Subset.trans hi <| Set.subset_bunionᵢ_of_mem <| show i ∈ (↑s : Set ι) from his⟩\n  fun h :\n    (I : Set R) ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i) =>\n  by\n  classical\n    by_cases has : a ∈ s\n    · obtain ⟨t, hat, rfl⟩ : ∃ t, a ∉ t ∧ insert a t = s :=\n        ⟨s.erase a, Finset.not_mem_erase a s, Finset.insert_erase has⟩\n      by_cases hbt : b ∈ t\n      · obtain ⟨u, hbu, rfl⟩ : ∃ u, b ∉ u ∧ insert b u = t :=\n          ⟨t.erase b, Finset.not_mem_erase b t, Finset.insert_erase hbt⟩\n        have hp' : ∀ i ∈ u, is_prime (f i) := by\n          intro i hiu\n          refine' hp i (Finset.mem_insert_of_mem (Finset.mem_insert_of_mem hiu)) _ _ <;> rintro rfl <;>\n            solve_by_elim only [Finset.mem_insert_of_mem, *]\n        rw [Finset.coe_insert, Finset.coe_insert, Set.bunionᵢ_insert, Set.bunionᵢ_insert, ← Set.union_assoc,\n          subset_union_prime' hp', bex_def] at h\n        rwa [Finset.exists_mem_insert, Finset.exists_mem_insert]\n      · have hp' : ∀ j ∈ t, is_prime (f j) := by\n          intro j hj\n          refine' hp j (Finset.mem_insert_of_mem hj) _ _ <;> rintro rfl <;>\n            solve_by_elim only [Finset.mem_insert_of_mem, *]\n        rw [Finset.coe_insert, Set.bunionᵢ_insert, ← Set.union_self (f a : Set R), subset_union_prime' hp', ← or_assoc',\n          or_self_iff, bex_def] at h\n        rwa [Finset.exists_mem_insert]\n    · by_cases hbs : b ∈ s\n      · obtain ⟨t, hbt, rfl⟩ : ∃ t, b ∉ t ∧ insert b t = s :=\n          ⟨s.erase b, Finset.not_mem_erase b s, Finset.insert_erase hbs⟩\n        have hp' : ∀ j ∈ t, is_prime (f j) := by\n          intro j hj\n          refine' hp j (Finset.mem_insert_of_mem hj) _ _ <;> rintro rfl <;>\n            solve_by_elim only [Finset.mem_insert_of_mem, *]\n        rw [Finset.coe_insert, Set.bunionᵢ_insert, ← Set.union_self (f b : Set R), subset_union_prime' hp', ← or_assoc',\n          or_self_iff, bex_def] at h\n        rwa [Finset.exists_mem_insert]\n      cases' s.eq_empty_or_nonempty with hse hsne\n      · subst hse\n        rw [Finset.coe_empty, Set.bunionᵢ_empty, Set.subset_empty_iff] at h\n        have : (I : Set R) ≠ ∅ := Set.Nonempty.ne_empty (Set.nonempty_of_mem I.zero_mem)\n        exact absurd h this\n      · cases' hsne.bex with i his\n        obtain ⟨t, hit, rfl⟩ : ∃ t, i ∉ t ∧ insert i t = s :=\n          ⟨s.erase i, Finset.not_mem_erase i s, Finset.insert_erase his⟩\n        have hp' : ∀ j ∈ t, is_prime (f j) := by\n          intro j hj\n          refine' hp j (Finset.mem_insert_of_mem hj) _ _ <;> rintro rfl <;>\n            solve_by_elim only [Finset.mem_insert_of_mem, *]\n        rw [Finset.coe_insert, Set.bunionᵢ_insert, ← Set.union_self (f i : Set R), subset_union_prime' hp', ← or_assoc',\n          or_self_iff, bex_def] at h\n        rwa [Finset.exists_mem_insert]\n#align subset_union_prime subset_union_prime\n\n",
 "subset_union":
 "theorem subset_union {R : Type u} [Ring R] {I J K : Ideal R} : (I : Set R) ⊆ J ∪ K ↔ I ≤ J ∨ I ≤ K :=\n  ⟨fun h =>\n    or_iff_not_imp_left.2 fun hij s hsi =>\n      let ⟨r, hri, hrj⟩ := Set.not_subset.1 hij\n      by_contradiction fun hsk =>\n        or.cases_on (h <| I.add_mem hri hsi)\n          (fun hj => hrj <| add_sub_cancel r s ▸ J.sub_mem hj ((h hsi).resolve_right hsk)) fun hk =>\n          hsk <| add_sub_cancel' r s ▸ K.sub_mem hk ((h hri).resolve_left hrj),\n    fun h =>\n    or.cases_on h (fun h => Set.Subset.trans h <| Set.subset_union_left J K) fun h =>\n      Set.Subset.trans h <| Set.subset_union_right J K⟩\n#align subset_union subset_union\n\n",
 "sub_mem_ker_iff":
 "theorem sub_mem_ker_iff {x y} : x - y ∈ ker f ↔ f x = f y := by rw [mem_ker, map_sub, sub_eq_zero]\n#align sub_mem_ker_iff sub_mem_ker_iff\n\n",
 "span_smul_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem span_smul_span :\n    «expr • » (Ideal.span S) (span R T) =\n      span R\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          {«expr • » s t}) :=\n  (map₂_span_span _ _ _ _).trans <| congr_arg _ <| Set.image2_eq_unionᵢ _ _ _\n#align span_smul_span span_smul_span\n\n",
 "span_singleton_pow":
 "theorem span_singleton_pow (s : R) (n : ℕ) : span {s} ^ n = (span {s ^ n} : Ideal R) :=\n  by\n  induction' n with n ih; · simp [Set.singleton_one]\n  simp only [pow_succ, ih, span_singleton_mul_span_singleton]\n#align span_singleton_pow span_singleton_pow\n\n",
 "span_singleton_mul_span_singleton":
 "theorem span_singleton_mul_span_singleton (r s : R) : span {r} * span {s} = (span {r * s} : Ideal R) :=\n  by\n  unfold span\n  rw [Submodule.span_mul_span, Set.singleton_mul_singleton]\n#align span_singleton_mul_span_singleton span_singleton_mul_span_singleton\n\n",
 "span_singleton_mul_right_mono":
 "theorem span_singleton_mul_right_mono [IsDomain R] {x : R} (hx : x ≠ 0) : span {x} * I ≤ span {x} * J ↔ I ≤ J := by\n  simp_rw [span_singleton_mul_le_span_singleton_mul, mul_right_inj' hx, exists_prop, exists_eq_right', SetLike.le_def]\n#align span_singleton_mul_right_mono span_singleton_mul_right_mono\n\n",
 "span_singleton_mul_right_injective":
 "theorem span_singleton_mul_right_injective [IsDomain R] {x : R} (hx : x ≠ 0) :\n    function.injective ((· * ·) (span {x} : Ideal R)) := fun _ _ => (span_singleton_mul_right_inj hx).mp\n#align span_singleton_mul_right_injective span_singleton_mul_right_injective\n\n",
 "span_singleton_mul_right_inj":
 "theorem span_singleton_mul_right_inj [IsDomain R] {x : R} (hx : x ≠ 0) : span {x} * I = span {x} * J ↔ I = J := by\n  simp only [le_antisymm_iff, span_singleton_mul_right_mono hx]\n#align span_singleton_mul_right_inj span_singleton_mul_right_inj\n\n",
 "span_singleton_mul_left_mono":
 "theorem span_singleton_mul_left_mono [IsDomain R] {x : R} (hx : x ≠ 0) : I * span {x} ≤ J * span {x} ↔ I ≤ J := by\n  simpa only [mul_comm I, mul_comm J] using span_singleton_mul_right_mono hx\n#align span_singleton_mul_left_mono span_singleton_mul_left_mono\n\n",
 "span_singleton_mul_left_injective":
 "theorem span_singleton_mul_left_injective [IsDomain R] {x : R} (hx : x ≠ 0) :\n    function.injective fun I : Ideal R => I * span {x} := fun _ _ => (span_singleton_mul_left_inj hx).mp\n#align span_singleton_mul_left_injective span_singleton_mul_left_injective\n\n",
 "span_singleton_mul_left_inj":
 "theorem span_singleton_mul_left_inj [IsDomain R] {x : R} (hx : x ≠ 0) : I * span {x} = J * span {x} ↔ I = J := by\n  simp only [le_antisymm_iff, span_singleton_mul_left_mono hx]\n#align span_singleton_mul_left_inj span_singleton_mul_left_inj\n\n",
 "span_singleton_mul_le_span_singleton_mul":
 "theorem span_singleton_mul_le_span_singleton_mul {x y : R} {I J : Ideal R} :\n    span {x} * I ≤ span {y} * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zI = y * zJ := by\n  simp only [span_singleton_mul_le_iff, mem_span_singleton_mul, eq_comm]\n#align span_singleton_mul_le_span_singleton_mul span_singleton_mul_le_span_singleton_mul\n\n",
 "span_singleton_mul_le_iff":
 "theorem span_singleton_mul_le_iff {x : R} {I J : Ideal R} : span {x} * I ≤ J ↔ ∀ z ∈ I, x * z ∈ J :=\n  by\n  simp only [mul_le, mem_span_singleton_mul, mem_span_singleton]\n  constructor\n  · intro h zI hzI\n    exact h x (dvd_refl x) zI hzI\n  · rintro h _ ⟨z, rfl⟩ zI hzI\n    rw [mul_comm x z, mul_assoc]\n    exact J.mul_mem_left _ (h zI hzI)\n#align span_singleton_mul_le_iff span_singleton_mul_le_iff\n\n",
 "span_singleton_mul_eq_span_singleton_mul":
 "theorem span_singleton_mul_eq_span_singleton_mul {x y : R} (I J : Ideal R) :\n    span {x} * I = span {y} * J ↔ (∀ zI ∈ I, ∃ zJ ∈ J, x * zI = y * zJ) ∧ ∀ zJ ∈ J, ∃ zI ∈ I, x * zI = y * zJ := by\n  simp only [le_antisymm_iff, span_singleton_mul_le_span_singleton_mul, eq_comm]\n#align span_singleton_mul_eq_span_singleton_mul span_singleton_mul_eq_span_singleton_mul\n\n",
 "span_pair_mul_span_pair":
 "theorem span_pair_mul_span_pair (w x y z : R) :\n    (span {w, x} : Ideal R) * span {y, z} = span {w * y, w * z, x * y, x * z} := by\n  simp_rw [span_insert, sup_mul, mul_sup, span_singleton_mul_span_singleton, sup_assoc]\n#align span_pair_mul_span_pair span_pair_mul_span_pair\n\n",
 "span_mul_span'":
 "theorem span_mul_span' (S T : Set R) : span S * span T = span (S * T) :=\n  by\n  unfold span\n  rw [Submodule.span_mul_span]\n#align span_mul_span' span_mul_span'\n\n",
 "span_mul_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem span_mul_span (S T : Set R) :\n    span S * span T =\n      span («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" {s * t}) :=\n  Submodule.span_smul_span S T\n#align span_mul_span span_mul_span\n\n",
 "smul_top_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem smul_top_eq_map {R S : Type _} [CommSemiring R] [CommSemiring S] [Algebra R S] (I : Ideal R) :\n    «expr • » I («expr⊤» : Submodule R S) = (I.map (algebraMap R S)).restrict_scalars R :=\n  by\n  refine' le_antisymm (submodule.smul_le.mpr fun r hr y _ => _) fun x hx => Submodule.span_induction hx _ _ _ _\n  · rw [Algebra.smul_def]\n    exact mul_mem_right _ _ (mem_map_of_mem _ hr)\n  · rintro _ ⟨x, hx, rfl⟩\n    rw [← mul_one (algebraMap R S x), ← Algebra.smul_def]\n    exact Submodule.smul_mem_smul hx Submodule.mem_top\n  · exact Submodule.zero_mem _\n  · intro x y\n    exact Submodule.add_mem _\n  intro a x hx\n  refine' Submodule.smul_induction_on hx _ _\n  · intro r hr s hs\n    rw [smul_comm]\n    exact Submodule.smul_mem_smul hr Submodule.mem_top\n  · intro x y hx hy\n    rw [smul_add]\n    exact Submodule.add_mem _ hx hy\n#align smul_top_eq_map smul_top_eq_map\n\n",
 "smul_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_supr {ι : Sort _} {I : Ideal R} {t : ι → Submodule R M} :\n    «expr • » I (supᵢ t) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr • » I (t i)) :=\n  map₂_supᵢ_right _ _ _\n#align smul_supr smul_supr\n\n",
 "smul_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_sup : «expr • » I («expr ⊔ » N P) = «expr ⊔ » («expr • » I N) («expr • » I P) :=\n  map₂_sup_right _ _ _ _\n#align smul_sup smul_sup\n\n",
 "smul_mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mono_right (h : N ≤ P) : «expr • » I N ≤ «expr • » I P :=\n  map₂_le_map₂_right h\n#align smul_mono_right smul_mono_right\n\n",
 "smul_mono_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mono_left (h : I ≤ J) : «expr • » I N ≤ «expr • » J N :=\n  map₂_le_map₂_left h\n#align smul_mono_left smul_mono_left\n\n",
 "smul_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mono (hij : I ≤ J) (hnp : N ≤ P) : «expr • » I N ≤ «expr • » J P :=\n  map₂_le_map₂ hij hnp\n#align smul_mono smul_mono\n\n",
 "smul_mem_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mem_smul {r} {n} (hr : r ∈ I) (hn : n ∈ N) : «expr • » r n ∈ «expr • » I N :=\n  apply_mem_map₂ _ hr hn\n#align smul_mem_smul smul_mem_smul\n\n",
 "smul_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_le_right : «expr • » I N ≤ N :=\n  smul_le.2 fun r hr n => N.smul_mem r\n#align smul_le_right smul_le_right\n\n",
 "smul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_le {P : Submodule R M} : «expr • » I N ≤ P ↔ ∀ r ∈ I, ∀ n ∈ N, «expr • » r n ∈ P :=\n  map₂_le\n#align smul_le smul_le\n\n",
 "smul_infi_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_infi_le {ι : Sort _} {I : Ideal R} {t : ι → Submodule R M} :\n    «expr • » I (infᵢ t) ≤\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr • » I (t i)) :=\n  le_infᵢ fun i => smul_mono_right (infᵢ_le _ _)\n#align smul_infi_le smul_infi_le\n\n",
 "smul_inf_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_inf_le (M₁ M₂ : Submodule R M) :\n    «expr • » I («expr ⊓ » M₁ M₂) ≤ «expr ⊓ » («expr • » I M₁) («expr • » I M₂) :=\n  le_inf (Submodule.smul_mono_right inf_le_left) (Submodule.smul_mono_right inf_le_right)\n#align smul_inf_le smul_inf_le\n\n",
 "smul_induction_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Dependent version of `submodule.smul_induction_on`. -/\n@[elab_as_elim]\ntheorem smul_induction_on' {x : M} (hx : x ∈ «expr • » I N) {p : ∀ x, x ∈ «expr • » I N → Prop}\n    (Hb : ∀ (r : R) (hr : r ∈ I) (n : M) (hn : n ∈ N), p («expr • » r n) (smul_mem_smul hr hn))\n    (H1 : ∀ x hx y hy, p x hx → p y hy → p (x + y) (Submodule.add_mem _ ‹_› ‹_›)) : p x hx :=\n  by\n  refine' exists.elim _ fun (h : x ∈ «expr • » I N) (H : p x h) => H\n  exact smul_induction_on hx (fun a ha x hx => ⟨_, Hb _ ha _ hx⟩) fun x y ⟨_, hx⟩ ⟨_, hy⟩ => ⟨_, H1 _ _ _ _ hx hy⟩\n#align smul_induction_on' smul_induction_on'\n\n",
 "smul_induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[elab_as_elim]\ntheorem smul_induction_on {p : M → Prop} {x} (H : x ∈ «expr • » I N) (Hb : ∀ r ∈ I, ∀ n ∈ N, p («expr • » r n))\n    (H1 : ∀ x y, p x → p y → p (x + y)) : p x :=\n  by\n  have H0 : p 0 := by simpa only [zero_smul] using Hb 0 I.zero_mem 0 N.zero_mem\n  refine' Submodule.supᵢ_induction _ H _ H0 H1\n  rintro ⟨i, hi⟩ m ⟨j, hj, rfl : «expr • » i _ = m⟩\n  exact Hb _ hi _ hj\n#align smul_induction_on smul_induction_on\n\n",
 "smul_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Ideal.smul_eq_mul /-\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n/-- This duplicates the global `smul_eq_mul`, but doesn't have to unfold anywhere near as much to\napply. -/\nprotected theorem Ideal.smul_eq_mul (I J : Ideal R) : «expr • » I J = I * J :=\n  rfl\n#align ideal.smul_eq_mul Ideal.smul_eq_mul\n-/\n\n",
 "smul_comap_le_comap_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_comap_le_comap_smul (f : «expr →ₗ[ ] » M R M') (S : Submodule R M') (I : Ideal R) :\n    «expr • » I (S.comap f) ≤ («expr • » I S).comap f :=\n  by\n  refine' submodule.smul_le.mpr fun r hr x hx => _\n  rw [Submodule.mem_comap] at hx⊢\n  rw [f.map_smul]\n  exact Submodule.smul_mem_smul hr hx\n#align smul_comap_le_comap_smul smul_comap_le_comap_smul\n\n",
 "smul_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem smul_bot : «expr • » I («expr⊥» : Submodule R M) = «expr⊥» :=\n  map₂_bot_right _ _\n#align smul_bot smul_bot\n\n",
 "smul_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_assoc /-\nprotected theorem smul_assoc : «expr • » («expr • » I J) N = «expr • » I («expr • » J N) :=\n  le_antisymm\n    (smul_le.2 fun rs hrsij t htn =>\n      smul_induction_on hrsij\n        (fun r hr s hs => (@smul_eq_mul R _ r s).symm ▸ smul_smul r s t ▸ smul_mem_smul hr (smul_mem_smul hs htn))\n        fun x y => (add_smul x y t).symm ▸ Submodule.add_mem _)\n    (smul_le.2 fun r hr sn hsn =>\n      suffices\n        «expr • » J N ≤ Submodule.comap («expr • » r (LinearMap.id : «expr →ₗ[ ] » M R M)) («expr • » («expr • » I J) N)\n        from this hsn\n      smul_le.2 fun s hs n hn =>\n        show «expr • » r («expr • » s n) ∈ «expr • » («expr • » I J) N from\n          mul_smul r s n ▸ smul_mem_smul (smul_mem_smul hr hs) hn)\n#align smul_assoc smul_assoc\n-/\n\n",
 "restrict_scalars_mul":
 "/-- The smallest `S`-submodule that contains all `x ∈ I * y ∈ J`\nis also the smallest `R`-submodule that does so. -/\n@[simp]\ntheorem restrict_scalars_mul {R S : Type _} [CommSemiring R] [CommSemiring S] [Algebra R S] (I J : Ideal S) :\n    (I * J).restrict_scalars R = I.restrict_scalars R * J.restrict_scalars R :=\n  le_antisymm\n    (fun x hx =>\n      Submodule.mul_induction_on hx (fun x hx y hy => Submodule.mul_mem_mul hx hy) fun x y => Submodule.add_mem _)\n    (Submodule.mul_le.mpr fun x hx y hy => Ideal.mul_mem_mul hx hy)\n#align restrict_scalars_mul restrict_scalars_mul\n\n",
 "range_finsupp_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem range_finsupp_total : (finsuppTotal ι M I v).range = «expr • » I (Submodule.span R (Set.range v)) :=\n  by\n  ext\n  rw [Submodule.mem_ideal_smul_span_iff_exists_sum]\n  refine' ⟨fun ⟨f, h⟩ => ⟨Finsupp.mapRange.linearMap I.subtype f, fun i => (f i).2, h⟩, _⟩\n  rintro ⟨a, ha, rfl⟩\n  classical\n    refine' ⟨a.map_range (fun r => if h : r ∈ I then ⟨r, h⟩ else 0) (by split_ifs <;> rfl), _⟩\n    rw [finsupp_total_apply, Finsupp.sum_mapRange_index]\n    · apply Finsupp.sum_congr\n      intro i _\n      rw [dif_pos (ha i)]\n      rfl\n    · exact fun _ => zero_smul _ _\n#align range_finsupp_total range_finsupp_total\n\n",
 "radical_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem radical_top : (radical («expr⊤») : Ideal R) = «expr⊤» :=\n  (eq_top_iff_one _).2 ⟨0, Submodule.mem_top⟩\n#align radical_top radical_top\n\n",
 "radical_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem radical_sup : radical («expr ⊔ » I J) = radical («expr ⊔ » (radical I) (radical J)) :=\n  le_antisymm (radical_mono <| sup_le_sup le_radical le_radical) <|\n    radical_le_radical_iff.2 <| sup_le (radical_mono le_sup_left) (radical_mono le_sup_right)\n#align radical_sup radical_sup\n\n",
 "radical_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem radical_pow (n : ℕ) (H : n > 0) : radical (I ^ n) = radical I :=\n  nat.rec_on n (Not.elim (by decide))\n    (fun n ih H =>\n      or.cases_on (lt_or_eq_of_le <| nat.le_of_lt_succ H)\n        (fun H =>\n          calc\n            radical (I ^ (n + 1)) = «expr ⊓ » (radical I) (radical (I ^ n)) :=\n              by\n              rw [pow_succ]\n              exact radical_mul _ _\n            _ = «expr ⊓ » (radical I) (radical I) := by rw [ih H]\n            _ = radical I := inf_idem\n            )\n        fun H => H ▸ (pow_one I).symm ▸ rfl)\n    H\n#align radical_pow radical_pow\n\n",
 "radical_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem radical_mul : radical (I * J) = «expr ⊓ » (radical I) (radical J) :=\n  le_antisymm (radical_inf I J ▸ radical_mono <| @mul_le_inf _ _ I J) fun r ⟨⟨m, hrm⟩, ⟨n, hrn⟩⟩ =>\n    ⟨m + n, (pow_add r m n).symm ▸ mul_mem_mul hrm hrn⟩\n#align radical_mul radical_mul\n\n",
 "radical_mono":
 "theorem radical_mono (H : I ≤ J) : radical I ≤ radical J := fun r ⟨n, hrni⟩ => ⟨n, H hrni⟩\n#align radical_mono radical_mono\n\n",
 "radical_le_radical_iff":
 "theorem radical_le_radical_iff : radical I ≤ radical J ↔ I ≤ radical J :=\n  (radical_isRadical J).radical_le_iff\n#align radical_le_radical_iff radical_le_radical_iff\n\n",
 "radical_le_iff":
 "theorem is_prime.radical_le_iff (hJ : IsPrime J) : radical I ≤ J ↔ I ≤ J :=\n  hJ.is_radical.radical_le_iff\n#align is_prime.radical_le_iff is_prime.radical_le_iff\n\n",
 "radical_is_radical":
 "theorem radical_is_radical : (radical I).is_radical := fun r ⟨n, k, hrnki⟩ => ⟨n * k, (pow_mul r n k).symm ▸ hrnki⟩\n#align radical_is_radical radical_is_radical\n\n",
 "radical_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem radical_inf : radical («expr ⊓ » I J) = «expr ⊓ » (radical I) (radical J) :=\n  le_antisymm (le_inf (radical_mono inf_le_left) (radical_mono inf_le_right)) fun r ⟨⟨m, hrm⟩, ⟨n, hrn⟩⟩ =>\n    ⟨m + n, (pow_add r m n).symm ▸ I.mul_mem_right _ hrm, (pow_add r m n).symm ▸ J.mul_mem_left _ hrn⟩\n#align radical_inf radical_inf\n\n",
 "radical_idem":
 "@[simp]\ntheorem radical_idem : radical (radical I) = radical I :=\n  (radical_isRadical I).radical\n#align radical_idem radical_idem\n\n",
 "radical_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem radical_eq_top : radical I = «expr⊤» ↔ I = «expr⊤» :=\n  ⟨fun h =>\n    (eq_top_iff_one _).2 <|\n      let ⟨n, hn⟩ := (eq_top_iff_one _).1 h\n      @one_pow R _ n ▸ hn,\n    fun h => h.symm ▸ radical_top R⟩\n#align radical_eq_top radical_eq_top\n\n",
 "radical_eq_iff":
 "/-- An ideal is radical iff it is equal to its radical. -/\ntheorem radical_eq_iff : I.radical = I ↔ I.is_radical := by rw [le_antisymm_iff, and_iff_left le_radical, IsRadical]\n#align radical_eq_iff radical_eq_iff\n\n",
 "radical_eq_Inf":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » m) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem radical_eq_Inf (I : Ideal R) : radical I = infₛ { J : Ideal R | I ≤ J ∧ IsPrime J } :=\n  le_antisymm (le_infₛ fun J hJ => hJ.2.radical_le_iff.2 hJ.1) fun r hr =>\n    by_contradiction fun hri =>\n      let ⟨m, (hrm : r ∉ radical m), him, hm⟩ :=\n        zorn_nonempty_partialOrder₀ { K : Ideal R | r ∉ radical K }\n          (fun c hc hcc y hyc =>\n            ⟨supₛ c, fun ⟨n, hrnc⟩ =>\n              let ⟨y, hyc, hrny⟩ := (Submodule.mem_supₛ_of_directed ⟨y, hyc⟩ hcc.directed_on).1 hrnc\n              hc hyc ⟨n, hrny⟩,\n              fun z => le_supₛ⟩)\n          I hri\n      have : ∀ (x) (_ : x ∉ m), r ∈ radical («expr ⊔ » m (span {x})) := fun x hxm =>\n        by_contradiction fun hrmx =>\n          hxm <|\n            hm («expr ⊔ » m (span {x})) hrmx le_sup_left ▸\n              (le_sup_right : _ ≤ «expr ⊔ » m (span {x})) (subset_span <| Set.mem_singleton _)\n      have : IsPrime m :=\n        ⟨by rintro rfl <;> rw [radical_top] at hrm <;> exact hrm trivial, fun x y hxym =>\n          or_iff_not_imp_left.2 fun hxm =>\n            by_contradiction fun hym =>\n              let ⟨n, hrn⟩ := this _ hxm\n              let ⟨p, hpm, q, hq, hpqrn⟩ := Submodule.mem_sup.1 hrn\n              let ⟨c, hcxq⟩ := mem_span_singleton'.1 hq\n              let ⟨k, hrk⟩ := this _ hym\n              let ⟨f, hfm, g, hg, hfgrk⟩ := Submodule.mem_sup.1 hrk\n              let ⟨d, hdyg⟩ := mem_span_singleton'.1 hg\n              hrm\n                ⟨n + k, by\n                  rw [pow_add, ← hpqrn, ← hcxq, ← hfgrk, ← hdyg, add_mul, mul_add (c * x), mul_assoc c x (d * y),\n                      mul_left_comm x, ← mul_assoc] <;>\n                    refine'\n                      m.add_mem (m.mul_mem_right _ hpm) (m.add_mem (m.mul_mem_left _ hfm) (m.mul_mem_left _ hxym))⟩⟩\n      hrm <| this.radical.symm ▸ (infₛ_le ⟨him, this⟩ : infₛ { J : Ideal R | I ≤ J ∧ IsPrime J } ≤ m) hr\n#align radical_eq_Inf radical_eq_Inf\n\n",
 "radical_bot_of_no_zero_divisors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem radical_bot_of_no_zero_divisors {R : Type u} [CommSemiring R] [NoZeroDivisors R] :\n    radical («expr⊥» : Ideal R) = «expr⊥» :=\n  eq_bot_iff.2 isRadical_bot_of_noZeroDivisors\n#align radical_bot_of_no_zero_divisors radical_bot_of_no_zero_divisors\n\n",
 "radical":
 "theorem is_prime.radical (H : IsPrime I) : radical I = I :=\n  H.is_radical.radical\n#align is_prime.radical is_prime.radical\n\n",
 "prod_sup_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem prod_sup_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → «expr ⊔ » (J i) I = «expr⊤») :\n    «expr ⊔ »\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (J i)) I =\n      «expr⊤» :=\n  sup_comm.trans (sup_prod_eq_top fun i hi => sup_comm.trans <| h i hi)\n#align prod_sup_eq_top prod_sup_eq_top\n\n",
 "prod_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_span_singleton {ι : Type _} (s : Finset ι) (I : ι → R) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (Ideal.span ({I i} : Set R)) =\n      Ideal.span\n        {finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (I i)} :=\n  Submodule.prod_span_singleton s I\n#align prod_span_singleton prod_span_singleton\n\n",
 "prod_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_span {ι : Type _} (s : Finset ι) (I : ι → Set R) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (Ideal.span (I i)) =\n      Ideal.span\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (I i)) :=\n  Submodule.prod_span s I\n#align prod_span prod_span\n\n",
 "prod_mem_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_mem_prod {ι : Type _} {s : Finset ι} {I : ι → Ideal R} {x : ι → R} :\n    (∀ i ∈ s, x i ∈ I i) →\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (x i) ∈\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (I i) :=\n  by\n  classical\n    apply Finset.induction_on s\n    · intro\n      rw [Finset.prod_empty, Finset.prod_empty, one_eq_top]\n      exact Submodule.mem_top\n    · intro a s ha IH h\n      rw [Finset.prod_insert ha, Finset.prod_insert ha]\n      exact mul_mem_mul (h a <| Finset.mem_insert_self a s) (IH fun i hi => h i <| Finset.mem_insert_of_mem hi)\n#align prod_mem_prod prod_mem_prod\n\n",
 "prod_le_inf":
 "theorem prod_le_inf {s : Finset ι} {f : ι → Ideal R} : s.prod f ≤ s.inf f :=\n  multiset_prod_le_inf\n#align prod_le_inf prod_le_inf\n\n",
 "prod_le":
 "theorem is_prime.prod_le {s : Finset ι} {f : ι → Ideal R} {P : Ideal R} (hp : IsPrime P) (hne : s.nonempty) :\n    s.prod f ≤ P ↔ ∃ i ∈ s, f i ≤ P :=\n  hp.multiset_prod_map_le f (mt Finset.val_eq_zero.mp hne.ne_empty)\n#align is_prime.prod_le is_prime.prod_le\n\n",
 "prod_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem prod_eq_bot {R : Type _} [CommRing R] [IsDomain R] {s : Multiset (Ideal R)} :\n    s.prod = «expr⊥» ↔ ∃ I ∈ s, I = «expr⊥» :=\n  prod_zero_iff_exists_zero\n#align prod_eq_bot prod_eq_bot\n\n",
 "pow_sup_pow_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem pow_sup_pow_eq_top {m n : ℕ} (h : «expr ⊔ » I J = «expr⊤») : «expr ⊔ » (I ^ m) (J ^ n) = «expr⊤» :=\n  sup_pow_eq_top (pow_sup_eq_top h)\n#align pow_sup_pow_eq_top pow_sup_pow_eq_top\n\n",
 "pow_sup_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem pow_sup_eq_top {n : ℕ} (h : «expr ⊔ » I J = «expr⊤») : «expr ⊔ » (I ^ n) J = «expr⊤» :=\n  by\n  rw [← Finset.card_range n, ← Finset.prod_const]\n  exact prod_sup_eq_top fun _ _ => h\n#align pow_sup_eq_top pow_sup_eq_top\n\n",
 "pow_mono":
 "#print pow_mono /-\ntheorem pow_mono {I J : Ideal R} (e : I ≤ J) (n : ℕ) : I ^ n ≤ J ^ n :=\n  by\n  induction n\n  · rw [pow_zero, pow_zero]\n    exact rfl.le\n  · rw [pow_succ, pow_succ]\n    exact Ideal.mul_mono e n_ih\n#align pow_mono pow_mono\n-/\n\n",
 "pow_mem_pow":
 "theorem pow_mem_pow {x : R} (hx : x ∈ I) (n : ℕ) : x ^ n ∈ I ^ n :=\n  Submodule.pow_mem_pow _ hx _\n#align pow_mem_pow pow_mem_pow\n\n",
 "pow_le_self":
 "theorem pow_le_self {n : ℕ} (hn : n ≠ 0) : I ^ n ≤ I :=\n  calc\n    I ^ n ≤ I ^ 1 := pow_le_pow (nat.pos_of_ne_zero hn)\n    _ = I := pow_one _\n    \n#align pow_le_self pow_le_self\n\n",
 "pow_le_pow":
 "#print pow_le_pow /-\ntheorem pow_le_pow {m n : ℕ} (h : m ≤ n) : I ^ n ≤ I ^ m :=\n  by\n  cases' Nat.exists_eq_add_of_le h with k hk\n  rw [hk, pow_add]\n  exact le_trans mul_le_inf inf_le_left\n#align pow_le_pow pow_le_pow\n-/\n\n",
 "one_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem one_eq_top : (1 : Ideal R) = «expr⊤» := by erw [Submodule.one_eq_range, LinearMap.range_id]\n#align one_eq_top one_eq_top\n\n",
 "not_one_mem_ker":
 "/-- If the target is not the zero ring, then one is not in the kernel.-/\ntheorem not_one_mem_ker [Nontrivial S] (f : F) : (1 : R) ∉ ker f :=\n  by\n  rw [mem_ker, map_one]\n  exact one_ne_zero\n#align not_one_mem_ker not_one_mem_ker\n\n",
 "multiset_prod_span_singleton":
 "@[simp]\ntheorem multiset_prod_span_singleton (m : Multiset R) :\n    (m.map fun x => Ideal.span {x}).prod = Ideal.span ({Multiset.prod m} : Set R) :=\n  Multiset.induction_on m (by simp) fun a m ih => by\n    simp only [Multiset.map_cons, Multiset.prod_cons, ih, ← Ideal.span_singleton_mul_span_singleton]\n#align multiset_prod_span_singleton multiset_prod_span_singleton\n\n",
 "multiset_prod_map_le":
 "theorem is_prime.multiset_prod_map_le {s : Multiset ι} (f : ι → Ideal R) {P : Ideal R} (hp : IsPrime P) (hne : s ≠ 0) :\n    (s.map f).prod ≤ P ↔ ∃ i ∈ s, f i ≤ P :=\n  by\n  rw [hp.multiset_prod_le (mt multiset.map_eq_zero.mp hne)]\n  simp_rw [exists_prop, Multiset.mem_map, exists_exists_and_eq_and]\n#align is_prime.multiset_prod_map_le is_prime.multiset_prod_map_le\n\n",
 "multiset_prod_le_inf":
 "theorem multiset_prod_le_inf {s : Multiset (Ideal R)} : s.prod ≤ s.inf := by\n  classical\n    refine' s.induction_on _ _\n    · rw [Multiset.inf_zero]\n      exact le_top\n    intro a s ih\n    rw [Multiset.prod_cons, Multiset.inf_cons]\n    exact le_trans mul_le_inf (inf_le_inf le_rfl ih)\n#align multiset_prod_le_inf multiset_prod_le_inf\n\n",
 "multiset_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem is_prime.multiset_prod_le {s : Multiset (Ideal R)} {P : Ideal R} (hp : IsPrime P) (hne : s ≠ 0) :\n    s.prod ≤ P ↔ ∃ I ∈ s, I ≤ P :=\n  by\n  suffices s.prod ≤ P → ∃ I ∈ s, I ≤ P from\n    ⟨this, fun ⟨i, his, hip⟩ => le_trans multiset_prod_le_inf <| le_trans (Multiset.inf_le his) hip⟩\n  classical\n    obtain ⟨b, hb⟩ : ∃ b, b ∈ s := Multiset.exists_mem_of_ne_zero hne\n    obtain ⟨t, rfl⟩ : ∃ t, s = «expr ::ₘ » b t\n    exact ⟨s.erase b, (Multiset.cons_erase hb).symm⟩\n    refine' t.induction_on _ _\n    ·\n      simp only [exists_prop, Multiset.cons_zero, Multiset.prod_singleton, Multiset.mem_singleton, exists_eq_left,\n        imp_self]\n    intro a s ih h\n    rw [Multiset.cons_swap, Multiset.prod_cons, hp.mul_le] at h\n    rw [Multiset.cons_swap]\n    cases h\n    · exact ⟨a, Multiset.mem_cons_self a _, h⟩\n    obtain ⟨I, hI, ih⟩ : ∃ I ∈ «expr ::ₘ » b s, I ≤ P := ih h\n    exact ⟨I, Multiset.mem_cons_of_mem hI, ih⟩\n#align is_prime.multiset_prod_le is_prime.multiset_prod_le\n\n",
 "mul_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mul_top : I * «expr⊤» = I :=\n  Ideal.mul_comm («expr⊤») I ▸ Submodule.top_smul I\n#align mul_top mul_top\n\n",
 "mul_sup_eq_of_coprime_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem mul_sup_eq_of_coprime_right (h : «expr ⊔ » K J = «expr⊤») : «expr ⊔ » (I * K) J = «expr ⊔ » I J :=\n  by\n  rw [sup_comm] at h\n  rw [sup_comm, sup_mul_eq_of_coprime_right h, sup_comm]\n#align mul_sup_eq_of_coprime_right mul_sup_eq_of_coprime_right\n\n",
 "mul_sup_eq_of_coprime_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem mul_sup_eq_of_coprime_left (h : «expr ⊔ » I J = «expr⊤») : «expr ⊔ » (I * K) J = «expr ⊔ » K J :=\n  by\n  rw [sup_comm] at h\n  rw [sup_comm, sup_mul_eq_of_coprime_left h, sup_comm]\n#align mul_sup_eq_of_coprime_left mul_sup_eq_of_coprime_left\n\n",
 "mul_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print mul_sup /-\ntheorem mul_sup : I * «expr ⊔ » J K = «expr ⊔ » (I * J) (I * K) :=\n  Submodule.smul_sup I J K\n#align mul_sup mul_sup\n-/\n\n",
 "mul_right_self_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem mul_right_self_sup : «expr ⊔ » (I * J) I = I :=\n  sup_eq_right.2 Ideal.mul_le_right\n#align mul_right_self_sup mul_right_self_sup\n\n",
 "mul_mono_right":
 "theorem mul_mono_right (h : J ≤ K) : I * J ≤ I * K :=\n  Submodule.smul_mono_right h\n#align mul_mono_right mul_mono_right\n\n",
 "mul_mono_left":
 "theorem mul_mono_left (h : I ≤ J) : I * K ≤ J * K :=\n  Submodule.smul_mono_left h\n#align mul_mono_left mul_mono_left\n\n",
 "mul_mono":
 "theorem mul_mono (hik : I ≤ K) (hjl : J ≤ L) : I * J ≤ K * L :=\n  Submodule.smul_mono hik hjl\n#align mul_mono mul_mono\n\n",
 "mul_mem_mul_rev":
 "theorem mul_mem_mul_rev {r s} (hr : r ∈ I) (hs : s ∈ J) : s * r ∈ I * J :=\n  mul_comm r s ▸ mul_mem_mul hr hs\n#align mul_mem_mul_rev mul_mem_mul_rev\n\n",
 "mul_mem_mul":
 "theorem mul_mem_mul {r s} (hr : r ∈ I) (hs : s ∈ J) : r * s ∈ I * J :=\n  Submodule.smul_mem_smul hr hs\n#align mul_mem_mul mul_mem_mul\n\n",
 "mul_left_self_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem mul_left_self_sup : «expr ⊔ » (J * I) I = I :=\n  sup_eq_right.2 Ideal.mul_le_left\n#align mul_left_self_sup mul_left_self_sup\n\n",
 "mul_le_right":
 "theorem mul_le_right : I * J ≤ I :=\n  Ideal.mul_le.2 fun r hr s hs => I.mul_mem_right _ hr\n#align mul_le_right mul_le_right\n\n",
 "mul_le_left":
 "theorem mul_le_left : I * J ≤ J :=\n  Ideal.mul_le.2 fun r hr s => J.mul_mem_left _\n#align mul_le_left mul_le_left\n\n",
 "mul_le_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem mul_le_inf : I * J ≤ «expr ⊓ » I J :=\n  mul_le.2 fun r hri s hsj => ⟨I.mul_mem_right s hri, J.mul_mem_left r hsj⟩\n#align mul_le_inf mul_le_inf\n\n",
 "mul_le":
 "theorem is_prime.mul_le {I J P : Ideal R} (hp : IsPrime P) : I * J ≤ P ↔ I ≤ P ∨ J ≤ P :=\n  ⟨fun h =>\n    or_iff_not_imp_left.2 fun hip j hj =>\n      let ⟨i, hi, hip⟩ := Set.not_subset.1 hip\n      (hp.mem_or_mem <| h <| mul_mem_mul hi hj).resolve_left hip,\n    fun h => or.cases_on h (le_trans <| le_trans mul_le_inf inf_le_left) (le_trans <| le_trans mul_le_inf inf_le_right)⟩\n#align is_prime.mul_le is_prime.mul_le\n\n",
 "mul_eq_inf_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem mul_eq_inf_of_coprime (h : «expr ⊔ » I J = «expr⊤») : I * J = «expr ⊓ » I J :=\n  le_antisymm mul_le_inf fun r ⟨hri, hrj⟩ =>\n    let ⟨s, hsi, t, htj, hst⟩ := Submodule.mem_sup.1 ((eq_top_iff_one _).1 h)\n    mul_one r ▸ hst ▸ (mul_add r s t).symm ▸ Ideal.add_mem (I * J) (mul_mem_mul_rev hsi hrj) (mul_mem_mul hri htj)\n#align mul_eq_inf_of_coprime mul_eq_inf_of_coprime\n\n",
 "mul_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mul_eq_bot {R : Type _} [CommSemiring R] [NoZeroDivisors R] {I J : Ideal R} :\n    I * J = «expr⊥» ↔ I = «expr⊥» ∨ J = «expr⊥» :=\n  ⟨fun hij =>\n    or_iff_not_imp_left.mpr fun I_ne_bot =>\n      J.eq_bot_iff.mpr fun j hj =>\n        let ⟨i, hi, ne0⟩ := I.ne_bot_iff.mp I_ne_bot\n        or.resolve_left (mul_eq_zero.mp ((I * J).eq_bot_iff.mp hij _ (mul_mem_mul hi hj))) ne0,\n    fun h => by cases h <;> rw [← Ideal.mul_bot, h, Ideal.mul_comm]⟩\n#align mul_eq_bot mul_eq_bot\n\n",
 "mul_comm":
 "#print mul_comm /-\nprotected theorem mul_comm : I * J = J * I :=\n  le_antisymm (mul_le.2 fun r hrI s hsJ => mul_mem_mul_rev hsJ hrI)\n    (mul_le.2 fun r hrJ s hsI => mul_mem_mul_rev hsI hrJ)\n#align mul_comm mul_comm\n-/\n\n",
 "mul_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem mul_bot : I * «expr⊥» = «expr⊥» :=\n  Submodule.smul_bot I\n#align mul_bot mul_bot\n\n",
 "mul_assoc":
 "#print mul_assoc /-\nprotected theorem mul_assoc : I * J * K = I * (J * K) :=\n  Submodule.smul_assoc I J K\n#align mul_assoc mul_assoc\n-/\n\n",
 "mul_annihilator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem mul_annihilator (I : Ideal R) : I * annihilator I = «expr⊥» := by rw [mul_comm, annihilator_mul]\n#align mul_annihilator mul_annihilator\n\n",
 "mk_ne_zero'":
 "#print Associates.mk_ne_zero' /-\ntheorem Associates.mk_ne_zero' {R : Type _} [CommSemiring R] {r : R} :\n    Associates.mk (Ideal.span {r} : Ideal R) ≠ 0 ↔ r ≠ 0 := by\n  rw [Associates.mk_ne_zero, Ideal.zero_eq_bot, ne.def, Ideal.span_singleton_eq_bot]\n#align associates.mk_ne_zero' Associates.mk_ne_zero'\n-/\n\n",
 "mem_span_singleton_mul":
 "theorem mem_span_singleton_mul {x y : R} {I : Ideal R} : x ∈ span {y} * I ↔ ∃ z ∈ I, y * z = x := by\n  simp only [mul_comm, mem_mul_span_singleton]\n#align mem_span_singleton_mul mem_span_singleton_mul\n\n",
 "mem_smul_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_smul_top_iff (N : Submodule R M) (x : N) :\n    x ∈ «expr • » I («expr⊤» : Submodule R N) ↔ (x : M) ∈ «expr • » I N :=\n  by\n  change _ ↔ N.subtype x ∈ «expr • » I N\n  have : Submodule.map N.subtype («expr • » I («expr⊤»)) = «expr • » I N := by\n    rw [Submodule.map_smul'', Submodule.map_top, Submodule.range_subtype]\n  rw [← this]\n  convert(Function.Injective.mem_set_image N.injective_subtype).symm using 1\n  rfl\n#align mem_smul_top_iff mem_smul_top_iff\n\n",
 "mem_smul_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_smul_span_singleton {I : Ideal R} {m : M} {x : M} :\n    x ∈ «expr • » I (span R ({m} : Set M)) ↔ ∃ y ∈ I, «expr • » y m = x :=\n  ⟨fun hx =>\n    smul_induction_on hx\n      (fun r hri n hnm =>\n        let ⟨s, hs⟩ := mem_span_singleton.1 hnm\n        ⟨r * s, I.mul_mem_right _ hri, hs ▸ mul_smul r s m⟩)\n      fun m1 m2 ⟨y1, hyi1, hy1⟩ ⟨y2, hyi2, hy2⟩ => ⟨y1 + y2, I.add_mem hyi1 hyi2, by rw [add_smul, hy1, hy2]⟩,\n    fun ⟨y, hyi, hy⟩ => hy ▸ smul_mem_smul hyi (subset_span <| Set.mem_singleton m)⟩\n#align mem_smul_span_singleton mem_smul_span_singleton\n\n",
 "mem_smul_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_smul_span {s : Set M} {x : M} :\n    x ∈ «expr • » I (Submodule.span R s) ↔\n      x ∈\n        Submodule.span R\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            ({«expr • » a b} : Set M)) :=\n  by rw [← I.span_eq, Submodule.span_smul_span, I.span_eq] <;> rfl\n#align mem_smul_span mem_smul_span\n\n",
 "mem_radical_of_pow_mem":
 "theorem mem_radical_of_pow_mem {I : Ideal R} {x : R} {m : ℕ} (hx : x ^ m ∈ radical I) : x ∈ radical I :=\n  radical_idem I ▸ ⟨m, hx⟩\n#align mem_radical_of_pow_mem mem_radical_of_pow_mem\n\n",
 "mem_of_span_top_of_smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_of_span_top_of_smul_mem (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = «expr⊤») (x : M)\n    (H : ∀ r : s, «expr • » (r : R) x ∈ M') : x ∈ M' :=\n  by\n  suffices «expr • » («expr⊤» : Ideal R) (span R ({x} : Set M)) ≤ M'\n    by\n    rw [top_smul] at this\n    exact this (subset_span (Set.mem_singleton x))\n  rw [← hs, span_smul_span, span_le]\n  simpa using H\n#align mem_of_span_top_of_smul_mem mem_of_span_top_of_smul_mem\n\n",
 "mem_of_span_eq_top_of_smul_pow_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Given `s`, a generating set of `R`, to check that an `x : M` falls in a\nsubmodule `M'` of `x`, we only need to show that `r ^ n • x ∈ M'` for some `n` for each `r : s`. -/\ntheorem mem_of_span_eq_top_of_smul_pow_mem (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = «expr⊤») (x : M)\n    (H : ∀ r : s, ∃ n : ℕ, «expr • » (r ^ n : R) x ∈ M') : x ∈ M' :=\n  by\n  obtain ⟨s', hs₁, hs₂⟩ := (Ideal.span_eq_top_iff_finite _).mp hs\n  replace H : ∀ r : s', ∃ n : ℕ, «expr • » (r ^ n : R) x ∈ M' := fun r => H ⟨_, hs₁ r.prop⟩\n  choose n₁ n₂ using H\n  let N := s'.attach.sup n₁\n  have hs' := Ideal.span_pow_eq_top (s' : Set R) hs₂ N\n  apply M'.mem_of_span_top_of_smul_mem _ hs'\n  rintro ⟨_, r, hr, rfl⟩\n  convert M'.smul_mem (r ^ (N - n₁ ⟨r, hr⟩)) (n₂ ⟨r, hr⟩) using 1\n  simp only [Subtype.coe_mk, smul_smul, ← pow_add]\n  rw [tsub_add_cancel_of_le (Finset.le_sup (s'.mem_attach _) : n₁ ⟨r, hr⟩ ≤ N)]\n#align mem_of_span_eq_top_of_smul_pow_mem mem_of_span_eq_top_of_smul_pow_mem\n\n",
 "mem_mul_span_singleton":
 "theorem mem_mul_span_singleton {x y : R} {I : Ideal R} : x ∈ I * span {y} ↔ ∃ z ∈ I, z * y = x :=\n  Submodule.mem_smul_span_singleton\n#align mem_mul_span_singleton mem_mul_span_singleton\n\n",
 "mem_map_of_mem":
 "theorem mem_map_of_mem (f : F) {I : Ideal R} {x : R} (h : x ∈ I) : f x ∈ map f I :=\n  subset_span ⟨x, h, rfl⟩\n#align mem_map_of_mem mem_map_of_mem\n\n",
 "mem_map_iff_of_surjective":
 "theorem mem_map_iff_of_surjective {I : Ideal R} {y} : y ∈ map f I ↔ ∃ x, x ∈ I ∧ f x = y :=\n  ⟨fun h => (Set.mem_image _ _ _).2 (mem_image_of_mem_map_of_surjective f hf h), fun ⟨x, hx⟩ =>\n    hx.right ▸ mem_map_of_mem f hx.left⟩\n#align mem_map_iff_of_surjective mem_map_iff_of_surjective\n\n",
 "mem_ker":
 "/-- An element is in the kernel if and only if it maps to zero.-/\ntheorem mem_ker {r} : r ∈ ker f ↔ f r = 0 := by rw [ker, Ideal.mem_comap, Submodule.mem_bot]\n#align mem_ker mem_ker\n\n",
 "mem_image_of_mem_map_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_image_of_mem_map_of_surjective {I : Ideal R} {y} (H : y ∈ map f I) : y ∈ «expr '' » f I :=\n  Submodule.span_induction H (fun _ => id) ⟨0, I.zero_mem, map_zero f⟩\n    (fun y1 y2 ⟨x1, hx1i, hxy1⟩ ⟨x2, hx2i, hxy2⟩ => ⟨x1 + x2, I.add_mem hx1i hx2i, hxy1 ▸ hxy2 ▸ map_add f _ _⟩)\n    fun c y ⟨x, hxi, hxy⟩ =>\n    let ⟨d, hdc⟩ := hf c\n    ⟨d * x, I.mul_mem_left _ hxi, hdc ▸ hxy ▸ map_mul f _ _⟩\n#align mem_image_of_mem_map_of_surjective mem_image_of_mem_map_of_surjective\n\n",
 "mem_ideal_smul_span_iff_exists_sum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_ideal_smul_span_iff_exists_sum' {ι : Type _} (s : Set ι) (f : ι → M) (x : M) :\n    x ∈ «expr • » I (span R («expr '' » f s)) ↔\n      ∃ (a : «expr →₀ » s R)(ha : ∀ i, a i ∈ I), (a.sum fun i c => «expr • » c (f i)) = x :=\n  by rw [← Submodule.mem_ideal_smul_span_iff_exists_sum, ← Set.image_eq_range]\n#align mem_ideal_smul_span_iff_exists_sum' mem_ideal_smul_span_iff_exists_sum'\n\n",
 "mem_ideal_smul_span_iff_exists_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `x` is an `I`-multiple of the submodule spanned by `f '' s`,\nthen we can write `x` as an `I`-linear combination of the elements of `f '' s`. -/\ntheorem mem_ideal_smul_span_iff_exists_sum {ι : Type _} (f : ι → M) (x : M) :\n    x ∈ «expr • » I (span R (Set.range f)) ↔\n      ∃ (a : «expr →₀ » ι R)(ha : ∀ i, a i ∈ I), (a.sum fun i c => «expr • » c (f i)) = x :=\n  by\n  constructor; swap\n  · rintro ⟨a, ha, rfl⟩\n    exact Submodule.sum_mem _ fun c _ => smul_mem_smul (ha c) <| subset_span <| Set.mem_range_self _\n  refine' fun hx => span_induction (mem_smul_span.mp hx) _ _ _ _\n  · simp only [Set.mem_unionᵢ, Set.mem_range, Set.mem_singleton_iff]\n    rintro x ⟨y, hy, x, ⟨i, rfl⟩, rfl⟩\n    refine' ⟨Finsupp.single i y, fun j => _, _⟩\n    · letI := Classical.decEq ι\n      rw [Finsupp.single_apply]\n      split_ifs\n      · assumption\n      · exact I.zero_mem\n    refine' @Finsupp.sum_single_index ι R M _ _ i _ (fun i y => «expr • » y (f i)) _\n    simp\n  · exact ⟨0, fun i => I.zero_mem, Finsupp.sum_zero_index⟩\n  · rintro x y ⟨ax, hax, rfl⟩ ⟨ay, hay, rfl⟩\n    refine' ⟨ax + ay, fun i => I.add_mem (hax i) (hay i), Finsupp.sum_add_index' _ _⟩ <;> intros <;>\n      simp only [zero_smul, add_smul]\n  · rintro c x ⟨a, ha, rfl⟩\n    refine' ⟨«expr • » c a, fun i => I.mul_mem_left c (ha i), _⟩\n    rw [Finsupp.sum_smul_index, Finsupp.smul_sum] <;> intros <;> simp only [zero_smul, mul_smul]\n#align mem_ideal_smul_span_iff_exists_sum mem_ideal_smul_span_iff_exists_sum\n\n",
 "mem_ideal_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.mem_ideal_iff' /-\n/-- If `I : ideal S` has a finite basis over `R`,\n`x ∈ I` iff it is a linear combination of basis vectors. -/\ntheorem Basis.mem_ideal_iff' {ι R S : Type _} [Fintype ι] [CommRing R] [CommRing S] [Algebra R S] {I : Ideal S}\n    (b : Basis ι R I) {x : S} :\n    x ∈ I ↔\n      ∃ c : ι → R,\n        x =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (c i) (b i)) :=\n  (b.map ((I.restrict_scalars_equiv R _ _).restrict_scalars R).symm).mem_submodule_iff'\n#align basis.mem_ideal_iff' Basis.mem_ideal_iff'\n-/\n\n",
 "mem_ideal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.mem_ideal_iff /-\n/-- If `I : ideal S` has a basis over `R`,\n`x ∈ I` iff it is a linear combination of basis vectors. -/\ntheorem Basis.mem_ideal_iff {ι R S : Type _} [CommRing R] [CommRing S] [Algebra R S] {I : Ideal S} (b : Basis ι R I)\n    {x : S} : x ∈ I ↔ ∃ c : «expr →₀ » ι R, x = Finsupp.sum c fun i x => «expr • » x (b i) :=\n  (b.map ((I.restrict_scalars_equiv R _ _).restrict_scalars R).symm).mem_submodule_iff\n#align basis.mem_ideal_iff Basis.mem_ideal_iff\n-/\n\n",
 "mem_comap":
 "@[simp]\ntheorem mem_comap {x} : x ∈ comap f K ↔ f x ∈ K :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_colon_singleton":
 "#print Ideal.mem_colon_singleton /-\n@[simp]\ntheorem Ideal.mem_colon_singleton {I : Ideal R} {x r : R} : r ∈ I.colon (Ideal.span {x}) ↔ r * x ∈ I := by\n  simp [← Ideal.submodule_span_eq, Submodule.mem_colon_singleton, smul_eq_mul]\n#align ideal.mem_colon_singleton Ideal.mem_colon_singleton\n-/\n\n",
 "mem_colon'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem mem_colon' {r} : r ∈ N.colon P ↔ P ≤ comap («expr • » r (LinearMap.id : «expr →ₗ[ ] » M R M)) N :=\n  mem_colon\n#align mem_colon' mem_colon'\n\n",
 "mem_colon":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_colon {r} : r ∈ N.colon P ↔ ∀ p ∈ P, «expr • » r p ∈ N :=\n  mem_annihilator.trans\n    ⟨fun H p hp => (Quotient.mk_eq_zero N).1 (H (Quotient.mk p) (mem_map_of_mem hp)), fun H m ⟨p, hp, hpm⟩ =>\n      hpm ▸ N.mkq.map_smul r p ▸ (Quotient.mk_eq_zero N).2 <| H p hp⟩\n#align mem_colon mem_colon\n\n",
 "mem_annihilator_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_annihilator_span_singleton (g : M) (r : R) :\n    r ∈ (Submodule.span R ({g} : Set M)).annihilator ↔ «expr • » r g = 0 := by simp [mem_annihilator_span]\n#align mem_annihilator_span_singleton mem_annihilator_span_singleton\n\n",
 "mem_annihilator_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_annihilator_span (s : Set M) (r : R) :\n    r ∈ (Submodule.span R s).annihilator ↔ ∀ n : s, «expr • » r (n : M) = 0 :=\n  by\n  rw [Submodule.mem_annihilator]\n  constructor\n  · intro h n\n    exact h _ (Submodule.subset_span n.prop)\n  · intro h n hn\n    apply Submodule.span_induction hn\n    · intro x hx\n      exact h ⟨x, hx⟩\n    · exact smul_zero _\n    · intro x y hx hy\n      rw [smul_add, hx, hy, zero_add]\n    · intro a x hx\n      rw [smul_comm, hx, smul_zero]\n#align mem_annihilator_span mem_annihilator_span\n\n",
 "mem_annihilator'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_annihilator' {r} :\n    r ∈ N.annihilator ↔ N ≤ comap («expr • » r (LinearMap.id : «expr →ₗ[ ] » M R M)) («expr⊥») :=\n  mem_annihilator.trans ⟨fun H n hn => (mem_bot R).2 <| H n hn, fun H n hn => (mem_bot R).1 <| H hn⟩\n#align mem_annihilator' mem_annihilator'\n\n",
 "mem_annihilator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_annihilator {r} : r ∈ N.annihilator ↔ ∀ n ∈ N, «expr • » r n = (0 : M) :=\n  ⟨fun hr n hn => congr_arg Subtype.val (LinearMap.ext_iff.1 (LinearMap.mem_ker.1 hr) ⟨n, hn⟩), fun h =>\n    LinearMap.mem_ker.2 <| LinearMap.ext fun n => Subtype.eq <| h n.1 n.2⟩\n#align mem_annihilator mem_annihilator\n\n",
 "map_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem map_top : map f («expr⊤») = «expr⊤» :=\n  (eq_top_iff_one _).2 <| subset_span ⟨1, trivial, map_one f⟩\n#align map_top map_top\n\n",
 "map_surjective_of_surjective":
 "theorem map_surjective_of_surjective : surjective (map f) :=\n  (giMapComap f hf).l_surjective\n#align map_surjective_of_surjective map_surjective_of_surjective\n\n",
 "map_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print map_supᵢ /-\ntheorem map_supᵢ (K : ι → Ideal R) :\n    (supᵢ K).map f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((K i).map f) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_supr\n#align map_supr map_supᵢ\n-/\n\n",
 "map_supr_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem map_supr_comap_of_surjective (K : ι → Ideal S) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            ((K i).comap f)).map\n        f =\n      supᵢ K :=\n  (giMapComap f hf).l_supr_u _\n#align map_supr_comap_of_surjective map_supr_comap_of_surjective\n\n",
 "map_sup_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup_comap_of_surjective (I J : Ideal S) : («expr ⊔ » (I.comap f) (J.comap f)).map f = «expr ⊔ » I J :=\n  (giMapComap f hf).l_sup_u _ _\n#align map_sup_comap_of_surjective map_sup_comap_of_surjective\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup : («expr ⊔ » I J).map f = «expr ⊔ » (I.map f) (J.map f) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_sup\n#align map_sup map_sup\n\n",
 "map_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_span (f : F) (s : Set R) : map f (span s) = span («expr '' » f s) :=\n  symm <|\n    Submodule.span_eq_of_le _ (fun y ⟨x, hy, x_eq⟩ => x_eq ▸ mem_map_of_mem f (subset_span hy))\n      (map_le_iff_le_comap.2 <| span_le.2 <| Set.image_subset_iff.1 subset_span)\n#align map_span map_span\n\n",
 "map_smul''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_smul'' (f : «expr →ₗ[ ] » M R M') : («expr • » I N).map f = «expr • » I (N.map f) :=\n  le_antisymm\n      (map_le_iff_le_comap.2 <|\n        smul_le.2 fun r hr n hn =>\n          show f («expr • » r n) ∈ «expr • » I (N.map f) from\n            (f.map_smul r n).symm ▸ smul_mem_smul hr (mem_map_of_mem hn)) <|\n    smul_le.2 fun r hr n hn =>\n      let ⟨p, hp, hfp⟩ := mem_map.1 hn\n      hfp ▸ f.map_smul r p ▸ mem_map_of_mem (smul_mem_smul hr hp)\n#align map_smul'' map_smul''\n\n",
 "map_radical_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_radical_of_surjective {f : «expr →+* » R S} (hf : function.surjective f) {I : Ideal R}\n    (h : RingHom.ker f ≤ I) : map f I.radical = (map f I).radical :=\n  by\n  rw [radical_eq_Inf, radical_eq_Inf]\n  have : ∀ J ∈ { J : Ideal R | I ≤ J ∧ J.is_prime }, f.ker ≤ J := fun J hJ => le_trans h hJ.left\n  convert map_Inf hf this\n  refine' funext fun j => propext ⟨_, _⟩\n  · rintro ⟨hj, hj'⟩\n    haveI : j.is_prime := hj'\n    exact ⟨comap f j, ⟨⟨map_le_iff_le_comap.1 hj, comap_is_prime f j⟩, map_comap_of_surjective f hf j⟩⟩\n  · rintro ⟨J, ⟨hJ, hJ'⟩⟩\n    haveI : J.is_prime := hJ.right\n    refine' ⟨hJ' ▸ map_mono hJ.left, hJ' ▸ map_is_prime_of_surjective hf (le_trans h hJ.left)⟩\n#align map_radical_of_surjective map_radical_of_surjective\n\n",
 "map_radical_le":
 "theorem map_radical_le : map f (radical I) ≤ radical (map f I) :=\n  map_le_iff_le_comap.2 fun r ⟨n, hrni⟩ => ⟨n, map_pow f r n ▸ mem_map_of_mem f hrni⟩\n#align map_radical_le map_radical_le\n\n",
 "map_pow":
 "#print map_pow /-\nprotected theorem map_pow (n : ℕ) : map f (I ^ n) = map f I ^ n :=\n  map_pow (mapHom f) I n\n#align map_pow map_pow\n-/\n\n",
 "map_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `f : R ≃+* S` is a ring isomorphism and `I : ideal R`, then `map f (map f.symm) = I`. -/\n@[simp]\ntheorem map_of_equiv (I : Ideal R) (f : «expr ≃+* » R S) :\n    (I.map (f : «expr →+* » R S)).map (f.symm : «expr →+* » S R) = I := by simp [← RingEquiv.toRingHom_eq_coe, map_map]\n#align map_of_equiv map_of_equiv\n\n",
 "map_mul":
 "#print map_mul /-\ntheorem map_mul : map f (I * J) = map f I * map f J :=\n  le_antisymm\n    (map_le_iff_le_comap.2 <|\n      mul_le.2 fun r hri s hsj =>\n        show f (r * s) ∈ _ by rw [map_mul] <;> exact mul_mem_mul (mem_map_of_mem f hri) (mem_map_of_mem f hsj))\n    (trans_rel_right _ (span_mul_span _ _) <|\n      span_le.2 <|\n        Set.unionᵢ₂_subset fun i ⟨r, hri, hfri⟩ =>\n          Set.unionᵢ₂_subset fun j ⟨s, hsj, hfsj⟩ =>\n            Set.singleton_subset_iff.2 <|\n              hfri ▸ hfsj ▸ by rw [← map_mul] <;> exact mem_map_of_mem f (mul_mem_mul hri hsj))\n#align map_mul map_mul\n-/\n\n",
 "map_mono":
 "theorem map_mono (h : I ≤ J) : map f I ≤ map f J :=\n  span_mono <| Set.image_subset _ h\n#align map_mono map_mono\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_map {T : Type _} [Semiring T] {I : Ideal R} (f : «expr →+* » R S) (g : «expr →+* » S T) :\n    (I.map f).map g = I.map (g.comp f) :=\n  ((gc_map_comap f).compose (gc_map_comap g)).l_unique (gc_map_comap (g.comp f)) fun _ => comap_comap _ _\n#align map_map map_map\n\n",
 "map_le_smul_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem map_le_smul_top (I : Ideal R) (f : «expr →ₗ[ ] » R R M) :\n    Submodule.map f I ≤ «expr • » I («expr⊤» : Submodule R M) :=\n  by\n  rintro _ ⟨y, hy, rfl⟩\n  rw [← mul_one y, ← smul_eq_mul, f.map_smul]\n  exact smul_mem_smul hy mem_top\n#align map_le_smul_top map_le_smul_top\n\n",
 "map_le_of_le_comap":
 "theorem map_le_of_le_comap : I ≤ K.comap f → I.map f ≤ K :=\n  (gc_map_comap f).l_le\n#align map_le_of_le_comap map_le_of_le_comap\n\n",
 "map_le_iff_le_comap":
 "theorem map_le_iff_le_comap : map f I ≤ K ↔ I ≤ comap f K :=\n  span_le.trans Set.image_subset_iff\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_le_comap_of_inverse":
 "/-- The `ideal` version of `set.image_subset_preimage_of_inverse`. -/\ntheorem map_le_comap_of_inverse (g : G) (I : Ideal R) (h : function.left_inverse g f) : I.map f ≤ I.comap g :=\n  map_le_comap_of_inv_on _ _ _ <| h.left_inv_on _\n#align map_le_comap_of_inverse map_le_comap_of_inverse\n\n",
 "map_le_comap_of_inv_on":
 "theorem map_le_comap_of_inv_on (g : G) (I : Ideal R) (hf : Set.LeftInvOn g f I) : I.map f ≤ I.comap g :=\n  by\n  refine' Ideal.span_le.2 _\n  rintro x ⟨x, hx, rfl⟩\n  rw [SetLike.mem_coe, mem_comap, hf hx]\n  exact hx\n#align map_le_comap_of_inv_on map_le_comap_of_inv_on\n\n",
 "map_is_prime_of_surjective":
 "theorem map_is_prime_of_surjective {f : F} (hf : function.surjective f) {I : Ideal R} [H : IsPrime I]\n    (hk : RingHom.ker f ≤ I) : IsPrime (map f I) :=\n  by\n  refine' ⟨fun h => H.ne_top (eq_top_iff.2 _), fun x y => _⟩\n  · replace h := congr_arg (comap f) h\n    rw [comap_map_of_surjective _ hf, comap_top] at h\n    exact h ▸ sup_le (le_of_eq rfl) hk\n  · refine' fun hxy => (hf x).rec_on fun a ha => (hf y).rec_on fun b hb => _\n    rw [← ha, ← hb, ← _root_.map_mul f, mem_map_iff_of_surjective _ hf] at hxy\n    rcases hxy with ⟨c, hc, hc'⟩\n    rw [← sub_eq_zero, ← map_sub] at hc'\n    have : a * b ∈ I := by\n      convert I.sub_mem hc (hk (hc' : c - a * b ∈ RingHom.ker f))\n      abel\n    exact (H.mem_or_mem this).imp (fun h => ha ▸ mem_map_of_mem f h) fun h => hb ▸ mem_map_of_mem f h\n#align map_is_prime_of_surjective map_is_prime_of_surjective\n\n",
 "map_is_prime_of_equiv":
 "theorem map_is_prime_of_equiv {F' : Type _} [RingEquivClass F' R S] (f : F') {I : Ideal R} [IsPrime I] :\n    IsPrime (map f I) :=\n  map_isPrime_of_surjective (EquivLike.surjective f) <| by simp only [RingHom.ker_equiv, bot_le]\n#align map_is_prime_of_equiv map_is_prime_of_equiv\n\n",
 "map_infi_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_infi_comap_of_surjective (K : ι → Ideal S) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            ((K i).comap f)).map\n        f =\n      infᵢ K :=\n  (giMapComap f hf).l_infi_u _\n#align map_infi_comap_of_surjective map_infi_comap_of_surjective\n\n",
 "map_inf_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem map_inf_le : map f («expr ⊓ » I J) ≤ «expr ⊓ » (map f I) (map f J) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).monotone_l.map_inf_le _ _\n#align map_inf_le map_inf_le\n\n",
 "map_inf_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem map_inf_comap_of_surjective (I J : Ideal S) : («expr ⊓ » (I.comap f) (J.comap f)).map f = «expr ⊓ » I J :=\n  (giMapComap f hf).l_inf_u _ _\n#align map_inf_comap_of_surjective map_inf_comap_of_surjective\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : I.map (RingHom.id R) = I :=\n  (gc_map_comap (RingHom.id R)).l_unique GaloisConnection.id comap_id\n#align map_id map_id\n\n",
 "map_eq_top_or_is_maximal_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem map_eq_top_or_is_maximal_of_surjective {I : Ideal R} (H : IsMaximal I) :\n    map f I = «expr⊤» ∨ IsMaximal (map f I) :=\n  by\n  refine' or_iff_not_imp_left.2 fun ne_top => ⟨⟨fun h => ne_top h, fun J hJ => _⟩⟩\n  · refine'\n      (rel_iso_of_surjective f hf).injective\n        (Subtype.ext_iff.2 (Eq.trans (H.1.2 (comap f J) (lt_of_le_of_ne _ _)) comap_top.symm))\n    · exact map_le_iff_le_comap.1 (le_of_lt hJ)\n    · exact fun h => hJ.right (le_map_of_comap_le_of_surjective f hf (le_of_eq h.symm))\n#align map_eq_top_or_is_maximal_of_surjective map_eq_top_or_is_maximal_of_surjective\n\n",
 "map_eq_submodule_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_eq_submodule_map (f : «expr →+* » R S) [h : RingHomSurjective f] (I : Ideal R) :\n    I.map f = Submodule.map f.to_semilinear_map I :=\n  Submodule.ext fun x => mem_map_iff_of_surjective f h.1\n#align map_eq_submodule_map map_eq_submodule_map\n\n",
 "map_eq_iff_sup_ker_eq_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_eq_iff_sup_ker_eq_of_surjective {I J : Ideal R} (f : «expr →+* » R S) (hf : function.surjective f) :\n    map f I = map f J ↔ «expr ⊔ » I f.ker = «expr ⊔ » J f.ker := by\n  rw [← (comap_injective_of_surjective f hf).eq_iff, comap_map_of_surjective f hf, comap_map_of_surjective f hf,\n    RingHom.ker_eq_comap_bot]\n#align map_eq_iff_sup_ker_eq_of_surjective map_eq_iff_sup_ker_eq_of_surjective\n\n",
 "map_eq_bot_iff_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem map_eq_bot_iff_of_injective {I : Ideal R} {f : F} (hf : function.injective f) :\n    I.map f = «expr⊥» ↔ I = «expr⊥» := by\n  rw [map_eq_bot_iff_le_ker, (RingHom.injective_iff_ker_eq_bot f).mp hf, le_bot_iff]\n#align map_eq_bot_iff_of_injective map_eq_bot_iff_of_injective\n\n",
 "map_eq_bot_iff_le_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem map_eq_bot_iff_le_ker {I : Ideal R} (f : F) : I.map f = «expr⊥» ↔ I ≤ RingHom.ker f := by\n  rw [RingHom.ker, eq_bot_iff, map_le_iff_le_comap]\n#align map_eq_bot_iff_le_ker map_eq_bot_iff_le_ker\n\n",
 "map_comap_of_surjective":
 "theorem map_comap_of_surjective (I : Ideal S) : map f (comap f I) = I :=\n  le_antisymm (map_le_iff_le_comap.2 le_rfl) fun s hsi =>\n    let ⟨r, hfrs⟩ := hf s\n    hfrs ▸ (mem_map_of_mem f <| show f r ∈ I from hfrs.symm ▸ hsi)\n#align map_comap_of_surjective map_comap_of_surjective\n\n",
 "map_comap_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `f : R ≃+* S` is a ring isomorphism and `I : ideal R`, then `map f I = comap f.symm I`. -/\ntheorem map_comap_of_equiv (I : Ideal R) (f : «expr ≃+* » R S) : I.map (f : «expr →+* » R S) = I.comap f.symm :=\n  le_antisymm (le_comap_of_map_le (map_of_equiv I f).le)\n    (le_map_of_comap_le_of_surjective _ f.surjective (comap_of_equiv I f).le)\n#align map_comap_of_equiv map_comap_of_equiv\n\n",
 "map_comap_map":
 "@[simp]\ntheorem map_comap_map : ((I.map f).comap f).map f = I.map f :=\n  (gc_map_comap f).l_u_l_eq_l I\n#align map_comap_map map_comap_map\n\n",
 "map_comap_le":
 "theorem map_comap_le : (K.comap f).map f ≤ K :=\n  (gc_map_comap f).l_u_le _\n#align map_comap_le map_comap_le\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot : («expr⊥» : Ideal R).map f = «expr⊥» :=\n  (gc_map_comap f).l_bot\n#align map_bot map_bot\n\n",
 "map_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem map_Sup (s : Set (Ideal R)) :\n    (supₛ s).map f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        ((I : Ideal R).map f) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_Sup\n#align map_Sup map_Sup\n\n",
 "map_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_Inf {A : Set (Ideal R)} {f : F} (hf : function.surjective f) :\n    (∀ J ∈ A, RingHom.ker f ≤ J) → map f (infₛ A) = infₛ («expr '' » (map f) A) :=\n  by\n  refine' fun h => le_antisymm (le_infₛ _) _\n  · intro j hj y hy\n    cases' (mem_map_iff_of_surjective f hf).1 hy with x hx\n    cases' (Set.mem_image _ _ _).mp hj with J hJ\n    rw [← hJ.right, ← hx.right]\n    exact mem_map_of_mem f (infₛ_le_of_le hJ.left (le_of_eq rfl) hx.left)\n  · intro y hy\n    cases' hf y with x hx\n    refine' hx ▸ mem_map_of_mem f _\n    have : ∀ I ∈ A, y ∈ map f I := by simpa using hy\n    rw [Submodule.mem_infₛ]\n    intro J hJ\n    rcases(mem_map_iff_of_surjective f hf).1 (this J hJ) with ⟨x', hx', rfl⟩\n    have : x - x' ∈ J := by\n      apply h J hJ\n      rw [RingHom.mem_ker, map_sub, hx, sub_self]\n    simpa only [sub_add_cancel] using J.add_mem this hx'\n#align map_Inf map_Inf\n\n",
 "lift_of_right_inverse_comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem lift_of_right_inverse_comp_apply (hf : function.right_inverse f_inv f)\n    (g : { g : «expr →+* » A C // f.ker ≤ g.ker }) (x : A) : (f.lift_of_right_inverse f_inv hf g) (f x) = g x :=\n  f.lift_of_right_inverse_aux_comp_apply f_inv hf g.1 g.2 x\n#align lift_of_right_inverse_comp_apply lift_of_right_inverse_comp_apply\n\n",
 "lift_of_right_inverse_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem lift_of_right_inverse_comp (hf : function.right_inverse f_inv f)\n    (g : { g : «expr →+* » A C // f.ker ≤ g.ker }) : (f.lift_of_right_inverse f_inv hf g).comp f = g :=\n  RingHom.ext <| f.lift_of_right_inverse_comp_apply f_inv hf g\n#align lift_of_right_inverse_comp lift_of_right_inverse_comp\n\n",
 "lift_of_right_inverse_aux_comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n-- TODO: show `[algebra R A] : algebra (ideal R) A` too\n@[simp]\ntheorem lift_of_right_inverse_aux_comp_apply (hf : function.right_inverse f_inv f) (g : «expr →+* » A C)\n    (hg : f.ker ≤ g.ker) (a : A) : (f.lift_of_right_inverse_aux f_inv hf g hg) (f a) = g a :=\n  f.to_add_monoid_hom.lift_of_right_inverse_comp_apply f_inv hf ⟨g.to_add_monoid_hom, hg⟩ a\n#align lift_of_right_inverse_aux_comp_apply lift_of_right_inverse_aux_comp_apply\n\n",
 "le_span_singleton_mul_iff":
 "theorem le_span_singleton_mul_iff {x : R} {I J : Ideal R} : I ≤ span {x} * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI :=\n  show (∀ {zI} (hzI : zI ∈ I), zI ∈ span {x} * J) ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI by\n    simp only [mem_span_singleton_mul]\n#align le_span_singleton_mul_iff le_span_singleton_mul_iff\n\n",
 "le_radical":
 "theorem le_radical : I ≤ radical I := fun r hri => ⟨1, (pow_one r).symm ▸ hri⟩\n#align le_radical le_radical\n\n",
 "le_of_dvd":
 "/-- If `I` divides `J`, then `I` contains `J`.\n\nIn a Dedekind domain, to divide and contain are equivalent, see `ideal.dvd_iff_le`.\n-/\ntheorem le_of_dvd {I J : Ideal R} : I ∣ J → J ≤ I\n  | ⟨K, h⟩ => h.symm ▸ le_trans mul_le_inf inf_le_left\n#align le_of_dvd le_of_dvd\n\n",
 "le_map_of_comap_le_of_surjective":
 "theorem le_map_of_comap_le_of_surjective : comap f K ≤ I → K ≤ map f I := fun h =>\n  map_comap_of_surjective f hf K ▸ map_mono h\n#align le_map_of_comap_le_of_surjective le_map_of_comap_le_of_surjective\n\n",
 "le_comap_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem le_comap_sup : «expr ⊔ » (comap f K) (comap f L) ≤ comap f («expr ⊔ » K L) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).monotone_u.le_map_sup _ _\n#align le_comap_sup le_comap_sup\n\n",
 "le_comap_pow":
 "theorem le_comap_pow (n : ℕ) : K.comap f ^ n ≤ (K ^ n).comap f :=\n  by\n  induction n\n  · rw [pow_zero, pow_zero, Ideal.one_eq_top, Ideal.one_eq_top]\n    exact rfl.le\n  · rw [pow_succ, pow_succ]\n    exact (Ideal.mul_mono_right n_ih).trans (Ideal.le_comap_mul f)\n#align le_comap_pow le_comap_pow\n\n",
 "le_comap_of_map_le":
 "theorem le_comap_of_map_le : I.map f ≤ K → I ≤ K.comap f :=\n  (gc_map_comap f).le_u\n#align le_comap_of_map_le le_comap_of_map_le\n\n",
 "le_comap_mul":
 "theorem le_comap_mul : comap f K * comap f L ≤ comap f (K * L) :=\n  map_le_iff_le_comap.1 <|\n    (map_mul f (comap f K) (comap f L)).symm ▸\n      mul_mono (map_le_iff_le_comap.2 <| le_rfl) (map_le_iff_le_comap.2 <| le_rfl)\n#align le_comap_mul le_comap_mul\n\n",
 "le_comap_map":
 "theorem le_comap_map : I ≤ (I.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n#align le_comap_map le_comap_map\n\n",
 "ker_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ker_ne_top [Nontrivial S] (f : F) : ker f ≠ «expr⊤» :=\n  (Ideal.ne_top_iff_one _).mpr <| not_one_mem_ker f\n#align ker_ne_top ker_ne_top\n\n",
 "ker_le_comap":
 "theorem ker_le_comap {K : Ideal S} (f : F) : RingHom.ker f ≤ comap f K := fun x hx =>\n  mem_comap.2 (((RingHom.mem_ker f).1 hx).symm ▸ K.zero_mem)\n#align ker_le_comap ker_le_comap\n\n",
 "ker_is_prime":
 "/-- The kernel of a homomorphism to a domain is a prime ideal. -/\ntheorem ker_is_prime {F : Type _} [Ring R] [Ring S] [IsDomain S] [RingHomClass F R S] (f : F) : (ker f).is_prime :=\n  ⟨by\n    rw [ne.def, Ideal.eq_top_iff_one]\n    exact not_one_mem_ker f, fun x y => by\n    simpa only [mem_ker, map_mul] using @eq_zero_or_eq_zero_of_mul_eq_zero S _ _ _ _ _⟩\n#align ker_is_prime ker_is_prime\n\n",
 "ker_is_maximal_of_surjective":
 "/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem ker_is_maximal_of_surjective {R K F : Type _} [Ring R] [Field K] [RingHomClass F R K] (f : F)\n    (hf : function.surjective f) : (ker f).is_maximal :=\n  by\n  refine' ideal.is_maximal_iff.mpr ⟨fun h1 => one_ne_zero' K <| map_one f ▸ (mem_ker f).mp h1, fun J x hJ hxf hxJ => _⟩\n  obtain ⟨y, hy⟩ := hf (f x)⁻¹\n  have H : 1 = y * x - (y * x - 1) := (sub_sub_cancel _ _).symm\n  rw [H]\n  refine' J.sub_mem (J.mul_mem_left _ hxJ) (hJ _)\n  rw [mem_ker]\n  simp only [hy, map_sub, map_one, map_mul, inv_mul_cancel (mt (mem_ker f).mpr hxf), sub_self]\n#align ker_is_maximal_of_surjective ker_is_maximal_of_surjective\n\n",
 "ker_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ker_equiv {F' : Type _} [RingEquivClass F' R S] (f : F') : ker f = «expr⊥» := by\n  simpa only [← injective_iff_ker_eq_bot] using EquivLike.injective f\n#align ker_equiv ker_equiv\n\n",
 "ker_eq_comap_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_eq_comap_bot (f : F) : ker f = Ideal.comap f («expr⊥») :=\n  rfl\n#align ker_eq_comap_bot ker_eq_comap_bot\n\n",
 "ker_eq_bot_iff_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_eq_bot_iff_eq_zero : ker f = «expr⊥» ↔ ∀ x, f x = 0 → x = 0 := by\n  rw [← injective_iff_map_eq_zero f, injective_iff_ker_eq_bot]\n#align ker_eq_bot_iff_eq_zero ker_eq_bot_iff_eq_zero\n\n",
 "ker_eq":
 "theorem ker_eq : (ker f : Set R) = Set.preimage f {0} :=\n  rfl\n#align ker_eq ker_eq\n\n",
 "ker_coe_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ker_coe_equiv (f : «expr ≃+* » R S) : ker (f : «expr →+* » R S) = «expr⊥» := by\n  simpa only [← injective_iff_ker_eq_bot] using EquivLike.injective f\n#align ker_coe_equiv ker_coe_equiv\n\n",
 "is_unit_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_unit_iff {I : Ideal R} : IsUnit I ↔ I = «expr⊤» :=\n  isUnit_iff_dvd_one.trans\n    ((@one_eq_top R _).symm ▸ ⟨fun h => eq_top_iff.mpr (Ideal.le_of_dvd h), fun h => ⟨«expr⊤», by rw [mul_top, h]⟩⟩)\n#align is_unit_iff is_unit_iff\n\n",
 "is_radical_bot_of_no_zero_divisors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_radical_bot_of_no_zero_divisors {R} [CommSemiring R] [NoZeroDivisors R] : («expr⊥» : Ideal R).is_radical :=\n  fun x hx => hx.rec_on fun n hn => pow_eq_zero hn\n#align is_radical_bot_of_no_zero_divisors is_radical_bot_of_no_zero_divisors\n\n",
 "is_radical":
 "theorem is_prime.is_radical (H : IsPrime I) : I.is_radical := fun r ⟨n, hrni⟩ => H.mem_of_pow_mem n hrni\n#align is_prime.is_radical is_prime.is_radical\n\n",
 "is_prime_radical":
 "theorem is_prime_radical {I : Ideal R} (hi : IsPrimary I) : IsPrime (radical I) :=\n  ⟨mt radical_eq_top.1 hi.1, fun x y ⟨m, hxy⟩ => by\n    rw [mul_pow] at hxy; cases hi.2 hxy\n    · exact or.inl ⟨m, h⟩\n    · exact or.inr (mem_radical_of_pow_mem h)⟩\n#align is_prime_radical is_prime_radical\n\n",
 "is_primary_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_primary_inf {I J : Ideal R} (hi : IsPrimary I) (hj : IsPrimary J) (hij : radical I = radical J) :\n    IsPrimary («expr ⊓ » I J) :=\n  ⟨ne_of_lt <| lt_of_le_of_lt inf_le_left (lt_top_iff_ne_top.2 hi.1), fun x y ⟨hxyi, hxyj⟩ =>\n    by\n    rw [radical_inf, hij, inf_idem]\n    cases' hi.2 hxyi with hxi hyi; cases' hj.2 hxyj with hxj hyj\n    · exact or.inl ⟨hxi, hxj⟩\n    · exact or.inr hyj\n    · rw [hij] at hyi\n      exact or.inr hyi⟩\n#align is_primary_inf is_primary_inf\n\n",
 "is_primary":
 "theorem is_prime.is_primary {I : Ideal R} (hi : IsPrime I) : IsPrimary I :=\n  ⟨hi.1, fun x y hxy => (hi.mem_or_mem hxy).imp id fun hyi => le_radical hyi⟩\n#align is_prime.is_primary is_prime.is_primary\n\n",
 "is_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem map.is_maximal {I : Ideal R} (H : IsMaximal I) : IsMaximal (map f I) := by\n  refine' or_iff_not_imp_left.1 (map_eq_top_or_is_maximal_of_surjective f hf.right H) fun h => H.1.1 _ <;>\n    calc\n      I = comap f (map f I) := ((rel_iso_of_bijective f hf).right_inv I).symm\n      _ = comap f («expr⊤») := by rw [h]\n      _ = «expr⊤» := by rw [comap_top]\n      \n#align map.is_maximal map.is_maximal\n\n",
 "injective_iff_ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem injective_iff_ker_eq_bot : function.injective f ↔ ker f = «expr⊥» :=\n  by\n  rw [SetLike.ext'_iff, ker_eq, Set.ext_iff]\n  exact injective_iff_map_eq_zero' f\n#align injective_iff_ker_eq_bot injective_iff_ker_eq_bot\n\n",
 "infi_sup_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem infi_sup_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → «expr ⊔ » (J i) I = «expr⊤») :\n    «expr ⊔ » («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (J i))\n        I =\n      «expr⊤» :=\n  sup_comm.trans (sup_infᵢ_eq_top fun i hi => sup_comm.trans <| h i hi)\n#align infi_sup_eq_top infi_sup_eq_top\n\n",
 "infi_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem infi_span_singleton {ι : Type _} [Fintype ι] (I : ι → R) (hI : ∀ (i j) (hij : i ≠ j), IsCoprime (I i) (I j)) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (Ideal.span ({I i} : Set R)) =\n      Ideal.span\n        {finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (I i)} :=\n  by\n  rw [← Finset.inf_univ_eq_infᵢ, finset_inf_span_singleton]\n  rwa [Finset.coe_univ, Set.pairwise_univ]\n#align infi_span_singleton infi_span_singleton\n\n",
 "infi_colon_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_colon_supr (ι₁ : Sort w) (f : ι₁ → Submodule R M) (ι₂ : Sort x) (g : ι₂ → Submodule R M) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)).colon\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (g j)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((f i).colon (g j)) :=\n  le_antisymm (le_infᵢ fun i => le_infᵢ fun j => colon_mono (infᵢ_le _ _) (le_supᵢ _ _)) fun r H =>\n    mem_colon'.2 <|\n      supᵢ_le fun j =>\n        map_le_iff_le_comap.1 <|\n          le_infᵢ fun i =>\n            map_le_iff_le_comap.2 <|\n              mem_colon'.1 <|\n                have := (mem_infᵢ _).1 H i\n                have := (mem_infᵢ _).1 this j\n                this\n#align infi_colon_supr infi_colon_supr\n\n",
 "inf_le'":
 "theorem is_prime.inf_le' {s : Finset ι} {f : ι → Ideal R} {P : Ideal R} (hp : IsPrime P) (hsne : s.nonempty) :\n    s.inf f ≤ P ↔ ∃ i ∈ s, f i ≤ P :=\n  ⟨fun h => (hp.prod_le hsne).1 <| le_trans prod_le_inf h, fun ⟨i, his, hip⟩ => le_trans (Finset.inf_le his) hip⟩\n#align is_prime.inf_le' is_prime.inf_le'\n\n",
 "inf_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_prime.inf_le {I J P : Ideal R} (hp : IsPrime P) : «expr ⊓ » I J ≤ P ↔ I ≤ P ∨ J ≤ P :=\n  ⟨fun h => hp.mul_le.1 <| le_trans mul_le_inf h, fun h => or.cases_on h (le_trans inf_le_left) (le_trans inf_le_right)⟩\n#align is_prime.inf_le is_prime.inf_le\n\n",
 "ideal_span_singleton_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem ideal_span_singleton_smul (r : R) (N : Submodule R M) :\n    «expr • » (Ideal.span {r} : Ideal R) N = «expr • » r N :=\n  by\n  have :\n    span R\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          {«expr • » r t}) =\n      «expr • » r N :=\n    by\n    convert span_eq _\n    exact (Set.image_eq_unionᵢ _ (N : Set M)).symm\n  conv_lhs => rw [← span_eq N, span_smul_span]\n  simpa\n#align ideal_span_singleton_smul ideal_span_singleton_smul\n\n",
 "gc_map_comap":
 "theorem gc_map_comap : GaloisConnection (Ideal.map f) (Ideal.comap f) := fun I J => Ideal.map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "finsupp_total_apply_eq_of_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem finsupp_total_apply_eq_of_fintype [Fintype ι] (f : «expr →₀ » ι I) :\n    finsuppTotal ι M I v f =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (f i : R) (v i)) :=\n  by\n  rw [finsupp_total_apply, Finsupp.sum_fintype]\n  exact fun _ => zero_smul _ _\n#align finsupp_total_apply_eq_of_fintype finsupp_total_apply_eq_of_fintype\n\n",
 "finsupp_total_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem finsupp_total_apply (f : «expr →₀ » ι I) : finsuppTotal ι M I v f = f.sum fun i x => «expr • » (x : R) (v i) :=\n  by\n  dsimp [finsupp_total]\n  rw [Finsupp.total_apply, Finsupp.sum_mapRange_index]\n  exact fun _ => zero_smul _ _\n#align finsupp_total_apply finsupp_total_apply\n\n",
 "finset_inf_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem finset_inf_span_singleton {ι : Type _} (s : Finset ι) (I : ι → R)\n    (hI : Set.Pairwise (↑s) («expr on » IsCoprime I)) :\n    (s.inf fun i => Ideal.span ({I i} : Set R)) =\n      Ideal.span\n        {finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (I i)} :=\n  by\n  ext x\n  simp only [Submodule.mem_finset_inf, Ideal.mem_span_singleton]\n  exact ⟨Finset.prod_dvd_of_coprime hI, fun h i hi => (Finset.dvd_prod_of_mem _ hi).trans h⟩\n#align finset_inf_span_singleton finset_inf_span_singleton\n\n",
 "eq_span_singleton_mul":
 "theorem eq_span_singleton_mul {x : R} (I J : Ideal R) :\n    I = span {x} * J ↔ (∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI) ∧ ∀ z ∈ J, x * z ∈ I := by\n  simp only [le_antisymm_iff, le_span_singleton_mul_iff, span_singleton_mul_le_iff]\n#align eq_span_singleton_mul eq_span_singleton_mul\n\n",
 "eq_lift_of_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eq_lift_of_right_inverse (hf : function.right_inverse f_inv f) (g : «expr →+* » A C) (hg : f.ker ≤ g.ker)\n    (h : «expr →+* » B C) (hh : h.comp f = g) : h = f.lift_of_right_inverse f_inv hf ⟨g, hg⟩ :=\n  by\n  simp_rw [← hh]\n  exact ((f.lift_of_right_inverse f_inv hf).apply_symm_apply _).symm\n#align eq_lift_of_right_inverse eq_lift_of_right_inverse\n\n",
 "constr_basis_span_singleton":
 "@[simp]\ntheorem constr_basis_span_singleton {N : Type _} [Semiring N] [Module N S] [SMulCommClass R N S] (b : Basis ι R S)\n    {x : S} (hx : x ≠ 0) : b.constr N (coe ∘ basisSpanSingleton b hx) = Algebra.lmul R S x :=\n  b.ext fun i => by erw [Basis.constr_basis, Function.comp_apply, basis_span_singleton_apply, LinearMap.mul_apply']\n#align constr_basis_span_singleton constr_basis_span_singleton\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top : («expr⊤» : Ideal S).comap f = «expr⊤» :=\n  (gc_map_comap f).u_top\n#align comap_top comap_top\n\n",
 "comap_radical":
 "theorem comap_radical : comap f (radical K) = radical (comap f K) :=\n  by\n  ext\n  simpa only [radical, mem_comap, map_pow]\n#align comap_radical comap_radical\n\n",
 "comap_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `f : R ≃+* S` is a ring isomorphism and `I : ideal R`, then `comap f.symm (comap f) = I`. -/\n@[simp]\ntheorem comap_of_equiv (I : Ideal R) (f : «expr ≃+* » R S) :\n    (I.comap (f.symm : «expr →+* » S R)).comap (f : «expr →+* » R S) = I := by\n  simp [← RingEquiv.toRingHom_eq_coe, comap_comap]\n#align comap_of_equiv comap_of_equiv\n\n",
 "comap_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem comap_ne_top (hK : K ≠ «expr⊤») : comap f K ≠ «expr⊤» :=\n  (ne_top_iff_one _).2 <| by rw [mem_comap, map_one] <;> exact (ne_top_iff_one _).1 hK\n#align comap_ne_top comap_ne_top\n\n",
 "comap_mono":
 "theorem comap_mono (h : K ≤ L) : comap f K ≤ comap f L :=\n  Set.preimage_mono fun x hx => h hx\n#align comap_mono comap_mono\n\n",
 "comap_map_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comap_map_of_surjective (I : Ideal R) : comap f (map f I) = «expr ⊔ » I (comap f («expr⊥»)) :=\n  le_antisymm\n    (fun r h =>\n      let ⟨s, hsi, hfsr⟩ := mem_image_of_mem_map_of_surjective f hf h\n      Submodule.mem_sup.2\n        ⟨s, hsi, r - s, (Submodule.mem_bot S).2 <| by rw [map_sub, hfsr, sub_self], add_sub_cancel'_right s r⟩)\n    (sup_le (map_le_iff_le_comap.1 le_rfl) (comap_mono bot_le))\n#align comap_map_of_surjective comap_map_of_surjective\n\n",
 "comap_map_comap":
 "@[simp]\ntheorem comap_map_comap : ((K.comap f).map f).comap f = K.comap f :=\n  (gc_map_comap f).u_l_u_eq_u K\n#align comap_map_comap comap_map_comap\n\n",
 "comap_le_map_of_inverse":
 "/-- The `ideal` version of `set.preimage_subset_image_of_inverse`. -/\ntheorem comap_le_map_of_inverse (g : G) (I : Ideal S) (h : function.left_inverse g f) : I.comap f ≤ I.map g :=\n  comap_le_map_of_inv_on _ _ _ <| h.left_inv_on _\n#align comap_le_map_of_inverse comap_le_map_of_inverse\n\n",
 "comap_le_map_of_inv_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comap_le_map_of_inv_on (g : G) (I : Ideal S) (hf : Set.LeftInvOn g f («expr ⁻¹' » f I)) : I.comap f ≤ I.map g :=\n  fun x (hx : f x ∈ I) => hf hx ▸ Ideal.mem_map_of_mem g hx\n#align comap_le_map_of_inv_on comap_le_map_of_inv_on\n\n",
 "comap_le_iff_le_map":
 "theorem comap_le_iff_le_map {I : Ideal R} {K : Ideal S} : comap f K ≤ I ↔ K ≤ map f I :=\n  ⟨fun h => le_map_of_comap_le_of_surjective f hf.right h, fun h => (relIsoOfBijective f hf).right_inv I ▸ comap_mono h⟩\n#align comap_le_iff_le_map comap_le_iff_le_map\n\n",
 "comap_le_comap_iff_of_surjective":
 "theorem comap_le_comap_iff_of_surjective (I J : Ideal S) : comap f I ≤ comap f J ↔ I ≤ J :=\n  ⟨fun h => (map_comap_of_surjective f hf I).symm.le.trans (map_le_of_le_comap h), fun h =>\n    le_comap_of_map_le ((map_comap_of_surjective f hf I).le.trans h)⟩\n#align comap_le_comap_iff_of_surjective comap_le_comap_iff_of_surjective\n\n",
 "comap_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_ker (f : «expr →+* » S R) (g : «expr →+* » T S) : f.ker.comap g = (f.comp g).ker := by\n  rw [RingHom.ker_eq_comap_bot, Ideal.comap_comap, RingHom.ker_eq_comap_bot]\n#align comap_ker comap_ker\n\n",
 "comap_is_prime":
 "theorem comap_is_prime [H : IsPrime K] : IsPrime (comap f K) :=\n  ⟨comap_ne_top f H.ne_top, fun x y h => H.mem_or_mem <| by rwa [mem_comap, map_mul] at h⟩\n#align comap_is_prime comap_is_prime\n\n",
 "comap_is_maximal_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem comap_is_maximal_of_surjective {K : Ideal S} [H : IsMaximal K] : IsMaximal (comap f K) :=\n  by\n  refine' ⟨⟨comap_ne_top _ H.1.1, fun J hJ => _⟩⟩\n  suffices map f J = «expr⊤» by\n    replace this := congr_arg (comap f) this\n    rw [comap_top, comap_map_of_surjective _ hf, eq_top_iff] at this\n    rw [eq_top_iff]\n    exact le_trans this (sup_le (le_of_eq rfl) (le_trans (comap_mono bot_le) (le_of_lt hJ)))\n  refine'\n    H.1.2 (map f J)\n      (lt_of_le_of_ne (le_map_of_comap_le_of_surjective _ hf (le_of_lt hJ)) fun h =>\n        ne_of_lt hJ (trans (congr_arg (comap f) h) _))\n  rw [comap_map_of_surjective _ hf, sup_eq_left]\n  exact le_trans (comap_mono bot_le) (le_of_lt hJ)\n#align comap_is_maximal_of_surjective comap_is_maximal_of_surjective\n\n",
 "comap_injective_of_surjective":
 "theorem comap_injective_of_surjective : injective (comap f) :=\n  (giMapComap f hf).u_injective\n#align comap_injective_of_surjective comap_injective_of_surjective\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_infi (K : ι → Ideal S) :\n    (infᵢ K).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((K i).comap f) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_infi\n#align comap_infi comap_infi\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_inf : comap f («expr ⊓ » K L) = «expr ⊓ » (comap f K) (comap f L) :=\n  rfl\n#align comap_inf comap_inf\n\n",
 "comap_id":
 "@[simp]\ntheorem comap_id : I.comap (RingHom.id R) = I :=\n  Ideal.ext fun _ => iff.rfl\n#align comap_id comap_id\n\n",
 "comap_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_eq_top_iff {I : Ideal S} : I.comap f = «expr⊤» ↔ I = «expr⊤» :=\n  ⟨fun h => I.eq_top_iff_one.mpr (map_one f ▸ mem_comap.mp ((I.comap f).eq_top_iff_one.mp h)), fun h => by\n    rw [h, comap_top]⟩\n#align comap_eq_top_iff comap_eq_top_iff\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_comap {T : Type _} [Semiring T] {I : Ideal T} (f : «expr →+* » R S) (g : «expr →+* » S T) :\n    (I.comap g).comap f = I.comap (g.comp f) :=\n  rfl\n#align comap_comap comap_comap\n\n",
 "comap_bot_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comap_bot_of_injective : Ideal.comap f («expr⊥») = «expr⊥» :=\n  le_bot_iff.mp (Ideal.comap_bot_le_of_injective f hf)\n#align comap_bot_of_injective comap_bot_of_injective\n\n",
 "comap_bot_le_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comap_bot_le_of_injective : comap f («expr⊥») ≤ I :=\n  by\n  refine' le_trans (fun x hx => _) bot_le\n  rw [mem_comap, Submodule.mem_bot, ← map_zero f] at hx\n  exact Eq.symm (hf hx) ▸ Submodule.zero_mem («expr⊥»)\n#align comap_bot_le_of_injective comap_bot_le_of_injective\n\n",
 "comap_Inf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_Inf' (s : Set (Ideal S)) :\n    (infₛ s).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" I :=\n  trans (comap_infₛ f s) (by rw [infᵢ_image])\n#align comap_Inf' comap_Inf'\n\n",
 "comap_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_Inf (s : Set (Ideal S)) :\n    (infₛ s).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((I : Ideal S).comap f) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_Inf\n#align comap_Inf comap_Inf\n\n",
 "comap":
 "theorem is_radical.comap (hK : K.is_radical) : (comap f K).is_radical :=\n  by\n  rw [← hK.radical, comap_radical]\n  apply radical_is_radical\n#align is_radical.comap is_radical.comap\n\n",
 "colon_mono":
 "theorem colon_mono (hn : N₁ ≤ N₂) (hp : P₁ ≤ P₂) : N₁.colon P₂ ≤ N₂.colon P₁ := fun r hrnp =>\n  mem_colon.2 fun p₁ hp₁ => hn <| mem_colon.1 hrnp p₁ <| hp hp₁\n#align colon_mono colon_mono\n\n",
 "coe_restrict_scalars":
 "@[simp]\ntheorem coe_restrict_scalars {R S : Type _} [CommSemiring R] [Semiring S] [Algebra R S] (I : Ideal S) :\n    (I.restrict_scalars R : Set S) = ↑I :=\n  rfl\n#align coe_restrict_scalars coe_restrict_scalars\n\n",
 "bot_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_smul : «expr • » («expr⊥» : Ideal R) N = «expr⊥» :=\n  map₂_bot_left _ _\n#align bot_smul bot_smul\n\n",
 "bot_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_mul : «expr⊥» * I = «expr⊥» :=\n  Submodule.bot_smul I\n#align bot_mul bot_mul\n\n",
 "bot_maximal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ring_equiv.bot_maximal_iff (e : «expr ≃+* » R S) :\n    («expr⊥» : Ideal R).is_maximal ↔ («expr⊥» : Ideal S).is_maximal :=\n  ⟨fun h => @map_bot _ _ _ _ _ _ e.to_ring_hom ▸ map.isMaximal e.to_ring_hom e.bijective h, fun h =>\n    @map_bot _ _ _ _ _ _ e.symm.to_ring_hom ▸ map.isMaximal e.symm.to_ring_hom e.symm.bijective h⟩\n#align ring_equiv.bot_maximal_iff ring_equiv.bot_maximal_iff\n\n",
 "basis_span_singleton_apply":
 "@[simp]\ntheorem basis_span_singleton_apply (b : Basis ι R S) {x : S} (hx : x ≠ 0) (i : ι) :\n    (basisSpanSingleton b hx i : S) = x * b i := by\n  simp only [basis_span_singleton, Basis.map_apply, LinearEquiv.trans_apply, submodule.restrict_scalars_equiv_apply,\n    LinearEquiv.ofInjective_apply, LinearEquiv.coe_ofEq_apply, LinearEquiv.restrictScalars_apply,\n    Algebra.coe_lmul_eq_mul, LinearMap.mul_apply']\n#align basis_span_singleton_apply basis_span_singleton_apply\n\n",
 "apply_coe_mem_map":
 "theorem apply_coe_mem_map (f : F) (I : Ideal R) (x : I) : f x ∈ I.map f :=\n  mem_map_of_mem f x.prop\n#align apply_coe_mem_map apply_coe_mem_map\n\n",
 "annihilator_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem annihilator_supr (ι : Sort w) (f : ι → Submodule R M) :\n    annihilator\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (annihilator (f i)) :=\n  le_antisymm (le_infᵢ fun i => annihilator_mono <| le_supᵢ _ _) fun r H =>\n    mem_annihilator'.2 <|\n      supᵢ_le fun i =>\n        have := (mem_infᵢ _).1 H i\n        mem_annihilator'.1 this\n#align annihilator_supr annihilator_supr\n\n",
 "annihilator_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem annihilator_smul (N : Submodule R M) : «expr • » (annihilator N) N = «expr⊥» :=\n  eq_bot_iff.2 (smul_le.2 fun r => mem_annihilator.1)\n#align annihilator_smul annihilator_smul\n\n",
 "annihilator_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem annihilator_mul (I : Ideal R) : annihilator I * I = «expr⊥» :=\n  annihilator_smul I\n#align annihilator_mul annihilator_mul\n\n",
 "annihilator_mono":
 "theorem annihilator_mono (h : N ≤ P) : P.annihilator ≤ N.annihilator := fun r hrp =>\n  mem_annihilator.2 fun n hn => mem_annihilator.1 hrp n <| h hn\n#align annihilator_mono annihilator_mono\n\n",
 "annihilator_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem annihilator_eq_top_iff : N.annihilator = «expr⊤» ↔ N = «expr⊥» :=\n  ⟨fun H =>\n    eq_bot_iff.2 fun (n : M) hn =>\n      (mem_bot R).2 <| one_smul R n ▸ mem_annihilator.1 ((Ideal.eq_top_iff_one _).1 H) n hn,\n    fun H => H.symm ▸ annihilator_bot⟩\n#align annihilator_eq_top_iff annihilator_eq_top_iff\n\n",
 "annihilator_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem annihilator_bot : («expr⊥» : Submodule R M).annihilator = «expr⊤» :=\n  (Ideal.eq_top_iff_one _).2 <| mem_annihilator'.2 bot_le\n#align annihilator_bot annihilator_bot\n\n",
 "add_eq_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print add_eq_sup /-\n@[simp]\ntheorem add_eq_sup {I J : Ideal R} : I + J = «expr ⊔ » I J :=\n  rfl\n#align add_eq_sup add_eq_sup\n-/\n\n"}