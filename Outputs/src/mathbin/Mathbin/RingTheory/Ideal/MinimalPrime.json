{"radical_minimal_primes":
 "@[simp]\ntheorem ideal.radical_minimal_primes : I.radical.minimal_primes = I.minimal_primes :=\n  by\n  rw [ideal.minimal_primes, ideal.minimal_primes]\n  congr\n  ext p\n  exact ⟨fun ⟨a, b⟩ => ⟨a, ideal.le_radical.trans b⟩, fun ⟨a, b⟩ => ⟨a, a.radical_le_iff.mpr b⟩⟩\n#align ideal.radical_minimal_primes ideal.radical_minimal_primes\n\n",
 "minimal_primes_eq_subsingleton_self":
 "theorem ideal.minimal_primes_eq_subsingleton_self [I.is_prime] : I.minimal_primes = {I} :=\n  by\n  ext J\n  constructor\n  · exact fun H => (H.2 ⟨inferInstance, rfl.le⟩ H.1.2).antisymm H.1.2\n  · rintro (rfl : J = I)\n    refine' ⟨⟨inferInstance, rfl.le⟩, fun _ h _ => h.2⟩\n#align ideal.minimal_primes_eq_subsingleton_self ideal.minimal_primes_eq_subsingleton_self\n\n",
 "minimal_primes_eq_subsingleton":
 "theorem ideal.minimal_primes_eq_subsingleton (hI : I.is_primary) : I.minimal_primes = {I.radical} :=\n  by\n  ext J\n  constructor\n  ·\n    exact fun H =>\n      let e := H.1.1.radical_le_iff.mpr H.1.2\n      (H.2 ⟨Ideal.isPrime_radical hI, Ideal.le_radical⟩ e).antisymm e\n  · rintro (rfl : J = I.radical)\n    exact ⟨⟨Ideal.isPrime_radical hI, Ideal.le_radical⟩, fun _ H _ => H.1.radical_le_iff.mpr H.2⟩\n#align ideal.minimal_primes_eq_subsingleton ideal.minimal_primes_eq_subsingleton\n\n",
 "minimal_primes_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem ideal.minimal_primes_eq_comap :\n    I.minimal_primes = «expr '' » (Ideal.comap I.quotient.mk) (minimal_primes («expr ⧸ » R I)) := by\n  rw [minimal_primes, ← ideal.comap_minimal_primes_eq_of_surjective Ideal.Quotient.mk_surjective, ←\n    RingHom.ker_eq_comap_bot, Ideal.mk_ker]\n#align ideal.minimal_primes_eq_comap ideal.minimal_primes_eq_comap\n\n",
 "mimimal_primes_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ideal.mimimal_primes_comap_of_surjective {f : «expr →+* » R S} (hf : function.surjective f) {I J : Ideal S}\n    (h : J ∈ I.minimal_primes) : J.comap f ∈ (I.comap f).minimal_primes :=\n  by\n  haveI := h.1.1\n  refine' ⟨⟨inferInstance, Ideal.comap_mono h.1.2⟩, _⟩\n  rintro K ⟨hK, e₁⟩ e₂\n  have : f.ker ≤ K := (Ideal.comap_mono bot_le).trans e₁\n  rw [← sup_eq_left.mpr this, RingHom.ker_eq_comap_bot, ← Ideal.comap_map_of_surjective f hf]\n  apply Ideal.comap_mono _\n  apply h.2 _ _\n  · exact ⟨Ideal.map_isPrime_of_surjective hf this, Ideal.le_map_of_comap_le_of_surjective f hf e₁⟩\n  · exact Ideal.map_le_of_le_comap e₂\n#align ideal.mimimal_primes_comap_of_surjective ideal.mimimal_primes_comap_of_surjective\n\n",
 "exists_minimal_primes_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem ideal.exists_minimal_primes_le [J.is_prime] (e : I ≤ J) : ∃ p ∈ I.minimal_primes, p ≤ J :=\n  by\n  suffices\n    ∃ m ∈ { p : «expr ᵒᵈ» (Ideal R) | Ideal.IsPrime p ∧ I ≤ OrderDual.ofDual p },\n      OrderDual.toDual J ≤ m ∧ ∀ z ∈ { p : «expr ᵒᵈ» (Ideal R) | Ideal.IsPrime p ∧ I ≤ p }, m ≤ z → z = m\n    by\n    obtain ⟨p, h₁, h₂, h₃⟩ := this\n    simp_rw [← @eq_comm _ p] at h₃\n    exact ⟨p, ⟨h₁, fun a b c => (h₃ a b c).le⟩, h₂⟩\n  apply zorn_nonempty_partialOrder₀\n  swap\n  · refine' ⟨show J.is_prime by infer_instance, e⟩\n  rintro (c : Set (Ideal R)) hc hc' J' hJ'\n  refine' ⟨OrderDual.toDual (Inf c), ⟨Ideal.infₛ_isPrime_of_isChain ⟨J', hJ'⟩ hc'.symm fun x hx => (hc hx).1, _⟩, _⟩\n  · rw [OrderDual.ofDual_toDual]\n    convert le_infₛ _\n    intro x hx\n    exact (hc hx).2\n  · rintro z hz\n    rw [OrderDual.le_toDual]\n    exact infₛ_le hz\n#align ideal.exists_minimal_primes_le ideal.exists_minimal_primes_le\n\n",
 "exists_minimal_primes_comap_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (p «expr ∈ » (I.comap f).minimal_primes) -/\ntheorem ideal.exists_minimal_primes_comap_eq {I : Ideal S} (f : «expr →+* » R S) (p)\n    (_ : p ∈ (I.comap f).minimal_primes) : ∃ p' ∈ I.minimal_primes, Ideal.comap f p' = p :=\n  by\n  obtain ⟨p', h₁, h₂, h₃⟩ := ideal.exists_comap_eq_of_mem_minimal_primes f p H\n  skip\n  obtain ⟨q, hq, hq'⟩ := ideal.exists_minimal_primes_le h₂\n  refine' ⟨q, hq, Eq.symm _⟩\n  haveI := hq.1.1\n  have := (Ideal.comap_mono hq').trans_eq h₃\n  exact (H.2 ⟨inferInstance, Ideal.comap_mono hq.1.2⟩ this).antisymm this\n#align ideal.exists_minimal_primes_comap_eq ideal.exists_minimal_primes_comap_eq\n\n",
 "exists_comap_eq_of_mem_minimal_primes_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (p «expr ∈ » minimal_primes[minimal_primes] R) -/\ntheorem ideal.exists_comap_eq_of_mem_minimal_primes_of_injective {f : «expr →+* » R S} (hf : function.injective f) (p)\n    (_ : p ∈ minimal_primes R) : ∃ p' : Ideal S, p'.is_prime ∧ p'.comap f = p :=\n  by\n  haveI := H.1.1\n  have : Nontrivial (Localization (Submonoid.map f p.prime_compl)) :=\n    by\n    refine' ⟨⟨1, 0, _⟩⟩\n    convert(IsLocalization.map_injective_of_injective p.prime_compl (localization.at_prime p)\n            (Localization <| p.prime_compl.map f) hf).ne\n        one_ne_zero\n    · rw [map_one]\n    · rw [map_zero]\n  obtain ⟨M, hM⟩ := Ideal.exists_maximal (Localization (Submonoid.map f p.prime_compl))\n  skip\n  refine' ⟨M.comap (algebraMap S <| Localization (Submonoid.map f p.prime_compl)), inferInstance, _⟩\n  rw [Ideal.comap_comap, ←\n    @IsLocalization.map_comp _ _ _ _ localization.is_localization _ p.prime_compl.le_comap_map _\n      localization.is_localization,\n    ← Ideal.comap_comap]\n  suffices _ ≤ p by exact this.antisymm (H.2 ⟨inferInstance, bot_le⟩ this)\n  intro x hx\n  by_contra h\n  apply hM.ne_top\n  apply M.eq_top_of_is_unit_mem hx\n  apply IsUnit.map\n  apply is_localization.map_units _ (show p.prime_compl from ⟨x, h⟩)\n  infer_instance\n#align ideal.exists_comap_eq_of_mem_minimal_primes_of_injective ideal.exists_comap_eq_of_mem_minimal_primes_of_injective\n\n",
 "exists_comap_eq_of_mem_minimal_primes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (p «expr ∈ » (I.comap f).minimal_primes) -/\ntheorem ideal.exists_comap_eq_of_mem_minimal_primes {I : Ideal S} (f : «expr →+* » R S) (p)\n    (_ : p ∈ (I.comap f).minimal_primes) : ∃ p' : Ideal S, p'.is_prime ∧ I ≤ p' ∧ p'.comap f = p :=\n  by\n  haveI := H.1.1\n  let f' := I.quotient.mk.comp f\n  have e : (I.quotient.mk.comp f).ker = I.comap f := by\n    ext1\n    exact Submodule.Quotient.mk_eq_zero _\n  have : (I.quotient.mk.comp f).ker.quotient.mk.ker ≤ p :=\n    by\n    rw [Ideal.mk_ker, e]\n    exact H.1.2\n  obtain ⟨p', hp₁, hp₂⟩ :=\n    ideal.exists_comap_eq_of_mem_minimal_primes_of_injective (I.quotient.mk.comp f).ker_lift_injective\n      (p.map (I.quotient.mk.comp f).ker.quotient.mk) _\n  · skip\n    refine' ⟨p'.comap I.quotient.mk, Ideal.IsPrime.comap _, _, _⟩\n    · exact ideal.mk_ker.symm.trans_le (Ideal.comap_mono bot_le)\n    convert congr_arg (Ideal.comap (I.quotient.mk.comp f).ker.quotient.mk) hp₂\n    rwa [Ideal.comap_map_of_surjective (I.quotient.mk.comp f).ker.quotient.mk Ideal.Quotient.mk_surjective, eq_comm,\n      sup_eq_left]\n  refine' ⟨⟨_, bot_le⟩, _⟩\n  · apply Ideal.map_isPrime_of_surjective _ this\n    exact Ideal.Quotient.mk_surjective\n  · rintro q ⟨hq, -⟩ hq'\n    rw [← Ideal.map_comap_of_surjective (I.quotient.mk.comp f).ker.quotient.mk Ideal.Quotient.mk_surjective q]\n    apply Ideal.map_mono\n    skip\n    apply H.2\n    · refine' ⟨inferInstance, (ideal.mk_ker.trans e).symm.trans_le (Ideal.comap_mono bot_le)⟩\n    · refine' (Ideal.comap_mono hq').trans _\n      rw [Ideal.comap_map_of_surjective]\n      exacts[sup_le rfl.le this, Ideal.Quotient.mk_surjective]\n#align ideal.exists_comap_eq_of_mem_minimal_primes ideal.exists_comap_eq_of_mem_minimal_primes\n\n",
 "comap_minimal_primes_eq_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem ideal.comap_minimal_primes_eq_of_surjective {f : «expr →+* » R S} (hf : function.surjective f) (I : Ideal S) :\n    (I.comap f).minimal_primes = «expr '' » (Ideal.comap f) I.minimal_primes :=\n  by\n  ext J\n  constructor\n  · intro H\n    obtain ⟨p, h, rfl⟩ := ideal.exists_minimal_primes_comap_eq f J H\n    exact ⟨p, h, rfl⟩\n  · rintro ⟨J, hJ, rfl⟩\n    exact ideal.mimimal_primes_comap_of_surjective hf hJ\n#align ideal.comap_minimal_primes_eq_of_surjective ideal.comap_minimal_primes_eq_of_surjective\n\n",
 "Inf_minimal_primes":
 "@[simp]\ntheorem ideal.Inf_minimal_primes : infₛ I.minimal_primes = I.radical :=\n  by\n  rw [I.radical_eq_Inf]\n  apply le_antisymm\n  · intro x hx\n    rw [Ideal.mem_infₛ] at hx⊢\n    rintro J ⟨e, hJ⟩\n    skip\n    obtain ⟨p, hp, hp'⟩ := ideal.exists_minimal_primes_le e\n    exact hp' (hx hp)\n  · apply infₛ_le_infₛ _\n    intro I hI\n    exact hI.1.symm\n#align ideal.Inf_minimal_primes ideal.Inf_minimal_primes\n\n"}