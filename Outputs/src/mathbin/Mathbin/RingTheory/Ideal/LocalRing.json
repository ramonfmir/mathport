{"symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem map_equiv.symm (f : «expr ≃+* » R S) : (map_equiv f).symm = map_equiv f.symm :=\n  rfl\n#align map_equiv.symm map_equiv.symm\n\n",
 "surjective_units_map_of_local_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `f : R →+* S` is a surjective local ring hom, then the induced units map is surjective. -/\ntheorem surjective_units_map_of_local_ring_hom [CommRing R] [CommRing S] (f : «expr →+* » R S)\n    (hf : function.surjective f) (h : is_local_ring_hom f) : function.surjective (Units.map <| f.to_monoid_hom) :=\n  by\n  intro a\n  obtain ⟨b, hb⟩ := hf (a : S)\n  use\n    (is_unit_of_map_unit f _\n        (by\n          rw [hb]\n          exact Units.isUnit _)).unit;\n  ext; exact hb\n#align surjective_units_map_of_local_ring_hom surjective_units_map_of_local_ring_hom\n\n",
 "residue_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem residue_smul (g : G) (r : R) : residue R («expr • » g r) = «expr • » g (residue R r) :=\n  rfl\n#align residue_smul residue_smul\n\n",
 "of_unique_nonzero_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem of_unique_nonzero_prime (h : ∃! P : Ideal R, P ≠ «expr⊥» ∧ Ideal.IsPrime P) : local_ring R :=\n  of_unique_max_ideal\n    (by\n      rcases h with ⟨P, ⟨hPnonzero, hPnot_top, _⟩, hPunique⟩\n      refine' ⟨P, ⟨⟨hPnot_top, _⟩⟩, fun M hM => hPunique _ ⟨_, Ideal.IsMaximal.isPrime hM⟩⟩\n      · refine' Ideal.maximal_of_no_maximal fun M hPM hM => ne_of_lt hPM _\n        exact (hPunique _ ⟨ne_bot_of_gt hPM, Ideal.IsMaximal.isPrime hM⟩).symm\n      · rintro rfl\n        exact hPnot_top (hM.1.2 P (bot_lt_iff_ne_bot.2 hPnonzero)))\n#align of_unique_nonzero_prime of_unique_nonzero_prime\n\n",
 "of_unique_max_ideal":
 "/-- A semiring is local if it has a unique maximal ideal. -/\ntheorem of_unique_max_ideal (h : ∃! I : Ideal R, I.is_maximal) : local_ring R :=\n  @of_nonunits_add _ _\n    (nontrivial_of_ne (0 : R) 1 <|\n      let ⟨I, Imax, _⟩ := h\n      fun H : 0 = 1 => Imax.1.1 <| I.eq_top_iff_one.2 <| H ▸ I.zero_mem)\n    fun x y hx hy H =>\n    let ⟨I, Imax, Iuniq⟩ := h\n    let ⟨Ix, Ixmax, Hx⟩ := exists_max_ideal_of_mem_nonunits hx\n    let ⟨Iy, Iymax, Hy⟩ := exists_max_ideal_of_mem_nonunits hy\n    have xmemI : x ∈ I := Iuniq Ix Ixmax ▸ Hx\n    have ymemI : y ∈ I := Iuniq Iy Iymax ▸ Hy\n    Imax.1.1 <| I.eq_top_of_is_unit_mem (I.add_mem xmemI ymemI) H\n#align of_unique_max_ideal of_unique_max_ideal\n\n",
 "of_surjective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem of_surjective' [CommRing S] [Nontrivial S] (f : «expr →+* » R S) (hf : function.surjective f) : local_ring S :=\n  of_is_unit_or_is_unit_one_sub_self\n    (by\n      intro b\n      obtain ⟨a, rfl⟩ := hf b\n      apply (is_unit_or_is_unit_one_sub_self a).imp f.is_unit_map _\n      rw [← f.map_one, ← f.map_sub]\n      apply f.is_unit_map)\n#align of_surjective' of_surjective'\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem of_surjective [CommSemiring R] [local_ring R] [CommSemiring S] [Nontrivial S] (f : «expr →+* » R S)\n    [is_local_ring_hom f] (hf : function.surjective f) : local_ring S :=\n  of_is_unit_or_is_unit_of_is_unit_add\n    (by\n      intro a b hab\n      obtain ⟨a, rfl⟩ := hf a\n      obtain ⟨b, rfl⟩ := hf b\n      rw [← map_add] at hab\n      exact (is_unit_or_is_unit_of_is_unit_add <| is_local_ring_hom.map_nonunit _ hab).imp f.is_unit_map f.is_unit_map)\n#align of_surjective of_surjective\n\n",
 "of_nonunits_add":
 "/-- A semiring is local if it is nontrivial and the set of nonunits is closed under the addition. -/\ntheorem of_nonunits_add [Nontrivial R] (h : ∀ a b : R, a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R) :\n    local_ring R :=\n  ⟨fun a b hab => or_iff_not_and_not.2 fun H => h a b H.1 H.2 <| hab.symm ▸ isUnit_one⟩\n#align of_nonunits_add of_nonunits_add\n\n",
 "of_is_unit_or_is_unit_one_sub_self":
 "theorem of_is_unit_or_is_unit_one_sub_self [Nontrivial R] (h : ∀ a : R, IsUnit a ∨ IsUnit (1 - a)) : local_ring R :=\n  ⟨fun a b hab => add_sub_cancel' a b ▸ hab.symm ▸ h a⟩\n#align of_is_unit_or_is_unit_one_sub_self of_is_unit_or_is_unit_one_sub_self\n\n",
 "of_is_unit_or_is_unit_of_is_unit_add":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes, Mario Carneiro\n-/\ntheorem of_is_unit_or_is_unit_of_is_unit_add [Nontrivial R] (h : ∀ a b : R, IsUnit (a + b) → IsUnit a ∨ IsUnit b) :\n    local_ring R :=\n  ⟨fun a b hab => h a b <| hab.symm ▸ isUnit_one⟩\n#align of_is_unit_or_is_unit_of_is_unit_add of_is_unit_or_is_unit_of_is_unit_add\n\n",
 "of_irreducible_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem of_irreducible_map (f : «expr →+* » R S) [h : is_local_ring_hom f] {x} (hfx : Irreducible (f x)) :\n    Irreducible x :=\n  ⟨fun h => hfx.not_unit <| IsUnit.map f h, fun p q hx =>\n    let ⟨H⟩ := h\n    Or.imp (H p) (H q) <| hfx.is_unit_or_is_unit <| f.map_mul p q ▸ congr_arg f hx⟩\n#align of_irreducible_map of_irreducible_map\n\n",
 "nonunits_add":
 "theorem nonunits_add {a b : R} (ha : a ∈ nonunits R) (hb : b ∈ nonunits R) : a + b ∈ nonunits R := fun H =>\n  not_or_of_not ha hb (is_unit_or_is_unit_of_is_unit_add H)\n#align nonunits_add nonunits_add\n\n",
 "mem_maximal_ideal":
 "@[simp]\ntheorem mem_maximal_ideal (x) : x ∈ maximal_ideal R ↔ x ∈ nonunits R :=\n  iff.rfl\n#align mem_maximal_ideal mem_maximal_ideal\n\n",
 "maximal_ideal_unique":
 "theorem maximal_ideal_unique : ∃! I : Ideal R, I.is_maximal :=\n  ⟨maximal_ideal R, maximal_ideal.is_maximal R, fun I hI =>\n    hI.eq_of_le (maximal_ideal.is_maximal R).1.1 fun x hx => hI.1.1 ∘ I.eq_top_of_is_unit_mem hx⟩\n#align maximal_ideal_unique maximal_ideal_unique\n\n",
 "maximal_ideal_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- see Note [lower instance priority]\ntheorem local_ring.maximal_ideal_eq_bot {R : Type _} [Field R] : local_ring.maximal_ideal R = «expr⊥» :=\n  local_ring.is_field_iff_maximal_ideal_eq.mp (Field.toIsField R)\n#align local_ring.maximal_ideal_eq_bot local_ring.maximal_ideal_eq_bot\n\n",
 "map_residue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_residue (f : «expr →+* » R S) [is_local_ring_hom f] (r : R) :\n    residue_field.map f (residue R r) = residue S (f r) :=\n  rfl\n#align map_residue map_residue\n\n",
 "map_nonunit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- The image of the maximal ideal of the source is contained within the maximal ideal of the target.\n-/\ntheorem map_nonunit (f : «expr →+* » R S) [is_local_ring_hom f] (a : R) (h : a ∈ maximal_ideal R) :\n    f a ∈ maximal_ideal S := fun H => h <| is_unit_of_map_unit f a H\n#align map_nonunit map_nonunit\n\n",
 "map_mem_nonunits_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map_mem_nonunits_iff (f : «expr →+* » R S) [is_local_ring_hom f] (a) : f a ∈ nonunits S ↔ a ∈ nonunits R :=\n  ⟨fun h ha => h <| (is_unit_map_iff f a).mpr ha, fun h ha => h <| (is_unit_map_iff f a).mp ha⟩\n#align map_mem_nonunits_iff map_mem_nonunits_iff\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map_map (f : «expr →+* » R S) (g : «expr →+* » S T) (x : residue_field R) [is_local_ring_hom f]\n    [is_local_ring_hom g] : map g (map f x) = map (g.comp f) x :=\n  FunLike.congr_fun (map_comp f g).symm x\n#align map_map map_map\n\n",
 "map_id_apply":
 "theorem map_id_apply (x : residue_field R) : map (RingHom.id R) x = x :=\n  FunLike.congr_fun map_id x\n#align map_id_apply map_id_apply\n\n",
 "map_id":
 "/-- Applying `residue_field.map` to the identity ring homomorphism gives the identity\nring homomorphism. -/\n@[simp]\ntheorem map_id : local_ring.residue_field.map (RingHom.id R) = RingHom.id (local_ring.residue_field R) :=\n  Ideal.Quotient.ringHom_ext <| RingHom.ext fun x => rfl\n#align map_id map_id\n\n",
 "map_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem map_equiv_trans (e₁ : «expr ≃+* » R S) (e₂ : «expr ≃+* » S T) :\n    map_equiv (e₁.trans e₂) = (map_equiv e₁).trans (map_equiv e₂) :=\n  RingEquiv.toRingHom_injective <| map_comp (e₁ : «expr →+* » R S) (e₂ : «expr →+* » S T)\n#align map_equiv_trans map_equiv_trans\n\n",
 "map_equiv_refl":
 "@[simp]\ntheorem map_equiv_refl : map_equiv (RingEquiv.refl R) = RingEquiv.refl _ :=\n  RingEquiv.toRingHom_injective map_id\n#align map_equiv_refl map_equiv_refl\n\n",
 "map_comp_residue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_comp_residue (f : «expr →+* » R S) [is_local_ring_hom f] :\n    (residue_field.map f).comp (residue R) = (residue S).comp f :=\n  rfl\n#align map_comp_residue map_comp_residue\n\n",
 "map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- The composite of two `residue_field.map`s is the `residue_field.map` of the composite. -/\ntheorem map_comp (f : «expr →+* » T R) (g : «expr →+* » R S) [is_local_ring_hom f] [is_local_ring_hom g] :\n    local_ring.residue_field.map (g.comp f) = (local_ring.residue_field.map g).comp (local_ring.residue_field.map f) :=\n  Ideal.Quotient.ringHom_ext <| RingHom.ext fun x => rfl\n#align map_comp map_comp\n\n",
 "local_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[reducible]\nprotected theorem local_ring {A B : Type _} [CommSemiring A] [local_ring A] [CommSemiring B] (e : «expr ≃+* » A B) :\n    local_ring B :=\n  haveI := e.symm.to_equiv.nontrivial\n  local_ring.of_surjective (e : «expr →+* » A B) e.surjective\n#align local_ring local_ring\n\n",
 "local_hom_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A ring homomorphism between local rings is a local ring hom iff it reflects units,\ni.e. any preimage of a unit is still a unit. https://stacks.math.columbia.edu/tag/07BJ\n-/\ntheorem local_hom_tfae (f : «expr →+* » R S) :\n    TFAE\n      [is_local_ring_hom f, «expr '' » f (maximal_ideal R).1 ⊆ maximal_ideal S,\n        (maximal_ideal R).map f ≤ maximal_ideal S, maximal_ideal R ≤ (maximal_ideal S).comap f,\n        (maximal_ideal S).comap f = maximal_ideal R] :=\n  by\n  tfae_have 1 → 2; rintro _ _ ⟨a, ha, rfl⟩\n  skip; exact map_nonunit f a ha\n  tfae_have 2 → 4; exact Set.image_subset_iff.1\n  tfae_have 3 ↔ 4; exact Ideal.map_le_iff_le_comap\n  tfae_have 4 → 1; intro h; fconstructor; exact fun x => not_imp_not.1 (@h x)\n  tfae_have 1 → 5; intro ; skip; ext\n  exact not_iff_not.2 (is_unit_map_iff f x)\n  tfae_have 5 → 4; exact fun h => le_of_eq h.symm\n  tfae_finish\n#align local_hom_tfae local_hom_tfae\n\n",
 "lift_residue_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem lift_residue_apply {R S : Type _} [CommRing R] [local_ring R] [Field S] (f : «expr →+* » R S)\n    [is_local_ring_hom f] (x) : lift f (residue R x) = f x :=\n  rfl\n#align lift_residue_apply lift_residue_apply\n\n",
 "lift_comp_residue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem lift_comp_residue {R S : Type _} [CommRing R] [local_ring R] [Field S] (f : «expr →+* » R S)\n    [is_local_ring_hom f] : (lift f).comp (residue R) = f :=\n  RingHom.ext fun _ => rfl\n#align lift_comp_residue lift_comp_residue\n\n",
 "le_maximal_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem le_maximal_ideal {J : Ideal R} (hJ : J ≠ «expr⊤») : J ≤ maximal_ideal R :=\n  by\n  rcases Ideal.exists_le_maximal J hJ with ⟨M, hM1, hM2⟩\n  rwa [← eq_maximal_ideal hM1]\n#align le_maximal_ideal le_maximal_ideal\n\n",
 "ker_eq_maximal_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ker_eq_maximal_ideal [Field K] (φ : «expr →+* » R K) (hφ : function.surjective φ) : φ.ker = maximal_ideal R :=\n  local_ring.eq_maximal_ideal <| (RingHom.ker_isMaximal_of_surjective φ) hφ\n#align ker_eq_maximal_ideal ker_eq_maximal_ideal\n\n",
 "jacobson_eq_maximal_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem jacobson_eq_maximal_ideal (I : Ideal R) (h : I ≠ «expr⊤») : I.jacobson = local_ring.maximal_ideal R :=\n  by\n  apply le_antisymm\n  · exact infₛ_le ⟨local_ring.le_maximal_ideal h, local_ring.maximal_ideal.is_maximal R⟩\n  · exact le_infₛ fun J (hJ : I ≤ J ∧ J.is_maximal) => le_of_eq (local_ring.eq_maximal_ideal hJ.2).symm\n#align jacobson_eq_maximal_ideal jacobson_eq_maximal_ideal\n\n",
 "is_unit_or_is_unit_one_sub_self":
 "theorem is_unit_or_is_unit_one_sub_self (a : R) : IsUnit a ∨ IsUnit (1 - a) :=\n  is_unit_or_is_unit_of_is_unit_add <| (add_sub_cancel'_right a 1).symm ▸ isUnit_one\n#align is_unit_or_is_unit_one_sub_self is_unit_or_is_unit_one_sub_self\n\n",
 "is_unit_or_is_unit_of_is_unit_add":
 "theorem is_unit_or_is_unit_of_is_unit_add {a b : R} (h : IsUnit (a + b)) : IsUnit a ∨ IsUnit b :=\n  by\n  rcases h with ⟨u, hu⟩\n  rw [← Units.inv_mul_eq_one, mul_add] at hu\n  apply Or.imp _ _ (is_unit_or_is_unit_of_add_one hu) <;> exact isUnit_of_mul_isUnit_right\n#align is_unit_or_is_unit_of_is_unit_add is_unit_or_is_unit_of_is_unit_add\n\n",
 "is_unit_one_sub_self_of_mem_nonunits":
 "theorem is_unit_one_sub_self_of_mem_nonunits (a : R) (h : a ∈ nonunits R) : IsUnit (1 - a) :=\n  or_iff_not_imp_left.1 (is_unit_or_is_unit_one_sub_self a) h\n#align is_unit_one_sub_self_of_mem_nonunits is_unit_one_sub_self_of_mem_nonunits\n\n",
 "is_unit_of_mem_nonunits_one_sub_self":
 "theorem is_unit_of_mem_nonunits_one_sub_self (a : R) (h : 1 - a ∈ nonunits R) : IsUnit a :=\n  or_iff_not_imp_right.1 (is_unit_or_is_unit_one_sub_self a) h\n#align is_unit_of_mem_nonunits_one_sub_self is_unit_of_mem_nonunits_one_sub_self\n\n",
 "is_unit_of_map_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem is_unit_of_map_unit (f : «expr →+* » R S) [is_local_ring_hom f] (a) (h : IsUnit (f a)) : IsUnit a :=\n  is_local_ring_hom.map_nonunit a h\n#align is_unit_of_map_unit is_unit_of_map_unit\n\n",
 "is_unit_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem is_unit_map_iff (f : «expr →+* » R S) [is_local_ring_hom f] (a) : IsUnit (f a) ↔ IsUnit a :=\n  ⟨is_local_ring_hom.map_nonunit a, f.is_unit_map⟩\n#align is_unit_map_iff is_unit_map_iff\n\n",
 "is_local_ring_hom_residue":
 "theorem is_local_ring_hom_residue : is_local_ring_hom (local_ring.residue R) :=\n  by\n  constructor\n  intro a ha\n  by_contra\n  erw [ideal.quotient.eq_zero_iff_mem.mpr ((local_ring.mem_maximal_ideal _).mpr h)] at ha\n  exact ha.ne_zero rfl\n#align is_local_ring_hom_residue is_local_ring_hom_residue\n\n",
 "is_local_ring_hom_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_local_ring_hom_of_comp (f : «expr →+* » R S) (g : «expr →+* » S T) [is_local_ring_hom (g.comp f)] :\n    is_local_ring_hom f :=\n  ⟨fun a ha => (is_unit_map_iff (g.comp f) _).mp (g.is_unit_map ha)⟩\n#align is_local_ring_hom_of_comp is_local_ring_hom_of_comp\n\n",
 "is_field_iff_maximal_ideal_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_field_iff_maximal_ideal_eq : IsField R ↔ maximal_ideal R = «expr⊥» :=\n  not_iff_not.mp\n    ⟨Ring.ne_bot_of_isMaximal_of_not_isField inferInstance, fun h =>\n      Ring.not_isField_iff_exists_prime.mpr ⟨_, h, Ideal.IsMaximal.isPrime' _⟩⟩\n#align is_field_iff_maximal_ideal_eq is_field_iff_maximal_ideal_eq\n\n",
 "eq_maximal_ideal":
 "theorem eq_maximal_ideal {I : Ideal R} (hI : I.is_maximal) : I = maximal_ideal R :=\n  ExistsUnique.unique (maximal_ideal_unique R) hI <| maximal_ideal.is_maximal R\n#align eq_maximal_ideal eq_maximal_ideal\n\n",
 "domain_local_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `f : R →+* S` is a local ring hom, then `R` is a local ring if `S` is. -/\ntheorem _root_.ring_hom.domain_local_ring {R S : Type _} [CommSemiring R] [CommSemiring S] [H : _root_.local_ring S]\n    (f : «expr →+* » R S) [is_local_ring_hom f] : _root_.local_ring R :=\n  by\n  haveI : Nontrivial R := pullback_nonzero f f.map_zero f.map_one\n  apply local_ring.of_nonunits_add\n  intro a b\n  simp_rw [← map_mem_nonunits_iff f, f.map_add]\n  exact local_ring.nonunits_add\n#align ring_hom.domain_local_ring ring_hom.domain_local_ring\n\n",
 "algebra_map_eq":
 "theorem residue_field.algebra_map_eq : algebraMap R (residue_field R) = residue R :=\n  rfl\n#align residue_field.algebra_map_eq residue_field.algebra_map_eq\n\n"}