{"symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem map_equiv.symm (f : «expr ≃+* » R S) : (map_equiv f).symm = map_equiv f.symm :=\n  rfl\n#align map_equiv.symm map_equiv.symm\n\n",
 "surjective_units_map_of_local_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `f : R →+* S` is a surjective local ring hom, then the induced units map is surjective. -/\ntheorem surjective_units_map_of_local_ring_hom [CommRing R] [CommRing S] (f : «expr →+* » R S)\n    (hf : function.surjective f) (h : is_local_ring_hom f) : function.surjective (Units.map <| f.to_monoid_hom) :=\n  by\n  intro a\n  obtain ⟨b, hb⟩ := hf (a : S)\n  use\n    (is_unit_of_map_unit f _\n        (by\n          rw [hb]\n          exact Units.isUnit _)).unit;\n  ext; exact hb\n#align surjective_units_map_of_local_ring_hom surjective_units_map_of_local_ring_hom\n\n",
 "residue_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem residue_smul (g : G) (r : R) : residue R («expr • » g r) = «expr • » g (residue R r) :=\n  rfl\n#align residue_smul residue_smul\n\n",
 "of_unique_nonzero_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem of_unique_nonzero_prime (h : ∃! P : ideal R, P ≠ «expr⊥» ∧ ideal.is_prime P) : local_ring R :=\n  of_unique_max_ideal\n    (by\n      rcases h with ⟨P, ⟨hPnonzero, hPnot_top, _⟩, hPunique⟩\n      refine' ⟨P, ⟨⟨hPnot_top, _⟩⟩, fun M hM => hPunique _ ⟨_, ideal.is_maximal.is_prime hM⟩⟩\n      · refine' ideal.maximal_of_no_maximal fun M hPM hM => ne_of_lt hPM _\n        exact (hPunique _ ⟨ne_bot_of_gt hPM, ideal.is_maximal.is_prime hM⟩).symm\n      · rintro rfl\n        exact hPnot_top (hM.1.2 P (bot_lt_iff_ne_bot.2 hPnonzero)))\n#align of_unique_nonzero_prime of_unique_nonzero_prime\n\n",
 "of_unique_max_ideal":
 "/-- A semiring is local if it has a unique maximal ideal. -/\ntheorem of_unique_max_ideal (h : ∃! I : ideal R, I.is_maximal) : local_ring R :=\n  @of_nonunits_add _ _\n    (nontrivial_of_ne (0 : R) 1 <|\n      let ⟨I, Imax, _⟩ := h\n      fun H : 0 = 1 => Imax.1.1 <| I.eq_top_iff_one.2 <| H ▸ I.zero_mem)\n    fun x y hx hy H =>\n    let ⟨I, Imax, Iuniq⟩ := h\n    let ⟨Ix, Ixmax, Hx⟩ := exists_max_ideal_of_mem_nonunits hx\n    let ⟨Iy, Iymax, Hy⟩ := exists_max_ideal_of_mem_nonunits hy\n    have xmemI : x ∈ I := Iuniq Ix Ixmax ▸ Hx\n    have ymemI : y ∈ I := Iuniq Iy Iymax ▸ Hy\n    Imax.1.1 <| I.eq_top_of_is_unit_mem (I.add_mem xmemI ymemI) H\n#align of_unique_max_ideal of_unique_max_ideal\n\n",
 "of_surjective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem of_surjective' [CommRing S] [nontrivial S] (f : «expr →+* » R S) (hf : function.surjective f) : local_ring S :=\n  of_is_unit_or_is_unit_one_sub_self\n    (by\n      intro b\n      obtain ⟨a, rfl⟩ := hf b\n      apply (is_unit_or_is_unit_one_sub_self a).imp f.is_unit_map _\n      rw [← f.map_one, ← f.map_sub]\n      apply f.is_unit_map)\n#align of_surjective' of_surjective'\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem of_surjective [CommSemiring R] [local_ring R] [CommSemiring S] [nontrivial S] (f : «expr →+* » R S)\n    [is_local_ring_hom f] (hf : function.surjective f) : local_ring S :=\n  of_is_unit_or_is_unit_of_is_unit_add\n    (by\n      intro a b hab\n      obtain ⟨a, rfl⟩ := hf a\n      obtain ⟨b, rfl⟩ := hf b\n      rw [← map_add] at hab\n      exact (is_unit_or_is_unit_of_is_unit_add <| is_local_ring_hom.map_nonunit _ hab).imp f.is_unit_map f.is_unit_map)\n#align of_surjective of_surjective\n\n",
 "of_nonunits_add":
 "/-- A semiring is local if it is nontrivial and the set of nonunits is closed under the addition. -/\ntheorem of_nonunits_add [nontrivial R] (h : ∀ a b : R, a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R) :\n    local_ring R :=\n  ⟨fun a b hab => or_iff_not_and_not.2 fun H => h a b H.1 H.2 <| hab.symm ▸ isUnit_one⟩\n#align of_nonunits_add of_nonunits_add\n\n",
 "of_is_unit_or_is_unit_one_sub_self":
 "theorem of_is_unit_or_is_unit_one_sub_self [nontrivial R] (h : ∀ a : R, is_unit a ∨ is_unit (1 - a)) : local_ring R :=\n  ⟨fun a b hab => add_sub_cancel' a b ▸ hab.symm ▸ h a⟩\n#align of_is_unit_or_is_unit_one_sub_self of_is_unit_or_is_unit_one_sub_self\n\n",
 "of_is_unit_or_is_unit_of_is_unit_add":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes, Mario Carneiro\n-/\ntheorem of_is_unit_or_is_unit_of_is_unit_add [nontrivial R] (h : ∀ a b : R, is_unit (a + b) → is_unit a ∨ is_unit b) :\n    local_ring R :=\n  ⟨fun a b hab => h a b <| hab.symm ▸ isUnit_one⟩\n#align of_is_unit_or_is_unit_of_is_unit_add of_is_unit_or_is_unit_of_is_unit_add\n\n",
 "of_irreducible_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem of_irreducible_map (f : «expr →+* » R S) [h : is_local_ring_hom f] {x} (hfx : Irreducible (f x)) :\n    Irreducible x :=\n  ⟨fun h => hfx.not_unit <| IsUnit.map f h, fun p q hx =>\n    let ⟨H⟩ := h\n    Or.imp (H p) (H q) <| hfx.is_unit_or_is_unit <| f.map_mul p q ▸ congr_arg f hx⟩\n#align of_irreducible_map of_irreducible_map\n\n",
 "nonunits_add":
 "theorem nonunits_add {a b : R} (ha : a ∈ nonunits R) (hb : b ∈ nonunits R) : a + b ∈ nonunits R := fun H =>\n  not_or_of_not ha hb (is_unit_or_is_unit_of_is_unit_add H)\n#align nonunits_add nonunits_add\n\n",
 "mem_maximal_ideal":
 "@[simp]\ntheorem mem_maximal_ideal (x) : x ∈ maximal_ideal R ↔ x ∈ nonunits R :=\n  iff.rfl\n#align mem_maximal_ideal mem_maximal_ideal\n\n",
 "maximal_ideal_unique":
 "theorem maximal_ideal_unique : ∃! I : ideal R, I.is_maximal :=\n  ⟨maximal_ideal R, maximal_ideal.is_maximal R, fun I hI =>\n    hI.eq_of_le (maximal_ideal.is_maximal R).1.1 fun x hx => hI.1.1 ∘ I.eq_top_of_is_unit_mem hx⟩\n#align maximal_ideal_unique maximal_ideal_unique\n\n",
 "map_residue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_residue (f : «expr →+* » R S) [is_local_ring_hom f] (r : R) :\n    residue_field.map f (residue R r) = residue S (f r) :=\n  rfl\n#align map_residue map_residue\n\n",
 "map_nonunit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- The image of the maximal ideal of the source is contained within the maximal ideal of the target.\n-/\ntheorem map_nonunit (f : «expr →+* » R S) [is_local_ring_hom f] (a : R) (h : a ∈ maximal_ideal R) :\n    f a ∈ maximal_ideal S := fun H => h <| is_unit_of_map_unit f a H\n#align map_nonunit map_nonunit\n\n",
 "map_mem_nonunits_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map_mem_nonunits_iff (f : «expr →+* » R S) [is_local_ring_hom f] (a) : f a ∈ nonunits S ↔ a ∈ nonunits R :=\n  ⟨fun h ha => h <| (is_unit_map_iff f a).mpr ha, fun h ha => h <| (is_unit_map_iff f a).mp ha⟩\n#align map_mem_nonunits_iff map_mem_nonunits_iff\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map_map (f : «expr →+* » R S) (g : «expr →+* » S T) (x : residue_field R) [is_local_ring_hom f]\n    [is_local_ring_hom g] : map g (map f x) = map (g.comp f) x :=\n  fun_like.congr_fun (map_comp f g).symm x\n#align map_map map_map\n\n",
 "map_id_apply":
 "theorem map_id_apply (x : residue_field R) : map (RingHom.id R) x = x :=\n  fun_like.congr_fun map_id x\n#align map_id_apply map_id_apply\n\n",
 "map_id":
 "/-- Applying `residue_field.map` to the identity ring homomorphism gives the identity\nring homomorphism. -/\n@[simp]\ntheorem map_id : local_ring.residue_field.map (RingHom.id R) = RingHom.id (local_ring.residue_field R) :=\n  ideal.quotient.ring_hom_ext <| RingHom.ext fun x => rfl\n#align map_id map_id\n\n",
 "map_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem map_equiv_trans (e₁ : «expr ≃+* » R S) (e₂ : «expr ≃+* » S T) :\n    map_equiv (e₁.trans e₂) = (map_equiv e₁).trans (map_equiv e₂) :=\n  RingEquiv.toRingHom_injective <| map_comp (e₁ : «expr →+* » R S) (e₂ : «expr →+* » S T)\n#align map_equiv_trans map_equiv_trans\n\n",
 "map_equiv_refl":
 "@[simp]\ntheorem map_equiv_refl : map_equiv (RingEquiv.refl R) = RingEquiv.refl _ :=\n  RingEquiv.toRingHom_injective map_id\n#align map_equiv_refl map_equiv_refl\n\n",
 "map_comp_residue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_comp_residue (f : «expr →+* » R S) [is_local_ring_hom f] :\n    (residue_field.map f).comp (residue R) = (residue S).comp f :=\n  rfl\n#align map_comp_residue map_comp_residue\n\n",
 "map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- The composite of two `residue_field.map`s is the `residue_field.map` of the composite. -/\ntheorem map_comp (f : «expr →+* » T R) (g : «expr →+* » R S) [is_local_ring_hom f] [is_local_ring_hom g] :\n    local_ring.residue_field.map (g.comp f) = (local_ring.residue_field.map g).comp (local_ring.residue_field.map f) :=\n  ideal.quotient.ring_hom_ext <| RingHom.ext fun x => rfl\n#align map_comp map_comp\n\n",
 "local_hom_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers\n      [(Command.docComment\n        \"/--\"\n        \"A ring homomorphism between local rings is a local ring hom iff it reflects units,\\ni.e. any preimage of a unit is still a unit. https://stacks.math.columbia.edu/tag/07BJ\\n-/\")]\n      []\n      []\n      []\n      []\n      [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `local_hom_tfae [])\n      (Command.declSig\n       [(Term.explicitBinder \"(\" [`f] [\":\" (Term.app `«expr →+* » [`R `S])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `is_local_ring_hom [`f])\n            \",\"\n            («term_⊆_»\n             (Term.app `«expr '' » [`f (Term.proj (Term.app `maximal_ideal [`R]) \".\" (fieldIdx \"1\"))])\n             \"⊆\"\n             (Term.app `maximal_ideal [`S]))\n            \",\"\n            («term_≤_»\n             (Term.app (Term.proj (Term.app `maximal_ideal [`R]) \".\" `map) [`f])\n             \"≤\"\n             (Term.app `maximal_ideal [`S]))\n            \",\"\n            («term_≤_»\n             (Term.app `maximal_ideal [`R])\n             \"≤\"\n             (Term.app (Term.proj (Term.app `maximal_ideal [`S]) \".\" `comap) [`f]))\n            \",\"\n            («term_=_»\n             (Term.app (Term.proj (Term.app `maximal_ideal [`S]) \".\" `comap) [`f])\n             \"=\"\n             (Term.app `maximal_ideal [`R]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n           \";\"\n           (Std.Tactic.rintro\n            \"rintro\"\n            [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.ignore \"_\"))\n             (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.ignore \"_\"))\n             (Std.Tactic.RCases.rintroPat.one\n              (Std.Tactic.RCases.rcasesPat.tuple\n               \"⟨\"\n               [(Std.Tactic.RCases.rcasesPatLo\n                 (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                 [])\n                \",\"\n                (Std.Tactic.RCases.rcasesPatLo\n                 (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                 [])\n                \",\"\n                (Std.Tactic.RCases.rcasesPatLo\n                 (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                 [])]\n               \"⟩\"))]\n            [])\n           []\n           (Tactic.skip \"skip\")\n           \";\"\n           (Tactic.exact \"exact\" (Term.app `map_nonunit [`f `a `ha]))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"4\"))\n           \";\"\n           (Tactic.exact \"exact\" (Term.proj `Set.image_subset_iff \".\" (fieldIdx \"1\")))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"↔\" (num \"4\"))\n           \";\"\n           (Tactic.exact \"exact\" `ideal.map_le_iff_le_comap)\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n           \";\"\n           (Tactic.intro \"intro\" [`h])\n           \";\"\n           (tacticFconstructor \"fconstructor\")\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`x]\n              []\n              \"=>\"\n              (Term.app (Term.proj `not_imp_not \".\" (fieldIdx \"1\")) [(Term.app (Term.explicit \"@\" `h) [`x])]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"5\"))\n           \";\"\n           (Tactic.intro \"intro\" [])\n           \";\"\n           (Tactic.skip \"skip\")\n           \";\"\n           (Std.Tactic.Ext.«tacticExt___:_» \"ext\" [] [])\n           []\n           (Tactic.exact\n            \"exact\"\n            (Term.app (Term.proj `not_iff_not \".\" (fieldIdx \"2\")) [(Term.app `is_unit_map_iff [`f `x])]))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"4\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.app `le_of_eq [(Term.proj `h \".\" `symm)]))))\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n          \";\"\n          (Std.Tactic.rintro\n           \"rintro\"\n           [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.ignore \"_\"))\n            (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.ignore \"_\"))\n            (Std.Tactic.RCases.rintroPat.one\n             (Std.Tactic.RCases.rcasesPat.tuple\n              \"⟨\"\n              [(Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                [])]\n              \"⟩\"))]\n           [])\n          []\n          (Tactic.skip \"skip\")\n          \";\"\n          (Tactic.exact \"exact\" (Term.app `map_nonunit [`f `a `ha]))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"4\"))\n          \";\"\n          (Tactic.exact \"exact\" (Term.proj `Set.image_subset_iff \".\" (fieldIdx \"1\")))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"↔\" (num \"4\"))\n          \";\"\n          (Tactic.exact \"exact\" `ideal.map_le_iff_le_comap)\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n          \";\"\n          (Tactic.intro \"intro\" [`h])\n          \";\"\n          (tacticFconstructor \"fconstructor\")\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`x]\n             []\n             \"=>\"\n             (Term.app (Term.proj `not_imp_not \".\" (fieldIdx \"1\")) [(Term.app (Term.explicit \"@\" `h) [`x])]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"5\"))\n          \";\"\n          (Tactic.intro \"intro\" [])\n          \";\"\n          (Tactic.skip \"skip\")\n          \";\"\n          (Std.Tactic.Ext.«tacticExt___:_» \"ext\" [] [])\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.app (Term.proj `not_iff_not \".\" (fieldIdx \"2\")) [(Term.app `is_unit_map_iff [`f `x])]))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"4\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.app `le_of_eq [(Term.proj `h \".\" `symm)]))))\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.app `le_of_eq [(Term.proj `h \".\" `symm)]))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.app `le_of_eq [(Term.proj `h \".\" `symm)])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `le_of_eq [(Term.proj `h \".\" `symm)])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj `h \".\" `symm)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `le_of_eq\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"4\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\n/--\n    A ring homomorphism between local rings is a local ring hom iff it reflects units,\n    i.e. any preimage of a unit is still a unit. https://stacks.math.columbia.edu/tag/07BJ\n    -/\n  theorem\n    local_hom_tfae\n    ( f : «expr →+* » R S )\n      :\n        TFAE\n          [\n            is_local_ring_hom f\n              ,\n              «expr '' » f maximal_ideal R . 1 ⊆ maximal_ideal S\n              ,\n              maximal_ideal R . map f ≤ maximal_ideal S\n              ,\n              maximal_ideal R ≤ maximal_ideal S . comap f\n              ,\n              maximal_ideal S . comap f = maximal_ideal R\n            ]\n    :=\n      by\n        tfae_have 1 → 2\n          ;\n          rintro _ _ ⟨ a , ha , rfl ⟩\n          skip\n          ;\n          exact map_nonunit f a ha\n          tfae_have 2 → 4\n          ;\n          exact Set.image_subset_iff . 1\n          tfae_have 3 ↔ 4\n          ;\n          exact ideal.map_le_iff_le_comap\n          tfae_have 4 → 1\n          ;\n          intro h\n          ;\n          fconstructor\n          ;\n          exact fun x => not_imp_not . 1 @ h x\n          tfae_have 1 → 5\n          ;\n          intro\n          ;\n          skip\n          ;\n          ext\n          exact not_iff_not . 2 is_unit_map_iff f x\n          tfae_have 5 → 4\n          ;\n          exact fun h => le_of_eq h . symm\n          tfae_finish\n#align local_hom_tfae local_hom_tfae\n\n",
 "le_maximal_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem le_maximal_ideal {J : ideal R} (hJ : J ≠ «expr⊤») : J ≤ maximal_ideal R :=\n  by\n  rcases ideal.exists_le_maximal J hJ with ⟨M, hM1, hM2⟩\n  rwa [← eq_maximal_ideal hM1]\n#align le_maximal_ideal le_maximal_ideal\n\n",
 "ker_eq_maximal_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ker_eq_maximal_ideal [Field K] (φ : «expr →+* » R K) (hφ : function.surjective φ) : φ.ker = maximal_ideal R :=\n  local_ring.eq_maximal_ideal <| (ring_hom.ker_is_maximal_of_surjective φ) hφ\n#align ker_eq_maximal_ideal ker_eq_maximal_ideal\n\n",
 "jacobson_eq_maximal_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem jacobson_eq_maximal_ideal (I : ideal R) (h : I ≠ «expr⊤») : I.jacobson = local_ring.maximal_ideal R :=\n  by\n  apply le_antisymm\n  · exact infₛ_le ⟨local_ring.le_maximal_ideal h, local_ring.maximal_ideal.is_maximal R⟩\n  · exact le_infₛ fun J (hJ : I ≤ J ∧ J.is_maximal) => le_of_eq (local_ring.eq_maximal_ideal hJ.2).symm\n#align jacobson_eq_maximal_ideal jacobson_eq_maximal_ideal\n\n",
 "is_unit_or_is_unit_one_sub_self":
 "theorem is_unit_or_is_unit_one_sub_self (a : R) : is_unit a ∨ is_unit (1 - a) :=\n  is_unit_or_is_unit_of_is_unit_add <| (add_sub_cancel'_right a 1).symm ▸ isUnit_one\n#align is_unit_or_is_unit_one_sub_self is_unit_or_is_unit_one_sub_self\n\n",
 "is_unit_or_is_unit_of_is_unit_add":
 "theorem is_unit_or_is_unit_of_is_unit_add {a b : R} (h : is_unit (a + b)) : is_unit a ∨ is_unit b :=\n  by\n  rcases h with ⟨u, hu⟩\n  rw [← units.inv_mul_eq_one, mul_add] at hu\n  apply Or.imp _ _ (is_unit_or_is_unit_of_add_one hu) <;> exact isUnit_of_mul_isUnit_right\n#align is_unit_or_is_unit_of_is_unit_add is_unit_or_is_unit_of_is_unit_add\n\n",
 "is_unit_one_sub_self_of_mem_nonunits":
 "theorem is_unit_one_sub_self_of_mem_nonunits (a : R) (h : a ∈ nonunits R) : is_unit (1 - a) :=\n  or_iff_not_imp_left.1 (is_unit_or_is_unit_one_sub_self a) h\n#align is_unit_one_sub_self_of_mem_nonunits is_unit_one_sub_self_of_mem_nonunits\n\n",
 "is_unit_of_mem_nonunits_one_sub_self":
 "theorem is_unit_of_mem_nonunits_one_sub_self (a : R) (h : 1 - a ∈ nonunits R) : is_unit a :=\n  or_iff_not_imp_right.1 (is_unit_or_is_unit_one_sub_self a) h\n#align is_unit_of_mem_nonunits_one_sub_self is_unit_of_mem_nonunits_one_sub_self\n\n",
 "is_unit_of_map_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem is_unit_of_map_unit (f : «expr →+* » R S) [is_local_ring_hom f] (a) (h : is_unit (f a)) : is_unit a :=\n  is_local_ring_hom.map_nonunit a h\n#align is_unit_of_map_unit is_unit_of_map_unit\n\n",
 "is_unit_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem is_unit_map_iff (f : «expr →+* » R S) [is_local_ring_hom f] (a) : is_unit (f a) ↔ is_unit a :=\n  ⟨is_local_ring_hom.map_nonunit a, f.is_unit_map⟩\n#align is_unit_map_iff is_unit_map_iff\n\n",
 "is_local_ring_hom_residue":
 "theorem is_local_ring_hom_residue : is_local_ring_hom (local_ring.residue R) :=\n  by\n  constructor\n  intro a ha\n  by_contra\n  erw [ideal.quotient.eq_zero_iff_mem.mpr ((local_ring.mem_maximal_ideal _).mpr h)] at ha\n  exact ha.ne_zero rfl\n#align is_local_ring_hom_residue is_local_ring_hom_residue\n\n",
 "is_local_ring_hom_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_local_ring_hom_of_comp (f : «expr →+* » R S) (g : «expr →+* » S T) [is_local_ring_hom (g.comp f)] :\n    is_local_ring_hom f :=\n  ⟨fun a ha => (is_unit_map_iff (g.comp f) _).mp (g.is_unit_map ha)⟩\n#align is_local_ring_hom_of_comp is_local_ring_hom_of_comp\n\n",
 "eq_maximal_ideal":
 "theorem eq_maximal_ideal {I : ideal R} (hI : I.is_maximal) : I = maximal_ideal R :=\n  ExistsUnique.unique (maximal_ideal_unique R) hI <| maximal_ideal.is_maximal R\n#align eq_maximal_ideal eq_maximal_ideal\n\n",
 "domain_local_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `f : R →+* S` is a local ring hom, then `R` is a local ring if `S` is. -/\ntheorem _root_.ring_hom.domain_local_ring {R S : Type _} [CommSemiring R] [CommSemiring S] [H : _root_.local_ring S]\n    (f : «expr →+* » R S) [is_local_ring_hom f] : _root_.local_ring R :=\n  by\n  haveI : nontrivial R := pullback_nonzero f f.map_zero f.map_one\n  apply local_ring.of_nonunits_add\n  intro a b\n  simp_rw [← map_mem_nonunits_iff f, f.map_add]\n  exact local_ring.nonunits_add\n#align ring_hom.domain_local_ring ring_hom.domain_local_ring\n\n",
 "algebra_map_eq":
 "theorem residue_field.algebra_map_eq : algebra_map R (residue_field R) = residue R :=\n  rfl\n#align residue_field.algebra_map_eq residue_field.algebra_map_eq\n\n"}