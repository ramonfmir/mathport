{"prime_of_irreducible_abs_norm_span":
 "theorem prime_of_irreducible_abs_norm_span {a : S} (ha : a ≠ 0) (hI : Irreducible (ideal.span ({a} : set S)).abs_norm) :\n    Prime a :=\n  (ideal.span_singleton_prime ha).mp (is_prime_of_irreducible_abs_norm hI)\n#align prime_of_irreducible_abs_norm_span prime_of_irreducible_abs_norm_span\n\n",
 "nat_abs_det_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/-- Let `e : S ≃ I` be an additive isomorphism (therefore a `ℤ`-linear equiv).\nThen an alternative way to compute the norm of `I` is given by taking the determinant of `e`.\nSee `nat_abs_det_basis_change` for a more familiar formulation of this result. -/\ntheorem nat_abs_det_equiv (I : ideal S) {E : Type _} [AddEquivClass E S I] (e : E) :\n    Int.natAbs\n        (linear_map.det\n          («expr ∘ₗ » ((submodule.subtype I).restrict_scalars ℤ)\n            (add_monoid_hom.to_int_linear_map (e : «expr →+ » S I)))) =\n      ideal.abs_norm I :=\n  by\n  -- `S ⧸ I` might be infinite if `I = ⊥`, but then `e` can't be an equiv.\n  by_cases hI : I = «expr⊥»\n  · subst hI\n    have : (1 : S) ≠ 0 := one_ne_zero\n    have : (1 : S) = 0 := equiv_like.injective e (subsingleton.elim _ _)\n    contradiction\n  let ι := module.free.choose_basis_index ℤ S\n  let b := module.free.choose_basis ℤ S\n  cases isEmpty_or_nonempty ι\n  · nontriviality S\n    exact\n      (not_nontrivial_iff_subsingleton.mpr (function.surjective.subsingleton b.repr.to_equiv.symm.surjective)\n          (by infer_instance)).elim\n  -- Thus `(S ⧸ I)` is isomorphic to a product of `zmod`s, so it is a fintype.\n  letI := ideal.fintype_quotient_of_free_of_ne_bot I hI\n  -- Use the Smith normal form to choose a nice basis for `I`.\n  letI := classical.dec_eq ι\n  let a := I.smith_coeffs b hI\n  let b' := I.ring_basis b hI\n  let ab := I.self_basis b hI\n  have ab_eq := I.self_basis_def b hI\n  let e' : «expr ≃ₗ[ ] » S ℤ I := b'.equiv ab (equiv.refl _)\n  let f : «expr →ₗ[ ] » S ℤ S := (I.subtype.restrict_scalars ℤ).comp (e' : «expr →ₗ[ ] » S ℤ I)\n  let f_apply : ∀ x, f x = b'.equiv ab (equiv.refl _) x := fun x => rfl\n  suffices (linear_map.det f).nat_abs = ideal.abs_norm I by\n    calc\n      (linear_map.det («expr ∘ₗ » ((submodule.subtype I).restrict_scalars ℤ) _)).nat_abs =\n          (linear_map.det\n              («expr ∘ₗ » ((submodule.subtype I).restrict_scalars ℤ)\n                (↑(add_equiv.to_int_linear_equiv ↑e) : «expr →ₗ[ ] » S ℤ I))).nat_abs :=\n        rfl\n      _ = (linear_map.det («expr ∘ₗ » ((submodule.subtype I).restrict_scalars ℤ) _)).nat_abs :=\n        int.nat_abs_eq_iff_associated.mpr (linear_map.associated_det_comp_equiv _ _ _)\n      _ = abs_norm I := this\n      \n  have ha : ∀ i, f (b' i) = «expr • » (a i) (b' i) := by\n    intro i\n    rw [f_apply, b'.equiv_apply, equiv.refl_apply, ab_eq]\n  have mem_I_iff : ∀ x, x ∈ I ↔ ∀ i, a i ∣ b'.repr x i :=\n    by\n    intro x\n    simp_rw [ab.mem_ideal_iff', ab_eq]\n    have :\n      ∀ (c : ι → ℤ) (i),\n        b'.repr\n            (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (c j) («expr • » (a j) (b' j))))\n            i =\n          a i * c i :=\n      by\n      intro c i\n      simp only [← mul_action.mul_smul, b'.repr_sum_self, mul_comm]\n    constructor\n    · rintro ⟨c, rfl⟩ i\n      exact ⟨c i, this c i⟩\n    · rintro ha\n      choose c hc using ha\n      exact ⟨c, b'.ext_elem fun i => trans (hc i) (this c i).symm⟩\n  -- `det f` is equal to `∏ i, a i`,\n  letI := classical.dec_eq ι\n  calc\n    Int.natAbs (linear_map.det f) = Int.natAbs (linear_map.to_matrix b' b' f).det := by rw [linear_map.det_to_matrix]\n    _ = Int.natAbs (matrix.diagonal a).det := _\n    _ =\n        Int.natAbs\n          (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (a i)) :=\n      by rw [matrix.det_diagonal]\n    _ =\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (Int.natAbs (a i)) :=\n      map_prod Int.natAbsHom a finset.univ\n    _ = fintype.card («expr ⧸ » S I) := _\n    _ = abs_norm I := (submodule.card_quot_apply _).symm\n    \n  -- since `linear_map.to_matrix b' b' f` is the diagonal matrix with `a` along the diagonal.\n  · congr\n    ext (i j)\n    rw [linear_map.to_matrix_apply, ha, linear_equiv.map_smul, basis.repr_self, finsupp.smul_single, smul_eq_mul,\n      mul_one]\n    by_cases h : i = j\n    · rw [h, matrix.diagonal_apply_eq, finsupp.single_eq_same]\n    · rw [matrix.diagonal_apply_ne _ h, finsupp.single_eq_of_ne (ne.symm h)]\n  -- Now we map everything through the linear equiv `S ≃ₗ (ι → ℤ)`,\n  -- which maps `(S ⧸ I)` to `Π i, zmod (a i).nat_abs`.\n  haveI : ∀ i, ne_zero (a i).nat_abs := fun i => ⟨Int.natAbs_ne_zero_of_ne_zero (ideal.smith_coeffs_ne_zero b I hI i)⟩\n  simp_rw [fintype.card_eq.mpr ⟨(ideal.quotient_equiv_pi_zmod I b hI).to_equiv⟩, fintype.card_pi, zmod.card]\n#align nat_abs_det_equiv nat_abs_det_equiv\n\n",
 "nat_abs_det_basis_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Let `b` be a basis for `S` over `ℤ` and `bI` a basis for `I` over `ℤ` of the same dimension.\nThen an alternative way to compute the norm of `I` is given by taking the determinant of `bI`\nover `b`. -/\ntheorem nat_abs_det_basis_change {ι : Type _} [fintype ι] [decidable_eq ι] (b : basis ι ℤ S) (I : ideal S)\n    (bI : basis ι ℤ I) : (b.det (coe ∘ bI)).nat_abs = ideal.abs_norm I :=\n  by\n  let e := b.equiv bI (equiv.refl _)\n  calc\n    (b.det ((submodule.subtype I).restrict_scalars ℤ ∘ bI)).nat_abs =\n        (linear_map.det («expr ∘ₗ » ((submodule.subtype I).restrict_scalars ℤ) (e : «expr →ₗ[ ] » S ℤ I))).nat_abs :=\n      by rw [basis.det_comp_basis]\n    _ = _ := nat_abs_det_equiv I e\n    \n#align nat_abs_det_basis_change nat_abs_det_basis_change\n\n",
 "mul_add_mem_pow_succ_unique":
 "/-- The choice of `d` in `ideal.exists_mul_add_mem_pow_succ` is unique, up to `P`.\nInspired by [Neukirch], proposition 6.1 -/\ntheorem ideal.mul_add_mem_pow_succ_unique [is_dedekind_domain S] {i : ℕ} (a d d' e e' : S) (a_not_mem : a ∉ P ^ (i + 1))\n    (e_mem : e ∈ P ^ (i + 1)) (e'_mem : e' ∈ P ^ (i + 1)) (h : a * d + e - (a * d' + e') ∈ P ^ (i + 1)) : d - d' ∈ P :=\n  by\n  have : e' - e ∈ P ^ (i + 1) := ideal.sub_mem _ e'_mem e_mem\n  have h' : a * (d - d') ∈ P ^ (i + 1) :=\n    by\n    convert ideal.add_mem _ h (ideal.sub_mem _ e'_mem e_mem)\n    ring\n  exact ideal.mem_prime_of_mul_mem_pow hP a_not_mem h'\n#align ideal.mul_add_mem_pow_succ_unique ideal.mul_add_mem_pow_succ_unique\n\n",
 "mul_add_mem_pow_succ_inj":
 "/-- If the `d` from `ideal.exists_mul_add_mem_pow_succ` is unique, up to `P`,\nthen so are the `c`s, up to `P ^ (i + 1)`.\nInspired by [Neukirch], proposition 6.1 -/\ntheorem ideal.mul_add_mem_pow_succ_inj (P : ideal S) {i : ℕ} (a d d' e e' : S) (a_mem : a ∈ P ^ i)\n    (e_mem : e ∈ P ^ (i + 1)) (e'_mem : e' ∈ P ^ (i + 1)) (h : d - d' ∈ P) : a * d + e - (a * d' + e') ∈ P ^ (i + 1) :=\n  by\n  have : a * d - a * d' ∈ P ^ (i + 1) := by convert ideal.mul_mem_mul a_mem h <;> simp [mul_sub, pow_succ, mul_comm]\n  convert ideal.add_mem _ this (ideal.sub_mem _ e_mem e'_mem)\n  ring\n#align ideal.mul_add_mem_pow_succ_inj ideal.mul_add_mem_pow_succ_inj\n\n",
 "mem_prime_of_mul_mem_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal.mem_prime_of_mul_mem_pow [is_dedekind_domain S] {P : ideal S} [P_prime : P.is_prime] (hP : P ≠ «expr⊥»)\n    {i : ℕ} {a b : S} (a_not_mem : a ∉ P ^ (i + 1)) (ab_mem : a * b ∈ P ^ (i + 1)) : b ∈ P :=\n  by\n  simp only [← ideal.span_singleton_le_iff_mem, ← ideal.dvd_iff_le, pow_succ, ←\n    ideal.span_singleton_mul_span_singleton] at a_not_mem ab_mem⊢\n  exact (prime_pow_succ_dvd_mul (ideal.prime_of_is_prime hP P_prime) ab_mem).resolve_left a_not_mem\n#align ideal.mem_prime_of_mul_mem_pow ideal.mem_prime_of_mul_mem_pow\n\n",
 "is_prime_of_irreducible_abs_norm":
 "theorem is_prime_of_irreducible_abs_norm {I : ideal S} (hI : Irreducible I.abs_norm) : I.is_prime :=\n  is_prime_of_prime (unique_factorization_monoid.irreducible_iff_prime.mp (irreducible_of_irreducible_abs_norm hI))\n#align is_prime_of_irreducible_abs_norm is_prime_of_irreducible_abs_norm\n\n",
 "irreducible_of_irreducible_abs_norm":
 "theorem irreducible_of_irreducible_abs_norm {I : ideal S} (hI : Irreducible I.abs_norm) : Irreducible I :=\n  irreducible_iff.mpr\n    ⟨fun h => hI.not_unit (by simpa only [ideal.is_unit_iff, Nat.isUnit_iff, abs_norm_eq_one_iff] using h), by\n      rintro a b rfl <;>\n        simpa only [ideal.is_unit_iff, Nat.isUnit_iff, abs_norm_eq_one_iff] using\n          hI.is_unit_or_is_unit (_root_.map_mul abs_norm a b)⟩\n#align irreducible_of_irreducible_abs_norm irreducible_of_irreducible_abs_norm\n\n",
 "exists_mul_add_mem_pow_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- If `a ∈ P^i \\ P^(i+1)` and `c ∈ P^i`, then `a * d + e = c` for `e ∈ P^(i+1)`.\n`ideal.mul_add_mem_pow_succ_unique` shows the choice of `d` is unique, up to `P`.\nInspired by [Neukirch], proposition 6.1 -/\ntheorem ideal.exists_mul_add_mem_pow_succ [is_dedekind_domain S] {i : ℕ} (a c : S) (a_mem : a ∈ P ^ i)\n    (a_not_mem : a ∉ P ^ (i + 1)) (c_mem : c ∈ P ^ i) : ∃ d : S, ∃ e ∈ P ^ (i + 1), a * d + e = c :=\n  by\n  suffices eq_b : P ^ i = «expr ⊔ » (ideal.span {a}) (P ^ (i + 1))\n  · rw [eq_b] at c_mem\n    simp only [mul_comm a]\n    exact ideal.mem_span_singleton_sup.mp c_mem\n  refine'\n    (ideal.eq_prime_pow_of_succ_lt_of_le hP (lt_of_le_of_ne le_sup_right _)\n        (sup_le (ideal.span_le.mpr (set.singleton_subset_iff.mpr a_mem)) (ideal.pow_succ_lt_pow hP i).le)).symm\n  contrapose! a_not_mem with this\n  rw [this]\n  exact mem_sup.mpr ⟨a, mem_span_singleton_self a, 0, by simp, by simp⟩\n#align ideal.exists_mul_add_mem_pow_succ ideal.exists_mul_add_mem_pow_succ\n\n",
 "card_quot_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem card_quot_top : card_quot («expr⊤» : submodule R M) = 1 :=\n  add_subgroup.index_top\n#align card_quot_top card_quot_top\n\n",
 "card_quot_pow_of_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- Multiplicity of the ideal norm, for powers of prime ideals. -/\ntheorem card_quot_pow_of_prime [is_dedekind_domain S] [module.finite ℤ S] [module.free ℤ S] {i : ℕ} :\n    card_quot (P ^ i) = card_quot P ^ i :=\n  by\n  let b := module.free.choose_basis ℤ S\n  classical\n    induction' i with i ih\n    · simp\n    letI := ideal.fintype_quotient_of_free_of_ne_bot (P ^ i.succ) (pow_ne_zero _ hP)\n    letI := ideal.fintype_quotient_of_free_of_ne_bot (P ^ i) (pow_ne_zero _ hP)\n    letI := ideal.fintype_quotient_of_free_of_ne_bot P hP\n    have : P ^ (i + 1) < P ^ i := ideal.pow_succ_lt_pow hP i\n    suffices hquot : «expr ≃ » (map (P ^ i.succ).mkq (P ^ i)) («expr ⧸ » S P)\n    · rw [pow_succ (card_quot P), ← ih, card_quot_apply (P ^ i.succ), ←\n        card_quotient_mul_card_quotient (P ^ i) (P ^ i.succ) this.le, card_quot_apply (P ^ i), card_quot_apply P]\n      congr 1\n      rw [fintype.card_eq]\n      exact ⟨hquot⟩\n    choose a a_mem a_not_mem using SetLike.exists_of_lt this\n    choose f g hg hf using fun c (hc : c ∈ P ^ i) => ideal.exists_mul_add_mem_pow_succ hP a c a_mem a_not_mem hc\n    choose k hk_mem hk_eq using fun c' (hc' : c' ∈ map (mkq (P ^ i.succ)) (P ^ i)) => submodule.mem_map.mp hc'\n    refine' Equiv.ofBijective (fun c' => quotient.mk' (f (k c' c'.prop) (hk_mem c' c'.prop))) ⟨_, _⟩\n    · rintro ⟨c₁', hc₁'⟩ ⟨c₂', hc₂'⟩ h\n      rw [subtype.mk_eq_mk, ← hk_eq _ hc₁', ← hk_eq _ hc₂', mkq_apply, mkq_apply, submodule.quotient.eq, ←\n        hf _ (hk_mem _ hc₁'), ← hf _ (hk_mem _ hc₂')]\n      refine' ideal.mul_add_mem_pow_succ_inj _ _ _ _ _ _ a_mem (hg _ _) (hg _ _) _\n      simpa only [submodule.quotient.mk'_eq_mk, submodule.quotient.mk'_eq_mk, submodule.quotient.eq] using h\n    · intro d'\n      refine' Quotient.inductionOn' d' fun d => _\n      have hd' := mem_map.mpr ⟨a * d, ideal.mul_mem_right d _ a_mem, rfl⟩\n      refine' ⟨⟨_, hd'⟩, _⟩\n      simp only [submodule.quotient.mk'_eq_mk, ideal.quotient.mk_eq_mk, ideal.quotient.eq, subtype.coe_mk]\n      refine' ideal.mul_add_mem_pow_succ_unique hP a _ _ _ _ a_not_mem (hg _ (hk_mem _ hd')) (zero_mem _) _\n      rw [hf, add_zero]\n      exact (submodule.quotient.eq _).mp (hk_eq _ hd')\n#align card_quot_pow_of_prime card_quot_pow_of_prime\n\n",
 "card_quot_mul_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Multiplicity of the ideal norm, for coprime ideals.\nThis is essentially just a repackaging of the Chinese Remainder Theorem.\n-/\ntheorem card_quot_mul_of_coprime [is_dedekind_domain S] [module.free ℤ S] [module.finite ℤ S] {I J : ideal S}\n    (coprime : «expr ⊔ » I J = «expr⊤») : card_quot (I * J) = card_quot I * card_quot J :=\n  by\n  let b := module.free.choose_basis ℤ S\n  cases isEmpty_or_nonempty (module.free.choose_basis_index ℤ S)\n  · haveI : subsingleton S := function.surjective.subsingleton b.repr.to_equiv.symm.surjective\n    nontriviality S\n    exfalso\n    exact not_nontrivial_iff_subsingleton.mpr ‹subsingleton S› ‹nontrivial S›\n  haveI : Infinite S := infinite.of_surjective _ b.repr.to_equiv.surjective\n  by_cases hI : I = «expr⊥»\n  · rw [hI, submodule.bot_mul, card_quot_bot, zero_mul]\n  by_cases hJ : J = «expr⊥»\n  · rw [hJ, submodule.mul_bot, card_quot_bot, mul_zero]\n  have hIJ : I * J ≠ «expr⊥» := mt ideal.mul_eq_bot.mp (not_or_of_not hI hJ)\n  letI := classical.dec_eq (module.free.choose_basis_index ℤ S)\n  letI := I.fintype_quotient_of_free_of_ne_bot hI\n  letI := J.fintype_quotient_of_free_of_ne_bot hJ\n  letI := (I * J).fintype_quotient_of_free_of_ne_bot hIJ\n  rw [card_quot_apply, card_quot_apply, card_quot_apply,\n    fintype.card_eq.mpr ⟨(ideal.quotient_mul_equiv_quotient_prod I J coprime).to_equiv⟩, fintype.card_prod]\n#align card_quot_mul_of_coprime card_quot_mul_of_coprime\n\n",
 "card_quot_mul":
 "/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem card_quot_mul [is_dedekind_domain S] [module.free ℤ S] [module.finite ℤ S] (I J : ideal S) :\n    card_quot (I * J) = card_quot I * card_quot J :=\n  by\n  let b := module.free.choose_basis ℤ S\n  cases isEmpty_or_nonempty (module.free.choose_basis_index ℤ S)\n  · haveI : subsingleton S := function.surjective.subsingleton b.repr.to_equiv.symm.surjective\n    nontriviality S\n    exfalso\n    exact not_nontrivial_iff_subsingleton.mpr ‹subsingleton S› ‹nontrivial S›\n  haveI : Infinite S := infinite.of_surjective _ b.repr.to_equiv.surjective\n  exact\n    unique_factorization_monoid.multiplicative_of_coprime card_quot I J (card_quot_bot _ _)\n      (fun I J hI => by simp [ideal.is_unit_iff.mp hI, ideal.mul_top])\n      (fun I i hI =>\n        have : ideal.is_prime I := ideal.is_prime_of_prime hI\n        card_quot_pow_of_prime hI.ne_zero)\n      fun I J hIJ =>\n      card_quot_mul_of_coprime\n        (ideal.is_unit_iff.mp (hIJ _ (ideal.dvd_iff_le.mpr le_sup_left) (ideal.dvd_iff_le.mpr le_sup_right)))\n#align card_quot_mul card_quot_mul\n\n",
 "card_quot_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem card_quot_eq_one_iff {P : submodule R M} : card_quot P = 1 ↔ P = «expr⊤» :=\n  add_subgroup.index_eq_one.trans (by simp [SetLike.ext_iff])\n#align card_quot_eq_one_iff card_quot_eq_one_iff\n\n",
 "card_quot_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem card_quot_bot [Infinite M] : card_quot («expr⊥» : submodule R M) = 0 :=\n  add_subgroup.index_bot.trans nat.card_eq_zero_of_infinite\n#align card_quot_bot card_quot_bot\n\n",
 "card_quot_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-\nCopyright (c) 2022 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen, Alex J. Best\n-/\n@[simp]\ntheorem card_quot_apply (S : submodule R M) [fintype («expr ⧸ » M S)] : card_quot S = fintype.card («expr ⧸ » M S) :=\n  add_subgroup.index_eq_card _\n#align card_quot_apply card_quot_apply\n\n",
 "abs_norm_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem abs_norm_top : abs_norm («expr⊤» : ideal S) = 1 := by rw [← ideal.one_eq_top, _root_.map_one]\n#align abs_norm_top abs_norm_top\n\n",
 "abs_norm_span_singleton":
 "@[simp]\ntheorem abs_norm_span_singleton (r : S) : abs_norm (span ({r} : set S)) = (algebra.norm ℤ r).nat_abs :=\n  by\n  rw [algebra.norm_apply]\n  by_cases hr : r = 0\n  ·\n    simp only [hr, ideal.span_zero, algebra.coe_lmul_eq_mul, eq_self_iff_true, ideal.abs_norm_bot,\n      linear_map.det_zero'', set.singleton_zero, _root_.map_zero, Int.natAbs_zero]\n  letI := ideal.fintype_quotient_of_free_of_ne_bot (span {r}) (mt span_singleton_eq_bot.mp hr)\n  let b := module.free.choose_basis ℤ S\n  rw [← nat_abs_det_equiv _ (b.equiv (basis_span_singleton b hr) (equiv.refl _))]\n  swap; infer_instance\n  congr\n  refine' b.ext fun i => _\n  simp\n#align abs_norm_span_singleton abs_norm_span_singleton\n\n",
 "abs_norm_span_insert":
 "@[simp]\ntheorem abs_norm_span_insert (r : S) (s : set S) :\n    abs_norm (span (insert r s)) ∣ gcd (abs_norm (span s)) (algebra.norm ℤ r).nat_abs :=\n  (dvd_gcd_iff _ _ _).mpr\n    ⟨abs_norm_dvd_abs_norm_of_le (span_mono (Set.subset_insert _ _)),\n      trans (abs_norm_dvd_abs_norm_of_le (span_mono (Set.singleton_subset_iff.mpr (Set.mem_insert _ _))))\n        (by rw [abs_norm_span_singleton])⟩\n#align abs_norm_span_insert abs_norm_span_insert\n\n",
 "abs_norm_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem abs_norm_eq_one_iff {I : ideal S} : abs_norm I = 1 ↔ I = «expr⊤» := by rw [abs_norm_apply, card_quot_eq_one_iff]\n#align abs_norm_eq_one_iff abs_norm_eq_one_iff\n\n",
 "abs_norm_dvd_abs_norm_of_le":
 "theorem abs_norm_dvd_abs_norm_of_le {I J : ideal S} (h : J ≤ I) : I.abs_norm ∣ J.abs_norm :=\n  map_dvd abs_norm (dvd_iff_le.mpr h)\n#align abs_norm_dvd_abs_norm_of_le abs_norm_dvd_abs_norm_of_le\n\n",
 "abs_norm_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem abs_norm_bot : abs_norm («expr⊥» : ideal S) = 0 := by rw [← ideal.zero_eq_bot, _root_.map_zero]\n#align abs_norm_bot abs_norm_bot\n\n",
 "abs_norm_apply":
 "theorem abs_norm_apply (I : ideal S) : abs_norm I = card_quot I :=\n  rfl\n#align abs_norm_apply abs_norm_apply\n\n"}