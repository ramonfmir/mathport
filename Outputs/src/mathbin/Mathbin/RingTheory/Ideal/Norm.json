{"span_singleton_abs_norm_le":
 "theorem span_singleton_abs_norm_le (I : Ideal S) : Ideal.span {(ideal.abs_norm I : S)} ≤ I := by\n  simp only [Ideal.span_le, Set.singleton_subset_iff, SetLike.mem_coe, ideal.abs_norm_mem I]\n#align span_singleton_abs_norm_le span_singleton_abs_norm_le\n\n",
 "span_norm_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem span_norm_top : span_norm R («expr⊤» : Ideal S) = «expr⊤» := by simp [← Ideal.span_singleton_one]\n#align span_norm_top span_norm_top\n\n",
 "span_norm_singleton":
 "@[simp]\ntheorem span_norm_singleton {r : S} : span_norm R (span ({r} : Set S)) = span {algebra.norm R r} :=\n  le_antisymm\n    (span_le.mpr fun x hx =>\n      mem_span_singleton.mpr\n        (by\n          obtain ⟨x, hx', rfl⟩ := (Set.mem_image _ _ _).mp hx\n          exact map_dvd _ (mem_span_singleton.mp hx')))\n    ((span_singleton_le_iff_mem _).mpr (norm_mem_span_norm _ _ (mem_span_singleton_self _)))\n#align span_norm_singleton span_norm_singleton\n\n",
 "span_norm_mul_span_norm_le":
 "theorem span_norm_mul_span_norm_le (I J : Ideal S) : span_norm R I * span_norm R J ≤ span_norm R (I * J) :=\n  by\n  rw [span_norm, span_norm, span_norm, Ideal.span_mul_span', ← Set.image_mul]\n  refine' Ideal.span_mono (Set.monotone_image _)\n  rintro _ ⟨x, y, hxI, hyJ, rfl⟩\n  exact Ideal.mul_mem_mul hxI hyJ\n#align span_norm_mul_span_norm_le span_norm_mul_span_norm_le\n\n",
 "span_norm_mul_of_field":
 "@[simp]\ntheorem span_norm_mul_of_field {K : Type _} [Field K] [Algebra K S] [IsDomain S] [Module.Finite K S] (I J : Ideal S) :\n    span_norm K (I * J) = span_norm K I * span_norm K J :=\n  span_norm_mul_of_bot_or_top K eq_bot_or_top I J\n#align span_norm_mul_of_field span_norm_mul_of_field\n\n",
 "span_norm_mul_of_bot_or_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- This condition `eq_bot_or_top` is equivalent to being a field.\nHowever, `span_norm_mul_of_field` is harder to apply since we'd need to upgrade a `comm_ring R`\ninstance to a `field R` instance. -/\ntheorem span_norm_mul_of_bot_or_top [IsDomain R] [IsDomain S] [Module.Free R S] [Module.Finite R S]\n    (eq_bot_or_top : ∀ I : Ideal R, I = «expr⊥» ∨ I = «expr⊤») (I J : Ideal S) :\n    span_norm R (I * J) = span_norm R I * span_norm R J :=\n  by\n  refine' le_antisymm _ (span_norm_mul_span_norm_le _ _ _)\n  cases' eq_bot_or_top (span_norm R I) with hI hI\n  · rw [hI, span_norm_eq_bot_iff.mp hI, bot_mul, span_norm_bot]\n    exact bot_le\n  rw [hI, Ideal.top_mul]\n  cases' eq_bot_or_top (span_norm R J) with hJ hJ\n  · rw [hJ, span_norm_eq_bot_iff.mp hJ, mul_bot, span_norm_bot]\n    exact bot_le\n  rw [hJ]\n  exact le_top\n#align span_norm_mul_of_bot_or_top span_norm_mul_of_bot_or_top\n\n",
 "span_norm_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- Multiplicativity of `ideal.span_norm`. simp-normal form is `map_mul (ideal.rel_norm R)`. -/\ntheorem span_norm_mul (I J : Ideal S) : span_norm R (I * J) = span_norm R I * span_norm R J :=\n  by\n  nontriviality R\n  cases subsingleton_or_nontrivial S\n  · have : ∀ I : Ideal S, I = «expr⊤» := fun I => subsingleton.elim I («expr⊤»)\n    simp [this I, this J, this (I * J)]\n  refine' eq_of_localization_maximal _\n  intro P hP\n  by_cases hP0 : P = «expr⊥»\n  · subst hP0\n    rw [span_norm_mul_of_bot_or_top]\n    intro I\n    refine' or_iff_not_imp_right.mpr fun hI => _\n    exact (hP.eq_of_le hI bot_le).symm\n  let P' := Algebra.algebraMapSubmonoid S P.prime_compl\n  letI : Algebra (localization.at_prime P) (Localization P') := localizationAlgebra P.prime_compl S\n  haveI : IsScalarTower R (localization.at_prime P) (Localization P') :=\n    IsScalarTower.of_algebraMap_eq fun x => (IsLocalization.map_eq _ _).symm\n  have h : P' ≤ non_zero_divisors S :=\n    map_le_nonZeroDivisors_of_injective _ (NoZeroSMulDivisors.algebraMap_injective _ _)\n      P.prime_compl_le_non_zero_divisors\n  haveI : IsDomain (Localization P') := IsLocalization.isDomain_localization h\n  haveI : is_dedekind_domain (Localization P') := is_localization.is_dedekind_domain S h _\n  letI := Classical.decEq (Ideal (Localization P'))\n  haveI : IsPrincipalIdealRing (Localization P') :=\n    is_dedekind_domain.is_principal_ideal_ring_localization_over_prime S P hP0\n  rw [Ideal.map_mul, ← span_norm_localization R I P.prime_compl (Localization P'), ←\n    span_norm_localization R J P.prime_compl (Localization P'), ←\n    span_norm_localization R (I * J) P.prime_compl (Localization P'), Ideal.map_mul, ←\n    (I.map _).span_singleton_generator, ← (J.map _).span_singleton_generator, span_singleton_mul_span_singleton,\n    span_norm_singleton, span_norm_singleton, span_norm_singleton, span_singleton_mul_span_singleton, _root_.map_mul]\n  repeat' infer_instance\n  repeat' assumption\n#align span_norm_mul span_norm_mul\n\n",
 "span_norm_mono":
 "@[mono]\ntheorem span_norm_mono {I J : Ideal S} (h : I ≤ J) : span_norm R I ≤ span_norm R J :=\n  Ideal.span_mono (Set.monotone_image h)\n#align span_norm_mono span_norm_mono\n\n",
 "span_norm_localization":
 "theorem span_norm_localization (I : Ideal S) [Module.Finite R S] [Module.Free R S] (M : Submonoid R) {Rₘ : Type _}\n    (Sₘ : Type _) [CommRing Rₘ] [Algebra R Rₘ] [CommRing Sₘ] [Algebra S Sₘ] [Algebra Rₘ Sₘ] [Algebra R Sₘ]\n    [IsScalarTower R Rₘ Sₘ] [IsScalarTower R S Sₘ] [IsLocalization M Rₘ]\n    [IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ] :\n    span_norm Rₘ (I.map (algebraMap S Sₘ)) = (span_norm R I).map (algebraMap R Rₘ) :=\n  by\n  cases h : subsingleton_or_nontrivial R\n  · haveI := IsLocalization.unique R Rₘ M\n    simp\n  let b := Module.Free.chooseBasis R S\n  rw [map_span_norm]\n  refine' span_eq_span (set.image_subset_iff.mpr _) (set.image_subset_iff.mpr _)\n  · rintro a' ha'\n    simp only [Set.mem_preimage, submodule_span_eq, ← map_span_norm, SetLike.mem_coe,\n      IsLocalization.mem_map_algebraMap_iff (Algebra.algebraMapSubmonoid S M) Sₘ,\n      IsLocalization.mem_map_algebraMap_iff M Rₘ, Prod.exists] at ha'⊢\n    obtain ⟨⟨a, ha⟩, ⟨_, ⟨s, hs, rfl⟩⟩, has⟩ := ha'\n    refine'\n      ⟨⟨algebra.norm R a, norm_mem_span_norm _ _ ha⟩,\n        ⟨s ^ Fintype.card (Module.Free.ChooseBasisIndex R S), pow_mem hs _⟩, _⟩\n    swap\n    simp only [Submodule.coe_mk, Subtype.coe_mk, map_pow] at has⊢\n    apply_fun algebra.norm Rₘ  at has\n    rwa [_root_.map_mul, ← IsScalarTower.algebraMap_apply, IsScalarTower.algebraMap_apply R Rₘ,\n      algebra.norm_algebra_map_of_basis (b.localization_localization Rₘ M Sₘ), algebra.norm_localization R M a] at has\n    all_goals infer_instance\n  · intro a ha\n    rw [Set.mem_preimage, Function.comp_apply, ← algebra.norm_localization R M a]\n    exact subset_span (Set.mem_image_of_mem _ (mem_map_of_mem _ ha))\n    all_goals infer_instance\n#align span_norm_localization span_norm_localization\n\n",
 "span_norm_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem span_norm_eq_bot_iff [IsDomain R] [IsDomain S] [Module.Free R S] [Module.Finite R S] {I : Ideal S} :\n    span_norm R I = «expr⊥» ↔ I = «expr⊥» :=\n  by\n  simp only [span_norm, Ideal.span_eq_bot, Set.mem_image, SetLike.mem_coe, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff₂, algebra.norm_eq_zero_iff_of_basis (Module.Free.chooseBasis R S), @eq_bot_iff _ _ _ I,\n    SetLike.le_def]\n  rfl\n#align span_norm_eq_bot_iff span_norm_eq_bot_iff\n\n",
 "span_norm_eq":
 "@[simp]\ntheorem span_norm_eq (I : Ideal S) : span_norm R I = rel_norm R I :=\n  rfl\n#align span_norm_eq span_norm_eq\n\n",
 "span_norm_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem span_norm_bot [Nontrivial S] [Module.Free R S] [Module.Finite R S] :\n    span_norm R («expr⊥» : Ideal S) = «expr⊥» :=\n  span_eq_bot.mpr fun x hx => by simpa using hx\n#align span_norm_bot span_norm_bot\n\n",
 "rel_norm_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem rel_norm_top : rel_norm R («expr⊤» : Ideal S) = «expr⊤» := by\n  simpa only [one_eq_top] using map_one (rel_norm R : «expr →*₀ » (Ideal S) _)\n#align rel_norm_top rel_norm_top\n\n",
 "rel_norm_singleton":
 "@[simp]\ntheorem rel_norm_singleton (r : S) : rel_norm R (span ({r} : Set S)) = span {algebra.norm R r} :=\n  span_norm_singleton R\n#align rel_norm_singleton rel_norm_singleton\n\n",
 "rel_norm_mono":
 "@[mono]\ntheorem rel_norm_mono {I J : Ideal S} (h : I ≤ J) : rel_norm R I ≤ rel_norm R J :=\n  span_norm_mono R h\n#align rel_norm_mono rel_norm_mono\n\n",
 "rel_norm_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem rel_norm_eq_bot_iff {I : Ideal S} : rel_norm R I = «expr⊥» ↔ I = «expr⊥» :=\n  span_norm_eq_bot_iff\n#align rel_norm_eq_bot_iff rel_norm_eq_bot_iff\n\n",
 "rel_norm_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem rel_norm_bot : rel_norm R («expr⊥» : Ideal S) = «expr⊥» := by\n  simpa only [zero_eq_bot] using map_zero (rel_norm R : «expr →*₀ » (Ideal S) _)\n#align rel_norm_bot rel_norm_bot\n\n",
 "rel_norm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem rel_norm_apply (I : Ideal S) : rel_norm R I = span («expr '' » (algebra.norm R) (I : Set S) : Set R) :=\n  rfl\n#align rel_norm_apply rel_norm_apply\n\n",
 "prime_of_irreducible_abs_norm_span":
 "theorem prime_of_irreducible_abs_norm_span {a : S} (ha : a ≠ 0) (hI : Irreducible (Ideal.span ({a} : Set S)).abs_norm) :\n    Prime a :=\n  (Ideal.span_singleton_prime ha).mp (is_prime_of_irreducible_abs_norm hI)\n#align prime_of_irreducible_abs_norm_span prime_of_irreducible_abs_norm_span\n\n",
 "norm_mem_span_norm":
 "theorem norm_mem_span_norm {I : Ideal S} (x : S) (hx : x ∈ I) : algebra.norm R x ∈ I.span_norm R :=\n  subset_span (Set.mem_image_of_mem _ hx)\n#align norm_mem_span_norm norm_mem_span_norm\n\n",
 "norm_mem_rel_norm":
 "theorem norm_mem_rel_norm (I : Ideal S) {x : S} (hx : x ∈ I) : algebra.norm R x ∈ rel_norm R I :=\n  norm_mem_span_norm R x hx\n#align norm_mem_rel_norm norm_mem_rel_norm\n\n",
 "nat_abs_det_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/-- Let `e : S ≃ I` be an additive isomorphism (therefore a `ℤ`-linear equiv).\nThen an alternative way to compute the norm of `I` is given by taking the determinant of `e`.\nSee `nat_abs_det_basis_change` for a more familiar formulation of this result. -/\ntheorem nat_abs_det_equiv (I : Ideal S) {E : Type _} [AddEquivClass E S I] (e : E) :\n    Int.natAbs\n        (LinearMap.det\n          («expr ∘ₗ » ((Submodule.subtype I).restrict_scalars ℤ) (AddMonoidHom.toIntLinearMap (e : «expr →+ » S I)))) =\n      ideal.abs_norm I :=\n  by\n  -- `S ⧸ I` might be infinite if `I = ⊥`, but then `e` can't be an equiv.\n  by_cases hI : I = «expr⊥»\n  · subst hI\n    have : (1 : S) ≠ 0 := one_ne_zero\n    have : (1 : S) = 0 := EquivLike.injective e (subsingleton.elim _ _)\n    contradiction\n  let ι := Module.Free.ChooseBasisIndex ℤ S\n  let b := Module.Free.chooseBasis ℤ S\n  cases isEmpty_or_nonempty ι\n  · nontriviality S\n    exact\n      (not_nontrivial_iff_subsingleton.mpr (Function.Surjective.subsingleton b.repr.to_equiv.symm.surjective)\n          (by infer_instance)).elim\n  -- Thus `(S ⧸ I)` is isomorphic to a product of `zmod`s, so it is a fintype.\n  letI := ideal.fintype_quotient_of_free_of_ne_bot I hI\n  -- Use the Smith normal form to choose a nice basis for `I`.\n  letI := Classical.decEq ι\n  let a := I.smith_coeffs b hI\n  let b' := I.ring_basis b hI\n  let ab := I.self_basis b hI\n  have ab_eq := I.self_basis_def b hI\n  let e' : «expr ≃ₗ[ ] » S ℤ I := b'.equiv ab (Equiv.refl _)\n  let f : «expr →ₗ[ ] » S ℤ S := (I.subtype.restrict_scalars ℤ).comp (e' : «expr →ₗ[ ] » S ℤ I)\n  let f_apply : ∀ x, f x = b'.equiv ab (Equiv.refl _) x := fun x => rfl\n  suffices (LinearMap.det f).nat_abs = ideal.abs_norm I by\n    calc\n      (LinearMap.det («expr ∘ₗ » ((Submodule.subtype I).restrict_scalars ℤ) _)).nat_abs =\n          (LinearMap.det\n              («expr ∘ₗ » ((Submodule.subtype I).restrict_scalars ℤ)\n                (↑(AddEquiv.toIntLinearEquiv ↑e) : «expr →ₗ[ ] » S ℤ I))).nat_abs :=\n        rfl\n      _ = (LinearMap.det («expr ∘ₗ » ((Submodule.subtype I).restrict_scalars ℤ) _)).nat_abs :=\n        (int.nat_abs_eq_iff_associated.mpr (LinearMap.associated_det_comp_equiv _ _ _))\n      _ = abs_norm I := this\n      \n  have ha : ∀ i, f (b' i) = «expr • » (a i) (b' i) := by\n    intro i\n    rw [f_apply, b'.equiv_apply, Equiv.refl_apply, ab_eq]\n  have mem_I_iff : ∀ x, x ∈ I ↔ ∀ i, a i ∣ b'.repr x i :=\n    by\n    intro x\n    simp_rw [ab.mem_ideal_iff', ab_eq]\n    have :\n      ∀ (c : ι → ℤ) (i),\n        b'.repr\n            (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (c j) («expr • » (a j) (b' j))))\n            i =\n          a i * c i :=\n      by\n      intro c i\n      simp only [← mul_action.mul_smul, b'.repr_sum_self, mul_comm]\n    constructor\n    · rintro ⟨c, rfl⟩ i\n      exact ⟨c i, this c i⟩\n    · rintro ha\n      choose c hc using ha\n      exact ⟨c, b'.ext_elem fun i => trans (hc i) (this c i).symm⟩\n  -- `det f` is equal to `∏ i, a i`,\n  letI := Classical.decEq ι\n  calc\n    Int.natAbs (LinearMap.det f) = Int.natAbs (LinearMap.toMatrix b' b' f).det := by rw [LinearMap.det_toMatrix]\n    _ = Int.natAbs (Matrix.diagonal a).det := _\n    _ =\n        Int.natAbs\n          (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (a i)) :=\n      by rw [Matrix.det_diagonal]\n    _ =\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (Int.natAbs (a i)) :=\n      (map_prod Int.natAbsHom a Finset.univ)\n    _ = Fintype.card («expr ⧸ » S I) := _\n    _ = abs_norm I := (submodule.card_quot_apply _).symm\n    \n  -- since `linear_map.to_matrix b' b' f` is the diagonal matrix with `a` along the diagonal.\n  · congr\n    ext (i j)\n    rw [LinearMap.toMatrix_apply, ha, LinearEquiv.map_smul, Basis.repr_self, Finsupp.smul_single, smul_eq_mul, mul_one]\n    by_cases h : i = j\n    · rw [h, Matrix.diagonal_apply_eq, Finsupp.single_eq_same]\n    · rw [Matrix.diagonal_apply_ne _ h, Finsupp.single_eq_of_ne (ne.symm h)]\n  -- Now we map everything through the linear equiv `S ≃ₗ (ι → ℤ)`,\n  -- which maps `(S ⧸ I)` to `Π i, zmod (a i).nat_abs`.\n  haveI : ∀ i, NeZero (a i).nat_abs := fun i => ⟨Int.natAbs_ne_zero_of_ne_zero (Ideal.smithCoeffs_ne_zero b I hI i)⟩\n  simp_rw [fintype.card_eq.mpr ⟨(ideal.quotient_equiv_pi_zmod I b hI).to_equiv⟩, Fintype.card_pi, ZMod.card]\n#align nat_abs_det_equiv nat_abs_det_equiv\n\n",
 "nat_abs_det_basis_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Let `b` be a basis for `S` over `ℤ` and `bI` a basis for `I` over `ℤ` of the same dimension.\nThen an alternative way to compute the norm of `I` is given by taking the determinant of `bI`\nover `b`. -/\ntheorem nat_abs_det_basis_change {ι : Type _} [Fintype ι] [DecidableEq ι] (b : Basis ι ℤ S) (I : Ideal S)\n    (bI : Basis ι ℤ I) : (b.det (coe ∘ bI)).nat_abs = ideal.abs_norm I :=\n  by\n  let e := b.equiv bI (Equiv.refl _)\n  calc\n    (b.det ((Submodule.subtype I).restrict_scalars ℤ ∘ bI)).nat_abs =\n        (LinearMap.det («expr ∘ₗ » ((Submodule.subtype I).restrict_scalars ℤ) (e : «expr →ₗ[ ] » S ℤ I))).nat_abs :=\n      by rw [Basis.det_comp_basis]\n    _ = _ := nat_abs_det_equiv I e\n    \n#align nat_abs_det_basis_change nat_abs_det_basis_change\n\n",
 "mul_add_mem_pow_succ_unique":
 "/-- The choice of `d` in `ideal.exists_mul_add_mem_pow_succ` is unique, up to `P`.\nInspired by [Neukirch], proposition 6.1 -/\ntheorem ideal.mul_add_mem_pow_succ_unique [is_dedekind_domain S] {i : ℕ} (a d d' e e' : S) (a_not_mem : a ∉ P ^ (i + 1))\n    (e_mem : e ∈ P ^ (i + 1)) (e'_mem : e' ∈ P ^ (i + 1)) (h : a * d + e - (a * d' + e') ∈ P ^ (i + 1)) : d - d' ∈ P :=\n  by\n  have : e' - e ∈ P ^ (i + 1) := Ideal.sub_mem _ e'_mem e_mem\n  have h' : a * (d - d') ∈ P ^ (i + 1) :=\n    by\n    convert Ideal.add_mem _ h (Ideal.sub_mem _ e'_mem e_mem)\n    ring\n  exact ideal.mem_prime_of_mul_mem_pow hP a_not_mem h'\n#align ideal.mul_add_mem_pow_succ_unique ideal.mul_add_mem_pow_succ_unique\n\n",
 "mul_add_mem_pow_succ_inj":
 "/-- If the `d` from `ideal.exists_mul_add_mem_pow_succ` is unique, up to `P`,\nthen so are the `c`s, up to `P ^ (i + 1)`.\nInspired by [Neukirch], proposition 6.1 -/\ntheorem ideal.mul_add_mem_pow_succ_inj (P : Ideal S) {i : ℕ} (a d d' e e' : S) (a_mem : a ∈ P ^ i)\n    (e_mem : e ∈ P ^ (i + 1)) (e'_mem : e' ∈ P ^ (i + 1)) (h : d - d' ∈ P) : a * d + e - (a * d' + e') ∈ P ^ (i + 1) :=\n  by\n  have : a * d - a * d' ∈ P ^ (i + 1) := by convert Ideal.mul_mem_mul a_mem h <;> simp [mul_sub, pow_succ, mul_comm]\n  convert Ideal.add_mem _ this (Ideal.sub_mem _ e_mem e'_mem)\n  ring\n#align ideal.mul_add_mem_pow_succ_inj ideal.mul_add_mem_pow_succ_inj\n\n",
 "mem_prime_of_mul_mem_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal.mem_prime_of_mul_mem_pow [is_dedekind_domain S] {P : Ideal S} [P_prime : P.is_prime] (hP : P ≠ «expr⊥»)\n    {i : ℕ} {a b : S} (a_not_mem : a ∉ P ^ (i + 1)) (ab_mem : a * b ∈ P ^ (i + 1)) : b ∈ P :=\n  by\n  simp only [← Ideal.span_singleton_le_iff_mem, ← ideal.dvd_iff_le, pow_succ, ←\n    Ideal.span_singleton_mul_span_singleton] at a_not_mem ab_mem⊢\n  exact (prime_pow_succ_dvd_mul (ideal.prime_of_is_prime hP P_prime) ab_mem).resolve_left a_not_mem\n#align ideal.mem_prime_of_mul_mem_pow ideal.mem_prime_of_mul_mem_pow\n\n",
 "map_span_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_span_norm (I : Ideal S) {T : Type _} [CommRing T] (f : «expr →+* » R T) :\n    map f (span_norm R I) = span («expr '' » (f ∘ algebra.norm R) (I : Set S)) := by\n  rw [span_norm, map_span, Set.image_image]\n#align map_span_norm map_span_norm\n\n",
 "map_rel_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_rel_norm (I : Ideal S) {T : Type _} [CommRing T] (f : «expr →+* » R T) :\n    map f (rel_norm R I) = span («expr '' » (f ∘ algebra.norm R) (I : Set S)) :=\n  map_span_norm R I f\n#align map_rel_norm map_rel_norm\n\n",
 "is_prime_of_irreducible_abs_norm":
 "theorem is_prime_of_irreducible_abs_norm {I : Ideal S} (hI : Irreducible I.abs_norm) : I.is_prime :=\n  is_prime_of_prime (unique_factorization_monoid.irreducible_iff_prime.mp (irreducible_of_irreducible_abs_norm hI))\n#align is_prime_of_irreducible_abs_norm is_prime_of_irreducible_abs_norm\n\n",
 "irreducible_of_irreducible_abs_norm":
 "theorem irreducible_of_irreducible_abs_norm {I : Ideal S} (hI : Irreducible I.abs_norm) : Irreducible I :=\n  irreducible_iff.mpr\n    ⟨fun h => hI.not_unit (by simpa only [Ideal.isUnit_iff, Nat.isUnit_iff, abs_norm_eq_one_iff] using h), by\n      rintro a b rfl <;>\n        simpa only [Ideal.isUnit_iff, Nat.isUnit_iff, abs_norm_eq_one_iff] using\n          hI.is_unit_or_is_unit (_root_.map_mul abs_norm a b)⟩\n#align irreducible_of_irreducible_abs_norm irreducible_of_irreducible_abs_norm\n\n",
 "finite_set_of_abs_norm_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem finite_set_of_abs_norm_eq [CharZero S] {n : ℕ} (hn : 0 < n) : { I : Ideal S | ideal.abs_norm I = n }.finite :=\n  by\n  let f := fun I : Ideal S => Ideal.map (Ideal.Quotient.mk (@Ideal.span S _ {n})) I\n  refine' @Set.Finite.of_finite_image _ _ _ f _ _\n  · suffices Finite («expr ⧸ » S (@Ideal.span S _ {n}))\n      by\n      let g := (coe : Ideal («expr ⧸ » S (@Ideal.span S _ {n})) → Set («expr ⧸ » S (@Ideal.span S _ {n})))\n      refine' @Set.Finite.of_finite_image _ _ _ g _ (set_like.coe_injective.inj_on _)\n      exact Set.Finite.subset (@Set.finite_univ _ (@Set.finite' _ this)) (Set.subset_univ _)\n    rw [← abs_norm_ne_zero_iff, abs_norm_span_singleton]\n    simpa only [ne.def, Int.natAbs_eq_zero, algebra.norm_eq_zero_iff, Nat.cast_eq_zero] using ne_of_gt hn\n  · intro I hI J hJ h\n    rw [← comap_map_mk (span_singleton_abs_norm_le I), ← hI.symm, ← comap_map_mk (span_singleton_abs_norm_le J), ←\n      hJ.symm]\n    exact congr_arg (Ideal.comap (Ideal.Quotient.mk (@Ideal.span S _ {n}))) h\n#align finite_set_of_abs_norm_eq finite_set_of_abs_norm_eq\n\n",
 "exists_mul_add_mem_pow_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- If `a ∈ P^i \\ P^(i+1)` and `c ∈ P^i`, then `a * d + e = c` for `e ∈ P^(i+1)`.\n`ideal.mul_add_mem_pow_succ_unique` shows the choice of `d` is unique, up to `P`.\nInspired by [Neukirch], proposition 6.1 -/\ntheorem ideal.exists_mul_add_mem_pow_succ [is_dedekind_domain S] {i : ℕ} (a c : S) (a_mem : a ∈ P ^ i)\n    (a_not_mem : a ∉ P ^ (i + 1)) (c_mem : c ∈ P ^ i) : ∃ d : S, ∃ e ∈ P ^ (i + 1), a * d + e = c :=\n  by\n  suffices eq_b : P ^ i = «expr ⊔ » (Ideal.span {a}) (P ^ (i + 1))\n  · rw [eq_b] at c_mem\n    simp only [mul_comm a]\n    exact ideal.mem_span_singleton_sup.mp c_mem\n  refine'\n    (ideal.eq_prime_pow_of_succ_lt_of_le hP (lt_of_le_of_ne le_sup_right _)\n        (sup_le (ideal.span_le.mpr (set.singleton_subset_iff.mpr a_mem)) (ideal.pow_succ_lt_pow hP i).le)).symm\n  contrapose! a_not_mem with this\n  rw [this]\n  exact mem_sup.mpr ⟨a, mem_span_singleton_self a, 0, by simp, by simp⟩\n#align ideal.exists_mul_add_mem_pow_succ ideal.exists_mul_add_mem_pow_succ\n\n",
 "card_quot_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem card_quot_top : card_quot («expr⊤» : Submodule R M) = 1 :=\n  AddSubgroup.index_top\n#align card_quot_top card_quot_top\n\n",
 "card_quot_pow_of_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- Multiplicity of the ideal norm, for powers of prime ideals. -/\ntheorem card_quot_pow_of_prime [is_dedekind_domain S] [Module.Finite ℤ S] [Module.Free ℤ S] {i : ℕ} :\n    card_quot (P ^ i) = card_quot P ^ i :=\n  by\n  let b := Module.Free.chooseBasis ℤ S\n  classical\n    induction' i with i ih\n    · simp\n    letI := ideal.fintype_quotient_of_free_of_ne_bot (P ^ i.succ) (pow_ne_zero _ hP)\n    letI := ideal.fintype_quotient_of_free_of_ne_bot (P ^ i) (pow_ne_zero _ hP)\n    letI := ideal.fintype_quotient_of_free_of_ne_bot P hP\n    have : P ^ (i + 1) < P ^ i := ideal.pow_succ_lt_pow hP i\n    suffices hquot : «expr ≃ » (map (P ^ i.succ).mkq (P ^ i)) («expr ⧸ » S P)\n    · rw [pow_succ (card_quot P), ← ih, card_quot_apply (P ^ i.succ), ←\n        card_quotient_mul_card_quotient (P ^ i) (P ^ i.succ) this.le, card_quot_apply (P ^ i), card_quot_apply P]\n      congr 1\n      rw [Fintype.card_eq]\n      exact ⟨hquot⟩\n    choose a a_mem a_not_mem using SetLike.exists_of_lt this\n    choose f g hg hf using fun c (hc : c ∈ P ^ i) => ideal.exists_mul_add_mem_pow_succ hP a c a_mem a_not_mem hc\n    choose k hk_mem hk_eq using fun c' (hc' : c' ∈ map (mkq (P ^ i.succ)) (P ^ i)) => submodule.mem_map.mp hc'\n    refine' Equiv.ofBijective (fun c' => Quotient.mk'' (f (k c' c'.prop) (hk_mem c' c'.prop))) ⟨_, _⟩\n    · rintro ⟨c₁', hc₁'⟩ ⟨c₂', hc₂'⟩ h\n      rw [Subtype.mk_eq_mk, ← hk_eq _ hc₁', ← hk_eq _ hc₂', mkq_apply, mkq_apply, Submodule.Quotient.eq, ←\n        hf _ (hk_mem _ hc₁'), ← hf _ (hk_mem _ hc₂')]\n      refine' ideal.mul_add_mem_pow_succ_inj _ _ _ _ _ _ a_mem (hg _ _) (hg _ _) _\n      simpa only [Submodule.Quotient.mk''_eq_mk, Submodule.Quotient.mk''_eq_mk, Submodule.Quotient.eq] using h\n    · intro d'\n      refine' Quotient.inductionOn' d' fun d => _\n      have hd' := mem_map.mpr ⟨a * d, Ideal.mul_mem_right d _ a_mem, rfl⟩\n      refine' ⟨⟨_, hd'⟩, _⟩\n      simp only [Submodule.Quotient.mk''_eq_mk, Ideal.Quotient.mk_eq_mk, Ideal.Quotient.eq, Subtype.coe_mk]\n      refine' ideal.mul_add_mem_pow_succ_unique hP a _ _ _ _ a_not_mem (hg _ (hk_mem _ hd')) (zero_mem _) _\n      rw [hf, add_zero]\n      exact (Submodule.Quotient.eq _).mp (hk_eq _ hd')\n#align card_quot_pow_of_prime card_quot_pow_of_prime\n\n",
 "card_quot_mul_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Multiplicity of the ideal norm, for coprime ideals.\nThis is essentially just a repackaging of the Chinese Remainder Theorem.\n-/\ntheorem card_quot_mul_of_coprime [is_dedekind_domain S] [Module.Free ℤ S] [Module.Finite ℤ S] {I J : Ideal S}\n    (coprime : «expr ⊔ » I J = «expr⊤») : card_quot (I * J) = card_quot I * card_quot J :=\n  by\n  let b := Module.Free.chooseBasis ℤ S\n  cases isEmpty_or_nonempty (Module.Free.ChooseBasisIndex ℤ S)\n  · haveI : subsingleton S := Function.Surjective.subsingleton b.repr.to_equiv.symm.surjective\n    nontriviality S\n    exfalso\n    exact not_nontrivial_iff_subsingleton.mpr ‹subsingleton S› ‹Nontrivial S›\n  haveI : Infinite S := Infinite.of_surjective _ b.repr.to_equiv.surjective\n  by_cases hI : I = «expr⊥»\n  · rw [hI, Submodule.bot_mul, card_quot_bot, MulZeroClass.zero_mul]\n  by_cases hJ : J = «expr⊥»\n  · rw [hJ, Submodule.mul_bot, card_quot_bot, MulZeroClass.mul_zero]\n  have hIJ : I * J ≠ «expr⊥» := mt ideal.mul_eq_bot.mp (not_or_of_not hI hJ)\n  letI := Classical.decEq (Module.Free.ChooseBasisIndex ℤ S)\n  letI := I.fintype_quotient_of_free_of_ne_bot hI\n  letI := J.fintype_quotient_of_free_of_ne_bot hJ\n  letI := (I * J).fintype_quotient_of_free_of_ne_bot hIJ\n  rw [card_quot_apply, card_quot_apply, card_quot_apply,\n    fintype.card_eq.mpr ⟨(ideal.quotient_mul_equiv_quotient_prod I J coprime).to_equiv⟩, Fintype.card_prod]\n#align card_quot_mul_of_coprime card_quot_mul_of_coprime\n\n",
 "card_quot_mul":
 "/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem card_quot_mul [is_dedekind_domain S] [Module.Free ℤ S] [Module.Finite ℤ S] (I J : Ideal S) :\n    card_quot (I * J) = card_quot I * card_quot J :=\n  by\n  let b := Module.Free.chooseBasis ℤ S\n  cases isEmpty_or_nonempty (Module.Free.ChooseBasisIndex ℤ S)\n  · haveI : subsingleton S := Function.Surjective.subsingleton b.repr.to_equiv.symm.surjective\n    nontriviality S\n    exfalso\n    exact not_nontrivial_iff_subsingleton.mpr ‹subsingleton S› ‹Nontrivial S›\n  haveI : Infinite S := Infinite.of_surjective _ b.repr.to_equiv.surjective\n  exact\n    UniqueFactorizationMonoid.multiplicative_of_coprime card_quot I J (card_quot_bot _ _)\n      (fun I J hI => by simp [ideal.is_unit_iff.mp hI, Ideal.mul_top])\n      (fun I i hI =>\n        have : Ideal.IsPrime I := ideal.is_prime_of_prime hI\n        card_quot_pow_of_prime hI.ne_zero)\n      fun I J hIJ =>\n      card_quot_mul_of_coprime\n        (ideal.is_unit_iff.mp (hIJ _ (ideal.dvd_iff_le.mpr le_sup_left) (ideal.dvd_iff_le.mpr le_sup_right)))\n#align card_quot_mul card_quot_mul\n\n",
 "card_quot_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem card_quot_eq_one_iff {P : Submodule R M} : card_quot P = 1 ↔ P = «expr⊤» :=\n  AddSubgroup.index_eq_one.trans (by simp [SetLike.ext_iff])\n#align card_quot_eq_one_iff card_quot_eq_one_iff\n\n",
 "card_quot_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem card_quot_bot [Infinite M] : card_quot («expr⊥» : Submodule R M) = 0 :=\n  AddSubgroup.index_bot.trans Nat.card_eq_zero_of_infinite\n#align card_quot_bot card_quot_bot\n\n",
 "card_quot_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-\nCopyright (c) 2022 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen, Alex J. Best\n-/\n@[simp]\ntheorem card_quot_apply (S : Submodule R M) [Fintype («expr ⧸ » M S)] : card_quot S = Fintype.card («expr ⧸ » M S) :=\n  AddSubgroup.index_eq_card _\n#align card_quot_apply card_quot_apply\n\n",
 "abs_norm_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem abs_norm_top : abs_norm («expr⊤» : Ideal S) = 1 := by rw [← Ideal.one_eq_top, _root_.map_one]\n#align abs_norm_top abs_norm_top\n\n",
 "abs_norm_span_singleton":
 "@[simp]\ntheorem abs_norm_span_singleton (r : S) : abs_norm (span ({r} : Set S)) = (algebra.norm ℤ r).nat_abs :=\n  by\n  rw [algebra.norm_apply]\n  by_cases hr : r = 0\n  ·\n    simp only [hr, Ideal.span_zero, Algebra.coe_lmul_eq_mul, eq_self_iff_true, ideal.abs_norm_bot, LinearMap.det_zero'',\n      Set.singleton_zero, _root_.map_zero, Int.natAbs_zero]\n  letI := ideal.fintype_quotient_of_free_of_ne_bot (span {r}) (mt span_singleton_eq_bot.mp hr)\n  let b := Module.Free.chooseBasis ℤ S\n  rw [← nat_abs_det_equiv _ (b.equiv (basis_span_singleton b hr) (Equiv.refl _))]\n  swap; infer_instance\n  congr\n  refine' b.ext fun i => _\n  simp\n#align abs_norm_span_singleton abs_norm_span_singleton\n\n",
 "abs_norm_span_insert":
 "@[simp]\ntheorem abs_norm_span_insert (r : S) (s : Set S) :\n    abs_norm (span (insert r s)) ∣ gcd (abs_norm (span s)) (algebra.norm ℤ r).nat_abs :=\n  (dvd_gcd_iff _ _ _).mpr\n    ⟨abs_norm_dvd_abs_norm_of_le (span_mono (Set.subset_insert _ _)),\n      trans (abs_norm_dvd_abs_norm_of_le (span_mono (Set.singleton_subset_iff.mpr (Set.mem_insert _ _))))\n        (by rw [abs_norm_span_singleton])⟩\n#align abs_norm_span_insert abs_norm_span_insert\n\n",
 "abs_norm_ne_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem abs_norm_ne_zero_iff (I : Ideal S) : ideal.abs_norm I ≠ 0 ↔ Finite («expr ⧸ » S I) :=\n  ⟨fun h => Nat.finite_of_card_ne_zero h, fun h => (@AddSubgroup.finiteIndex_of_finite_quotient _ _ _ h).finite_index⟩\n#align abs_norm_ne_zero_iff abs_norm_ne_zero_iff\n\n",
 "abs_norm_mem":
 "theorem abs_norm_mem (I : Ideal S) : ↑I.abs_norm ∈ I := by\n  rw [abs_norm_apply, card_quot, ← Ideal.Quotient.eq_zero_iff_mem, map_natCast, quotient.index_eq_zero]\n#align abs_norm_mem abs_norm_mem\n\n",
 "abs_norm_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem abs_norm_eq_one_iff {I : Ideal S} : abs_norm I = 1 ↔ I = «expr⊤» := by rw [abs_norm_apply, card_quot_eq_one_iff]\n#align abs_norm_eq_one_iff abs_norm_eq_one_iff\n\n",
 "abs_norm_dvd_norm_of_mem":
 "theorem abs_norm_dvd_norm_of_mem {I : Ideal S} {x : S} (h : x ∈ I) : ↑I.abs_norm ∣ algebra.norm ℤ x :=\n  by\n  rw [← Int.dvd_natAbs, ← abs_norm_span_singleton x, Int.coe_nat_dvd]\n  exact abs_norm_dvd_abs_norm_of_le ((span_singleton_le_iff_mem _).mpr h)\n#align abs_norm_dvd_norm_of_mem abs_norm_dvd_norm_of_mem\n\n",
 "abs_norm_dvd_abs_norm_of_le":
 "theorem abs_norm_dvd_abs_norm_of_le {I J : Ideal S} (h : J ≤ I) : I.abs_norm ∣ J.abs_norm :=\n  map_dvd abs_norm (dvd_iff_le.mpr h)\n#align abs_norm_dvd_abs_norm_of_le abs_norm_dvd_abs_norm_of_le\n\n",
 "abs_norm_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem abs_norm_bot : abs_norm («expr⊥» : Ideal S) = 0 := by rw [← Ideal.zero_eq_bot, _root_.map_zero]\n#align abs_norm_bot abs_norm_bot\n\n",
 "abs_norm_apply":
 "theorem abs_norm_apply (I : Ideal S) : abs_norm I = card_quot I :=\n  rfl\n#align abs_norm_apply abs_norm_apply\n\n"}