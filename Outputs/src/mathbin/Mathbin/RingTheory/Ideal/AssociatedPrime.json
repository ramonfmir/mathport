{"subset_of_injective":
 "#print associatedPrimes.subset_of_injective /-\ntheorem associatedPrimes.subset_of_injective (hf : function.injective f) :\n    associatedPrimes R M ⊆ associatedPrimes R M' := fun I h => h.map_of_injective f hf\n#align associated_primes.subset_of_injective associatedPrimes.subset_of_injective\n-/\n\n",
 "not_isAssociatedPrime_of_subsingleton":
 "#print not_isAssociatedPrime_of_subsingleton /-\ntheorem not_isAssociatedPrime_of_subsingleton [subsingleton M] : ¬IsAssociatedPrime I M :=\n  by\n  rintro ⟨hI, x, hx⟩\n  apply hI.ne_top\n  rwa [subsingleton.elim x 0, submodule.span_singleton_eq_bot.mpr rfl, Submodule.annihilator_bot] at hx\n#align not_is_associated_prime_of_subsingleton not_isAssociatedPrime_of_subsingleton\n-/\n\n",
 "nonempty":
 "#print associatedPrimes.nonempty /-\ntheorem associatedPrimes.nonempty [IsNoetherianRing R] [Nontrivial M] : (associatedPrimes R M).nonempty :=\n  by\n  obtain ⟨x, hx⟩ := exists_ne (0 : M)\n  obtain ⟨P, hP, _⟩ := exists_le_isAssociatedPrime_of_isNoetherianRing R x hx\n  exact ⟨P, hP⟩\n#align associated_primes.nonempty associatedPrimes.nonempty\n-/\n\n",
 "mem_iff":
 "#print AssociatePrimes.mem_iff /-\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem AssociatePrimes.mem_iff : I ∈ associatedPrimes R M ↔ IsAssociatedPrime I M :=\n  iff.rfl\n#align associate_primes.mem_iff AssociatePrimes.mem_iff\n-/\n\n",
 "map_of_injective":
 "#print IsAssociatedPrime.map_of_injective /-\ntheorem IsAssociatedPrime.map_of_injective (h : IsAssociatedPrime I M) (hf : function.injective f) :\n    IsAssociatedPrime I M' := by\n  obtain ⟨x, rfl⟩ := h.2\n  refine' ⟨h.1, ⟨f x, _⟩⟩\n  ext r\n  rw [Submodule.mem_annihilator_span_singleton, Submodule.mem_annihilator_span_singleton, ← map_smul, ← f.map_zero,\n    hf.eq_iff]\n#align is_associated_prime.map_of_injective IsAssociatedPrime.map_of_injective\n-/\n\n",
 "isPrime":
 "#print IsAssociatedPrime.isPrime /-\ntheorem IsAssociatedPrime.isPrime : I.is_prime :=\n  h.1\n#align is_associated_prime.is_prime IsAssociatedPrime.isPrime\n-/\n\n",
 "isAssociatedPrime_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print LinearEquiv.isAssociatedPrime_iff /-\ntheorem LinearEquiv.isAssociatedPrime_iff (l : «expr ≃ₗ[ ] » M R M') : IsAssociatedPrime I M ↔ IsAssociatedPrime I M' :=\n  ⟨fun h => h.map_of_injective l l.injective, fun h => h.map_of_injective l.symm l.symm.injective⟩\n#align linear_equiv.is_associated_prime_iff LinearEquiv.isAssociatedPrime_iff\n-/\n\n",
 "exists_le_isAssociatedPrime_of_isNoetherianRing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n#print exists_le_isAssociatedPrime_of_isNoetherianRing /-\ntheorem exists_le_isAssociatedPrime_of_isNoetherianRing [H : IsNoetherianRing R] (x : M) (hx : x ≠ 0) :\n    ∃ P : Ideal R, IsAssociatedPrime P M ∧ («expr ∙ » R x).annihilator ≤ P :=\n  by\n  have : («expr ∙ » R x).annihilator ≠ «expr⊤» := by\n    rwa [ne.def, Ideal.eq_top_iff_one, Submodule.mem_annihilator_span_singleton, one_smul]\n  obtain ⟨P, ⟨l, h₁, y, rfl⟩, h₃⟩ :=\n    set_has_maximal_iff_noetherian.mpr H\n      { P | («expr ∙ » R x).annihilator ≤ P ∧ P ≠ «expr⊤» ∧ ∃ y : M, P = («expr ∙ » R y).annihilator }\n      ⟨(«expr ∙ » R x).annihilator, rfl.le, this, x, rfl⟩\n  refine' ⟨_, ⟨⟨h₁, _⟩, y, rfl⟩, l⟩\n  intro a b hab\n  rw [or_iff_not_imp_left]\n  intro ha\n  rw [Submodule.mem_annihilator_span_singleton] at ha hab\n  have H₁ : («expr ∙ » R y).annihilator ≤ («expr ∙ » R («expr • » a y)).annihilator :=\n    by\n    intro c hc\n    rw [Submodule.mem_annihilator_span_singleton] at hc⊢\n    rw [smul_comm, hc, smul_zero]\n  have H₂ : (Submodule.span R {«expr • » a y}).annihilator ≠ «expr⊤» := by\n    rwa [ne.def, Submodule.annihilator_eq_top_iff, Submodule.span_singleton_eq_bot]\n  rwa [H₁.eq_of_not_lt (h₃ («expr ∙ » R («expr • » a y)).annihilator ⟨l.trans H₁, H₂, _, rfl⟩),\n    Submodule.mem_annihilator_span_singleton, smul_comm, smul_smul]\n#align exists_le_is_associated_prime_of_is_noetherian_ring exists_le_isAssociatedPrime_of_isNoetherianRing\n-/\n\n",
 "eq_singleton_of_isPrimary":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print associatedPrimes.eq_singleton_of_isPrimary /-\ntheorem associatedPrimes.eq_singleton_of_isPrimary [IsNoetherianRing R] (hI : I.is_primary) :\n    associatedPrimes R («expr ⧸ » R I) = {I.radical} := by\n  ext J\n  rw [Set.mem_singleton_iff]\n  refine' ⟨IsAssociatedPrime.eq_radical hI, _⟩\n  rintro rfl\n  haveI : Nontrivial («expr ⧸ » R I) := ⟨⟨(I.quotient.mk : _) 1, (I.quotient.mk : _) 0, _⟩⟩\n  obtain ⟨a, ha⟩ := associatedPrimes.nonempty R («expr ⧸ » R I)\n  exact ha.eq_radical hI ▸ ha\n  rw [ne.def, Ideal.Quotient.eq, sub_zero, ← Ideal.eq_top_iff_one]\n  exact hI.1\n#align associated_primes.eq_singleton_of_is_primary associatedPrimes.eq_singleton_of_isPrimary\n-/\n\n",
 "eq_radical":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print IsAssociatedPrime.eq_radical /-\ntheorem IsAssociatedPrime.eq_radical (hI : I.is_primary) (h : IsAssociatedPrime J («expr ⧸ » R I)) : J = I.radical :=\n  by\n  obtain ⟨hJ, x, e⟩ := h\n  have : x ≠ 0 := by\n    rintro rfl\n    apply hJ.1\n    rwa [submodule.span_singleton_eq_bot.mpr rfl, Submodule.annihilator_bot] at e\n  obtain ⟨x, rfl⟩ := Ideal.Quotient.mkₐ_surjective R _ x\n  replace e : ∀ {y}, y ∈ J ↔ x * y ∈ I\n  · intro y\n    rw [e, Submodule.mem_annihilator_span_singleton, ← map_smul, smul_eq_mul, mul_comm, Ideal.Quotient.mkₐ_eq_mk, ←\n      Ideal.Quotient.mk_eq_mk, Submodule.Quotient.mk_eq_zero]\n  apply le_antisymm\n  · intro y hy\n    exact (hI.2 <| e.mp hy).resolve_left ((Submodule.Quotient.mk_eq_zero I).not.mp this)\n  · rw [hJ.radical_le_iff]\n    intro y hy\n    exact e.mpr (I.mul_mem_left x hy)\n#align is_associated_prime.eq_radical IsAssociatedPrime.eq_radical\n-/\n\n",
 "eq_empty_of_subsingleton":
 "#print associatedPrimes.eq_empty_of_subsingleton /-\ntheorem associatedPrimes.eq_empty_of_subsingleton [subsingleton M] : associatedPrimes R M = ∅ := by ext;\n  simp only [Set.mem_empty_iff_false, iff_false_iff]; apply not_isAssociatedPrime_of_subsingleton\n#align associated_primes.eq_empty_of_subsingleton associatedPrimes.eq_empty_of_subsingleton\n-/\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print LinearEquiv.AssociatedPrimes.eq /-\ntheorem LinearEquiv.AssociatedPrimes.eq (l : «expr ≃ₗ[ ] » M R M') : associatedPrimes R M = associatedPrimes R M' :=\n  le_antisymm (associatedPrimes.subset_of_injective l l.injective)\n    (associatedPrimes.subset_of_injective l.symm l.symm.injective)\n#align linear_equiv.associated_primes.eq LinearEquiv.AssociatedPrimes.eq\n-/\n\n",
 "annihilator_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print IsAssociatedPrime.annihilator_le /-\ntheorem IsAssociatedPrime.annihilator_le (h : IsAssociatedPrime I M) : («expr⊤» : Submodule R M).annihilator ≤ I :=\n  by\n  obtain ⟨hI, x, rfl⟩ := h\n  exact Submodule.annihilator_mono le_top\n#align is_associated_prime.annihilator_le IsAssociatedPrime.annihilator_le\n-/\n\n"}