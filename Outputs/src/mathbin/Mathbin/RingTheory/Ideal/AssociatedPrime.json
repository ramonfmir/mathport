{"subset_of_injective":
 "theorem associated_primes.subset_of_injective (hf : function.injective f) :\n    associated_primes R M ⊆ associated_primes R M' := fun I h => h.map_of_injective f hf\n#align associated_primes.subset_of_injective associated_primes.subset_of_injective\n\n",
 "not_is_associated_prime_of_subsingleton":
 "theorem not_is_associated_prime_of_subsingleton [subsingleton M] : ¬is_associated_prime I M :=\n  by\n  rintro ⟨hI, x, hx⟩\n  apply hI.ne_top\n  rwa [subsingleton.elim x 0, submodule.span_singleton_eq_bot.mpr rfl, submodule.annihilator_bot] at hx\n#align not_is_associated_prime_of_subsingleton not_is_associated_prime_of_subsingleton\n\n",
 "nonempty":
 "theorem associated_primes.nonempty [is_noetherian_ring R] [nontrivial M] : (associated_primes R M).nonempty :=\n  by\n  obtain ⟨x, hx⟩ := exists_ne (0 : M)\n  obtain ⟨P, hP, _⟩ := exists_le_is_associated_prime_of_is_noetherian_ring R x hx\n  exact ⟨P, hP⟩\n#align associated_primes.nonempty associated_primes.nonempty\n\n",
 "mem_iff":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem associate_primes.mem_iff : I ∈ associated_primes R M ↔ is_associated_prime I M :=\n  iff.rfl\n#align associate_primes.mem_iff associate_primes.mem_iff\n\n",
 "map_of_injective":
 "theorem is_associated_prime.map_of_injective (h : is_associated_prime I M) (hf : function.injective f) :\n    is_associated_prime I M' := by\n  obtain ⟨x, rfl⟩ := h.2\n  refine' ⟨h.1, ⟨f x, _⟩⟩\n  ext r\n  rw [submodule.mem_annihilator_span_singleton, submodule.mem_annihilator_span_singleton, ← map_smul, ← f.map_zero,\n    hf.eq_iff]\n#align is_associated_prime.map_of_injective is_associated_prime.map_of_injective\n\n",
 "is_prime":
 "theorem is_associated_prime.is_prime : I.is_prime :=\n  h.1\n#align is_associated_prime.is_prime is_associated_prime.is_prime\n\n",
 "is_associated_prime_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem linear_equiv.is_associated_prime_iff (l : «expr ≃ₗ[ ] » M R M') :\n    is_associated_prime I M ↔ is_associated_prime I M' :=\n  ⟨fun h => h.map_of_injective l l.injective, fun h => h.map_of_injective l.symm l.symm.injective⟩\n#align linear_equiv.is_associated_prime_iff linear_equiv.is_associated_prime_iff\n\n",
 "exists_le_is_associated_prime_of_is_noetherian_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem exists_le_is_associated_prime_of_is_noetherian_ring [H : is_noetherian_ring R] (x : M) (hx : x ≠ 0) :\n    ∃ P : ideal R, is_associated_prime P M ∧ («expr ∙ » R x).annihilator ≤ P :=\n  by\n  have : («expr ∙ » R x).annihilator ≠ «expr⊤» := by\n    rwa [ne.def, ideal.eq_top_iff_one, submodule.mem_annihilator_span_singleton, one_smul]\n  obtain ⟨P, ⟨l, h₁, y, rfl⟩, h₃⟩ :=\n    set_has_maximal_iff_noetherian.mpr H\n      { P | («expr ∙ » R x).annihilator ≤ P ∧ P ≠ «expr⊤» ∧ ∃ y : M, P = («expr ∙ » R y).annihilator }\n      ⟨(«expr ∙ » R x).annihilator, rfl.le, this, x, rfl⟩\n  refine' ⟨_, ⟨⟨h₁, _⟩, y, rfl⟩, l⟩\n  intro a b hab\n  rw [or_iff_not_imp_left]\n  intro ha\n  rw [submodule.mem_annihilator_span_singleton] at ha hab\n  have H₁ : («expr ∙ » R y).annihilator ≤ («expr ∙ » R («expr • » a y)).annihilator :=\n    by\n    intro c hc\n    rw [submodule.mem_annihilator_span_singleton] at hc⊢\n    rw [smul_comm, hc, smul_zero]\n  have H₂ : (submodule.span R {«expr • » a y}).annihilator ≠ «expr⊤» := by\n    rwa [ne.def, submodule.annihilator_eq_top_iff, submodule.span_singleton_eq_bot]\n  rwa [← h₃ («expr ∙ » R («expr • » a y)).annihilator ⟨l.trans H₁, H₂, _, rfl⟩ H₁,\n    submodule.mem_annihilator_span_singleton, smul_comm, smul_smul]\n#align exists_le_is_associated_prime_of_is_noetherian_ring exists_le_is_associated_prime_of_is_noetherian_ring\n\n",
 "eq_singleton_of_is_primary":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem associated_primes.eq_singleton_of_is_primary [is_noetherian_ring R] (hI : I.is_primary) :\n    associated_primes R («expr ⧸ » R I) = {I.radical} := by\n  ext J\n  rw [Set.mem_singleton_iff]\n  refine' ⟨is_associated_prime.eq_radical hI, _⟩\n  rintro rfl\n  haveI : nontrivial («expr ⧸ » R I) := ⟨⟨(I : _) 1, (I : _) 0, _⟩⟩\n  obtain ⟨a, ha⟩ := associated_primes.nonempty R («expr ⧸ » R I)\n  exact ha.eq_radical hI ▸ ha\n  rw [ne.def, ideal.quotient.eq, sub_zero, ← ideal.eq_top_iff_one]\n  exact hI.1\n#align associated_primes.eq_singleton_of_is_primary associated_primes.eq_singleton_of_is_primary\n\n",
 "eq_radical":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem is_associated_prime.eq_radical (hI : I.is_primary) (h : is_associated_prime J («expr ⧸ » R I)) :\n    J = I.radical := by\n  obtain ⟨hJ, x, e⟩ := h\n  have : x ≠ 0 := by\n    rintro rfl\n    apply hJ.1\n    rwa [submodule.span_singleton_eq_bot.mpr rfl, submodule.annihilator_bot] at e\n  obtain ⟨x, rfl⟩ := ideal.quotient.mkₐ_surjective R _ x\n  replace e : ∀ {y}, y ∈ J ↔ x * y ∈ I\n  · intro y\n    rw [e, submodule.mem_annihilator_span_singleton, ← map_smul, smul_eq_mul, mul_comm, ideal.quotient.mkₐ_eq_mk, ←\n      ideal.quotient.mk_eq_mk, submodule.quotient.mk_eq_zero]\n  apply le_antisymm\n  · intro y hy\n    exact (hI.2 <| e.mp hy).resolve_left ((submodule.quotient.mk_eq_zero I).not.mp this)\n  · rw [hJ.radical_le_iff]\n    intro y hy\n    exact e.mpr (I.mul_mem_left x hy)\n#align is_associated_prime.eq_radical is_associated_prime.eq_radical\n\n",
 "eq_empty_of_subsingleton":
 "theorem associated_primes.eq_empty_of_subsingleton [subsingleton M] : associated_primes R M = ∅ := by ext;\n  simp only [Set.mem_empty_iff_false, iff_false_iff]; apply not_is_associated_prime_of_subsingleton\n#align associated_primes.eq_empty_of_subsingleton associated_primes.eq_empty_of_subsingleton\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem linear_equiv.associated_primes.eq (l : «expr ≃ₗ[ ] » M R M') : associated_primes R M = associated_primes R M' :=\n  le_antisymm (associated_primes.subset_of_injective l l.injective)\n    (associated_primes.subset_of_injective l.symm l.symm.injective)\n#align linear_equiv.associated_primes.eq linear_equiv.associated_primes.eq\n\n",
 "annihilator_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_associated_prime.annihilator_le (h : is_associated_prime I M) : («expr⊤» : submodule R M).annihilator ≤ I :=\n  by\n  obtain ⟨hI, x, rfl⟩ := h\n  exact submodule.annihilator_mono le_top\n#align is_associated_prime.annihilator_le is_associated_prime.annihilator_le\n\n"}