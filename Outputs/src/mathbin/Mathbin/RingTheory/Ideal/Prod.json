{"prod_top_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem prod_top_top : prod («expr⊤» : ideal R) («expr⊤» : ideal S) = «expr⊤» :=\n  ideal.ext <| by simp\n#align prod_top_top prod_top_top\n\n",
 "mem_prod":
 "/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\n@[simp]\ntheorem mem_prod {r : R} {s : S} : (⟨r, s⟩ : R × S) ∈ prod I J ↔ r ∈ I ∧ s ∈ J :=\n  iff.rfl\n#align mem_prod mem_prod\n\n",
 "map_snd_prod":
 "@[simp]\ntheorem map_snd_prod (I : ideal R) (J : ideal S) : map (RingHom.snd R S) (prod I J) = J :=\n  by\n  ext\n  rw [mem_map_iff_of_surjective (RingHom.snd R S) prod.snd_surjective]\n  exact\n    ⟨by\n      rintro ⟨x, ⟨h, rfl⟩⟩\n      exact h.2, fun h => ⟨⟨0, x⟩, ⟨⟨ideal.zero_mem _, h⟩, rfl⟩⟩⟩\n#align map_snd_prod map_snd_prod\n\n",
 "map_prod_comm_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map_prod_comm_prod :\n    map ((RingEquiv.prodComm : «expr ≃+* » (R × S) (S × R)) : «expr →+* » (R × S) (S × R)) (prod I J) = prod J I :=\n  by\n  refine' trans (ideal_prod_eq _) _\n  simp [map_map]\n#align map_prod_comm_prod map_prod_comm_prod\n\n",
 "map_fst_prod":
 "@[simp]\ntheorem map_fst_prod (I : ideal R) (J : ideal S) : map (RingHom.fst R S) (prod I J) = I :=\n  by\n  ext\n  rw [mem_map_iff_of_surjective (RingHom.fst R S) prod.fst_surjective]\n  exact\n    ⟨by\n      rintro ⟨x, ⟨h, rfl⟩⟩\n      exact h.1, fun h => ⟨⟨x, 0⟩, ⟨⟨h, ideal.zero_mem _⟩, rfl⟩⟩⟩\n#align map_fst_prod map_fst_prod\n\n",
 "is_prime_of_is_prime_prod_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_prime_of_is_prime_prod_top' {I : ideal S} (h : (ideal.prod («expr⊤» : ideal R) I).is_prime) : I.is_prime :=\n  by\n  apply @is_prime_of_is_prime_prod_top _ R\n  rw [← map_prod_comm_prod]\n  exact map_is_prime_of_equiv _\n#align is_prime_of_is_prime_prod_top' is_prime_of_is_prime_prod_top'\n\n",
 "is_prime_of_is_prime_prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_prime_of_is_prime_prod_top {I : ideal R} (h : (ideal.prod I («expr⊤» : ideal S)).is_prime) : I.is_prime :=\n  by\n  constructor\n  · contrapose! h\n    simp [is_prime_iff, h]\n  · intro x y hxy\n    have : (⟨x, 1⟩ : R × S) * ⟨y, 1⟩ ∈ Prod I («expr⊤») :=\n      by\n      rw [Prod.mk_mul_mk, mul_one, mem_prod]\n      exact ⟨hxy, trivial⟩\n    simpa using h.mem_or_mem this\n#align is_prime_of_is_prime_prod_top is_prime_of_is_prime_prod_top\n\n",
 "is_prime_ideal_prod_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_prime_ideal_prod_top' {I : ideal S} [h : I.is_prime] : (prod («expr⊤» : ideal R) I).is_prime :=\n  by\n  rw [← map_prod_comm_prod]\n  apply map_is_prime_of_equiv _\n  exact is_prime_ideal_prod_top\n#align is_prime_ideal_prod_top' is_prime_ideal_prod_top'\n\n",
 "is_prime_ideal_prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_prime_ideal_prod_top {I : ideal R} [h : I.is_prime] : (prod I («expr⊤» : ideal S)).is_prime :=\n  by\n  constructor\n  · rcases h with ⟨h, -⟩\n    contrapose! h\n    rw [← prod_top_top, prod.ext_iff] at h\n    exact h.1\n  rintro ⟨r₁, s₁⟩ ⟨r₂, s₂⟩ ⟨h₁, h₂⟩\n  cases' h.mem_or_mem h₁ with h h\n  · exact or.inl ⟨h, trivial⟩\n  · exact or.inr ⟨h, trivial⟩\n#align is_prime_ideal_prod_top is_prime_ideal_prod_top\n\n",
 "ideal_prod_prime_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ideal_prod_prime_aux {I : ideal R} {J : ideal S} : (ideal.prod I J).is_prime → I = «expr⊤» ∨ J = «expr⊤» :=\n  by\n  contrapose!\n  simp only [ne_top_iff_one, is_prime_iff, not_and, not_forall, not_or]\n  exact fun ⟨hI, hJ⟩ hIJ => ⟨⟨0, 1⟩, ⟨1, 0⟩, by simp, by simp [hJ], by simp [hI]⟩\n#align ideal_prod_prime_aux ideal_prod_prime_aux\n\n",
 "ideal_prod_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Classification of prime ideals in product rings: the prime ideals of `R × S` are precisely the\n    ideals of the form `p × S` or `R × p`, where `p` is a prime ideal of `R` or `S`. -/\ntheorem ideal_prod_prime (I : ideal (R × S)) :\n    I.is_prime ↔\n      (∃ p : ideal R, p.is_prime ∧ I = ideal.prod p («expr⊤»)) ∨\n        ∃ p : ideal S, p.is_prime ∧ I = ideal.prod («expr⊤») p :=\n  by\n  constructor\n  · rw [ideal_prod_eq I]\n    intro hI\n    rcases ideal_prod_prime_aux hI with (h | h)\n    · right\n      rw [h] at hI⊢\n      exact ⟨_, ⟨is_prime_of_is_prime_prod_top' hI, rfl⟩⟩\n    · left\n      rw [h] at hI⊢\n      exact ⟨_, ⟨is_prime_of_is_prime_prod_top hI, rfl⟩⟩\n  · rintro (⟨p, ⟨h, rfl⟩⟩ | ⟨p, ⟨h, rfl⟩⟩)\n    · exact is_prime_ideal_prod_top\n    · exact is_prime_ideal_prod_top'\n#align ideal_prod_prime ideal_prod_prime\n\n",
 "ideal_prod_equiv_symm_apply":
 "@[simp]\ntheorem ideal_prod_equiv_symm_apply (I : ideal R) (J : ideal S) : ideal_prod_equiv.symm ⟨I, J⟩ = prod I J :=\n  rfl\n#align ideal_prod_equiv_symm_apply ideal_prod_equiv_symm_apply\n\n",
 "ideal_prod_eq":
 "/-- Every ideal of the product ring is of the form `I × J`, where `I` and `J` can be explicitly\n    given as the image under the projection maps. -/\ntheorem ideal_prod_eq (I : ideal (R × S)) : I = ideal.prod (map (RingHom.fst R S) I) (map (RingHom.snd R S) I) :=\n  by\n  apply ideal.ext\n  rintro ⟨r, s⟩\n  rw [mem_prod, mem_map_iff_of_surjective (RingHom.fst R S) prod.fst_surjective,\n    mem_map_iff_of_surjective (RingHom.snd R S) prod.snd_surjective]\n  refine' ⟨fun h => ⟨⟨_, ⟨h, rfl⟩⟩, ⟨_, ⟨h, rfl⟩⟩⟩, _⟩\n  rintro ⟨⟨⟨r, s'⟩, ⟨h₁, rfl⟩⟩, ⟨⟨r', s⟩, ⟨h₂, rfl⟩⟩⟩\n  simpa using I.add_mem (I.mul_mem_left (1, 0) h₁) (I.mul_mem_left (0, 1) h₂)\n#align ideal_prod_eq ideal_prod_eq\n\n",
 "ext_iff":
 "theorem prod.ext_iff {I I' : ideal R} {J J' : ideal S} : prod I J = prod I' J' ↔ I = I' ∧ J = J' := by\n  simp only [← ideal_prod_equiv_symm_apply, ideal_prod_equiv.symm.injective.eq_iff, prod.mk.inj_iff]\n#align prod.ext_iff prod.ext_iff\n\n"}