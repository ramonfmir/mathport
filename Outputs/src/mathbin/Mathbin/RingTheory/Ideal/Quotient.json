{"zero_ne_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem zero_ne_one_iff {I : Ideal R} : (0 : «expr ⧸ » R I) ≠ 1 ↔ I ≠ «expr⊤» :=\n  not_congr zero_eq_one_iff\n#align zero_ne_one_iff zero_ne_one_iff\n\n",
 "zero_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem zero_eq_one_iff {I : Ideal R} : (0 : «expr ⧸ » R I) = 1 ↔ I = «expr⊤» :=\n  eq_comm.trans <| eq_zero_iff_mem.trans (eq_top_iff_one _).symm\n#align zero_eq_one_iff zero_eq_one_iff\n\n",
 "subsingleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print subsingleton_iff /-\ntheorem subsingleton_iff {I : Ideal R} : subsingleton («expr ⧸ » R I) ↔ I = «expr⊤» := by\n  rw [eq_top_iff_one, ← subsingleton_iff_zero_eq_one, eq_comm, ← I.quotient.mk.map_one, quotient.eq_zero_iff_mem]\n#align subsingleton_iff subsingleton_iff\n-/\n\n",
 "snd_comp_quotient_inf_equiv_quotient_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem snd_comp_quotient_inf_equiv_quotient_prod (I J : Ideal R) (coprime : «expr ⊔ » I J = «expr⊤») :\n    (RingHom.snd _ _).comp\n        (quotientInfEquivQuotientProd I J coprime :\n          «expr →+* » («expr ⧸ » R («expr ⊓ » I J)) («expr ⧸ » R I × «expr ⧸ » R J)) =\n      Ideal.Quotient.factor («expr ⊓ » I J) J inf_le_right :=\n  by ext <;> rfl\n#align snd_comp_quotient_inf_equiv_quotient_prod snd_comp_quotient_inf_equiv_quotient_prod\n\n",
 "ring_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes, Mario Carneiro, Anne Baanen\n-/\n-- Note that at present `ideal` means a left-ideal,\n-- so this quotient is only useful in a commutative ring.\n-- We should develop quotients by two-sided ideals as well.\n-- to help with unification\n-- this instance is harder to find than the one via `algebra α (R ⧸ I)`, so use a lower priority\n/- Two `ring_homs`s from the quotient by an ideal are equal if their\ncompositions with `ideal.quotient.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem ring_hom_ext [NonAssocSemiring S] ⦃f g : «expr →+* » («expr ⧸ » R I) S⦄ (h : f.comp (mk I) = g.comp (mk I)) :\n    f = g :=\n  RingHom.ext fun x => Quotient.inductionOn' x <| (RingHom.congr_fun h : _)\n#align ring_hom_ext ring_hom_ext\n\n",
 "quotient_ring_saturate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If `I` is an ideal of a commutative ring `R`, if `q : R → R/I` is the quotient map, and if\n`s ⊆ R` is a subset, then `q⁻¹(q(s)) = ⋃ᵢ(i + s)`, the union running over all `i ∈ I`. -/\ntheorem quotient_ring_saturate (I : Ideal R) (s : Set R) :\n    «expr ⁻¹' » (mk I) («expr '' » (mk I) s) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » (fun y => x.1 + y) s) :=\n  by\n  ext x\n  simp only [mem_preimage, mem_image, mem_Union, Ideal.Quotient.eq]\n  exact\n    ⟨fun ⟨a, a_in, h⟩ => ⟨⟨_, I.neg_mem h⟩, a, a_in, by simp⟩, fun ⟨⟨i, hi⟩, a, ha, Eq⟩ =>\n      ⟨a, ha, by rw [← Eq, sub_add_eq_sub_sub_swap, sub_self, zero_sub] <;> exact I.neg_mem hi⟩⟩\n#align quotient_ring_saturate quotient_ring_saturate\n\n",
 "quotient_inf_to_pi_quotient_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem quotient_inf_to_pi_quotient_bijective [Finite ι] {f : ι → Ideal R}\n    (hf : ∀ i j, i ≠ j → «expr ⊔ » (f i) (f j) = «expr⊤») : function.bijective (quotientInfToPiQuotient f) :=\n  ⟨fun x y =>\n    Quotient.inductionOn₂' x y fun r s hrs =>\n      Quotient.eq.2 <|\n        (Submodule.mem_infᵢ _).2 fun i =>\n          Quotient.eq.1 <| show quotientInfToPiQuotient f (Quotient.mk'' r) i = _ by rw [hrs] <;> rfl,\n    fun g =>\n    let ⟨r, hr⟩ := exists_sub_mem hf fun i => Quotient.out' (g i)\n    ⟨Quotient.mk _ r, funext fun i => Quotient.out_eq' (g i) ▸ Quotient.eq.2 (hr i)⟩⟩\n#align quotient_inf_to_pi_quotient_bijective quotient_inf_to_pi_quotient_bijective\n\n",
 "quotient_inf_equiv_quotient_prod_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem quotient_inf_equiv_quotient_prod_snd (I J : Ideal R) (coprime : «expr ⊔ » I J = «expr⊤»)\n    (x : «expr ⧸ » R («expr ⊓ » I J)) :\n    (quotientInfEquivQuotientProd I J coprime x).snd = Ideal.Quotient.factor («expr ⊓ » I J) J inf_le_right x :=\n  Quot.inductionOn x fun x => rfl\n#align quotient_inf_equiv_quotient_prod_snd quotient_inf_equiv_quotient_prod_snd\n\n",
 "quotient_inf_equiv_quotient_prod_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem quotient_inf_equiv_quotient_prod_fst (I J : Ideal R) (coprime : «expr ⊔ » I J = «expr⊤»)\n    (x : «expr ⧸ » R («expr ⊓ » I J)) :\n    (quotientInfEquivQuotientProd I J coprime x).fst = Ideal.Quotient.factor («expr ⊓ » I J) I inf_le_left x :=\n  Quot.inductionOn x fun x => rfl\n#align quotient_inf_equiv_quotient_prod_fst quotient_inf_equiv_quotient_prod_fst\n\n",
 "quot_equiv_of_eq_symm":
 "@[simp]\ntheorem quot_equiv_of_eq_symm {R : Type _} [CommRing R] {I J : Ideal R} (h : I = J) :\n    (Ideal.quotEquivOfEq h).symm = Ideal.quotEquivOfEq h.symm := by ext <;> rfl\n#align quot_equiv_of_eq_symm quot_equiv_of_eq_symm\n\n",
 "quot_equiv_of_eq_mk":
 "@[simp]\ntheorem quot_equiv_of_eq_mk {R : Type _} [CommRing R] {I J : Ideal R} (h : I = J) (x : R) :\n    quotEquivOfEq h (Ideal.Quotient.mk I x) = Ideal.Quotient.mk J x :=\n  rfl\n#align quot_equiv_of_eq_mk quot_equiv_of_eq_mk\n\n",
 "mk_surjective":
 "theorem mk_surjective : function.surjective (mk I) := fun y => Quotient.inductionOn' y fun x => exists.intro x rfl\n#align mk_surjective mk_surjective\n\n",
 "mk_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp]\ntheorem mk_eq_mk (x : R) : (Submodule.Quotient.mk x : «expr ⧸ » R I) = mk I x :=\n  rfl\n#align mk_eq_mk mk_eq_mk\n\n",
 "maximal_of_is_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem maximal_of_is_field (I : Ideal R) (hqf : IsField («expr ⧸ » R I)) : I.is_maximal :=\n  by\n  apply Ideal.isMaximal_iff.2\n  constructor\n  · intro h\n    rcases hqf.exists_pair_ne with ⟨⟨x⟩, ⟨y⟩, hxy⟩\n    exact hxy (Ideal.Quotient.eq.2 (mul_one (x - y) ▸ I.mul_mem_left _ h))\n  · intro J x hIJ hxnI hxJ\n    rcases hqf.mul_inv_cancel (mt Ideal.Quotient.eq_zero_iff_mem.1 hxnI) with ⟨⟨y⟩, hy⟩\n    rw [← zero_add (1 : R), ← sub_self (x * y), sub_add]\n    refine' J.sub_mem (J.mul_mem_right _ hxJ) (hIJ (Ideal.Quotient.eq.1 hy))\n#align maximal_of_is_field maximal_of_is_field\n\n",
 "maximal_ideal_iff_is_field_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem maximal_ideal_iff_is_field_quotient (I : Ideal R) : I.is_maximal ↔ IsField («expr ⧸ » R I) :=\n  ⟨fun h =>\n    letI := @quotient.field _ _ I h\n    Field.toIsField _,\n    maximal_of_isField _⟩\n#align maximal_ideal_iff_is_field_quotient maximal_ideal_iff_is_field_quotient\n\n",
 "map_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If `f : R^n → R^m` is an `R`-linear map and `I ⊆ R` is an ideal, then the image of `I^n` is\n    contained in `I^m`. -/\ntheorem map_pi {ι : Type _} [Finite ι] {ι' : Type w} (x : ι → R) (hi : ∀ i, x i ∈ I)\n    (f : «expr →ₗ[ ] » (ι → R) R (ι' → R)) (i : ι') : f x i ∈ I := by\n  classical\n    cases nonempty_fintype ι\n    rw [pi_eq_sum_univ x]\n    simp only [Finset.sum_apply, smul_eq_mul, LinearMap.map_sum, Pi.smul_apply, LinearMap.map_smul]\n    exact I.sum_mem fun j hj => I.mul_mem_right _ (hi j)\n#align map_pi map_pi\n\n",
 "lift_surjective_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem lift_surjective_of_surjective (I : Ideal R) {f : «expr →+* » R S} (H : ∀ a : R, a ∈ I → f a = 0)\n    (hf : function.surjective f) : function.surjective (Ideal.Quotient.lift I f H) :=\n  by\n  intro y\n  obtain ⟨x, rfl⟩ := hf y\n  use Ideal.Quotient.mk I x\n  simp only [Ideal.Quotient.lift_mk]\n#align lift_surjective_of_surjective lift_surjective_of_surjective\n\n",
 "lift_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem lift_mk (I : Ideal R) (f : «expr →+* » R S) (H : ∀ a : R, a ∈ I → f a = 0) : lift I f H (mk I a) = f a :=\n  rfl\n#align lift_mk lift_mk\n\n",
 "is_domain_iff_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem is_domain_iff_prime (I : Ideal R) : IsDomain («expr ⧸ » R I) ↔ I.is_prime :=\n  by\n  refine'\n    ⟨fun H => ⟨zero_ne_one_iff.1 _, fun x y h => _⟩, fun h =>\n      by\n      skip\n      infer_instance⟩\n  · haveI : Nontrivial («expr ⧸ » R I) := ⟨H.3⟩\n    exact zero_ne_one\n  · simp only [← eq_zero_iff_mem, (mk I).map_mul] at h⊢\n    haveI := @IsDomain.to_noZeroDivisors («expr ⧸ » R I) _ H\n    exact eq_zero_or_eq_zero_of_mul_eq_zero h\n#align is_domain_iff_prime is_domain_iff_prime\n\n",
 "fst_comp_quotient_inf_equiv_quotient_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem fst_comp_quotient_inf_equiv_quotient_prod (I J : Ideal R) (coprime : «expr ⊔ » I J = «expr⊤») :\n    (RingHom.fst _ _).comp\n        (quotientInfEquivQuotientProd I J coprime :\n          «expr →+* » («expr ⧸ » R («expr ⊓ » I J)) («expr ⧸ » R I × «expr ⧸ » R J)) =\n      Ideal.Quotient.factor («expr ⊓ » I J) I inf_le_left :=\n  by ext <;> rfl\n#align fst_comp_quotient_inf_equiv_quotient_prod fst_comp_quotient_inf_equiv_quotient_prod\n\n",
 "factor_mk":
 "@[simp]\ntheorem factor_mk (S T : Ideal R) (H : S ≤ T) (x : R) : factor S T H (mk S x) = mk T x :=\n  rfl\n#align factor_mk factor_mk\n\n",
 "factor_comp_mk":
 "@[simp]\ntheorem factor_comp_mk (S T : Ideal R) (H : S ≤ T) : (factor S T H).comp (mk S) = mk T :=\n  by\n  ext x\n  rw [RingHom.comp_apply, factor_mk]\n#align factor_comp_mk factor_comp_mk\n\n",
 "exists_sub_one_mem_and_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem exists_sub_one_mem_and_mem (s : Finset ι) {f : ι → Ideal R}\n    (hf : ∀ i ∈ s, ∀ j ∈ s, i ≠ j → «expr ⊔ » (f i) (f j) = «expr⊤») (i : ι) (his : i ∈ s) :\n    ∃ r : R, r - 1 ∈ f i ∧ ∀ j ∈ s, j ≠ i → r ∈ f j :=\n  by\n  have : ∀ j ∈ s, j ≠ i → ∃ r : R, ∃ H : r - 1 ∈ f i, r ∈ f j :=\n    by\n    intro j hjs hji\n    specialize hf i his j hjs hji.symm\n    rw [eq_top_iff_one, Submodule.mem_sup] at hf\n    rcases hf with ⟨r, hri, s, hsj, hrs⟩\n    refine' ⟨1 - r, _, _⟩\n    · rw [sub_right_comm, sub_self, zero_sub]\n      exact (f i).neg_mem hri\n    · rw [← hrs, add_sub_cancel']\n      exact hsj\n  classical\n    have : ∃ g : ι → R, (∀ j, g j - 1 ∈ f i) ∧ ∀ j ∈ s, j ≠ i → g j ∈ f j :=\n      by\n      choose g hg1 hg2\n      refine' ⟨fun j => if H : j ∈ s ∧ j ≠ i then g j H.1 H.2 else 1, fun j => _, fun j => _⟩\n      · split_ifs with h\n        · apply hg1\n        rw [sub_self]\n        exact (f i).zero_mem\n      · intro hjs hji\n        rw [dif_pos]\n        · apply hg2\n        exact ⟨hjs, hji⟩\n    rcases this with ⟨g, hgi, hgj⟩\n    use\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.erase i)\n        (g x)\n    constructor\n    · rw [← Quotient.eq', RingHom.map_one, RingHom.map_prod]\n      apply Finset.prod_eq_one\n      intros\n      rw [← RingHom.map_one, Quotient.eq']\n      apply hgi\n    intro j hjs hji\n    rw [← quotient.eq_zero_iff_mem, RingHom.map_prod]\n    refine' Finset.prod_eq_zero (Finset.mem_erase_of_ne_of_mem hji hjs) _\n    rw [quotient.eq_zero_iff_mem]\n    exact hgj j hjs hji\n#align exists_sub_one_mem_and_mem exists_sub_one_mem_and_mem\n\n",
 "exists_sub_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem exists_sub_mem [Finite ι] {f : ι → Ideal R} (hf : ∀ i j, i ≠ j → «expr ⊔ » (f i) (f j) = «expr⊤») (g : ι → R) :\n    ∃ r : R, ∀ i, r - g i ∈ f i := by\n  cases nonempty_fintype ι\n  have : ∃ φ : ι → R, (∀ i, φ i - 1 ∈ f i) ∧ ∀ i j, i ≠ j → φ i ∈ f j :=\n    by\n    have := exists_sub_one_mem_and_mem (Finset.univ : Finset ι) fun i _ j _ hij => hf i j hij\n    choose φ hφ\n    exists fun i => φ i (Finset.mem_univ i)\n    exact ⟨fun i => (hφ i _).1, fun i j hij => (hφ i _).2 j (Finset.mem_univ j) hij.symm⟩\n  rcases this with ⟨φ, hφ1, hφ2⟩\n  use\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n      (g i * φ i)\n  intro i\n  rw [← Quotient.eq', RingHom.map_sum]\n  refine' Eq.trans (Finset.sum_eq_single i _ _) _\n  · intro j _ hji\n    rw [quotient.eq_zero_iff_mem]\n    exact (f i).mul_mem_left _ (hφ2 j i hji)\n  · intro hi\n    exact (hi <| Finset.mem_univ i).elim\n  specialize hφ1 i\n  rw [← Quotient.eq', RingHom.map_one] at hφ1\n  rw [RingHom.map_mul, hφ1, mul_one]\n#align exists_sub_mem exists_sub_mem\n\n",
 "exists_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem exists_inv {I : Ideal R} [hI : I.is_maximal] : ∀ {a : «expr ⧸ » R I}, a ≠ 0 → ∃ b : «expr ⧸ » R I, a * b = 1 :=\n  by\n  rintro ⟨a⟩ h\n  rcases hI.exists_inv (mt eq_zero_iff_mem.2 h) with ⟨b, c, hc, abc⟩\n  rw [mul_comm] at abc\n  refine' ⟨mk _ b, quot.sound _⟩\n  --quot.sound hb\n  rw [← eq_sub_iff_add_eq'] at abc\n  rw [abc, ← neg_mem_iff, neg_sub] at hc\n  rw [Submodule.quotientRel_r_def]\n  convert hc\n#align exists_inv exists_inv\n\n",
 "eq_zero_iff_mem":
 "theorem eq_zero_iff_mem {I : Ideal R} : mk I a = 0 ↔ a ∈ I :=\n  Submodule.Quotient.mk_eq_zero _\n#align eq_zero_iff_mem eq_zero_iff_mem\n\n",
 "Nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print Nontrivial /-\nprotected theorem Nontrivial {I : Ideal R} (hI : I ≠ «expr⊤») : Nontrivial («expr ⧸ » R I) :=\n  ⟨⟨0, 1, zero_ne_one_iff.2 hI⟩⟩\n#align nontrivial Nontrivial\n-/\n\n",
 "Eq":
 "#print Eq /-\nprotected theorem Eq : mk I x = mk I y ↔ x - y ∈ I :=\n  Submodule.Quotient.eq I\n#align eq Eq\n-/\n\n"}