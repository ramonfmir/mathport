{"quotient_mk_maps_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The identity in this lemma asserts that the \"obvious\" square\n```\n    R    → (R / (P ∩ R))\n    ↓          ↓\nR[x] / P → (R / (P ∩ R))[x] / (P / (P ∩ R))\n```\ncommutes.  It is used, for instance, in the proof of `quotient_mk_comp_C_is_integral_of_jacobson`,\nin the file `ring_theory/jacobson`.\n-/\ntheorem quotient_mk_maps_eq (P : Ideal (polynomial R)) :\n    ((Quotient.mk (map (mapRingHom (Quotient.mk (P.comap (C : «expr →+* » R (polynomial R))))) P)).comp C).comp\n        (Quotient.mk (P.comap (C : «expr →+* » R (polynomial R)))) =\n      ((map (mapRingHom (Quotient.mk (P.comap (C : «expr →+* » R (polynomial R))))) P).quotient_map\n            (mapRingHom (Quotient.mk (P.comap (C : «expr →+* » R (polynomial R))))) le_comap_map).comp\n        ((Quotient.mk P).comp C) :=\n  by\n  refine' RingHom.ext fun x => _\n  repeat' rw [RingHom.coe_comp, Function.comp_apply]\n  rw [quotient_map_mk, coe_map_ring_hom, map_C]\n#align quotient_mk_maps_eq quotient_mk_maps_eq\n\n",
 "mk_smul_mk_quotient_map_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem quotient.mk_smul_mk_quotient_map_quotient (x : R) (y : S) :\n    «expr • » (Quotient.mk p x) (Quotient.mk (map f p) y) = Quotient.mk _ (f x * y) :=\n  rfl\n#align quotient.mk_smul_mk_quotient_map_quotient quotient.mk_smul_mk_quotient_map_quotient\n\n",
 "mem_of_one_mem":
 "theorem mem_of_one_mem (h : (1 : S) ∈ I) (x) : x ∈ I :=\n  (I.eq_top_iff_one.mpr h).symm ▸ mem_top\n#align mem_of_one_mem mem_of_one_mem\n\n",
 "is_maximal_of_is_maximal_comap":
 "theorem integral_closure.is_maximal_of_is_maximal_comap (I : Ideal (integral_closure R S)) [I.is_prime]\n    (hI : IsMaximal (I.comap (algebraMap R (integral_closure R S)))) : IsMaximal I :=\n  is_integral_closure.is_maximal_of_is_maximal_comap S I hI\n#align integral_closure.is_maximal_of_is_maximal_comap integral_closure.is_maximal_of_is_maximal_comap\n\n",
 "is_maximal_of_is_integral_of_is_maximal_comap'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_maximal_of_is_integral_of_is_maximal_comap' (f : «expr →+* » R S) (hf : f.is_integral) (I : Ideal S)\n    [hI' : I.is_prime] (hI : IsMaximal (I.comap f)) : IsMaximal I :=\n  @is_maximal_of_is_integral_of_is_maximal_comap R _ S _ f.to_algebra hf I hI' hI\n#align is_maximal_of_is_integral_of_is_maximal_comap' is_maximal_of_is_integral_of_is_maximal_comap'\n\n",
 "is_maximal_of_is_integral_of_is_maximal_comap":
 "theorem is_maximal_of_is_integral_of_is_maximal_comap [Algebra R S] (hRS : algebra.is_integral R S) (I : Ideal S)\n    [I.is_prime] (hI : IsMaximal (I.comap (algebraMap R S))) : IsMaximal I :=\n  ⟨⟨mt comap_eq_top_iff.mpr hI.1.1, fun J I_lt_J =>\n      let ⟨I_le_J, x, hxJ, hxI⟩ := SetLike.lt_iff_le_and_exists.mp I_lt_J\n      comap_eq_top_iff.1 <| hI.1.2 _ (comap_lt_comap_of_integral_mem_sdiff I_le_J ⟨hxJ, hxI⟩ (hRS x))⟩⟩\n#align is_maximal_of_is_integral_of_is_maximal_comap is_maximal_of_is_integral_of_is_maximal_comap\n\n",
 "is_maximal_comap_of_is_integral_of_is_maximal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_maximal_comap_of_is_integral_of_is_maximal' {R S : Type _} [CommRing R] [CommRing S] (f : «expr →+* » R S)\n    (hf : f.is_integral) (I : Ideal S) (hI : I.is_maximal) : IsMaximal (I.comap f) :=\n  @is_maximal_comap_of_is_integral_of_is_maximal R _ S _ f.to_algebra hf I hI\n#align is_maximal_comap_of_is_integral_of_is_maximal' is_maximal_comap_of_is_integral_of_is_maximal'\n\n",
 "is_maximal_comap_of_is_integral_of_is_maximal":
 "theorem is_maximal_comap_of_is_integral_of_is_maximal (hRS : algebra.is_integral R S) (I : Ideal S)\n    [hI : I.is_maximal] : IsMaximal (I.comap (algebraMap R S)) :=\n  by\n  refine' quotient.maximal_of_is_field _ _\n  haveI : is_prime (I.comap (algebraMap R S)) := comap_is_prime _ _\n  exact\n    is_field_of_is_integral_of_is_field (is_integral_quotient_of_is_integral hRS) algebra_map_quotient_injective\n      (by rwa [← quotient.maximal_ideal_iff_is_field_quotient])\n#align is_maximal_comap_of_is_integral_of_is_maximal is_maximal_comap_of_is_integral_of_is_maximal\n\n",
 "injective_quotient_le_comap_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Let `P` be an ideal in `R[x]`.  The map\n`R[x]/P → (R / (P ∩ R))[x] / (P / (P ∩ R))`\nis injective.\n-/\ntheorem injective_quotient_le_comap_map (P : Ideal (polynomial R)) :\n    function.injective\n      ((map (mapRingHom (Quotient.mk (P.comap (C : «expr →+* » R (polynomial R))))) P).quotient_map\n        (mapRingHom (Quotient.mk (P.comap (C : «expr →+* » R (polynomial R))))) le_comap_map) :=\n  by\n  refine' quotient_map_injective' (le_of_eq _)\n  rw [comap_map_of_surjective (map_ring_hom (Quotient.mk' (P.comap (C : «expr →+* » R (polynomial R)))))\n      (map_surjective (Quotient.mk' (P.comap (C : «expr →+* » R (polynomial R)))) quotient.mk_surjective)]\n  refine' le_antisymm (sup_le le_rfl _) (le_sup_of_le_left le_rfl)\n  refine' fun p hp => polynomial_mem_ideal_of_coeff_mem_ideal P p fun n => quotient.eq_zero_iff_mem.mp _\n  simpa only [coeff_map, coe_map_ring_hom] using ext_iff.mp (ideal.mem_bot.mp (mem_comap.mp hp)) n\n#align injective_quotient_le_comap_map injective_quotient_le_comap_map\n\n",
 "exists_nonzero_mem_of_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- This technical lemma asserts the existence of a polynomial `p` in an ideal `P ⊂ R[x]`\nthat is non-zero in the quotient `R / (P ∩ R) [x]`.  The assumptions are equivalent to\n`P ≠ 0` and `P ∩ R = (0)`.\n-/\ntheorem exists_nonzero_mem_of_ne_bot {P : Ideal (polynomial R)} (Pb : P ≠ «expr⊥») (hP : ∀ x : R, C x ∈ P → x = 0) :\n    ∃ p : polynomial R, p ∈ P ∧ Polynomial.map (Quotient.mk (P.comap (C : «expr →+* » R (polynomial R)))) p ≠ 0 :=\n  by\n  obtain ⟨m, hm⟩ := Submodule.nonzero_mem_of_bot_lt (bot_lt_iff_ne_bot.mpr Pb)\n  refine' ⟨m, Submodule.coe_mem m, fun pp0 => hm (submodule.coe_eq_zero.mp _)⟩\n  refine'\n    (injective_iff_map_eq_zero (Polynomial.mapRingHom (Quotient.mk' (P.comap (C : «expr →+* » R (polynomial R)))))).mp _\n      _ pp0\n  refine' map_injective _ ((Quotient.mk' (P.comap C)).injective_iff_ker_eq_bot.mpr _)\n  rw [mk_ker]\n  exact (Submodule.eq_bot_iff _).mpr fun x hx => hP x (mem_comap.mp hx)\n#align exists_nonzero_mem_of_ne_bot exists_nonzero_mem_of_ne_bot\n\n",
 "exists_ideal_over_prime_of_is_integral'":
 "/-- `comap (algebra_map R S)` is a surjection from the prime spec of `R` to prime spec of `S`.\n`hP : (algebra_map R S).ker ≤ P` is a slight generalization of the extension being injective -/\ntheorem exists_ideal_over_prime_of_is_integral' (H : algebra.is_integral R S) (P : Ideal R) [IsPrime P]\n    (hP : (algebraMap R S).ker ≤ P) : ∃ Q : Ideal S, IsPrime Q ∧ Q.comap (algebraMap R S) = P :=\n  by\n  have hP0 : (0 : S) ∉ Algebra.algebraMapSubmonoid S P.prime_compl :=\n    by\n    rintro ⟨x, ⟨hx, x0⟩⟩\n    exact absurd (hP x0) hx\n  let Rₚ := Localization P.prime_compl\n  let Sₚ := Localization (Algebra.algebraMapSubmonoid S P.prime_compl)\n  letI : IsDomain (Localization (Algebra.algebraMapSubmonoid S P.prime_compl)) :=\n    IsLocalization.isDomain_localization (le_nonZeroDivisors_of_noZeroDivisors hP0)\n  obtain ⟨Qₚ : Ideal Sₚ, Qₚ_maximal⟩ := exists_maximal Sₚ\n  haveI Qₚ_max : is_maximal (comap _ Qₚ) :=\n    @is_maximal_comap_of_is_integral_of_is_maximal Rₚ _ Sₚ _ (localizationAlgebra P.prime_compl S)\n      (is_integral_localization H) _ Qₚ_maximal\n  refine' ⟨comap (algebraMap S Sₚ) Qₚ, ⟨comap_is_prime _ Qₚ, _⟩⟩\n  convert localization.at_prime.comap_maximal_ideal\n  rw [comap_comap, ← local_ring.eq_maximal_ideal Qₚ_max, ← IsLocalization.map_comp _]\n  rfl\n#align exists_ideal_over_prime_of_is_integral' exists_ideal_over_prime_of_is_integral'\n\n",
 "exists_ideal_over_prime_of_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- More general going-up theorem than `exists_ideal_over_prime_of_is_integral'`.\nTODO: Version of going-up theorem with arbitrary length chains (by induction on this)?\n  Not sure how best to write an ascending chain in Lean -/\ntheorem exists_ideal_over_prime_of_is_integral (H : algebra.is_integral R S) (P : Ideal R) [IsPrime P] (I : Ideal S)\n    [IsPrime I] (hIP : I.comap (algebraMap R S) ≤ P) : ∃ Q ≥ I, IsPrime Q ∧ Q.comap (algebraMap R S) = P :=\n  by\n  let quot := «expr ⧸ » R (I.comap (algebraMap R S))\n  obtain ⟨Q' : Ideal («expr ⧸ » S I), ⟨Q'_prime, hQ'⟩⟩ :=\n    @exists_ideal_over_prime_of_is_integral' Quot _ («expr ⧸ » S I) _ Ideal.quotientAlgebra _\n      (is_integral_quotient_of_is_integral H) (map (Quotient.mk' (I.comap (algebraMap R S))) P)\n      (map_is_prime_of_surjective quotient.mk_surjective (by simp [hIP]))\n      (le_trans (le_of_eq ((RingHom.injective_iff_ker_eq_bot _).1 algebra_map_quotient_injective)) bot_le)\n  haveI := Q'_prime\n  refine' ⟨Q'.comap _, le_trans (le_of_eq mk_ker.symm) (ker_le_comap _), ⟨comap_is_prime _ Q', _⟩⟩\n  rw [comap_comap]\n  refine' trans _ (trans (congr_arg (comap (Quotient.mk' (comap (algebraMap R S) I))) hQ') _)\n  · simpa [comap_comap]\n  · refine' trans (comap_map_of_surjective _ quotient.mk_surjective _) (sup_eq_left.2 _)\n    simpa [← RingHom.ker_eq_comap_bot] using hIP\n#align exists_ideal_over_prime_of_is_integral exists_ideal_over_prime_of_is_integral\n\n",
 "exists_ideal_over_maximal_of_is_integral":
 "/-- `comap (algebra_map R S)` is a surjection from the max spec of `S` to max spec of `R`.\n`hP : (algebra_map R S).ker ≤ P` is a slight generalization of the extension being injective -/\ntheorem exists_ideal_over_maximal_of_is_integral [IsDomain S] (H : algebra.is_integral R S) (P : Ideal R)\n    [P_max : IsMaximal P] (hP : (algebraMap R S).ker ≤ P) : ∃ Q : Ideal S, IsMaximal Q ∧ Q.comap (algebraMap R S) = P :=\n  by\n  obtain ⟨Q, ⟨Q_prime, hQ⟩⟩ := exists_ideal_over_prime_of_is_integral' H P hP\n  haveI : Q.is_prime := Q_prime\n  exact ⟨Q, is_maximal_of_is_integral_of_is_maximal_comap H _ (hQ.symm ▸ P_max), hQ⟩\n#align exists_ideal_over_maximal_of_is_integral exists_ideal_over_maximal_of_is_integral\n\n",
 "exists_coeff_ne_zero_mem_comap_of_root_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_coeff_ne_zero_mem_comap_of_root_mem [IsDomain S] {r : S} (r_ne_zero : r ≠ 0) (hr : r ∈ I)\n    {p : polynomial R} : ∀ (p_ne_zero : p ≠ 0) (hp : p.eval₂ f r = 0), ∃ i, p.coeff i ≠ 0 ∧ p.coeff i ∈ I.comap f :=\n  exists_coeff_ne_zero_mem_comap_of_non_zero_divisor_root_mem (fun _ h => or.resolve_right (mul_eq_zero.mp h) r_ne_zero)\n    hr\n#align exists_coeff_ne_zero_mem_comap_of_root_mem exists_coeff_ne_zero_mem_comap_of_root_mem\n\n",
 "exists_coeff_ne_zero_mem_comap_of_non_zero_divisor_root_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_coeff_ne_zero_mem_comap_of_non_zero_divisor_root_mem {r : S}\n    (r_non_zero_divisor : ∀ {x}, x * r = 0 → x = 0) (hr : r ∈ I) {p : polynomial R} :\n    ∀ (p_ne_zero : p ≠ 0) (hp : p.eval₂ f r = 0), ∃ i, p.coeff i ≠ 0 ∧ p.coeff i ∈ I.comap f :=\n  by\n  refine' p.rec_on_horner _ _ _\n  · intro h\n    contradiction\n  · intro p a coeff_eq_zero a_ne_zero ih p_ne_zero hp\n    refine' ⟨0, _, coeff_zero_mem_comap_of_root_mem hr hp⟩\n    simp [coeff_eq_zero, a_ne_zero]\n  · intro p p_nonzero ih mul_nonzero hp\n    rw [eval₂_mul, eval₂_X] at hp\n    obtain ⟨i, hi, mem⟩ := ih p_nonzero (r_non_zero_divisor hp)\n    refine' ⟨i + 1, _, _⟩ <;> simp [hi, mem]\n#align exists_coeff_ne_zero_mem_comap_of_non_zero_divisor_root_mem exists_coeff_ne_zero_mem_comap_of_non_zero_divisor_root_mem\n\n",
 "exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff [IsPrime I] (hIJ : I ≤ J) {r : S}\n    (hr : r ∈ (J : Set S) \\ I) {p : polynomial R} (p_ne_zero : p.map (Quotient.mk (I.comap f)) ≠ 0)\n    (hpI : p.eval₂ f r ∈ I) : ∃ i, p.coeff i ∈ (J.comap f : Set R) \\ I.comap f :=\n  by\n  obtain ⟨hrJ, hrI⟩ := hr\n  have rbar_ne_zero : Quotient.mk' I r ≠ 0 := mt (quotient.mk_eq_zero I).mp hrI\n  have rbar_mem_J : Quotient.mk' I r ∈ J.map (Quotient.mk' I) := mem_map_of_mem _ hrJ\n  have quotient_f : ∀ x ∈ I.comap f, (Quotient.mk' I).comp f x = 0 := by simp [quotient.eq_zero_iff_mem]\n  have rbar_root :\n    (p.map (Quotient.mk' (I.comap f))).eval₂ (quotient.lift (I.comap f) _ quotient_f) (Quotient.mk' I r) = 0 :=\n    by\n    convert quotient.eq_zero_iff_mem.mpr hpI\n    exact trans (eval₂_map _ _ _) (hom_eval₂ p f (Quotient.mk' I) r).symm\n  obtain ⟨i, ne_zero, mem⟩ := exists_coeff_ne_zero_mem_comap_of_root_mem rbar_ne_zero rbar_mem_J p_ne_zero rbar_root\n  rw [coeff_map] at ne_zero mem\n  refine' ⟨i, (mem_quotient_iff_mem hIJ).mp _, mt _ NeZero⟩\n  · simpa using mem\n  simp [quotient.eq_zero_iff_mem]\n#align exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff\n\n",
 "eq_bot_of_comap_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem integral_closure.eq_bot_of_comap_eq_bot [Nontrivial R] {I : Ideal (integral_closure R S)} :\n    I.comap (algebraMap R (integral_closure R S)) = «expr⊥» → I = «expr⊥» :=\n  is_integral_closure.eq_bot_of_comap_eq_bot S\n#align integral_closure.eq_bot_of_comap_eq_bot integral_closure.eq_bot_of_comap_eq_bot\n\n",
 "comap_ne_bot_of_root_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comap_ne_bot_of_root_mem [IsDomain S] {r : S} (r_ne_zero : r ≠ 0) (hr : r ∈ I) {p : polynomial R}\n    (p_ne_zero : p ≠ 0) (hp : p.eval₂ f r = 0) : I.comap f ≠ «expr⊥» := fun h =>\n  let ⟨i, hi, mem⟩ := exists_coeff_ne_zero_mem_comap_of_root_mem r_ne_zero hr p_ne_zero hp\n  absurd (mem_bot.mp (eq_bot_iff.mp h mem)) hi\n#align comap_ne_bot_of_root_mem comap_ne_bot_of_root_mem\n\n",
 "comap_ne_bot_of_integral_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comap_ne_bot_of_integral_mem [Nontrivial R] [IsDomain S] {x : S} (x_ne_zero : x ≠ 0) (x_mem : x ∈ I)\n    (hx : is_integral R x) : I.comap (algebraMap R S) ≠ «expr⊥» :=\n  comap_ne_bot_of_algebraic_mem x_ne_zero x_mem (hx.is_algebraic R)\n#align comap_ne_bot_of_integral_mem comap_ne_bot_of_integral_mem\n\n",
 "comap_ne_bot_of_algebraic_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comap_ne_bot_of_algebraic_mem [IsDomain S] {x : S} (x_ne_zero : x ≠ 0) (x_mem : x ∈ I) (hx : is_algebraic R x) :\n    I.comap (algebraMap R S) ≠ «expr⊥» :=\n  let ⟨p, p_ne_zero, hp⟩ := hx\n  comap_ne_bot_of_root_mem x_ne_zero x_mem p_ne_zero hp\n#align comap_ne_bot_of_algebraic_mem comap_ne_bot_of_algebraic_mem\n\n",
 "comap_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem integral_closure.comap_ne_bot [Nontrivial R] {I : Ideal (integral_closure R S)} (I_ne_bot : I ≠ «expr⊥») :\n    I.comap (algebraMap R (integral_closure R S)) ≠ «expr⊥» :=\n  is_integral_closure.comap_ne_bot S I_ne_bot\n#align integral_closure.comap_ne_bot integral_closure.comap_ne_bot\n\n",
 "comap_lt_comap_of_root_mem_sdiff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem comap_lt_comap_of_root_mem_sdiff [I.is_prime] (hIJ : I ≤ J) {r : S} (hr : r ∈ (J : Set S) \\ I)\n    {p : polynomial R} (p_ne_zero : p.map (Quotient.mk (I.comap f)) ≠ 0) (hp : p.eval₂ f r ∈ I) :\n    I.comap f < J.comap f :=\n  let ⟨i, hJ, hI⟩ := exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff hIJ hr p_ne_zero hp\n  SetLike.lt_iff_le_and_exists.mpr ⟨comap_mono hIJ, p.coeff i, hJ, hI⟩\n#align comap_lt_comap_of_root_mem_sdiff comap_lt_comap_of_root_mem_sdiff\n\n",
 "comap_lt_comap_of_integral_mem_sdiff":
 "theorem comap_lt_comap_of_integral_mem_sdiff [Algebra R S] [hI : I.is_prime] (hIJ : I ≤ J) {x : S}\n    (mem : x ∈ (J : Set S) \\ I) (integral : is_integral R x) : I.comap (algebraMap R S) < J.comap (algebraMap R S) :=\n  by\n  obtain ⟨p, p_monic, hpx⟩ := integral\n  refine' comap_lt_comap_of_root_mem_sdiff hIJ mem _ _\n  swap\n  · apply map_monic_ne_zero p_monic\n    apply quotient.nontrivial\n    apply mt comap_eq_top_iff.mp\n    apply hI.1\n  convert I.zero_mem\n#align comap_lt_comap_of_integral_mem_sdiff comap_lt_comap_of_integral_mem_sdiff\n\n",
 "comap_lt_comap":
 "theorem integral_closure.comap_lt_comap {I J : Ideal (integral_closure R S)} [I.is_prime] (I_lt_J : I < J) :\n    I.comap (algebraMap R (integral_closure R S)) < J.comap (algebraMap R (integral_closure R S)) :=\n  is_integral_closure.comap_lt_comap S I_lt_J\n#align integral_closure.comap_lt_comap integral_closure.comap_lt_comap\n\n",
 "comap_eq_of_scalar_tower_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If there is an injective map `R/p → S/P` such that following diagram commutes:\n```\nR   → S\n↓     ↓\nR/p → S/P\n```\nthen `P` lies over `p`.\n-/\ntheorem comap_eq_of_scalar_tower_quotient [Algebra R S] [Algebra («expr ⧸ » R p) («expr ⧸ » S P)]\n    [IsScalarTower R («expr ⧸ » R p) («expr ⧸ » S P)]\n    (h : function.injective (algebraMap («expr ⧸ » R p) («expr ⧸ » S P))) : comap (algebraMap R S) P = p :=\n  by\n  ext x;\n  constructor <;>\n    rw [mem_comap, ← quotient.eq_zero_iff_mem, ← quotient.eq_zero_iff_mem, quotient.mk_algebra_map,\n      IsScalarTower.algebraMap_apply _ («expr ⧸ » R p), quotient.algebra_map_eq]\n  · intro hx\n    exact (injective_iff_map_eq_zero (algebraMap («expr ⧸ » R p) («expr ⧸ » S P))).mp h _ hx\n  · intro hx\n    rw [hx, RingHom.map_zero]\n#align comap_eq_of_scalar_tower_quotient comap_eq_of_scalar_tower_quotient\n\n",
 "coeff_zero_mem_comap_of_root_mem_of_eval_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\ntheorem coeff_zero_mem_comap_of_root_mem_of_eval_mem {r : S} (hr : r ∈ I) {p : polynomial R} (hp : p.eval₂ f r ∈ I) :\n    p.coeff 0 ∈ I.comap f :=\n  by\n  rw [← p.div_X_mul_X_add, eval₂_add, eval₂_C, eval₂_mul, eval₂_X] at hp\n  refine' mem_comap.mpr ((I.add_mem_iff_right _).mp hp)\n  exact I.mul_mem_left _ hr\n#align coeff_zero_mem_comap_of_root_mem_of_eval_mem coeff_zero_mem_comap_of_root_mem_of_eval_mem\n\n",
 "coeff_zero_mem_comap_of_root_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_zero_mem_comap_of_root_mem {r : S} (hr : r ∈ I) {p : polynomial R} (hp : p.eval₂ f r = 0) :\n    p.coeff 0 ∈ I.comap f :=\n  coeff_zero_mem_comap_of_root_mem_of_eval_mem hr (hp.symm ▸ I.zero_mem)\n#align coeff_zero_mem_comap_of_root_mem coeff_zero_mem_comap_of_root_mem\n\n",
 "algebra_map_quotient_map_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp]\ntheorem quotient.algebra_map_quotient_map_quotient (x : R) :\n    algebraMap («expr ⧸ » R p) («expr ⧸ » S (map f p)) (Quotient.mk p x) = Quotient.mk _ (f x) :=\n  rfl\n#align quotient.algebra_map_quotient_map_quotient quotient.algebra_map_quotient_map_quotient\n\n"}