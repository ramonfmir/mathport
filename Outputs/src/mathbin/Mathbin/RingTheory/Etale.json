{"of_unramified_and_smooth":
 "theorem formally_etale.of_unramified_and_smooth [h₁ : formally_unramified R A] [h₂ : formally_smooth R A] :\n    formally_etale R A :=\n  formally_etale.iff_unramified_and_smooth.mpr ⟨h₁, h₂⟩\n#align formally_etale.of_unramified_and_smooth formally_etale.of_unramified_and_smooth\n\n",
 "of_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem formally_smooth.of_split [formally_smooth R P] (g : «expr →ₐ[ ] » A R («expr ⧸ » P (f.to_ring_hom.ker ^ 2)))\n    (hg : f.ker_square_lift.comp g = alg_hom.id R A) : formally_smooth R A :=\n  by\n  constructor\n  intro C _ _ I hI i\n  let l : «expr →ₐ[ ] » («expr ⧸ » P (f.to_ring_hom.ker ^ 2)) R C :=\n    by\n    refine' ideal.quotient.liftₐ _ (formally_smooth.lift I ⟨2, hI⟩ (i.comp f)) _\n    have : ring_hom.ker f ≤ I.comap (formally_smooth.lift I ⟨2, hI⟩ (i.comp f)) :=\n      by\n      rintro x (hx : f x = 0)\n      have : _ = i (f x) := (formally_smooth.mk_lift I ⟨2, hI⟩ (i.comp f) x : _)\n      rwa [hx, map_zero, ← ideal.quotient.mk_eq_mk, submodule.quotient.mk_eq_zero] at this\n    intro x hx\n    have := (ideal.pow_mono this 2).trans (ideal.le_comap_pow _ 2) hx\n    rwa [hI] at this\n  have : i.comp f.ker_square_lift = (ideal.quotient.mkₐ R _).comp l :=\n    by\n    apply alg_hom.coe_ring_hom_injective\n    apply ideal.quotient.ring_hom_ext\n    ext x\n    exact (formally_smooth.mk_lift I ⟨2, hI⟩ (i.comp f) x).symm\n  exact ⟨l.comp g, by rw [← alg_hom.comp_assoc, ← this, alg_hom.comp_assoc, hg, alg_hom.comp_id]⟩\n#align formally_smooth.of_split formally_smooth.of_split\n\n",
 "of_is_localization":
 "theorem formally_etale.of_is_localization : formally_etale R Rₘ :=\n  formally_etale.iff_unramified_and_smooth.mpr\n    ⟨formally_unramified.of_is_localization M, formally_smooth.of_is_localization M⟩\n#align formally_etale.of_is_localization formally_etale.of_is_localization\n\n",
 "of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem formally_etale.of_equiv [formally_etale R A] (e : «expr ≃ₐ[ ] » A R B) : formally_etale R B :=\n  formally_etale.iff_unramified_and_smooth.mpr ⟨formally_unramified.of_equiv e, formally_smooth.of_equiv e⟩\n#align formally_etale.of_equiv formally_etale.of_equiv\n\n",
 "of_comp":
 "theorem formally_unramified.of_comp [formally_unramified R B] : formally_unramified A B :=\n  by\n  constructor\n  intro Q _ _ I e f₁ f₂ e'\n  letI := ((algebra_map A Q).comp (algebra_map R A)).to_algebra\n  letI : IsScalarTower R A Q := is_scalar_tower.of_algebra_map_eq' rfl\n  refine' alg_hom.restrict_scalars_injective R _\n  refine' formally_unramified.ext I ⟨2, e⟩ _\n  intro x\n  exact alg_hom.congr_fun e' x\n#align formally_unramified.of_comp formally_unramified.of_comp\n\n",
 "mk_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp]\ntheorem formally_smooth.mk_lift [formally_smooth R A] (I : ideal B) (hI : is_nilpotent I)\n    (g : «expr →ₐ[ ] » A R («expr ⧸ » B I)) (x : A) : ideal.quotient.mk I (formally_smooth.lift I hI g x) = g x :=\n  alg_hom.congr_fun (formally_smooth.comp_lift I hI g : _) x\n#align formally_smooth.mk_lift formally_smooth.mk_lift\n\n",
 "localization_map":
 "theorem formally_etale.localization_map [formally_etale R S] : formally_etale Rₘ Sₘ :=\n  by\n  haveI : formally_etale S Sₘ := formally_etale.of_is_localization (M.map (algebra_map R S))\n  haveI : formally_etale R Sₘ := formally_etale.comp R S Sₘ\n  exact formally_etale.localization_base M\n#align formally_etale.localization_map formally_etale.localization_map\n\n",
 "localization_base":
 "theorem formally_etale.localization_base [formally_etale R Sₘ] : formally_etale Rₘ Sₘ :=\n  formally_etale.iff_unramified_and_smooth.mpr\n    ⟨formally_unramified.localization_base M, formally_smooth.localization_base M⟩\n#align formally_etale.localization_base formally_etale.localization_base\n\n",
 "lift_unique_of_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem formally_unramified.lift_unique_of_ring_hom [formally_unramified R A] {C : Type u} [CommRing C]\n    (f : «expr →+* » B C) (hf : is_nilpotent f.ker) (g₁ g₂ : «expr →ₐ[ ] » A R B)\n    (h : f.comp ↑g₁ = f.comp (g₂ : «expr →+* » A B)) : g₁ = g₂ :=\n  formally_unramified.lift_unique _ hf _ _\n    (by\n      ext x\n      have := RingHom.congr_fun h x\n      simpa only [ideal.quotient.eq, Function.comp_apply, alg_hom.coe_comp, ideal.quotient.mkₐ_eq_mk, ring_hom.mem_ker,\n        map_sub, sub_eq_zero] )\n#align formally_unramified.lift_unique_of_ring_hom formally_unramified.lift_unique_of_ring_hom\n\n",
 "lift_unique'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem formally_unramified.lift_unique' [formally_unramified R A] {C : Type u} [CommRing C] [algebra R C]\n    (f : «expr →ₐ[ ] » B R C) (hf : is_nilpotent (f : «expr →+* » B C).ker) (g₁ g₂ : «expr →ₐ[ ] » A R B)\n    (h : f.comp g₁ = f.comp g₂) : g₁ = g₂ :=\n  formally_unramified.ext' _ hf g₁ g₂ (alg_hom.congr_fun h)\n#align formally_unramified.lift_unique' formally_unramified.lift_unique'\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem formally_unramified.lift_unique {B : Type u} [CommRing B] [_RB : algebra R B] [formally_unramified R A]\n    (I : ideal B) (hI : is_nilpotent I) (g₁ g₂ : «expr →ₐ[ ] » A R B)\n    (h : (ideal.quotient.mkₐ R I).comp g₁ = (ideal.quotient.mkₐ R I).comp g₂) : g₁ = g₂ :=\n  by\n  revert g₁ g₂\n  change function.injective (ideal.quotient.mkₐ R I).comp\n  revert _RB\n  apply ideal.is_nilpotent.induction_on I hI\n  · intro B _ I hI _\n    exact formally_unramified.comp_injective I hI\n  · intro B _ I J hIJ h₁ h₂ _ g₁ g₂ e\n    apply h₁\n    apply h₂\n    ext x\n    replace e := alg_hom.congr_fun e x\n    dsimp only [alg_hom.comp_apply, ideal.quotient.mkₐ_eq_mk] at e⊢\n    rwa [ideal.quotient.eq, ← map_sub, ideal.mem_quotient_iff_mem hIJ, ← ideal.quotient.eq]\n#align formally_unramified.lift_unique formally_unramified.lift_unique\n\n",
 "lift_of_surjective_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem formally_smooth.lift_of_surjective_apply [formally_smooth R A] (f : «expr →ₐ[ ] » A R C)\n    (g : «expr →ₐ[ ] » B R C) (hg : function.surjective g) (hg' : is_nilpotent (g : «expr →+* » B C).ker) (x : A) :\n    g (formally_smooth.lift_of_surjective f g hg hg' x) = f x :=\n  by\n  apply (ideal.quotient_ker_alg_equiv_of_surjective hg).symm.injective\n  change _ = ((ideal.quotient_ker_alg_equiv_of_surjective hg).symm.to_alg_hom.comp f) x\n  rw [← formally_smooth.mk_lift _ hg' ((ideal.quotient_ker_alg_equiv_of_surjective hg).symm.to_alg_hom.comp f)]\n  apply (ideal.quotient_ker_alg_equiv_of_surjective hg).injective\n  rw [alg_equiv.apply_symm_apply, ideal.quotient_ker_alg_equiv_of_surjective,\n    ideal.quotient_ker_alg_equiv_of_right_inverse.apply]\n  exact (ideal.ker_lift_alg_mk _ _).symm\n#align formally_smooth.lift_of_surjective_apply formally_smooth.lift_of_surjective_apply\n\n",
 "iff_unramified_and_smooth":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem formally_etale.iff_unramified_and_smooth : formally_etale R A ↔ formally_unramified R A ∧ formally_smooth R A :=\n  by\n  rw [formally_unramified_iff, formally_smooth_iff, formally_etale_iff]\n  simp_rw [← forall_and]\n  rfl\n#align formally_etale.iff_unramified_and_smooth formally_etale.iff_unramified_and_smooth\n\n",
 "iff_subsingleton_kaehler_differential":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\ntheorem formally_unramified.iff_subsingleton_kaehler_differential :\n    formally_unramified R S ↔ subsingleton («exprΩ[ ⁄ ]» S R) :=\n  by\n  constructor\n  · intros\n    infer_instance\n  · intro H\n    constructor\n    intro B _ _ I hI f₁ f₂ e\n    letI := f₁.to_ring_hom.to_algebra\n    haveI := is_scalar_tower.of_algebra_map_eq' f₁.comp_algebra_map.symm\n    have :=\n      ((kaehler_differential.linear_map_equiv_derivation R S).to_equiv.trans\n            (derivation_to_square_zero_equiv_lift I hI)).surjective.subsingleton\n    exact subtype.ext_iff.mp (@subsingleton.elim this ⟨f₁, rfl⟩ ⟨f₂, e.symm⟩)\n#align\n  formally_unramified.iff_subsingleton_kaehler_differential formally_unramified.iff_subsingleton_kaehler_differential\n\n",
 "iff_split_surjection":
 "/-- Let `P →ₐ[R] A` be a surjection with kernel `J`, and `P` a formally smooth `R`-algebra,\nthen `A` is formally smooth over `R` iff the surjection `P ⧸ J ^ 2 →ₐ[R] A` has a section.\n\nGeometric intuition: we require that a first-order thickening of `Spec A` inside `Spec P` admits\na retraction. -/\ntheorem formally_smooth.iff_split_surjection [formally_smooth R P] :\n    formally_smooth R A ↔ ∃ g, f.ker_square_lift.comp g = alg_hom.id R A :=\n  by\n  constructor\n  · intro\n    have surj : function.surjective f.ker_square_lift := fun x => ⟨submodule.quotient.mk (hf x).some, (hf x).some_spec⟩\n    have sqz : ring_hom.ker f.ker_square_lift.to_ring_hom ^ 2 = 0 := by\n      rw [alg_hom.ker_ker_sqare_lift, ideal.cotangent_ideal_square, ideal.zero_eq_bot]\n    refine' ⟨formally_smooth.lift _ ⟨2, sqz⟩ (ideal.quotient_ker_alg_equiv_of_surjective surj).symm.to_alg_hom, _⟩\n    ext x\n    have :=\n      (ideal.quotient_ker_alg_equiv_of_surjective surj).to_alg_hom.congr_arg\n        (formally_smooth.mk_lift _ ⟨2, sqz⟩ (ideal.quotient_ker_alg_equiv_of_surjective surj).symm.to_alg_hom x)\n    dsimp at this\n    rw [alg_equiv.apply_symm_apply] at this\n    conv_rhs => rw [← this, alg_hom.id_apply]\n    obtain ⟨y, e⟩ :=\n      ideal.quotient.mk_surjective\n        (formally_smooth.lift _ ⟨2, sqz⟩ (ideal.quotient_ker_alg_equiv_of_surjective surj).symm.to_alg_hom x)\n    dsimp at e⊢\n    rw [← e]\n    rfl\n  · rintro ⟨g, hg⟩\n    exact formally_smooth.of_split f g hg\n#align formally_smooth.iff_split_surjection formally_smooth.iff_split_surjection\n\n",
 "ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem formally_unramified.ext' [formally_unramified R A] {C : Type u} [CommRing C] (f : «expr →+* » B C)\n    (hf : is_nilpotent f.ker) (g₁ g₂ : «expr →ₐ[ ] » A R B) (h : ∀ x, f (g₁ x) = f (g₂ x)) : g₁ = g₂ :=\n  formally_unramified.lift_unique_of_ring_hom f hf g₁ g₂ (RingHom.ext h)\n#align formally_unramified.ext' formally_unramified.ext'\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem formally_unramified.ext [formally_unramified R A] (hI : is_nilpotent I) {g₁ g₂ : «expr →ₐ[ ] » A R B}\n    (H : ∀ x, ideal.quotient.mk I (g₁ x) = ideal.quotient.mk I (g₂ x)) : g₁ = g₂ :=\n  formally_unramified.lift_unique I hI g₁ g₂ (alg_hom.ext H)\n#align formally_unramified.ext formally_unramified.ext\n\n",
 "exists_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem formally_smooth.exists_lift {B : Type u} [CommRing B] [_RB : algebra R B] [formally_smooth R A] (I : ideal B)\n    (hI : is_nilpotent I) (g : «expr →ₐ[ ] » A R («expr ⧸ » B I)) :\n    ∃ f : «expr →ₐ[ ] » A R B, (ideal.quotient.mkₐ R I).comp f = g :=\n  by\n  revert g\n  change function.surjective (ideal.quotient.mkₐ R I).comp\n  revert _RB\n  apply ideal.is_nilpotent.induction_on I hI\n  · intro B _ I hI _\n    exact formally_smooth.comp_surjective I hI\n  · intro B _ I J hIJ h₁ h₂ _ g\n    let this : «expr ≃ₐ[ ] » («expr ⧸ » («expr ⧸ » B I) (J.map (ideal.quotient.mk I))) R («expr ⧸ » B J) :=\n      { (double_quot.quot_quot_equiv_quot_sup I J).trans (ideal.quot_equiv_of_eq (sup_eq_right.mpr hIJ)) with\n        commutes' := fun x => rfl }\n    obtain ⟨g', e⟩ := h₂ (this.symm.to_alg_hom.comp g)\n    obtain ⟨g', rfl⟩ := h₁ g'\n    replace e := congr_arg this.to_alg_hom.comp e\n    conv_rhs at e =>\n      rw [← alg_hom.comp_assoc, alg_equiv.to_alg_hom_eq_coe, alg_equiv.to_alg_hom_eq_coe, alg_equiv.comp_symm,\n        alg_hom.id_comp]\n    exact ⟨g', e⟩\n#align formally_smooth.exists_lift formally_smooth.exists_lift\n\n",
 "comp_lift_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem formally_smooth.comp_lift_of_surjective [formally_smooth R A] (f : «expr →ₐ[ ] » A R C)\n    (g : «expr →ₐ[ ] » B R C) (hg : function.surjective g) (hg' : is_nilpotent (g : «expr →+* » B C).ker) :\n    g.comp (formally_smooth.lift_of_surjective f g hg hg') = f :=\n  alg_hom.ext (formally_smooth.lift_of_surjective_apply f g hg hg')\n#align formally_smooth.comp_lift_of_surjective formally_smooth.comp_lift_of_surjective\n\n",
 "comp_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp]\ntheorem formally_smooth.comp_lift [formally_smooth R A] (I : ideal B) (hI : is_nilpotent I)\n    (g : «expr →ₐ[ ] » A R («expr ⧸ » B I)) : (ideal.quotient.mkₐ R I).comp (formally_smooth.lift I hI g) = g :=\n  (formally_smooth.exists_lift I hI g).some_spec\n#align formally_smooth.comp_lift formally_smooth.comp_lift\n\n",
 "comp":
 "theorem formally_etale.comp [formally_etale R A] [formally_etale A B] : formally_etale R B :=\n  formally_etale.iff_unramified_and_smooth.mpr ⟨formally_unramified.comp R A B, formally_smooth.comp R A B⟩\n#align formally_etale.comp formally_etale.comp\n\n"}