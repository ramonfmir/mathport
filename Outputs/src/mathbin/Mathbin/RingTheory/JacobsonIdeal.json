{"radical_le_jacobson":
 "theorem radical_le_jacobson : radical I ≤ jacobson I :=\n  le_infₛ fun J hJ => (radical_eq_infₛ I).symm ▸ infₛ_le ⟨hJ.left, IsMaximal.isPrime hJ.right⟩\n#align radical_le_jacobson radical_le_jacobson\n\n",
 "radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The standard radical and Jacobson radical of an ideal `I` of `R` are equal if and only if\nthe nilradical and Jacobson radical of the quotient ring `R/I` coincide -/\ntheorem radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot :\n    I.radical = I.jacobson ↔ radical («expr⊥» : Ideal («expr ⧸ » R I)) = jacobson («expr⊥») :=\n  by\n  have hf : function.surjective (Quotient.mk' I) := Submodule.Quotient.mk_surjective I\n  constructor\n  · intro h\n    have := congr_arg (map (Quotient.mk' I)) h\n    rw [map_radical_of_surjective hf (le_of_eq mk_ker), map_jacobson_of_surjective hf (le_of_eq mk_ker)] at this\n    simpa using this\n  · intro h\n    have := congr_arg (comap (Quotient.mk' I)) h\n    rw [comap_radical, comap_jacobson_of_surjective hf, ← (Quotient.mk' I).ker_eq_comap_bot] at this\n    simpa using this\n#align radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot\n\n",
 "mem_jacobson_or_exists_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_local.mem_jacobson_or_exists_inv {I : Ideal R} (hi : is_local I) (x : R) :\n    x ∈ jacobson I ∨ ∃ y, y * x - 1 ∈ I :=\n  by_cases\n    (fun h : «expr ⊔ » I (span {x}) = «expr⊤» =>\n      let ⟨p, hpi, q, hq, hpq⟩ := Submodule.mem_sup.1 ((eq_top_iff_one _).1 h)\n      let ⟨r, hr⟩ := mem_span_singleton.1 hq\n      or.inr ⟨r, by rw [← hpq, mul_comm, ← hr, ← neg_sub, add_sub_cancel] <;> exact I.neg_mem hpi⟩)\n    fun h : «expr ⊔ » I (span {x}) ≠ «expr⊤» =>\n    or.inl <| le_trans le_sup_right (hi.le_jacobson le_sup_left h) <| mem_span_singleton.2 <| dvd_refl x\n#align is_local.mem_jacobson_or_exists_inv is_local.mem_jacobson_or_exists_inv\n\n",
 "mem_jacobson_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem mem_jacobson_iff {x : R} : x ∈ jacobson I ↔ ∀ y, ∃ z, z * y * x + z - 1 ∈ I :=\n  ⟨fun hx y =>\n    by_cases\n      (fun hxy : «expr ⊔ » I (span {y * x + 1}) = «expr⊤» =>\n        let ⟨p, hpi, q, hq, hpq⟩ := Submodule.mem_sup.1 ((eq_top_iff_one _).1 hxy)\n        let ⟨r, hr⟩ := mem_span_singleton'.1 hq\n        ⟨r, by rw [mul_assoc, ← mul_add_one, hr, ← hpq, ← neg_sub, add_sub_cancel] <;> exact I.neg_mem hpi⟩)\n      fun hxy : «expr ⊔ » I (span {y * x + 1}) ≠ «expr⊤» =>\n      let ⟨M, hm1, hm2⟩ := exists_le_maximal _ hxy\n      suffices x ∉ M from (this <| mem_infₛ.1 hx ⟨le_trans le_sup_left hm2, hm1⟩).elim\n      fun hxm =>\n      hm1.1.1 <|\n        (eq_top_iff_one _).2 <|\n          add_sub_cancel' (y * x) 1 ▸ M.sub_mem (le_sup_right.trans hm2 <| subset_span rfl) (M.mul_mem_left _ hxm),\n    fun hx =>\n    mem_infₛ.2 fun M ⟨him, hm⟩ =>\n      by_contradiction fun hxm =>\n        let ⟨y, i, hi, df⟩ := hm.exists_inv hxm\n        let ⟨z, hz⟩ := hx (-y)\n        hm.1.1 <|\n          (eq_top_iff_one _).2 <|\n            sub_sub_cancel (z * -y * x + z) 1 ▸\n              M.sub_mem\n                (by\n                  rw [mul_assoc, ← mul_add_one, neg_mul, ← sub_eq_iff_eq_add.mpr df.symm, neg_sub, sub_add_cancel]\n                  exact M.mul_mem_left _ hi)\n                (him hz)⟩\n#align mem_jacobson_iff mem_jacobson_iff\n\n",
 "mem_jacobson_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_jacobson_bot {x : R} : x ∈ jacobson («expr⊥» : Ideal R) ↔ ∀ y, IsUnit (x * y + 1) :=\n  ⟨fun hx y =>\n    let ⟨z, hz⟩ := (mem_jacobson_iff.1 hx) y\n    isUnit_iff_exists_inv.2 ⟨z, by rwa [add_mul, one_mul, ← sub_eq_zero, mul_right_comm, mul_comm _ z, mul_right_comm]⟩,\n    fun h =>\n    mem_jacobson_iff.mpr fun y =>\n      let ⟨b, hb⟩ := isUnit_iff_exists_inv.1 (h y)\n      ⟨b, (Submodule.mem_bot R).2 (hb ▸ by ring)⟩⟩\n#align mem_jacobson_bot mem_jacobson_bot\n\n",
 "map_jacobson_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_jacobson_of_surjective {f : «expr →+* » R S} (hf : function.surjective f) :\n    RingHom.ker f ≤ I → map f I.jacobson = (map f I).jacobson :=\n  by\n  intro h\n  unfold ideal.jacobson\n  have : ∀ J ∈ { J : Ideal R | I ≤ J ∧ J.is_maximal }, f.ker ≤ J := fun J hJ => le_trans h hJ.left\n  refine' trans (map_Inf hf this) (le_antisymm _ _)\n  · refine' infₛ_le_infₛ fun J hJ => ⟨comap f J, ⟨⟨le_comap_of_map_le hJ.1, _⟩, map_comap_of_surjective f hf J⟩⟩\n    haveI : J.is_maximal := hJ.right\n    exact comap_is_maximal_of_surjective f hf\n  · refine' infₛ_le_infₛ_of_subset_insert_top fun j hj => hj.rec_on fun J hJ => _\n    rw [← hJ.2]\n    cases' map_eq_top_or_is_maximal_of_surjective f hf hJ.left.right with htop hmax\n    · exact htop.symm ▸ Set.mem_insert («expr⊤») _\n    · exact Set.mem_insert_of_mem («expr⊤») ⟨map_mono hJ.1.1, hmax⟩\n#align map_jacobson_of_surjective map_jacobson_of_surjective\n\n",
 "map_jacobson_of_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_jacobson_of_bijective {f : «expr →+* » R S} (hf : function.bijective f) :\n    map f I.jacobson = (map f I).jacobson :=\n  map_jacobson_of_surjective hf.right (le_trans (le_of_eq (f.injective_iff_ker_eq_bot.1 hf.left)) bot_le)\n#align map_jacobson_of_bijective map_jacobson_of_bijective\n\n",
 "le_jacobson":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_local.le_jacobson {I J : Ideal R} (hi : is_local I) (hij : I ≤ J) (hj : J ≠ «expr⊤») : J ≤ jacobson I :=\n  let ⟨M, hm, hjm⟩ := exists_le_maximal J hj\n  le_trans hjm <| le_of_eq <| Eq.symm <| hi.1.eq_of_le hm.1.1 <| infₛ_le ⟨le_trans hij hjm, hm⟩\n#align is_local.le_jacobson is_local.le_jacobson\n\n",
 "jacobson_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem jacobson_top : jacobson («expr⊤» : Ideal R) = «expr⊤» :=\n  eq_top_iff.2 le_jacobson\n#align jacobson_top jacobson_top\n\n",
 "jacobson_radical_eq_jacobson":
 "theorem jacobson_radical_eq_jacobson : I.radical.jacobson = I.jacobson :=\n  le_antisymm\n    (le_trans (le_of_eq (congr_arg jacobson (radical_eq_infₛ I)))\n      (infₛ_le_infₛ fun J hJ => ⟨infₛ_le ⟨hJ.1, hJ.2.is_prime⟩, hJ.2⟩))\n    (jacobson_mono le_radical)\n#align jacobson_radical_eq_jacobson jacobson_radical_eq_jacobson\n\n",
 "jacobson_mono":
 "@[mono]\ntheorem jacobson_mono {I J : Ideal R} : I ≤ J → I.jacobson ≤ J.jacobson :=\n  by\n  intro h x hx\n  erw [mem_Inf] at hx⊢\n  exact fun K ⟨hK, hK_max⟩ => hx ⟨trans h hK, hK_max⟩\n#align jacobson_mono jacobson_mono\n\n",
 "jacobson_idem":
 "@[simp]\ntheorem jacobson_idem : jacobson (jacobson I) = jacobson I :=\n  le_antisymm (infₛ_le_infₛ fun J hJ => ⟨infₛ_le hJ, hJ.2⟩) le_jacobson\n#align jacobson_idem jacobson_idem\n\n",
 "jacobson_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem jacobson_eq_top_iff : jacobson I = «expr⊤» ↔ I = «expr⊤» :=\n  ⟨fun H =>\n    by_contradiction fun hi =>\n      let ⟨M, hm, him⟩ := exists_le_maximal I hi\n      lt_top_iff_ne_top.1 (lt_of_le_of_lt (show jacobson I ≤ M from infₛ_le ⟨him, hm⟩) <| lt_top_iff_ne_top.2 hm.ne_top)\n        H,\n    fun H => eq_top_iff.2 <| le_infₛ fun J ⟨hij, hj⟩ => H ▸ hij⟩\n#align jacobson_eq_top_iff jacobson_eq_top_iff\n\n",
 "jacobson_eq_self_of_is_maximal":
 "theorem jacobson_eq_self_of_is_maximal [H : IsMaximal I] : I.jacobson = I :=\n  le_antisymm (infₛ_le ⟨le_of_eq rfl, H⟩) le_jacobson\n#align jacobson_eq_self_of_is_maximal jacobson_eq_self_of_is_maximal\n\n",
 "jacobson_eq_iff_jacobson_quotient_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem jacobson_eq_iff_jacobson_quotient_eq_bot :\n    I.jacobson = I ↔ jacobson («expr⊥» : Ideal («expr ⧸ » R I)) = «expr⊥» :=\n  by\n  have hf : function.surjective (Quotient.mk' I) := Submodule.Quotient.mk_surjective I\n  constructor\n  · intro h\n    replace h := congr_arg (map (Quotient.mk' I)) h\n    rw [map_jacobson_of_surjective hf (le_of_eq mk_ker)] at h\n    simpa using h\n  · intro h\n    replace h := congr_arg (comap (Quotient.mk' I)) h\n    rw [comap_jacobson_of_surjective hf, ← (Quotient.mk' I).ker_eq_comap_bot] at h\n    simpa using h\n#align jacobson_eq_iff_jacobson_quotient_eq_bot jacobson_eq_iff_jacobson_quotient_eq_bot\n\n",
 "jacobson_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem jacobson_eq_bot : jacobson I = «expr⊥» → I = «expr⊥» := fun h => eq_bot_iff.mpr (h ▸ le_jacobson)\n#align jacobson_eq_bot jacobson_eq_bot\n\n",
 "jacobson_bot_polynomial_of_jacobson_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem jacobson_bot_polynomial_of_jacobson_bot (h : jacobson («expr⊥» : Ideal R) = «expr⊥») :\n    jacobson («expr⊥» : Ideal (polynomial R)) = «expr⊥» :=\n  by\n  refine' eq_bot_iff.2 (le_trans jacobson_bot_polynomial_le_Inf_map_maximal _)\n  refine' fun f hf => (Submodule.mem_bot _).2 (Polynomial.ext fun n => trans _ (coeff_zero n).symm)\n  suffices f.coeff n ∈ ideal.jacobson («expr⊥») by rwa [h, Submodule.mem_bot] at this\n  exact mem_Inf.2 fun j hj => (mem_map_C_iff.1 ((mem_Inf.1 hf) ⟨j, ⟨hj.2, rfl⟩⟩)) n\n#align jacobson_bot_polynomial_of_jacobson_bot jacobson_bot_polynomial_of_jacobson_bot\n\n",
 "jacobson_bot_polynomial_le_Inf_map_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem jacobson_bot_polynomial_le_Inf_map_maximal :\n    jacobson («expr⊥» : Ideal (polynomial R)) ≤\n      infₛ («expr '' » (map (C : «expr →+* » R (polynomial R))) { J : Ideal R | J.is_maximal }) :=\n  by\n  refine' le_infₛ fun J => exists_imp.2 fun j hj => _\n  haveI : j.is_maximal := hj.1\n  refine' trans (jacobson_mono bot_le) (le_of_eq _ : J.jacobson ≤ J)\n  suffices («expr⊥» : Ideal (Polynomial («expr ⧸ » R j))).jacobson = «expr⊥»\n    by\n    rw [← hj.2, jacobson_eq_iff_jacobson_quotient_eq_bot]\n    replace this := congr_arg (map (polynomial_quotient_equiv_quotient_polynomial j).to_ring_hom) this\n    rwa [map_jacobson_of_bijective _, map_bot] at this\n    exact RingEquiv.bijective (polynomial_quotient_equiv_quotient_polynomial j)\n  refine' eq_bot_iff.2 fun f hf => _\n  simpa [(fun hX => by simpa using congr_arg (fun f => coeff f 1) hX : (X : polynomial («expr ⧸ » R j)) ≠ 0)] using\n    eq_C_of_degree_eq_zero (degree_eq_zero_of_is_unit ((mem_jacobson_bot.1 hf) X))\n#align jacobson_bot_polynomial_le_Inf_map_maximal jacobson_bot_polynomial_le_Inf_map_maximal\n\n",
 "is_unit_of_sub_one_mem_jacobson_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_unit_of_sub_one_mem_jacobson_bot (r : R) (h : r - 1 ∈ jacobson («expr⊥» : Ideal R)) : IsUnit r :=\n  by\n  cases' exists_mul_sub_mem_of_sub_one_mem_jacobson r h with s hs\n  rw [mem_bot, sub_eq_zero, mul_comm] at hs\n  exact isUnit_of_mul_eq_one _ _ hs\n#align is_unit_of_sub_one_mem_jacobson_bot is_unit_of_sub_one_mem_jacobson_bot\n\n",
 "is_radical_of_eq_jacobson":
 "theorem is_radical_of_eq_jacobson (h : jacobson I = I) : I.is_radical :=\n  radical_le_jacobson.trans h.le\n#align is_radical_of_eq_jacobson is_radical_of_eq_jacobson\n\n",
 "is_primary_of_is_maximal_radical":
 "theorem is_primary_of_is_maximal_radical [CommRing R] {I : Ideal R} (hi : IsMaximal (radical I)) : IsPrimary I :=\n  have : radical I = jacobson I :=\n    le_antisymm (le_infₛ fun M ⟨him, hm⟩ => hm.is_prime.radical_le_iff.2 him) (infₛ_le ⟨le_radical, hi⟩)\n  ⟨ne_top_of_lt <| lt_of_le_of_lt le_radical (lt_top_iff_ne_top.2 hi.1.1), fun x y hxy =>\n    ((is_local_of_is_maximal_radical hi).mem_jacobson_or_exists_inv y).symm.imp\n      (fun ⟨z, hz⟩ => by\n        rw [← mul_one x, ← sub_sub_cancel (z * y) 1, mul_sub, mul_left_comm] <;>\n          exact I.sub_mem (I.mul_mem_left _ hxy) (I.mul_mem_left _ hz))\n      (this ▸ id)⟩\n#align is_primary_of_is_maximal_radical is_primary_of_is_maximal_radical\n\n",
 "is_local_of_is_maximal_radical":
 "theorem is_local_of_is_maximal_radical {I : Ideal R} (hi : IsMaximal (radical I)) : is_local I :=\n  ⟨have : radical I = jacobson I :=\n      le_antisymm (le_infₛ fun M ⟨him, hm⟩ => hm.is_prime.radical_le_iff.2 him) (infₛ_le ⟨le_radical, hi⟩)\n    show IsMaximal (jacobson I) from this ▸ hi⟩\n#align is_local_of_is_maximal_radical is_local_of_is_maximal_radical\n\n",
 "is_local_iff":
 "theorem is_local_iff {I : Ideal R} : is_local I ↔ IsMaximal (jacobson I) :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align is_local_iff is_local_iff\n\n",
 "exists_mul_sub_mem_of_sub_one_mem_jacobson":
 "theorem exists_mul_sub_mem_of_sub_one_mem_jacobson {I : Ideal R} (r : R) (h : r - 1 ∈ jacobson I) :\n    ∃ s, s * r - 1 ∈ I := by\n  cases' mem_jacobson_iff.1 h 1 with s hs\n  use s\n  simpa [mul_sub] using hs\n#align exists_mul_sub_mem_of_sub_one_mem_jacobson exists_mul_sub_mem_of_sub_one_mem_jacobson\n\n",
 "eq_jacobson_iff_not_mem":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » I) -/\n/-- An ideal `I` equals its Jacobson radical if and only if every element outside `I`\nalso lies outside of a maximal ideal containing `I`. -/\ntheorem eq_jacobson_iff_not_mem : I.jacobson = I ↔ ∀ (x) (_ : x ∉ I), ∃ M : Ideal R, (I ≤ M ∧ M.is_maximal) ∧ x ∉ M :=\n  by\n  constructor\n  · intro h x hx\n    erw [← h, mem_Inf] at hx\n    push_neg  at hx\n    exact hx\n  · refine' fun h => le_antisymm (fun x hx => _) le_jacobson\n    contrapose hx\n    erw [mem_Inf]\n    push_neg\n    exact h x hx\n#align eq_jacobson_iff_not_mem eq_jacobson_iff_not_mem\n\n",
 "eq_jacobson_iff_Inf_maximal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_jacobson_iff_Inf_maximal' :\n    I.jacobson = I ↔ ∃ M : Set (Ideal R), (∀ J ∈ M, ∀ (K : Ideal R), J < K → K = «expr⊤») ∧ I = infₛ M :=\n  eq_jacobson_iff_Inf_maximal.trans\n    ⟨fun h =>\n      let ⟨M, hM⟩ := h\n      ⟨M,\n        ⟨fun J hJ K hK => or.rec_on (hM.1 J hJ) (fun h => h.1.2 K hK) fun h => eq_top_iff.2 (le_of_lt (h ▸ hK)), hM.2⟩⟩,\n      fun h =>\n      let ⟨M, hM⟩ := h\n      ⟨M,\n        ⟨fun J hJ => or.rec_on (classical.em (J = «expr⊤»)) (fun h => or.inr h) fun h => or.inl ⟨⟨h, hM.1 J hJ⟩⟩,\n          hM.2⟩⟩⟩\n#align eq_jacobson_iff_Inf_maximal' eq_jacobson_iff_Inf_maximal'\n\n",
 "eq_jacobson_iff_Inf_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- An ideal equals its Jacobson radical iff it is the intersection of a set of maximal ideals.\nAllowing the set to include ⊤ is equivalent, and is included only to simplify some proofs. -/\ntheorem eq_jacobson_iff_Inf_maximal :\n    I.jacobson = I ↔ ∃ M : Set (Ideal R), (∀ J ∈ M, IsMaximal J ∨ J = «expr⊤») ∧ I = infₛ M :=\n  by\n  use fun hI => ⟨{ J : Ideal R | I ≤ J ∧ J.is_maximal }, ⟨fun _ hJ => or.inl hJ.right, hI.symm⟩⟩\n  rintro ⟨M, hM, hInf⟩\n  refine' le_antisymm (fun x hx => _) le_jacobson\n  rw [hInf, mem_Inf]\n  intro I hI\n  cases' hM I hI with is_max is_top\n  · exact (mem_Inf.1 hx) ⟨le_infₛ_iff.1 (le_of_eq hInf) I hI, IsMax⟩\n  · exact is_top.symm ▸ Submodule.mem_top\n#align eq_jacobson_iff_Inf_maximal eq_jacobson_iff_Inf_maximal\n\n",
 "comap_jacobson_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_jacobson_of_surjective {f : «expr →+* » R S} (hf : function.surjective f) {K : Ideal S} :\n    comap f K.jacobson = (comap f K).jacobson := by\n  unfold ideal.jacobson\n  refine' le_antisymm _ _\n  · refine' le_trans (comap_mono (le_of_eq (trans top_inf_eq.symm Inf_insert.symm))) _\n    rw [comap_Inf', infₛ_eq_infᵢ]\n    refine' infᵢ_le_infᵢ_of_subset fun J hJ => _\n    have : comap f (map f J) = J :=\n      trans (comap_map_of_surjective f hf J)\n        (le_antisymm (sup_le_iff.2 ⟨le_of_eq rfl, le_trans (comap_mono bot_le) hJ.left⟩) le_sup_left)\n    cases' map_eq_top_or_is_maximal_of_surjective _ hf hJ.right with htop hmax\n    · refine' ⟨«expr⊤», ⟨Set.mem_insert («expr⊤») _, htop ▸ this⟩⟩\n    · refine' ⟨map f J, ⟨Set.mem_insert_of_mem _ ⟨le_map_of_comap_le_of_surjective f hf hJ.1, hmax⟩, this⟩⟩\n  · rw [comap_Inf]\n    refine' le_infᵢ_iff.2 fun J => le_infᵢ_iff.2 fun hJ => _\n    haveI : J.is_maximal := hJ.right\n    refine' infₛ_le ⟨comap_mono hJ.left, comap_is_maximal_of_surjective _ hf⟩\n#align comap_jacobson_of_surjective comap_jacobson_of_surjective\n\n",
 "comap_jacobson":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem comap_jacobson {f : «expr →+* » R S} {K : Ideal S} :\n    comap f K.jacobson = infₛ («expr '' » (comap f) { J : Ideal S | K ≤ J ∧ J.is_maximal }) :=\n  trans (comap_infₛ' f _) infₛ_eq_infᵢ.symm\n#align comap_jacobson comap_jacobson\n\n"}