{"to_subtype_range'":
 "theorem algebraic_independent.to_subtype_range' {ι} {f : ι → A} (hf : algebraic_independent R f) {t}\n    (ht : range f = t) : algebraic_independent R (coe : t → A) :=\n  ht ▸ hf.to_subtype_range\n#align algebraic_independent.to_subtype_range' algebraic_independent.to_subtype_range'\n\n",
 "to_subtype_range":
 "theorem algebraic_independent.to_subtype_range {ι} {f : ι → A} (hf : algebraic_independent R f) :\n    algebraic_independent R (coe : range f → A) := by\n  nontriviality R\n  · rwa [algebraic_independent_subtype_range hf.injective]\n#align algebraic_independent.to_subtype_range algebraic_independent.to_subtype_range\n\n",
 "restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- A set of algebraically independent elements in an algebra `A` over a ring `K` is also\nalgebraically independent over a subring `R` of `K`. -/\ntheorem algebraic_independent.restrict_scalars {K : Type _} [CommRing K] [algebra R K] [algebra K A]\n    [IsScalarTower R K A] (hinj : function.injective (algebra_map R K)) (ai : algebraic_independent K x) :\n    algebraic_independent R x :=\n  by\n  have :\n    (aeval x : «expr →ₐ[ ] » (mv_polynomial ι K) K A).to_ring_hom.comp (mv_polynomial.map (algebra_map R K)) =\n      (aeval x : «expr →ₐ[ ] » (mv_polynomial ι R) R A).to_ring_hom :=\n    by ext <;> simp [algebra_map_eq_smul_one]\n  show injective (aeval x).to_ring_hom\n  rw [← this]\n  exact injective.comp ai (mv_polynomial.map_injective _ hinj)\n#align algebraic_independent.restrict_scalars algebraic_independent.restrict_scalars\n\n",
 "restrict_of_comp_subtype":
 "theorem algebraic_independent.restrict_of_comp_subtype {s : set ι} (hs : algebraic_independent R (x ∘ coe : s → A)) :\n    algebraic_independent R (s.restrict x) :=\n  hs\n#align algebraic_independent.restrict_of_comp_subtype algebraic_independent.restrict_of_comp_subtype\n\n",
 "repr_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem algebraic_independent.repr_ker :\n    (hx.repr : «expr →+* » (adjoin R (range x)) (mv_polynomial ι R)).ker = «expr⊥» :=\n  (ring_hom.injective_iff_ker_eq_bot _).1 (alg_equiv.injective _)\n#align algebraic_independent.repr_ker algebraic_independent.repr_ker\n\n",
 "option_iff":
 "theorem algebraic_independent.option_iff (hx : algebraic_independent R x) (a : A) :\n    (algebraic_independent R fun o : option ι => o.elim a x) ↔ ¬is_algebraic (adjoin R (Set.range x)) a := by\n  erw [algebraic_independent_iff_injective_aeval, is_algebraic_iff_not_injective, not_not, ← alg_hom.coe_to_ring_hom, ←\n    hx.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin, RingHom.coe_comp,\n    injective.of_comp_iff' _ (RingEquiv.bijective _), alg_hom.coe_to_ring_hom]\n#align algebraic_independent.option_iff algebraic_independent.option_iff\n\n",
 "of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_comp (f : «expr →ₐ[ ] » A R A') (hfv : algebraic_independent R (f ∘ x)) : algebraic_independent R x :=\n  by\n  have : aeval (f ∘ x) = f.comp (aeval x) := by ext <;> simp\n  rw [algebraic_independent, this] at hfv <;> exact hfv.of_comp\n#align of_comp of_comp\n\n",
 "ne_zero":
 "theorem ne_zero [nontrivial R] (i : ι) : x i ≠ 0 :=\n  hx.linear_independent.ne_zero i\n#align ne_zero ne_zero\n\n",
 "mv_polynomial_option_equiv_polynomial_adjoin_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n-- TODO - make this an `alg_equiv`\n@[simp]\ntheorem algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply (hx : algebraic_independent R x) (y) :\n    hx.mv_polynomial_option_equiv_polynomial_adjoin y =\n      polynomial.map (hx.aeval_equiv : «expr →+* » (mv_polynomial ι R) (adjoin R (range x)))\n        (aeval (fun o : option ι => o.elim polynomial.X fun s : ι => polynomial.C (X s)) y) :=\n  rfl\n#align\n  algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply\n\n",
 "mv_polynomial_option_equiv_polynomial_adjoin_X_some":
 "@[simp]\ntheorem algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_some (hx : algebraic_independent R x) (i) :\n    hx.mv_polynomial_option_equiv_polynomial_adjoin (X (some i)) = polynomial.C (hx.aeval_equiv (X i)) := by\n  rw [algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply, aeval_X, Option.elim', polynomial.map_C,\n    RingHom.coe_coe]\n#align\n  algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_some algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_some\n\n",
 "mv_polynomial_option_equiv_polynomial_adjoin_X_none":
 "@[simp]\ntheorem algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_none (hx : algebraic_independent R x) :\n    hx.mv_polynomial_option_equiv_polynomial_adjoin (X none) = polynomial.X := by\n  rw [algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply, aeval_X, Option.elim', polynomial.map_X]\n#align\n  algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_none algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_none\n\n",
 "mv_polynomial_option_equiv_polynomial_adjoin_C":
 "@[simp]\ntheorem algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_C (hx : algebraic_independent R x) (r) :\n    hx.mv_polynomial_option_equiv_polynomial_adjoin (C r) = polynomial.C (algebra_map _ _ r) :=\n  by\n  -- TODO: this instance is slow to infer\n  have h : IsScalarTower R (mv_polynomial ι R) (polynomial (mv_polynomial ι R)) :=\n    @polynomial.is_scalar_tower (mv_polynomial ι R) _ R _ _ _ _ _ _ _\n  rw [algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply, aeval_C,\n    @is_scalar_tower.algebra_map_apply _ _ _ _ _ _ _ _ _ h, ← polynomial.C_eq_algebra_map, polynomial.map_C,\n    RingHom.coe_coe, alg_equiv.commutes]\n#align\n  algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_C algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_C\n\n",
 "mono":
 "theorem algebraic_independent.mono {t s : set A} (h : t ⊆ s) (hx : algebraic_independent R (fun x => x : s → A)) :\n    algebraic_independent R (fun x => x : t → A) := by\n  simpa [function.comp] using hx.comp (inclusion h) (inclusion_injective h)\n#align algebraic_independent.mono algebraic_independent.mono\n\n",
 "map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map' {f : «expr →ₐ[ ] » A R A'} (hf_inj : injective f) : algebraic_independent R (f ∘ x) :=\n  hx.map (injOn_of_injective hf_inj _)\n#align map' map'\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map {f : «expr →ₐ[ ] » A R A'} (hf_inj : Set.InjOn f (adjoin R (range x))) : algebraic_independent R (f ∘ x) :=\n  by\n  have : aeval (f ∘ x) = f.comp (aeval x) := by ext <;> simp\n  have h : ∀ p : mv_polynomial ι R, aeval x p ∈ (@aeval R _ _ _ _ _ (coe : range x → A)).range :=\n    by\n    intro p\n    rw [alg_hom.mem_range]\n    refine' ⟨mv_polynomial.rename (cod_restrict x (range x) mem_range_self) p, _⟩\n    simp [function.comp, aeval_rename]\n  intro x y hxy\n  rw [this] at hxy\n  rw [adjoin_eq_range] at hf_inj\n  exact hx (hf_inj (h x) (h y) hxy)\n#align map map\n\n",
 "linear_independent":
 "theorem linear_independent : linear_independent R x :=\n  by\n  rw [linear_independent_iff_injective_total]\n  have : finsupp.total ι A R x = (mv_polynomial.aeval x).to_linear_map.comp (finsupp.total ι _ R X) :=\n    by\n    ext\n    simp\n  rw [this]\n  refine' hx.comp _\n  rw [← linear_independent_iff_injective_total]\n  exact linear_independent_X _ _\n#align linear_independent linear_independent\n\n",
 "is_transcendence_basis_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem algebraic_independent.is_transcendence_basis_iff {ι : Type w} {R : Type u} [CommRing R] [nontrivial R]\n    {A : Type v} [CommRing A] [algebra R A] {x : ι → A} (i : algebraic_independent R x) :\n    is_transcendence_basis R x ↔\n      ∀ (κ : Type v) (w : κ → A) (i' : algebraic_independent R w) (j : ι → κ) (h : w ∘ j = x), surjective j :=\n  by\n  fconstructor\n  · rintro p κ w i' j rfl\n    have p := p.2 (range w) i'.coe_range (range_comp_subset_range _ _)\n    rw [range_comp, ← @image_univ _ _ w] at p\n    exact range_iff_surjective.mp (image_injective.mpr i'.injective p)\n  · intro p\n    use i\n    intro w i' h\n    specialize\n      p w (coe : w → A) i' (fun i => ⟨x i, range_subset_iff.mp h i⟩)\n        (by\n          ext\n          simp)\n    have q := congr_arg (fun s => «expr '' » (coe : w → A) s) p.range_eq\n    dsimp at q\n    rw [← image_univ, image_image] at q\n    simpa using q\n#align algebraic_independent.is_transcendence_basis_iff algebraic_independent.is_transcendence_basis_iff\n\n",
 "is_algebraic":
 "theorem is_transcendence_basis.is_algebraic [nontrivial R] (hx : is_transcendence_basis R x) :\n    is_algebraic (adjoin R (range x)) A := by\n  intro a\n  rw [← not_iff_comm.1 (hx.1.option_iff _).symm]\n  intro ai\n  have h₁ : range x ⊆ range fun o : option ι => o.elim a x :=\n    by\n    rintro x ⟨y, rfl⟩\n    exact ⟨some y, rfl⟩\n  have h₂ : range x ≠ range fun o : option ι => o.elim a x :=\n    by\n    intro h\n    have : a ∈ range x := by\n      rw [h]\n      exact ⟨none, rfl⟩\n    rcases this with ⟨b, rfl⟩\n    have : some b = none := ai.injective rfl\n    simpa\n  exact\n    h₂ (hx.2 (Set.range fun o : option ι => o.elim a x) ((algebraic_independent_subtype_range ai.injective).2 ai) h₁)\n#align is_transcendence_basis.is_algebraic is_transcendence_basis.is_algebraic\n\n",
 "injective":
 "protected theorem injective [nontrivial R] : injective x :=\n  hx.linear_independent.injective\n#align injective injective\n\n",
 "image_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem algebraic_independent.image_of_comp {ι ι'} (s : set ι) (f : ι → ι') (g : ι' → A)\n    (hs : algebraic_independent R fun x : s => g (f x)) : algebraic_independent R fun x : «expr '' » f s => g x :=\n  by\n  nontriviality R\n  have : inj_on f s := inj_on_iff_injective.2 hs.injective.of_comp\n  exact (algebraic_independent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs\n#align algebraic_independent.image_of_comp algebraic_independent.image_of_comp\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem algebraic_independent.image {ι} {s : set ι} {f : ι → A} (hs : algebraic_independent R fun x : s => f x) :\n    algebraic_independent R fun x : «expr '' » f s => (x : A) := by\n  convert algebraic_independent.image_of_comp s f id hs\n#align algebraic_independent.image algebraic_independent.image\n\n",
 "exists_maximal_algebraic_independent":
 "theorem exists_maximal_algebraic_independent (s t : set A) (hst : s ⊆ t) (hs : algebraic_independent R (coe : s → A)) :\n    ∃ u : set A,\n      algebraic_independent R (coe : u → A) ∧\n        s ⊆ u ∧ u ⊆ t ∧ ∀ x : set A, algebraic_independent R (coe : x → A) → u ⊆ x → x ⊆ t → x = u :=\n  by\n  rcases zorn_subset_nonempty { u : set A | algebraic_independent R (coe : u → A) ∧ s ⊆ u ∧ u ⊆ t }\n      (fun c hc chainc hcn =>\n        ⟨⋃₀ c,\n          by\n          refine' ⟨⟨algebraic_independent_sUnion_of_directed hcn chainc.directed_on fun a ha => (hc ha).1, _, _⟩, _⟩\n          · cases' hcn with x hx\n            exact subset_sUnion_of_subset _ x (hc hx).2.1 hx\n          · exact sUnion_subset fun x hx => (hc hx).2.2\n          · intro s\n            exact subset_sUnion_of_mem⟩)\n      s ⟨hs, Set.Subset.refl s, hst⟩ with\n    ⟨u, ⟨huai, hsu, hut⟩, hsu, hx⟩\n  use u, huai, hsu, hut\n  intro x hxai huv hxt\n  exact hx _ ⟨hxai, trans hsu huv, hxt⟩ huv\n#align exists_maximal_algebraic_independent exists_maximal_algebraic_independent\n\n",
 "exists_is_transcendence_basis":
 "theorem exists_is_transcendence_basis (h : injective (algebra_map R A)) :\n    ∃ s : set A, is_transcendence_basis R (coe : s → A) :=\n  by\n  cases'\n    exists_maximal_algebraic_independent (∅ : set A) Set.univ (Set.subset_univ _)\n      ((algebraic_independent_empty_iff R A).2 h) with\n    s hs\n  use s, hs.1\n  intro t ht hr\n  simp only [Subtype.range_coe_subtype, set_of_mem_eq] at *\n  exact eq.symm (hs.2.2.2 t ht hr (Set.subset_univ _))\n#align exists_is_transcendence_basis exists_is_transcendence_basis\n\n",
 "eq_zero_of_aeval_eq_zero":
 "theorem algebraic_independent.eq_zero_of_aeval_eq_zero (h : algebraic_independent R x) :\n    ∀ p : mv_polynomial ι R, mv_polynomial.aeval (x : ι → A) p = 0 → p = 0 :=\n  algebraic_independent_iff.1 h\n#align algebraic_independent.eq_zero_of_aeval_eq_zero algebraic_independent.eq_zero_of_aeval_eq_zero\n\n",
 "comp":
 "theorem comp (f : ι' → ι) (hf : function.injective f) : algebraic_independent R (x ∘ f) := fun p q => by\n  simpa [aeval_rename, (rename_injective f hf).eq_iff] using @hx (rename f p) (rename f q)\n#align comp comp\n\n",
 "coe_range":
 "theorem coe_range : algebraic_independent R (coe : range x → A) := by\n  simpa using hx.comp _ (range_splitting_injective x)\n#align coe_range coe_range\n\n",
 "algebraic_independent_subtype_range":
 "theorem algebraic_independent_subtype_range {ι} {f : ι → A} (hf : injective f) :\n    algebraic_independent R (coe : range f → A) ↔ algebraic_independent R f :=\n  iff.symm <| algebraic_independent_equiv' (Equiv.ofInjective f hf) rfl\n#align algebraic_independent_subtype_range algebraic_independent_subtype_range\n\n",
 "algebraic_independent_subtype":
 "theorem algebraic_independent_subtype {s : set A} :\n    algebraic_independent R (fun x => x : s → A) ↔\n      ∀ p : mv_polynomial A R, p ∈ mv_polynomial.supported R s → aeval id p = 0 → p = 0 :=\n  by apply @algebraic_independent_comp_subtype _ _ _ id\n#align algebraic_independent_subtype algebraic_independent_subtype\n\n",
 "algebraic_independent_sUnion_of_directed":
 "theorem algebraic_independent_sUnion_of_directed {s : set (set A)} (hsn : s.nonempty) (hs : DirectedOn (· ⊆ ·) s)\n    (h : ∀ a ∈ s, algebraic_independent R (fun x => x : (a : set A) → A)) :\n    algebraic_independent R (fun x => x : ⋃₀ s → A) := by\n  letI : nonempty s := nonempty.to_subtype hsn <;> rw [sUnion_eq_Union] <;>\n    exact algebraic_independent_Union_of_directed hs.directed_coe (by simpa using h)\n#align algebraic_independent_sUnion_of_directed algebraic_independent_sUnion_of_directed\n\n",
 "algebraic_independent_of_subsingleton":
 "@[nontriviality]\ntheorem algebraic_independent_of_subsingleton [subsingleton R] : algebraic_independent R x :=\n  algebraic_independent_iff.2 fun l hl => subsingleton.elim _ _\n#align algebraic_independent_of_subsingleton algebraic_independent_of_subsingleton\n\n",
 "algebraic_independent_of_finite":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem algebraic_independent_of_finite (s : set A)\n    (H : ∀ (t) (_ : t ⊆ s), t.finite → algebraic_independent R (fun x => x : t → A)) :\n    algebraic_independent R (fun x => x : s → A) :=\n  algebraic_independent_subtype.2 fun p hp =>\n    algebraic_independent_subtype.1 (H _ (mem_supported.1 hp) (finset.finite_to_set _)) _ (by simp)\n#align algebraic_independent_of_finite algebraic_independent_of_finite\n\n",
 "algebraic_independent_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem algebraic_independent_image {ι} {s : set ι} {f : ι → A} (hf : Set.InjOn f s) :\n    (algebraic_independent R fun x : s => f x) ↔ algebraic_independent R fun x : «expr '' » f s => (x : A) :=\n  algebraic_independent_equiv' (Equiv.Set.imageOfInjOn _ _ hf) rfl\n#align algebraic_independent_image algebraic_independent_image\n\n",
 "algebraic_independent_iff_ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-\nCopyright (c) 2021 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\ntheorem algebraic_independent_iff_ker_eq_bot :\n    algebraic_independent R x ↔\n      (mv_polynomial.aeval x : «expr →ₐ[ ] » (mv_polynomial ι R) R A).to_ring_hom.ker = «expr⊥» :=\n  ring_hom.injective_iff_ker_eq_bot _\n#align algebraic_independent_iff_ker_eq_bot algebraic_independent_iff_ker_eq_bot\n\n",
 "algebraic_independent_iff_injective_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem algebraic_independent_iff_injective_aeval :\n    algebraic_independent R x ↔ injective (mv_polynomial.aeval x : «expr →ₐ[ ] » (mv_polynomial ι R) R A) :=\n  iff.rfl\n#align algebraic_independent_iff_injective_aeval algebraic_independent_iff_injective_aeval\n\n",
 "algebraic_independent_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem alg_hom.algebraic_independent_iff (f : «expr →ₐ[ ] » A R A') (hf : injective f) :\n    algebraic_independent R (f ∘ x) ↔ algebraic_independent R x :=\n  ⟨fun h => h.of_comp f, fun h => h.map (injOn_of_injective hf _)⟩\n#align alg_hom.algebraic_independent_iff alg_hom.algebraic_independent_iff\n\n",
 "algebraic_independent_finset_map_embedding_subtype":
 "/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem algebraic_independent_finset_map_embedding_subtype (s : set A) (li : algebraic_independent R (coe : s → A))\n    (t : Finset s) : algebraic_independent R (coe : Finset.map (Embedding.subtype s) t → A) :=\n  by\n  let f : t.map (embedding.subtype s) → s := fun x =>\n    ⟨x.1, by\n      obtain ⟨x, h⟩ := x\n      rw [Finset.mem_map] at h\n      obtain ⟨a, ha, rfl⟩ := h\n      simp only [subtype.coe_prop, embedding.coe_subtype]⟩\n  convert algebraic_independent.comp li f _\n  rintro ⟨x, hx⟩ ⟨y, hy⟩\n  rw [Finset.mem_map] at hx hy\n  obtain ⟨a, ha, rfl⟩ := hx\n  obtain ⟨b, hb, rfl⟩ := hy\n  simp only [imp_self, subtype.mk_eq_mk]\n#align algebraic_independent_finset_map_embedding_subtype algebraic_independent_finset_map_embedding_subtype\n\n",
 "algebraic_independent_equiv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem algebraic_independent_equiv' (e : «expr ≃ » ι ι') {f : ι' → A} {g : ι → A} (h : f ∘ e = g) :\n    algebraic_independent R g ↔ algebraic_independent R f :=\n  h ▸ algebraic_independent_equiv e\n#align algebraic_independent_equiv' algebraic_independent_equiv'\n\n",
 "algebraic_independent_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem algebraic_independent_equiv (e : «expr ≃ » ι ι') {f : ι' → A} :\n    algebraic_independent R (f ∘ e) ↔ algebraic_independent R f :=\n  ⟨fun h => function.comp.right_id f ▸ e.self_comp_symm ▸ h.comp _ e.symm.injective, fun h => h.comp _ e.injective⟩\n#align algebraic_independent_equiv algebraic_independent_equiv\n\n",
 "algebraic_independent_empty_type_iff":
 "@[simp]\ntheorem algebraic_independent_empty_type_iff [is_empty ι] : algebraic_independent R x ↔ injective (algebra_map R A) :=\n  by\n  have : aeval x = (algebra.of_id R A).comp (@is_empty_alg_equiv R ι _ _).to_alg_hom :=\n    by\n    ext i\n    exact is_empty.elim' ‹is_empty ι› i\n  rw [algebraic_independent, this, ← injective.of_comp_iff' _ (@is_empty_alg_equiv R ι _ _).bijective]\n  rfl\n#align algebraic_independent_empty_type_iff algebraic_independent_empty_type_iff\n\n",
 "algebraic_independent_empty_type":
 "@[simp]\ntheorem algebraic_independent_empty_type [is_empty ι] [nontrivial A] : algebraic_independent K x :=\n  by\n  rw [algebraic_independent_empty_type_iff]\n  exact RingHom.injective _\n#align algebraic_independent_empty_type algebraic_independent_empty_type\n\n",
 "algebraic_independent_empty_iff":
 "theorem algebraic_independent_empty_iff :\n    algebraic_independent R (fun x => x : (∅ : set A) → A) ↔ injective (algebra_map R A) := by simp\n#align algebraic_independent_empty_iff algebraic_independent_empty_iff\n\n",
 "algebraic_independent_empty":
 "theorem algebraic_independent_empty [nontrivial A] : algebraic_independent K (coe : (∅ : set A) → A) :=\n  algebraic_independent_empty_type\n#align algebraic_independent_empty algebraic_independent_empty\n\n",
 "algebraic_independent_comp_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem algebraic_independent_comp_subtype {s : set ι} :\n    algebraic_independent R (x ∘ coe : s → A) ↔ ∀ p ∈ mv_polynomial.supported R s, aeval x p = 0 → p = 0 :=\n  by\n  have : (aeval (x ∘ coe : s → A) : «expr →ₐ[ ] » _ R _) = (aeval x).comp (rename coe) := by ext <;> simp\n  have : ∀ p : mv_polynomial s R, rename (coe : s → ι) p = 0 ↔ p = 0 :=\n    (injective_iff_map_eq_zero' (rename (coe : s → ι) : «expr →ₐ[ ] » (mv_polynomial s R) R _).to_ring_hom).1\n      (rename_injective _ subtype.val_injective)\n  simp [algebraic_independent_iff, supported_eq_range_rename, *]\n#align algebraic_independent_comp_subtype algebraic_independent_comp_subtype\n\n",
 "algebraic_independent_bounded_of_finset_algebraic_independent_bounded":
 "/-- If every finite set of algebraically independent element has cardinality at most `n`,\nthen the same is true for arbitrary sets of algebraically independent elements.\n-/\ntheorem algebraic_independent_bounded_of_finset_algebraic_independent_bounded {n : ℕ}\n    (H : ∀ s : Finset A, (algebraic_independent R fun i : s => (i : A)) → s.card ≤ n) :\n    ∀ s : set A, algebraic_independent R (coe : s → A) → cardinal.mk s ≤ n :=\n  by\n  intro s li\n  apply cardinal.card_le_of\n  intro t\n  rw [← finset.card_map (embedding.subtype s)]\n  apply H\n  apply algebraic_independent_finset_map_embedding_subtype _ li\n#align\n  algebraic_independent_bounded_of_finset_algebraic_independent_bounded algebraic_independent_bounded_of_finset_algebraic_independent_bounded\n\n",
 "algebraic_independent_adjoin":
 "theorem algebraic_independent_adjoin (hs : algebraic_independent R x) :\n    @algebraic_independent ι R (adjoin R (range x)) (fun i : ι => ⟨x i, subset_adjoin (mem_range_self i)⟩) _ _ _ :=\n  algebraic_independent.of_comp (adjoin R (range x)).val hs\n#align algebraic_independent_adjoin algebraic_independent_adjoin\n\n",
 "algebraic_independent_Union_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem algebraic_independent_Union_of_directed {η : Type _} [nonempty η] {s : η → set A} (hs : Directed (· ⊆ ·) s)\n    (h : ∀ i, algebraic_independent R (fun x => x : s i → A)) :\n    algebraic_independent R\n      (fun x => x :\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) → A) :=\n  by\n  refine'\n    algebraic_independent_of_finite\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n      fun t ht ft => _\n  rcases finite_subset_Union ft ht with ⟨I, fi, hI⟩\n  rcases hs.finset_le fi.to_finset with ⟨i, hi⟩\n  exact (h i).mono (subset.trans hI <| Union₂_subset fun j hj => hi j (fi.mem_to_finset.2 hj))\n#align algebraic_independent_Union_of_directed algebraic_independent_Union_of_directed\n\n",
 "algebra_map_injective":
 "theorem algebra_map_injective : injective (algebra_map R A) := by\n  simpa [← mv_polynomial.algebra_map_eq, function.comp] using\n    (injective.of_comp_iff (algebraic_independent_iff_injective_aeval.1 hx) mv_polynomial.C).2\n      (mv_polynomial.C_injective _ _)\n#align algebra_map_injective algebra_map_injective\n\n",
 "algebra_map_aeval_equiv":
 "@[simp]\ntheorem algebraic_independent.algebra_map_aeval_equiv (hx : algebraic_independent R x) (p : mv_polynomial ι R) :\n    algebra_map (algebra.adjoin R (range x)) A (hx.aeval_equiv p) = aeval x p :=\n  rfl\n#align algebraic_independent.algebra_map_aeval_equiv algebraic_independent.algebra_map_aeval_equiv\n\n",
 "aeval_repr":
 "@[simp]\ntheorem algebraic_independent.aeval_repr (p) : aeval x (hx.repr p) = p :=\n  subtype.ext_iff.1 (alg_equiv.apply_symm_apply hx.aeval_equiv p)\n#align algebraic_independent.aeval_repr algebraic_independent.aeval_repr\n\n",
 "aeval_comp_repr":
 "theorem algebraic_independent.aeval_comp_repr : (aeval x).comp hx.repr = subalgebra.val _ :=\n  alg_hom.ext <| hx.aeval_repr\n#align algebraic_independent.aeval_comp_repr algebraic_independent.aeval_comp_repr\n\n",
 "aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem algebraic_independent.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin (hx : algebraic_independent R x)\n    (a : A) :\n    RingHom.comp\n        (↑(polynomial.aeval a : «expr →ₐ[ ] » (polynomial (adjoin R (Set.range x))) _ A) :\n          «expr →+* » (polynomial (adjoin R (Set.range x))) A)\n        hx.mv_polynomial_option_equiv_polynomial_adjoin.to_ring_hom =\n      ↑(mv_polynomial.aeval fun o : option ι => o.elim a x : «expr →ₐ[ ] » (mv_polynomial (option ι) R) R A) :=\n  by\n  refine' mv_polynomial.ring_hom_ext _ _ <;>\n    simp only [RingHom.comp_apply, RingEquiv.toRingHom_eq_coe, RingEquiv.coe_toRingHom, alg_hom.coe_to_ring_hom,\n      alg_hom.coe_to_ring_hom]\n  · intro r\n    rw [hx.mv_polynomial_option_equiv_polynomial_adjoin_C, aeval_C, polynomial.aeval_C,\n      is_scalar_tower.algebra_map_apply R (adjoin R (range x)) A]\n  · rintro (⟨⟩ | ⟨i⟩)\n    · rw [hx.mv_polynomial_option_equiv_polynomial_adjoin_X_none, aeval_X, polynomial.aeval_X, Option.elim']\n    ·\n      rw [hx.mv_polynomial_option_equiv_polynomial_adjoin_X_some, polynomial.aeval_C, hx.algebra_map_aeval_equiv,\n        aeval_X, aeval_X, Option.elim']\n#align\n  algebraic_independent.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin algebraic_independent.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin\n\n"}