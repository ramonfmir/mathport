{"to_matrix_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Let `B B' : power_basis K S` be such that `is_integral R B.gen`, and let `P : R[X]` be such that\n`aeval B.gen P = B'.gen`. Then `is_integral R (B.basis.to_matrix B'.basis i j)` for all `i` and `j`\nif `minpoly K B.gen = (minpoly R B.gen).map (algebra_map R L)`. This is the case\nif `R` is a GCD domain and `K` is its fraction ring. -/\ntheorem to_matrix_is_integral {B B' : power_basis K S} {P : polynomial R} (h : aeval B.gen P = B'.gen)\n    (hB : is_integral R B.gen) (hmin : minpoly K B.gen = (minpoly R B.gen).map (algebraMap R K)) :\n    ∀ i j, is_integral R (B.basis.to_matrix B'.basis i j) :=\n  by\n  intro i j\n  rw [B.basis.to_matrix_apply, B'.coe_basis]\n  refine' repr_pow_is_integral hB (fun i => _) hmin _ _\n  rw [← h, aeval_eq_sum_range, LinearEquiv.map_sum, Finset.sum_apply']\n  refine' is_integral.sum _ fun n hn => _\n  rw [Algebra.smul_def, IsScalarTower.algebraMap_apply R K S, ← Algebra.smul_def, LinearEquiv.map_smul, algebraMap_smul]\n  exact is_integral_smul _ (repr_gen_pow_is_integral hB hmin _ _)\n#align to_matrix_is_integral to_matrix_is_integral\n\n",
 "repr_pow_is_integral":
 "/-- Let `B : power_basis S A` be such that `is_integral R B.gen`, and let `x : A` be and element\nwith integral coordinates in the base `B.basis`. Then `is_integral R ((B.basis.repr (x ^ n) i)` for\nall `i` and all `n` if `minpoly S B.gen = (minpoly R B.gen).map (algebra_map R S)`. This is the case\nif `R` is a GCD domain and `S` is its fraction ring. -/\ntheorem repr_pow_is_integral [IsDomain S] {x : A} (hx : ∀ i, is_integral R (B.basis.repr x i))\n    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) (n : ℕ) :\n    ∀ i, is_integral R (B.basis.repr (x ^ n) i) :=\n  by\n  nontriviality A using subsingleton.elim (x ^ n) 0, is_integral_zero\n  revert hx\n  refine' nat.case_strong_induction_on n _ fun n hn => _\n  · intro hx i\n    rw [pow_zero, ← pow_zero B.gen, ← Fin.val_mk B.dim_pos, ← B.basis_eq_pow, B.basis.repr_self_apply]\n    split_ifs\n    · exact is_integral_one\n    · exact is_integral_zero\n  · intro hx\n    rw [pow_succ]\n    exact repr_mul_is_integral hB hx (fun _ => hn _ le_rfl (fun _ => hx _) _) hmin\n#align repr_pow_is_integral repr_pow_is_integral\n\n",
 "repr_mul_is_integral":
 "/-- Let `B : power_basis S A` be such that `is_integral R B.gen`, and let `x y : A` be elements with\nintegral coordinates in the base `B.basis`. Then `is_integral R ((B.basis.repr (x * y) i)` for all\n`i` if `minpoly S B.gen = (minpoly R B.gen).map (algebra_map R S)`. This is the case if `R` is a GCD\ndomain and `S` is its fraction ring. -/\ntheorem repr_mul_is_integral [IsDomain S] {x y : A} (hx : ∀ i, is_integral R (B.basis.repr x i))\n    (hy : ∀ i, is_integral R (B.basis.repr y i)) (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :\n    ∀ i, is_integral R (B.basis.repr (x * y) i) := by\n  intro i\n  rw [← B.basis.sum_repr x, ← B.basis.sum_repr y, Finset.sum_mul_sum, LinearEquiv.map_sum, Finset.sum_apply']\n  refine' is_integral.sum _ fun I hI => _\n  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulₛₗ, RingHom.id_apply, Finsupp.coe_smul,\n    Pi.smul_apply, id.smul_eq_mul]\n  refine' is_integral_mul (hy _) (is_integral_mul (hx _) _)\n  simp only [coe_basis, ← pow_add]\n  refine' repr_gen_pow_is_integral hB hmin _ _\n#align repr_mul_is_integral repr_mul_is_integral\n\n",
 "repr_gen_pow_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n/-- If `B : power_basis S A` is such that `is_integral R B.gen`, then\n`is_integral R (B.basis.repr (B.gen ^ n) i)` for all `i` if\n`minpoly S B.gen = (minpoly R B.gen).map (algebra_map R S)`. This is the case if `R` is a GCD domain\nand `S` is its fraction ring. -/\ntheorem repr_gen_pow_is_integral [IsDomain S] (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S))\n    (n : ℕ) : ∀ i, is_integral R (B.basis.repr (B.gen ^ n) i) :=\n  by\n  intro i\n  let Q := «expr %ₘ » (X ^ n) (minpoly R B.gen)\n  have : B.gen ^ n = aeval B.gen Q :=\n    by\n    rw [← @aeval_X_pow R _ _ _ _ B.gen, ← mod_by_monic_add_div (X ^ n) (minpoly.monic hB)]\n    simp\n  by_cases hQ : Q = 0\n  · simp [this, hQ, is_integral_zero]\n  have hlt : Q.nat_degree < B.dim :=\n    by\n    rw [← B.nat_degree_minpoly, hmin, (minpoly.monic hB).nat_degree_map, nat_degree_lt_nat_degree_iff hQ]\n    letI : Nontrivial R := nontrivial.of_polynomial_ne hQ\n    exact degree_mod_by_monic_lt _ (minpoly.monic hB)\n    infer_instance\n  rw [this, aeval_eq_sum_range' hlt]\n  simp only [LinearEquiv.map_sum, LinearEquiv.map_smulₛₗ, RingHom.id_apply, Finset.sum_apply']\n  refine' is_integral.sum _ fun j hj => _\n  replace hj := Finset.mem_range.1 hj\n  rw [← Fin.val_mk hj, ← B.basis_eq_pow, Algebra.smul_def, IsScalarTower.algebraMap_apply R S A, ← Algebra.smul_def,\n    LinearEquiv.map_smul]\n  simp only [algebraMap_smul, Finsupp.coe_smul, Pi.smul_apply, B.basis.repr_self_apply]\n  by_cases hij : (⟨j, hj⟩ : Fin _) = i\n  · simp only [hij, eq_self_iff_true, if_true]\n    rw [Algebra.smul_def, mul_one]\n    exact is_integral_algebra_map\n  · simp [hij, is_integral_zero]\n#align repr_gen_pow_is_integral repr_gen_pow_is_integral\n\n"}