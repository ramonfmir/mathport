{"prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem fg.prod {S : subalgebra R A} {T : subalgebra R B} (hS : S.fg) (hT : T.fg) : (S.prod T).fg :=\n  by\n  obtain ⟨s, hs⟩ := fg_def.1 hS\n  obtain ⟨t, ht⟩ := fg_def.1 hT\n  rw [← hs.2, ← ht.2]\n  exact\n    fg_def.2\n      ⟨«expr '' » (linear_map.inl R A B) (s ∪ {1}) ∪ «expr '' » (linear_map.inr R A B) (t ∪ {1}),\n        set.finite.union (set.finite.image _ (set.finite.union hs.1 (set.finite_singleton _)))\n          (set.finite.image _ (set.finite.union ht.1 (set.finite_singleton _))),\n        algebra.adjoin_inl_union_inr_eq_prod R s t⟩\n#align fg.prod fg.prod\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem fg.map {S : subalgebra R A} (f : «expr →ₐ[ ] » A R B) (hs : S.fg) : (S.map f).fg :=\n  let ⟨s, hs⟩ := hs\n  ⟨s.image f, by rw [Finset.coe_image, algebra.adjoin_image, hs]⟩\n#align fg.map fg.map\n\n",
 "is_noetherian_subring_closure":
 "theorem is_noetherian_subring_closure (s : set R) (hs : s.finite) : is_noetherian_ring (subring.closure s) :=\n  show is_noetherian_ring (subalgebra_of_subring (subring.closure s)) from\n    algebra.adjoin_int s ▸ is_noetherian_ring_of_fg (subalgebra.fg_def.2 ⟨s, hs, rfl⟩)\n#align is_noetherian_subring_closure is_noetherian_subring_closure\n\n",
 "is_noetherian_ring_of_fg":
 "theorem is_noetherian_ring_of_fg {S : subalgebra R A} (HS : S.fg) [is_noetherian_ring R] : is_noetherian_ring S :=\n  let ⟨t, ht⟩ := HS\n  ht ▸\n    (algebra.adjoin_eq_range R (↑t : set A)).symm ▸ by\n      haveI : is_noetherian_ring (mv_polynomial (↑t : set A) R) := mv_polynomial.is_noetherian_ring <;>\n          convert alg_hom.is_noetherian_ring_range _ <;>\n        infer_instance\n#align is_noetherian_ring_of_fg is_noetherian_ring_of_fg\n\n",
 "induction_on_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem induction_on_adjoin [is_noetherian R A] (P : subalgebra R A → Prop) (base : P («expr⊥»))\n    (ih : ∀ (S : subalgebra R A) (x : A), P S → P (algebra.adjoin R (insert x S))) (S : subalgebra R A) : P S := by\n  classical\n    obtain ⟨t, rfl⟩ := S.fg_of_noetherian\n    refine' Finset.induction_on t _ _\n    · simpa using base\n    intro x t hxt h\n    rw [Finset.coe_insert]\n    simpa only [algebra.adjoin_insert_adjoin] using ih _ x h\n#align induction_on_adjoin induction_on_adjoin\n\n",
 "fg_trans":
 "/-\nCopyright (c) 2019 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem fg_trans (h1 : (adjoin R s).to_submodule.fg) (h2 : (adjoin (adjoin R s) t).to_submodule.fg) :\n    (adjoin R (s ∪ t)).to_submodule.fg :=\n  by\n  rcases fg_def.1 h1 with ⟨p, hp, hp'⟩\n  rcases fg_def.1 h2 with ⟨q, hq, hq'⟩\n  refine' fg_def.2 ⟨p * q, hp.mul hq, le_antisymm _ _⟩\n  · rw [span_le]\n    rintro _ ⟨x, y, hx, hy, rfl⟩\n    change x * y ∈ _\n    refine' subalgebra.mul_mem _ _ _\n    · have : x ∈ (adjoin R s).to_submodule := by\n        rw [← hp']\n        exact subset_span hx\n      exact adjoin_mono (Set.subset_union_left _ _) this\n    have : y ∈ (adjoin (adjoin R s) t).to_submodule := by\n      rw [← hq']\n      exact subset_span hy\n    change y ∈ adjoin R (s ∪ t)\n    rwa [adjoin_union_eq_adjoin_adjoin]\n  · intro r hr\n    change r ∈ adjoin R (s ∪ t) at hr\n    rw [adjoin_union_eq_adjoin_adjoin] at hr\n    change r ∈ (adjoin (adjoin R s) t).to_submodule at hr\n    rw [← hq', ← Set.image_id q, finsupp.mem_span_image_iff_total (adjoin R s)] at hr\n    rcases hr with ⟨l, hlq, rfl⟩\n    have := @finsupp.total_apply A A (adjoin R s)\n    rw [this, finsupp.sum]\n    refine' sum_mem _\n    intro z hz\n    change (l z).1 * _ ∈ _\n    have : (l z).1 ∈ (adjoin R s).to_submodule := (l z).2\n    rw [← hp', ← Set.image_id p, finsupp.mem_span_image_iff_total R] at this\n    rcases this with ⟨l2, hlp, hl⟩\n    have := @finsupp.total_apply A A R\n    rw [this] at hl\n    rw [← hl, finsupp.sum_mul]\n    refine' sum_mem _\n    intro t ht\n    change _ * _ ∈ _\n    rw [smul_mul_assoc]\n    refine' smul_mem _ _ _\n    exact subset_span ⟨t, z, hlp ht, hlq hz, rfl⟩\n#align fg_trans fg_trans\n\n",
 "fg_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem fg_top (S : subalgebra R A) : («expr⊤» : subalgebra R S).fg ↔ S.fg :=\n  ⟨fun h => by\n    rw [← S.range_val, ← algebra.map_top]\n    exact fg.map _ h, fun h =>\n    fg_of_fg_map _ S.val subtype.val_injective <|\n      by\n      rw [algebra.map_top, range_val]\n      exact h⟩\n#align fg_top fg_top\n\n",
 "fg_of_submodule_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem fg_of_submodule_fg (h : («expr⊤» : submodule R A).fg) : («expr⊤» : subalgebra R A).fg :=\n  let ⟨s, hs⟩ := h\n  ⟨s,\n    to_submodule.injective <| by\n      rw [algebra.top_to_submodule, eq_top_iff, ← hs, span_le]\n      exact algebra.subset_adjoin⟩\n#align fg_of_submodule_fg fg_of_submodule_fg\n\n",
 "fg_of_noetherian":
 "theorem fg_of_noetherian [is_noetherian R A] (S : subalgebra R A) : S.fg :=\n  fg_of_fg_to_submodule (is_noetherian.noetherian S.to_submodule)\n#align fg_of_noetherian fg_of_noetherian\n\n",
 "fg_of_fg_to_submodule":
 "theorem fg_of_fg_to_submodule {S : subalgebra R A} : S.to_submodule.fg → S.fg := fun ⟨t, ht⟩ =>\n  ⟨t,\n    le_antisymm (algebra.adjoin_le fun x hx => show x ∈ S.to_submodule from ht ▸ subset_span hx) <|\n      show S.to_submodule ≤ (algebra.adjoin R ↑t).to_submodule from fun x hx =>\n        span_le.mpr (fun x hx => algebra.subset_adjoin hx)\n          (show x ∈ span R ↑t by\n            rw [ht]\n            exact hx)⟩\n#align fg_of_fg_to_submodule fg_of_fg_to_submodule\n\n",
 "fg_of_fg_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem fg_of_fg_map (S : subalgebra R A) (f : «expr →ₐ[ ] » A R B) (hf : function.injective f) (hs : (S.map f).fg) :\n    S.fg :=\n  let ⟨s, hs⟩ := hs\n  ⟨s.preimage f fun _ _ _ _ h => hf h,\n    map_injective hf <|\n      by\n      rw [← algebra.adjoin_image, finset.coe_preimage, Set.image_preimage_eq_of_subset, hs]\n      rw [← alg_hom.coe_range, ← algebra.adjoin_le_iff, hs, ← algebra.map_top]\n      exact map_mono le_top⟩\n#align fg_of_fg_map fg_of_fg_map\n\n",
 "fg_def":
 "theorem fg_def {S : subalgebra R A} : S.fg ↔ ∃ t : set A, set.finite t ∧ algebra.adjoin R t = S :=\n  iff.symm set.exists_finite_iff_finset\n#align fg_def fg_def\n\n",
 "fg_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem fg_bot : («expr⊥» : subalgebra R A).fg :=\n  ⟨∅, algebra.adjoin_empty R A⟩\n#align fg_bot fg_bot\n\n",
 "fg_adjoin_finset":
 "theorem fg_adjoin_finset (s : Finset A) : (algebra.adjoin R (↑s : set A)).fg :=\n  ⟨s, rfl⟩\n#align fg_adjoin_finset fg_adjoin_finset\n\n"}