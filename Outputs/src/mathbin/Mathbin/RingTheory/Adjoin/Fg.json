{"prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem fg.prod {S : Subalgebra R A} {T : Subalgebra R B} (hS : S.fg) (hT : T.fg) : (S.prod T).fg :=\n  by\n  obtain ⟨s, hs⟩ := fg_def.1 hS\n  obtain ⟨t, ht⟩ := fg_def.1 hT\n  rw [← hs.2, ← ht.2]\n  exact\n    fg_def.2\n      ⟨«expr '' » (LinearMap.inl R A B) (s ∪ {1}) ∪ «expr '' » (LinearMap.inr R A B) (t ∪ {1}),\n        Set.Finite.union (Set.Finite.image _ (Set.Finite.union hs.1 (Set.finite_singleton _)))\n          (Set.Finite.image _ (Set.Finite.union ht.1 (Set.finite_singleton _))),\n        Algebra.adjoin_inl_union_inr_eq_prod R s t⟩\n#align fg.prod fg.prod\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem fg.map {S : Subalgebra R A} (f : «expr →ₐ[ ] » A R B) (hs : S.fg) : (S.map f).fg :=\n  let ⟨s, hs⟩ := hs\n  ⟨s.image f, by rw [Finset.coe_image, Algebra.adjoin_image, hs]⟩\n#align fg.map fg.map\n\n",
 "is_noetherian_subring_closure":
 "#print is_noetherian_subring_closure /-\ntheorem is_noetherian_subring_closure (s : Set R) (hs : s.finite) : IsNoetherianRing (Subring.closure s) :=\n  show IsNoetherianRing (subalgebraOfSubring (Subring.closure s)) from\n    Algebra.adjoin_int s ▸ isNoetherianRing_of_fg (Subalgebra.fg_def.2 ⟨s, hs, rfl⟩)\n#align is_noetherian_subring_closure is_noetherian_subring_closure\n-/\n\n",
 "isNoetherianRing_of_fg":
 "#print isNoetherianRing_of_fg /-\ntheorem isNoetherianRing_of_fg {S : Subalgebra R A} (HS : S.fg) [IsNoetherianRing R] : IsNoetherianRing S :=\n  let ⟨t, ht⟩ := HS\n  ht ▸\n    (Algebra.adjoin_eq_range R (↑t : Set A)).symm ▸ by\n      haveI : IsNoetherianRing (MvPolynomial (↑t : Set A) R) := MvPolynomial.isNoetherianRing <;>\n          convert AlgHom.isNoetherianRing_range _ <;>\n        infer_instance\n#align is_noetherian_ring_of_fg isNoetherianRing_of_fg\n-/\n\n",
 "induction_on_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem induction_on_adjoin [IsNoetherian R A] (P : Subalgebra R A → Prop) (base : P («expr⊥»))\n    (ih : ∀ (S : Subalgebra R A) (x : A), P S → P (Algebra.adjoin R (insert x S))) (S : Subalgebra R A) : P S := by\n  classical\n    obtain ⟨t, rfl⟩ := S.fg_of_noetherian\n    refine' Finset.induction_on t _ _\n    · simpa using base\n    intro x t hxt h\n    rw [Finset.coe_insert]\n    simpa only [Algebra.adjoin_insert_adjoin] using ih _ x h\n#align induction_on_adjoin induction_on_adjoin\n\n",
 "fg_trans":
 "/-\nCopyright (c) 2019 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem fg_trans (h1 : (adjoin R s).to_submodule.fg) (h2 : (adjoin (adjoin R s) t).to_submodule.fg) :\n    (adjoin R (s ∪ t)).to_submodule.fg :=\n  by\n  rcases fg_def.1 h1 with ⟨p, hp, hp'⟩\n  rcases fg_def.1 h2 with ⟨q, hq, hq'⟩\n  refine' fg_def.2 ⟨p * q, hp.mul hq, le_antisymm _ _⟩\n  · rw [span_le]\n    rintro _ ⟨x, y, hx, hy, rfl⟩\n    change x * y ∈ _\n    refine' Subalgebra.mul_mem _ _ _\n    · have : x ∈ (adjoin R s).to_submodule := by\n        rw [← hp']\n        exact subset_span hx\n      exact adjoin_mono (Set.subset_union_left _ _) this\n    have : y ∈ (adjoin (adjoin R s) t).to_submodule := by\n      rw [← hq']\n      exact subset_span hy\n    change y ∈ adjoin R (s ∪ t)\n    rwa [adjoin_union_eq_adjoin_adjoin]\n  · intro r hr\n    change r ∈ adjoin R (s ∪ t) at hr\n    rw [adjoin_union_eq_adjoin_adjoin] at hr\n    change r ∈ (adjoin (adjoin R s) t).to_submodule at hr\n    rw [← hq', ← Set.image_id q, Finsupp.mem_span_image_iff_total (adjoin R s)] at hr\n    rcases hr with ⟨l, hlq, rfl⟩\n    have := @Finsupp.total_apply A A (adjoin R s)\n    rw [this, Finsupp.sum]\n    refine' sum_mem _\n    intro z hz\n    change (l z).1 * _ ∈ _\n    have : (l z).1 ∈ (adjoin R s).to_submodule := (l z).2\n    rw [← hp', ← Set.image_id p, Finsupp.mem_span_image_iff_total R] at this\n    rcases this with ⟨l2, hlp, hl⟩\n    have := @Finsupp.total_apply A A R\n    rw [this] at hl\n    rw [← hl, Finsupp.sum_mul]\n    refine' sum_mem _\n    intro t ht\n    change _ * _ ∈ _\n    rw [smul_mul_assoc]\n    refine' smul_mem _ _ _\n    exact subset_span ⟨t, z, hlp ht, hlq hz, rfl⟩\n#align fg_trans fg_trans\n\n",
 "fg_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem fg_top (S : Subalgebra R A) : («expr⊤» : Subalgebra R S).fg ↔ S.fg :=\n  ⟨fun h => by\n    rw [← S.range_val, ← Algebra.map_top]\n    exact fg.map _ h, fun h =>\n    fg_of_fg_map _ S.val Subtype.val_injective <|\n      by\n      rw [Algebra.map_top, range_val]\n      exact h⟩\n#align fg_top fg_top\n\n",
 "fg_of_submodule_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem fg_of_submodule_fg (h : («expr⊤» : Submodule R A).fg) : («expr⊤» : Subalgebra R A).fg :=\n  let ⟨s, hs⟩ := h\n  ⟨s,\n    toSubmodule.injective <| by\n      rw [Algebra.top_toSubmodule, eq_top_iff, ← hs, span_le]\n      exact Algebra.subset_adjoin⟩\n#align fg_of_submodule_fg fg_of_submodule_fg\n\n",
 "fg_of_noetherian":
 "theorem fg_of_noetherian [IsNoetherian R A] (S : Subalgebra R A) : S.fg :=\n  fg_of_fg_toSubmodule (is_noetherian.noetherian S.to_submodule)\n#align fg_of_noetherian fg_of_noetherian\n\n",
 "fg_of_fg_to_submodule":
 "theorem fg_of_fg_to_submodule {S : Subalgebra R A} : S.to_submodule.fg → S.fg := fun ⟨t, ht⟩ =>\n  ⟨t,\n    le_antisymm (Algebra.adjoin_le fun x hx => show x ∈ S.to_submodule from ht ▸ subset_span hx) <|\n      show S.to_submodule ≤ (Algebra.adjoin R ↑t).to_submodule from fun x hx =>\n        span_le.mpr (fun x hx => Algebra.subset_adjoin hx)\n          (show x ∈ span R ↑t by\n            rw [ht]\n            exact hx)⟩\n#align fg_of_fg_to_submodule fg_of_fg_to_submodule\n\n",
 "fg_of_fg_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem fg_of_fg_map (S : Subalgebra R A) (f : «expr →ₐ[ ] » A R B) (hf : function.injective f) (hs : (S.map f).fg) :\n    S.fg :=\n  let ⟨s, hs⟩ := hs\n  ⟨s.preimage f fun _ _ _ _ h => hf h,\n    map_injective hf <|\n      by\n      rw [← Algebra.adjoin_image, Finset.coe_preimage, Set.image_preimage_eq_of_subset, hs]\n      rw [← AlgHom.coe_range, ← Algebra.adjoin_le_iff, hs, ← Algebra.map_top]\n      exact map_mono le_top⟩\n#align fg_of_fg_map fg_of_fg_map\n\n",
 "fg_def":
 "theorem fg_def {S : Subalgebra R A} : S.fg ↔ ∃ t : Set A, Set.Finite t ∧ Algebra.adjoin R t = S :=\n  iff.symm Set.exists_finite_iff_finset\n#align fg_def fg_def\n\n",
 "fg_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem fg_bot : («expr⊥» : Subalgebra R A).fg :=\n  ⟨∅, Algebra.adjoin_empty R A⟩\n#align fg_bot fg_bot\n\n",
 "fg_adjoin_finset":
 "theorem fg_adjoin_finset (s : Finset A) : (Algebra.adjoin R (↑s : Set A)).fg :=\n  ⟨s, rfl⟩\n#align fg_adjoin_finset fg_adjoin_finset\n\n"}