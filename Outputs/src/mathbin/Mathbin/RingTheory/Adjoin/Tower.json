{"fg_trans'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem algebra.fg_trans' {R S A : Type _} [CommSemiring R] [CommSemiring S] [CommSemiring A] [algebra R S]\n    [algebra S A] [algebra R A] [IsScalarTower R S A] (hRS : («expr⊤» : subalgebra R S).fg)\n    (hSA : («expr⊤» : subalgebra S A).fg) : («expr⊤» : subalgebra R A).fg :=\n  let ⟨s, hs⟩ := hRS\n  let ⟨t, ht⟩ := hSA\n  ⟨s.image (algebra_map S A) ∪ t, by\n    rw [Finset.coe_union, Finset.coe_image, algebra.adjoin_union_eq_adjoin_adjoin, algebra.adjoin_algebra_map, hs,\n      algebra.map_top, is_scalar_tower.adjoin_range_to_alg_hom, ht, subalgebra.restrict_scalars_top]⟩\n#align algebra.fg_trans' algebra.fg_trans'\n\n",
 "fg_of_fg_of_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- **Artin--Tate lemma**: if A ⊆ B ⊆ C is a chain of subrings of commutative rings, and\nA is noetherian, and C is algebra-finite over A, and C is module-finite over B,\nthen B is algebra-finite over A.\n\nReferences: Atiyah--Macdonald Proposition 7.8; Stacks 00IS; Altman--Kleiman 16.17. -/\ntheorem fg_of_fg_of_fg [is_noetherian_ring A] (hAC : («expr⊤» : subalgebra A C).fg) (hBC : («expr⊤» : submodule B C).fg)\n    (hBCi : function.injective (algebra_map B C)) : («expr⊤» : subalgebra A B).fg :=\n  let ⟨B₀, hAB₀, hB₀C⟩ := exists_subalgebra_of_fg A B C hAC hBC\n  algebra.fg_trans' (B₀.fg_top.2 hAB₀) <|\n    subalgebra.fg_of_submodule_fg <|\n      have : is_noetherian_ring B₀ := is_noetherian_ring_of_fg hAB₀\n      have : is_noetherian B₀ C := is_noetherian_of_fg_of_noetherian' hB₀C\n      fg_of_injective (is_scalar_tower.to_alg_hom B₀ B C).to_linear_map hBCi\n#align fg_of_fg_of_fg fg_of_fg_of_fg\n\n",
 "exists_subalgebra_of_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem exists_subalgebra_of_fg (hAC : («expr⊤» : subalgebra A C).fg) (hBC : («expr⊤» : submodule B C).fg) :\n    ∃ B₀ : subalgebra A B, B₀.fg ∧ («expr⊤» : submodule B₀ C).fg :=\n  by\n  cases' hAC with x hx\n  cases' hBC with y hy\n  have := hy\n  simp_rw [eq_top_iff', mem_span_finset] at this\n  choose f hf\n  let s : Finset B := finset.image₂ f (x ∪ y * y) y\n  have hxy : ∀ xi ∈ x, xi ∈ span (algebra.adjoin A (↑s : set B)) (↑(insert 1 y : Finset C) : set C) := fun xi hxi =>\n    hf xi ▸\n      sum_mem fun yj hyj =>\n        smul_mem (span (algebra.adjoin A (↑s : set B)) (↑(insert 1 y : Finset C) : set C))\n          ⟨f xi yj, algebra.subset_adjoin <| mem_image₂_of_mem (mem_union_left _ hxi) hyj⟩\n          (subset_span <| mem_insert_of_mem hyj)\n  have hyy :\n    span (algebra.adjoin A (↑s : set B)) (↑(insert 1 y : Finset C) : set C) *\n        span (algebra.adjoin A (↑s : set B)) (↑(insert 1 y : Finset C) : set C) ≤\n      span (algebra.adjoin A (↑s : set B)) (↑(insert 1 y : Finset C) : set C) :=\n    by\n    rw [span_mul_span, span_le, coe_insert]\n    rintro _ ⟨yi, yj, rfl | hyi, rfl | hyj, rfl⟩\n    · rw [mul_one]\n      exact subset_span (Set.mem_insert _ _)\n    · rw [one_mul]\n      exact subset_span (Set.mem_insert_of_mem _ hyj)\n    · rw [mul_one]\n      exact subset_span (Set.mem_insert_of_mem _ hyi)\n    · rw [← hf (yi * yj)]\n      exact\n        SetLike.mem_coe.2\n          (sum_mem fun yk hyk =>\n            smul_mem (span (algebra.adjoin A (↑s : set B)) (insert 1 ↑y : set C))\n              ⟨f (yi * yj) yk,\n                algebra.subset_adjoin <| mem_image₂_of_mem (mem_union_right _ <| mul_mem_mul hyi hyj) hyk⟩\n              (subset_span <| Set.mem_insert_of_mem _ hyk : yk ∈ _))\n  refine' ⟨algebra.adjoin A (↑s : set B), subalgebra.fg_adjoin_finset _, insert 1 y, _⟩\n  refine' restrict_scalars_injective A _ _ _\n  rw [restrict_scalars_top, eq_top_iff, ← algebra.top_to_submodule, ← hx, algebra.adjoin_eq_span, span_le]\n  refine' fun r hr =>\n    Submonoid.closure_induction hr (fun c hc => hxy c hc) (subset_span <| mem_insert_self _ _) fun p q hp hq =>\n      hyy <| submodule.mul_mem_mul hp hq\n#align exists_subalgebra_of_fg exists_subalgebra_of_fg\n\n",
 "adjoin_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem adjoin_restrict_scalars (C D E : Type _) [CommSemiring C] [CommSemiring D] [CommSemiring E] [algebra C D]\n    [algebra C E] [algebra D E] [IsScalarTower C D E] (S : set E) :\n    (algebra.adjoin D S).restrict_scalars C =\n      (algebra.adjoin ((«expr⊤» : subalgebra C D).map (is_scalar_tower.to_alg_hom C D E)) S).restrict_scalars C :=\n  by\n  suffices\n    Set.range (algebra_map D E) =\n      Set.range (algebra_map ((«expr⊤» : subalgebra C D).map (is_scalar_tower.to_alg_hom C D E)) E)\n    by\n    ext x\n    change x ∈ subsemiring.closure (_ ∪ S) ↔ x ∈ subsemiring.closure (_ ∪ S)\n    rw [this]\n  ext x\n  constructor\n  · rintro ⟨y, hy⟩\n    exact ⟨⟨algebra_map D E y, ⟨y, ⟨algebra.mem_top, rfl⟩⟩⟩, hy⟩\n  · rintro ⟨⟨y, ⟨z, ⟨h0, h1⟩⟩⟩, h2⟩\n    exact ⟨z, eq.trans h1 h2⟩\n#align adjoin_restrict_scalars adjoin_restrict_scalars\n\n",
 "adjoin_res_eq_adjoin_res":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem adjoin_res_eq_adjoin_res (C D E F : Type _) [CommSemiring C] [CommSemiring D] [CommSemiring E] [CommSemiring F]\n    [algebra C D] [algebra C E] [algebra C F] [algebra D F] [algebra E F] [IsScalarTower C D F] [IsScalarTower C E F]\n    {S : set D} {T : set E} (hS : algebra.adjoin C S = «expr⊤») (hT : algebra.adjoin C T = «expr⊤») :\n    (algebra.adjoin E («expr '' » (algebra_map D F) S)).restrict_scalars C =\n      (algebra.adjoin D («expr '' » (algebra_map E F) T)).restrict_scalars C :=\n  by\n  rw [adjoin_restrict_scalars C E, adjoin_restrict_scalars C D, ← hS, ← hT, ← algebra.adjoin_image, ←\n    algebra.adjoin_image, ← alg_hom.coe_to_ring_hom, ← alg_hom.coe_to_ring_hom, is_scalar_tower.coe_to_alg_hom,\n    is_scalar_tower.coe_to_alg_hom, ← adjoin_union_eq_adjoin_adjoin, ← adjoin_union_eq_adjoin_adjoin, Set.union_comm]\n#align adjoin_res_eq_adjoin_res adjoin_res_eq_adjoin_res\n\n",
 "adjoin_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem adjoin_algebra_map (R : Type u) (S : Type v) (A : Type w) [CommSemiring R] [CommSemiring S] [Semiring A]\n    [algebra R S] [algebra S A] [algebra R A] [IsScalarTower R S A] (s : set S) :\n    adjoin R («expr '' » (algebra_map S A) s) = (adjoin R s).map (is_scalar_tower.to_alg_hom R S A) :=\n  le_antisymm (adjoin_le <| Set.image_subset_iff.2 fun y hy => ⟨y, subset_adjoin hy, rfl⟩)\n    (subalgebra.map_le.2 <| adjoin_le fun y hy => subset_adjoin ⟨y, hy, rfl⟩)\n#align adjoin_algebra_map adjoin_algebra_map\n\n"}