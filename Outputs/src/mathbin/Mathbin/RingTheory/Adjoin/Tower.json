{"fg_trans'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Algebra.fg_trans' /-\ntheorem Algebra.fg_trans' {R S A : Type _} [CommSemiring R] [CommSemiring S] [CommSemiring A] [Algebra R S]\n    [Algebra S A] [Algebra R A] [IsScalarTower R S A] (hRS : («expr⊤» : Subalgebra R S).fg)\n    (hSA : («expr⊤» : Subalgebra S A).fg) : («expr⊤» : Subalgebra R A).fg :=\n  let ⟨s, hs⟩ := hRS\n  let ⟨t, ht⟩ := hSA\n  ⟨s.image (algebraMap S A) ∪ t, by\n    rw [Finset.coe_union, Finset.coe_image, Algebra.adjoin_union_eq_adjoin_adjoin, Algebra.adjoin_algebraMap, hs,\n      Algebra.map_top, IsScalarTower.adjoin_range_toAlgHom, ht, Subalgebra.restrictScalars_top]⟩\n#align algebra.fg_trans' Algebra.fg_trans'\n-/\n\n",
 "fg_of_fg_of_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print fg_of_fg_of_fg /-\n/-- **Artin--Tate lemma**: if A ⊆ B ⊆ C is a chain of subrings of commutative rings, and\nA is noetherian, and C is algebra-finite over A, and C is module-finite over B,\nthen B is algebra-finite over A.\n\nReferences: Atiyah--Macdonald Proposition 7.8; Stacks 00IS; Altman--Kleiman 16.17. -/\ntheorem fg_of_fg_of_fg [IsNoetherianRing A] (hAC : («expr⊤» : Subalgebra A C).fg) (hBC : («expr⊤» : Submodule B C).fg)\n    (hBCi : function.injective (algebraMap B C)) : («expr⊤» : Subalgebra A B).fg :=\n  let ⟨B₀, hAB₀, hB₀C⟩ := exists_subalgebra_of_fg A B C hAC hBC\n  Algebra.fg_trans' (B₀.fg_top.2 hAB₀) <|\n    Subalgebra.fg_of_submodule_fg <|\n      have : IsNoetherianRing B₀ := isNoetherianRing_of_fg hAB₀\n      have : IsNoetherian B₀ C := isNoetherian_of_fg_of_noetherian' hB₀C\n      fg_of_injective (IsScalarTower.toAlgHom B₀ B C).to_linear_map hBCi\n#align fg_of_fg_of_fg fg_of_fg_of_fg\n-/\n\n",
 "exists_subalgebra_of_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print exists_subalgebra_of_fg /-\ntheorem exists_subalgebra_of_fg (hAC : («expr⊤» : Subalgebra A C).fg) (hBC : («expr⊤» : Submodule B C).fg) :\n    ∃ B₀ : Subalgebra A B, B₀.fg ∧ («expr⊤» : Submodule B₀ C).fg :=\n  by\n  cases' hAC with x hx\n  cases' hBC with y hy\n  have := hy\n  simp_rw [eq_top_iff', mem_span_finset] at this\n  choose f hf\n  let s : Finset B := Finset.image₂ f (x ∪ y * y) y\n  have hxy : ∀ xi ∈ x, xi ∈ span (Algebra.adjoin A (↑s : Set B)) (↑(insert 1 y : Finset C) : Set C) := fun xi hxi =>\n    hf xi ▸\n      sum_mem fun yj hyj =>\n        smul_mem (span (Algebra.adjoin A (↑s : Set B)) (↑(insert 1 y : Finset C) : Set C))\n          ⟨f xi yj, Algebra.subset_adjoin <| mem_image₂_of_mem (mem_union_left _ hxi) hyj⟩\n          (subset_span <| mem_insert_of_mem hyj)\n  have hyy :\n    span (Algebra.adjoin A (↑s : Set B)) (↑(insert 1 y : Finset C) : Set C) *\n        span (Algebra.adjoin A (↑s : Set B)) (↑(insert 1 y : Finset C) : Set C) ≤\n      span (Algebra.adjoin A (↑s : Set B)) (↑(insert 1 y : Finset C) : Set C) :=\n    by\n    rw [span_mul_span, span_le, coe_insert]\n    rintro _ ⟨yi, yj, rfl | hyi, rfl | hyj, rfl⟩\n    · rw [mul_one]\n      exact subset_span (Set.mem_insert _ _)\n    · rw [one_mul]\n      exact subset_span (Set.mem_insert_of_mem _ hyj)\n    · rw [mul_one]\n      exact subset_span (Set.mem_insert_of_mem _ hyi)\n    · rw [← hf (yi * yj)]\n      exact\n        SetLike.mem_coe.2\n          (sum_mem fun yk hyk =>\n            smul_mem (span (Algebra.adjoin A (↑s : Set B)) (insert 1 ↑y : Set C))\n              ⟨f (yi * yj) yk,\n                Algebra.subset_adjoin <| mem_image₂_of_mem (mem_union_right _ <| mul_mem_mul hyi hyj) hyk⟩\n              (subset_span <| Set.mem_insert_of_mem _ hyk : yk ∈ _))\n  refine' ⟨Algebra.adjoin A (↑s : Set B), Subalgebra.fg_adjoin_finset _, insert 1 y, _⟩\n  refine' restrict_scalars_injective A _ _ _\n  rw [restrict_scalars_top, eq_top_iff, ← Algebra.top_toSubmodule, ← hx, Algebra.adjoin_eq_span, span_le]\n  refine' fun r hr =>\n    Submonoid.closure_induction hr (fun c hc => hxy c hc) (subset_span <| mem_insert_self _ _) fun p q hp hq =>\n      hyy <| Submodule.mul_mem_mul hp hq\n#align exists_subalgebra_of_fg exists_subalgebra_of_fg\n-/\n\n",
 "adjoin_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem adjoin_restrict_scalars (C D E : Type _) [CommSemiring C] [CommSemiring D] [CommSemiring E] [Algebra C D]\n    [Algebra C E] [Algebra D E] [IsScalarTower C D E] (S : Set E) :\n    (Algebra.adjoin D S).restrict_scalars C =\n      (Algebra.adjoin ((«expr⊤» : Subalgebra C D).map (IsScalarTower.toAlgHom C D E)) S).restrict_scalars C :=\n  by\n  suffices\n    Set.range (algebraMap D E) =\n      Set.range (algebraMap ((«expr⊤» : Subalgebra C D).map (IsScalarTower.toAlgHom C D E)) E)\n    by\n    ext x\n    change x ∈ Subsemiring.closure (_ ∪ S) ↔ x ∈ Subsemiring.closure (_ ∪ S)\n    rw [this]\n  ext x\n  constructor\n  · rintro ⟨y, hy⟩\n    exact ⟨⟨algebraMap D E y, ⟨y, ⟨Algebra.mem_top, rfl⟩⟩⟩, hy⟩\n  · rintro ⟨⟨y, ⟨z, ⟨h0, h1⟩⟩⟩, h2⟩\n    exact ⟨z, Eq.trans h1 h2⟩\n#align adjoin_restrict_scalars adjoin_restrict_scalars\n\n",
 "adjoin_res_eq_adjoin_res":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem adjoin_res_eq_adjoin_res (C D E F : Type _) [CommSemiring C] [CommSemiring D] [CommSemiring E] [CommSemiring F]\n    [Algebra C D] [Algebra C E] [Algebra C F] [Algebra D F] [Algebra E F] [IsScalarTower C D F] [IsScalarTower C E F]\n    {S : Set D} {T : Set E} (hS : Algebra.adjoin C S = «expr⊤») (hT : Algebra.adjoin C T = «expr⊤») :\n    (Algebra.adjoin E («expr '' » (algebraMap D F) S)).restrict_scalars C =\n      (Algebra.adjoin D («expr '' » (algebraMap E F) T)).restrict_scalars C :=\n  by\n  rw [adjoin_restrict_scalars C E, adjoin_restrict_scalars C D, ← hS, ← hT, ← Algebra.adjoin_image, ←\n    Algebra.adjoin_image, ← AlgHom.coe_toRingHom, ← AlgHom.coe_toRingHom, IsScalarTower.coe_toAlgHom,\n    IsScalarTower.coe_toAlgHom, ← adjoin_union_eq_adjoin_adjoin, ← adjoin_union_eq_adjoin_adjoin, Set.union_comm]\n#align adjoin_res_eq_adjoin_res adjoin_res_eq_adjoin_res\n\n",
 "adjoin_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem adjoin_algebra_map (R : Type u) (S : Type v) (A : Type w) [CommSemiring R] [CommSemiring S] [Semiring A]\n    [Algebra R S] [Algebra S A] [Algebra R A] [IsScalarTower R S A] (s : Set S) :\n    adjoin R («expr '' » (algebraMap S A) s) = (adjoin R s).map (IsScalarTower.toAlgHom R S A) :=\n  le_antisymm (adjoin_le <| Set.image_subset_iff.2 fun y hy => ⟨y, subset_adjoin hy, rfl⟩)\n    (Subalgebra.map_le.2 <| adjoin_le fun y hy => subset_adjoin ⟨y, hy, rfl⟩)\n#align adjoin_algebra_map adjoin_algebra_map\n\n"}