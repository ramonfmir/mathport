{"subset_adjoin":
 "/-\nCopyright (c) 2019 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem subset_adjoin : s ⊆ adjoin R s :=\n  algebra.gc.le_u_l s\n#align subset_adjoin subset_adjoin\n\n",
 "span_le_adjoin":
 "theorem span_le_adjoin (s : set A) : span R s ≤ (adjoin R s).to_submodule :=\n  span_le.mpr subset_adjoin\n#align span_le_adjoin span_le_adjoin\n\n",
 "self_mem_adjoin_singleton":
 "theorem self_mem_adjoin_singleton (x : A) : x ∈ adjoin R ({x} : set A) :=\n  algebra.subset_adjoin (Set.mem_singleton_iff.mpr rfl)\n#align self_mem_adjoin_singleton self_mem_adjoin_singleton\n\n",
 "pow_smul_mem_of_smul_subset_of_mem_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem pow_smul_mem_of_smul_subset_of_mem_adjoin [CommSemiring B] [algebra R B] [algebra A B] [IsScalarTower R A B]\n    (r : A) (s : set B) (B' : subalgebra R B) (hs : «expr • » r s ⊆ B') {x : B} (hx : x ∈ adjoin R s)\n    (hr : algebra_map A B r ∈ B') : ∃ n₀ : ℕ, ∀ n ≥ n₀, «expr • » (r ^ n) x ∈ B' :=\n  by\n  change x ∈ (adjoin R s).to_submodule at hx\n  rw [adjoin_eq_span, finsupp.mem_span_iff_total] at hx\n  rcases hx with ⟨l, rfl : (l.sum fun (i : Submonoid.closure s) (c : R) => «expr • » c ↑i) = x⟩\n  choose n₁ n₂ using fun x : Submonoid.closure s => submonoid.pow_smul_mem_closure_smul r s x.prop\n  use l.support.sup n₁\n  intro n hn\n  rw [finsupp.smul_sum]\n  refine' B'.to_submodule.sum_mem _\n  intro a ha\n  have : n ≥ n₁ a := le_trans (finset.le_sup ha) hn\n  dsimp only\n  rw [← tsub_add_cancel_of_le this, pow_add, ← smul_smul, ← is_scalar_tower.algebra_map_smul A (l a) (a : B),\n    smul_smul (r ^ n₁ a), mul_comm, ← smul_smul, smul_def, map_pow, is_scalar_tower.algebra_map_smul]\n  apply subalgebra.mul_mem _ (subalgebra.pow_mem _ hr _) _\n  refine' subalgebra.smul_mem _ _ _\n  change _ ∈ B'.to_submonoid\n  rw [← Submonoid.closure_eq B'.to_submonoid]\n  apply Submonoid.closure_mono hs (n₂ a)\n#align pow_smul_mem_of_smul_subset_of_mem_adjoin pow_smul_mem_of_smul_subset_of_mem_adjoin\n\n",
 "pow_smul_mem_adjoin_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem pow_smul_mem_adjoin_smul (r : R) (s : set A) {x : A} (hx : x ∈ adjoin R s) :\n    ∃ n₀ : ℕ, ∀ n ≥ n₀, «expr • » (r ^ n) x ∈ adjoin R («expr • » r s) :=\n  pow_smul_mem_of_smul_subset_of_mem_adjoin r s _ subset_adjoin hx (subalgebra.algebra_map_mem _ _)\n#align pow_smul_mem_adjoin_smul pow_smul_mem_adjoin_smul\n\n",
 "mem_adjoin_of_map_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_adjoin_of_map_mul {s} {x : A} {f : «expr →ₗ[ ] » A R B} (hf : ∀ a₁ a₂, f (a₁ * a₂) = f a₁ * f a₂)\n    (h : x ∈ adjoin R s) : f x ∈ adjoin R («expr '' » f (s ∪ {1})) :=\n  by\n  refine'\n    @adjoin_induction R A _ _ _ _ (fun a => f a ∈ adjoin R («expr '' » f (s ∪ {1}))) x h\n      (fun a ha => subset_adjoin ⟨a, ⟨Set.subset_union_left _ _ ha, rfl⟩⟩) (fun r => _)\n      (fun y z hy hz => by simpa [hy, hz] using subalgebra.add_mem _ hy hz) fun y z hy hz => by\n      simpa [hy, hz, hf y z] using subalgebra.mul_mem _ hy hz\n  have : f 1 ∈ adjoin R («expr '' » f (s ∪ {1})) :=\n    subset_adjoin ⟨1, ⟨Set.subset_union_right _ _ <| Set.mem_singleton 1, rfl⟩⟩\n  replace this := subalgebra.smul_mem (adjoin R («expr '' » f (s ∪ {1}))) this r\n  convert this\n  rw [algebra_map_eq_smul_one]\n  exact f.map_smul _ _\n#align mem_adjoin_of_map_mul mem_adjoin_of_map_mul\n\n",
 "mem_adjoin_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem mem_adjoin_iff {s : set A} {x : A} : x ∈ adjoin R s ↔ x ∈ subring.closure (Set.range (algebra_map R A) ∪ s) :=\n  ⟨fun hx =>\n    subsemiring.closure_induction hx subring.subset_closure (subring.zero_mem _) (subring.one_mem _)\n      (fun _ _ => subring.add_mem _) fun _ _ => subring.mul_mem _,\n    suffices subring.closure (Set.range («expr⇑ » (algebra_map R A)) ∪ s) ≤ (adjoin R s).to_subring from @this x\n    subring.closure_le.2 subsemiring.subset_closure⟩\n#align mem_adjoin_iff mem_adjoin_iff\n\n",
 "map_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_adjoin (φ : «expr →ₐ[ ] » A R B) (s : set A) : (adjoin R s).map φ = adjoin R («expr '' » φ s) :=\n  (adjoin_image _ _ _).symm\n#align map_adjoin map_adjoin\n\n",
 "ext_of_adjoin_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem ext_of_adjoin_eq_top {s : set A} (h : adjoin R s = «expr⊤») ⦃φ₁ φ₂ : «expr →ₐ[ ] » A R B⦄ (hs : s.eq_on φ₁ φ₂) :\n    φ₁ = φ₂ :=\n  ext fun x => adjoin_le_equalizer φ₁ φ₂ hs <| h.symm ▸ trivial\n#align ext_of_adjoin_eq_top ext_of_adjoin_eq_top\n\n",
 "adjoin_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem adjoin_univ : adjoin R (Set.univ : set A) = «expr⊤» :=\n  eq_top_iff.2 fun x => subset_adjoin <| Set.mem_univ _\n#align adjoin_univ adjoin_univ\n\n",
 "adjoin_union_eq_adjoin_adjoin":
 "theorem adjoin_union_eq_adjoin_adjoin : adjoin R (s ∪ t) = (adjoin (adjoin R s) t).restrict_scalars R :=\n  le_antisymm\n    (closure_mono <|\n      Set.union_subset (Set.range_subset_iff.2 fun r => or.inl ⟨algebra_map R (adjoin R s) r, rfl⟩)\n        (Set.union_subset_union_left _ fun x hxs => ⟨⟨_, subset_adjoin hxs⟩, rfl⟩))\n    (closure_le.2 <|\n      Set.union_subset (Set.range_subset_iff.2 fun x => adjoin_mono (Set.subset_union_left _ _) x.2)\n        (Set.Subset.trans (Set.subset_union_right _ _) subset_adjoin))\n#align adjoin_union_eq_adjoin_adjoin adjoin_union_eq_adjoin_adjoin\n\n",
 "adjoin_union_coe_submodule":
 "theorem adjoin_union_coe_submodule :\n    (adjoin R (s ∪ t)).to_submodule = (adjoin R s).to_submodule * (adjoin R t).to_submodule :=\n  by\n  rw [adjoin_eq_span, adjoin_eq_span, adjoin_eq_span, span_mul_span]\n  congr 1 with z; simp [Submonoid.closure_union, submonoid.mem_sup, Set.mem_mul]\n#align adjoin_union_coe_submodule adjoin_union_coe_submodule\n\n",
 "adjoin_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem adjoin_union (s t : set A) : adjoin R (s ∪ t) = «expr ⊔ » (adjoin R s) (adjoin R t) :=\n  (algebra.gc : GaloisConnection _ (coe : subalgebra R A → set A)).l_sup\n#align adjoin_union adjoin_union\n\n",
 "adjoin_to_submodule_le":
 "theorem adjoin_to_submodule_le {s : set A} {t : submodule R A} :\n    (adjoin R s).to_submodule ≤ t ↔ ↑(Submonoid.closure s) ⊆ (t : set A) := by rw [adjoin_eq_span, span_le]\n#align adjoin_to_submodule_le adjoin_to_submodule_le\n\n",
 "adjoin_span":
 "@[simp]\ntheorem adjoin_span {s : set A} : adjoin R (submodule.span R s : set A) = adjoin R s :=\n  le_antisymm (adjoin_le (span_le_adjoin _ _)) (adjoin_mono submodule.subset_span)\n#align adjoin_span adjoin_span\n\n",
 "adjoin_singleton_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem adjoin_singleton_one : adjoin R ({1} : set A) = «expr⊥» :=\n  eq_bot_iff.2 <| adjoin_le <| Set.singleton_subset_iff.2 <| SetLike.mem_coe.2 <| one_mem _\n#align adjoin_singleton_one adjoin_singleton_one\n\n",
 "adjoin_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem adjoin_prod_le (s : set A) (t : set B) : adjoin R (finset.product s t) ≤ (adjoin R s).prod (adjoin R t) :=\n  adjoin_le <| Set.prod_mono subset_adjoin subset_adjoin\n#align adjoin_prod_le adjoin_prod_le\n\n",
 "adjoin_mono":
 "theorem adjoin_mono (H : s ⊆ t) : adjoin R s ≤ adjoin R t :=\n  algebra.gc.monotone_l H\n#align adjoin_mono adjoin_mono\n\n",
 "adjoin_le_iff":
 "theorem adjoin_le_iff {S : subalgebra R A} : adjoin R s ≤ S ↔ s ⊆ S :=\n  algebra.gc _ _\n#align adjoin_le_iff adjoin_le_iff\n\n",
 "adjoin_le_equalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem adjoin_le_equalizer (φ₁ φ₂ : «expr →ₐ[ ] » A R B) {s : set A} (h : s.eq_on φ₁ φ₂) :\n    adjoin R s ≤ φ₁.equalizer φ₂ :=\n  adjoin_le h\n#align adjoin_le_equalizer adjoin_le_equalizer\n\n",
 "adjoin_le":
 "theorem adjoin_le {S : subalgebra R A} (H : s ⊆ S) : adjoin R s ≤ S :=\n  algebra.gc.l_le H\n#align adjoin_le adjoin_le\n\n",
 "adjoin_int":
 "theorem adjoin_int (s : set R) : adjoin ℤ s = subalgebra_of_subring (subring.closure s) :=\n  le_antisymm (adjoin_le subring.subset_closure)\n    (subring.closure_le.2 subset_adjoin : subring.closure s ≤ (adjoin ℤ s).to_subring)\n#align adjoin_int adjoin_int\n\n",
 "adjoin_insert_adjoin":
 "@[simp]\ntheorem adjoin_insert_adjoin (x : A) : adjoin R (insert x ↑(adjoin R s)) = adjoin R (insert x s) :=\n  le_antisymm\n    (adjoin_le (Set.insert_subset.mpr ⟨subset_adjoin (Set.mem_insert _ _), adjoin_mono (Set.subset_insert _ _)⟩))\n    (algebra.adjoin_mono (Set.insert_subset_insert algebra.subset_adjoin))\n#align adjoin_insert_adjoin adjoin_insert_adjoin\n\n",
 "adjoin_inl_union_inr_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem adjoin_inl_union_inr_eq_prod (s) (t) :\n    adjoin R («expr '' » (linear_map.inl R A B) (s ∪ {1}) ∪ «expr '' » (linear_map.inr R A B) (t ∪ {1})) =\n      (adjoin R s).prod (adjoin R t) :=\n  by\n  apply le_antisymm\n  ·\n    simp only [adjoin_le_iff, Set.insert_subset, subalgebra.zero_mem, subalgebra.one_mem,\n      subset_adjoin,-- the rest comes from `squeeze_simp`\n      Set.union_subset_iff,\n      linear_map.coe_inl, Set.mk_preimage_prod_right, Set.image_subset_iff, SetLike.mem_coe, Set.mk_preimage_prod_left,\n      linear_map.coe_inr, and_self_iff, Set.union_singleton, subalgebra.coe_prod]\n  · rintro ⟨a, b⟩ ⟨ha, hb⟩\n    let P := adjoin R («expr '' » (linear_map.inl R A B) (s ∪ {1}) ∪ «expr '' » (linear_map.inr R A B) (t ∪ {1}))\n    have Ha : (a, (0 : B)) ∈ adjoin R («expr '' » (linear_map.inl R A B) (s ∪ {1})) :=\n      mem_adjoin_of_map_mul R linear_map.inl_map_mul ha\n    have Hb : ((0 : A), b) ∈ adjoin R («expr '' » (linear_map.inr R A B) (t ∪ {1})) :=\n      mem_adjoin_of_map_mul R linear_map.inr_map_mul hb\n    replace Ha : (a, (0 : B)) ∈ P := adjoin_mono (Set.subset_union_left _ _) Ha\n    replace Hb : ((0 : A), b) ∈ P := adjoin_mono (Set.subset_union_right _ _) Hb\n    simpa using subalgebra.add_mem _ Ha Hb\n#align adjoin_inl_union_inr_eq_prod adjoin_inl_union_inr_eq_prod\n\n",
 "adjoin_induction₂":
 "/-- Induction principle for the algebra generated by a set `s`: show that `p x y` holds for any\n`x y ∈ adjoin R s` given that that it holds for `x y ∈ s` and that it satisfies a number of\nnatural properties. -/\n@[elab_as_elim]\ntheorem adjoin_induction₂ {p : A → A → Prop} {a b : A} (ha : a ∈ adjoin R s) (hb : b ∈ adjoin R s)\n    (Hs : ∀ x ∈ s, ∀ y ∈ s, p x y) (Halg : ∀ r₁ r₂, p (algebra_map R A r₁) (algebra_map R A r₂))\n    (Halg_left : ∀ (r), ∀ x ∈ s, p (algebra_map R A r) x) (Halg_right : ∀ (r), ∀ x ∈ s, p x (algebra_map R A r))\n    (Hadd_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ + x₂) y) (Hadd_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ + y₂))\n    (Hmul_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ * x₂) y) (Hmul_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ * y₂)) :\n    p a b := by\n  refine' adjoin_induction hb _ (fun r => _) (Hadd_right a) (Hmul_right a)\n  ·\n    exact\n      adjoin_induction ha Hs Halg_left (fun x y Hx Hy z hz => Hadd_left x y z (Hx z hz) (Hy z hz)) fun x y Hx Hy z hz =>\n        Hmul_left x y z (Hx z hz) (Hy z hz)\n  ·\n    exact\n      adjoin_induction ha (Halg_right r) (fun r' => Halg r' r) (fun x y => Hadd_left x y ((algebra_map R A) r))\n        fun x y => Hmul_left x y ((algebra_map R A) r)\n#align adjoin_induction₂ adjoin_induction₂\n\n",
 "adjoin_induction'":
 "/-- The difference with `algebra.adjoin_induction` is that this acts on the subtype. -/\ntheorem adjoin_induction' {p : adjoin R s → Prop} (Hs : ∀ (x) (h : x ∈ s), p ⟨x, subset_adjoin h⟩)\n    (Halg : ∀ r, p (algebra_map R _ r)) (Hadd : ∀ x y, p x → p y → p (x + y)) (Hmul : ∀ x y, p x → p y → p (x * y))\n    (x : adjoin R s) : p x :=\n  subtype.rec_on x fun x hx =>\n    by\n    refine' exists.elim _ fun (hx : x ∈ adjoin R s) (hc : p ⟨x, hx⟩) => hc\n    exact\n      adjoin_induction hx (fun x hx => ⟨subset_adjoin hx, Hs x hx⟩) (fun r => ⟨subalgebra.algebra_map_mem _ r, Halg r⟩)\n        (fun x y hx hy =>\n          exists.elim hx fun hx' hx => exists.elim hy fun hy' hy => ⟨subalgebra.add_mem _ hx' hy', Hadd _ _ hx hy⟩)\n        fun x y hx hy =>\n        exists.elim hx fun hx' hx => exists.elim hy fun hy' hy => ⟨subalgebra.mul_mem _ hx' hy', Hmul _ _ hx hy⟩\n#align adjoin_induction' adjoin_induction'\n\n",
 "adjoin_induction":
 "@[elab_as_elim]\ntheorem adjoin_induction {p : A → Prop} {x : A} (h : x ∈ adjoin R s) (Hs : ∀ x ∈ s, p x)\n    (Halg : ∀ r, p (algebra_map R A r)) (Hadd : ∀ x y, p x → p y → p (x + y)) (Hmul : ∀ x y, p x → p y → p (x * y)) :\n    p x :=\n  let S : subalgebra R A :=\n    { carrier := p\n      mul_mem' := Hmul\n      add_mem' := Hadd\n      algebra_map_mem' := Halg }\n  adjoin_le (show s ≤ S from Hs) h\n#align adjoin_induction adjoin_induction\n\n",
 "adjoin_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem adjoin_image (f : «expr →ₐ[ ] » A R B) (s : set A) : adjoin R («expr '' » f s) = (adjoin R s).map f :=\n  le_antisymm (adjoin_le <| Set.image_subset _ subset_adjoin) <|\n    subalgebra.map_le.2 <| adjoin_le <| Set.image_subset_iff.1 subset_adjoin\n#align adjoin_image adjoin_image\n\n",
 "adjoin_eq_span_of_subset":
 "theorem adjoin_eq_span_of_subset {s : set A} (hs : ↑(Submonoid.closure s) ⊆ (span R s : set A)) :\n    (adjoin R s).to_submodule = span R s :=\n  le_antisymm ((adjoin_to_submodule_le R).mpr hs) (span_le_adjoin R s)\n#align adjoin_eq_span_of_subset adjoin_eq_span_of_subset\n\n",
 "adjoin_eq_span":
 "theorem adjoin_eq_span : (adjoin R s).to_submodule = span R (Submonoid.closure s) :=\n  by\n  apply le_antisymm\n  · intro r hr\n    rcases subsemiring.mem_closure_iff_exists_list.1 hr with ⟨L, HL, rfl⟩\n    clear hr\n    induction' L with hd tl ih\n    · exact zero_mem _\n    rw [List.forall_mem_cons] at HL\n    rw [list.map_cons, list.sum_cons]\n    refine' submodule.add_mem _ _ (ih HL.2)\n    replace HL := HL.1\n    clear ih tl\n    suffices ∃ (z r : _)(hr : r ∈ Submonoid.closure s), has_smul.smul z r = List.prod hd\n      by\n      rcases this with ⟨z, r, hr, hzr⟩\n      rw [← hzr]\n      exact smul_mem _ _ (subset_span hr)\n    induction' hd with hd tl ih\n    · exact ⟨1, 1, (Submonoid.closure s).one_mem', one_smul _ _⟩\n    rw [List.forall_mem_cons] at HL\n    rcases ih HL.2 with ⟨z, r, hr, hzr⟩\n    rw [List.prod_cons, ← hzr]\n    rcases HL.1 with (⟨hd, rfl⟩ | hs)\n    · refine' ⟨hd * z, r, hr, _⟩\n      rw [algebra.smul_def, algebra.smul_def, (algebra_map _ _).map_mul, _root_.mul_assoc]\n    · exact ⟨z, hd * r, Submonoid.mul_mem _ (Submonoid.subset_closure hs) hr, (mul_smul_comm _ _ _).symm⟩\n  refine' span_le.2 _\n  change Submonoid.closure s ≤ (adjoin R s).to_subsemiring.to_submonoid\n  exact Submonoid.closure_le.2 subset_adjoin\n#align adjoin_eq_span adjoin_eq_span\n\n",
 "adjoin_eq_ring_closure":
 "theorem adjoin_eq_ring_closure (s : set A) :\n    (adjoin R s).to_subring = subring.closure (Set.range (algebra_map R A) ∪ s) :=\n  subring.ext fun x => mem_adjoin_iff\n#align adjoin_eq_ring_closure adjoin_eq_ring_closure\n\n",
 "adjoin_eq_of_le":
 "theorem adjoin_eq_of_le (S : subalgebra R A) (h₁ : s ⊆ S) (h₂ : S ≤ adjoin R s) : adjoin R s = S :=\n  le_antisymm (adjoin_le h₁) h₂\n#align adjoin_eq_of_le adjoin_eq_of_le\n\n",
 "adjoin_eq_Inf":
 "theorem adjoin_eq_Inf : adjoin R s = infₛ { p | s ⊆ p } :=\n  le_antisymm (le_infₛ fun _ h => adjoin_le h) (infₛ_le subset_adjoin)\n#align adjoin_eq_Inf adjoin_eq_Inf\n\n",
 "adjoin_eq":
 "theorem adjoin_eq (S : subalgebra R A) : adjoin R ↑S = S :=\n  adjoin_eq_of_le _ (Set.Subset.refl _) subset_adjoin\n#align adjoin_eq adjoin_eq\n\n",
 "adjoin_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem adjoin_empty : adjoin R (∅ : set A) = «expr⊥» :=\n  show adjoin R («expr⊥») = «expr⊥» by\n    apply GaloisConnection.l_bot\n    exact algebra.gc\n#align adjoin_empty adjoin_empty\n\n",
 "adjoin_attach_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem adjoin_attach_bUnion [decidable_eq A] {α : Type _} {s : Finset α} (f : s → Finset A) :\n    adjoin R (s.attach.bUnion f : set A) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (adjoin R (f x)) :=\n  by simpa [adjoin_Union]\n#align adjoin_attach_bUnion adjoin_attach_bUnion\n\n",
 "adjoin_adjoin_of_tower":
 "theorem adjoin_adjoin_of_tower [Semiring B] [algebra R B] [algebra A B] [IsScalarTower R A B] (s : set B) :\n    adjoin A (adjoin R s : set B) = adjoin A s :=\n  by\n  apply le_antisymm (adjoin_le _)\n  · exact adjoin_mono subset_adjoin\n  · change adjoin R s ≤ (adjoin A s).restrict_scalars R\n    refine' adjoin_le _\n    exact subset_adjoin\n#align adjoin_adjoin_of_tower adjoin_adjoin_of_tower\n\n",
 "adjoin_adjoin_coe_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem adjoin_adjoin_coe_preimage {s : set A} : adjoin R («expr ⁻¹' » (coe : adjoin R s → A) s) = «expr⊤» :=\n  by\n  refine' eq_top_iff.2 fun x => adjoin_induction' (fun a ha => _) (fun r => _) (fun _ _ => _) (fun _ _ => _) x\n  · exact subset_adjoin ha\n  · exact subalgebra.algebra_map_mem _ r\n  · exact subalgebra.add_mem _\n  · exact subalgebra.mul_mem _\n#align adjoin_adjoin_coe_preimage adjoin_adjoin_coe_preimage\n\n",
 "adjoin_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem adjoin_Union {α : Type _} (s : α → set A) :\n    adjoin R (Set.unionᵢ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (adjoin R (s i)) :=\n  (@algebra.gc R A _ _ _).l_supr\n#align adjoin_Union adjoin_Union\n\n"}