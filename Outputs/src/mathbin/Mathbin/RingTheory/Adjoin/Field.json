{"lift_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n/-- If `K` and `L` are field extensions of `F` and we have `s : finset K` such that\nthe minimal polynomial of each `x ∈ s` splits in `L` then `algebra.adjoin F s` embeds in `L`. -/\ntheorem lift_of_splits {F K L : Type _} [Field F] [Field K] [Field L] [Algebra F K] [Algebra F L] (s : Finset K) :\n    (∀ x ∈ s, is_integral F x ∧ Polynomial.Splits (algebraMap F L) (minpoly F x)) →\n      Nonempty («expr →ₐ[ ] » (Algebra.adjoin F (↑s : Set K)) F L) :=\n  by\n  classical\n    refine' Finset.induction_on s (fun H => _) fun a s has ih H => _\n    · rw [coe_empty, Algebra.adjoin_empty]\n      exact ⟨(Algebra.ofId F L).comp (Algebra.botEquiv F K)⟩\n    rw [forall_mem_insert] at H\n    rcases H with ⟨⟨H1, H2⟩, H3⟩\n    cases' ih H3 with f\n    choose H3 H4 using H3\n    rw [coe_insert, Set.insert_eq, Set.union_comm, Algebra.adjoin_union_eq_adjoin_adjoin]\n    letI := (f : «expr →+* » (Algebra.adjoin F (↑s : Set K)) L).to_algebra\n    haveI : FiniteDimensional F (Algebra.adjoin F (↑s : Set K)) :=\n      ((Submodule.fg_iff_finiteDimensional _).1 (fg_adjoin_of_finite s.finite_to_set H3)).of_subalgebra_to_submodule\n    letI := fieldOfFiniteDimensional F (Algebra.adjoin F (↑s : Set K))\n    have H5 : is_integral (Algebra.adjoin F (↑s : Set K)) a := is_integral_of_is_scalar_tower H1\n    have H6 : (minpoly (Algebra.adjoin F (↑s : Set K)) a).splits (algebraMap (Algebra.adjoin F (↑s : Set K)) L) :=\n      by\n      refine'\n        Polynomial.splits_of_splits_of_dvd _\n          (Polynomial.map_ne_zero <| minpoly.ne_zero H1 : Polynomial.map (algebraMap _ _) _ ≠ 0)\n          ((Polynomial.splits_map_iff _ _).2 _) (minpoly.dvd _ _ _)\n      · rw [← IsScalarTower.algebraMap_eq]\n        exact H2\n      · rw [Polynomial.aeval_map_algebraMap, minpoly.aeval]\n    obtain ⟨y, hy⟩ := Polynomial.exists_root_of_splits _ H6 (ne_of_lt (minpoly.degree_pos H5)).symm\n    refine' ⟨Subalgebra.ofRestrictScalars _ _ _⟩\n    refine' (adjoin_root.lift_hom (minpoly (Algebra.adjoin F (↑s : Set K)) a) y hy).comp _\n    exact alg_equiv.adjoin_singleton_equiv_adjoin_root_minpoly (Algebra.adjoin F (↑s : Set K)) a\n#align lift_of_splits lift_of_splits\n\n"}