{"lift_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n/-- If `K` and `L` are field extensions of `F` and we have `s : finset K` such that\nthe minimal polynomial of each `x ∈ s` splits in `L` then `algebra.adjoin F s` embeds in `L`. -/\ntheorem lift_of_splits {F K L : Type _} [Field F] [Field K] [Field L] [algebra F K] [algebra F L] (s : Finset K) :\n    (∀ x ∈ s, is_integral F x ∧ polynomial.splits (algebra_map F L) (minpoly F x)) →\n      nonempty («expr →ₐ[ ] » (algebra.adjoin F (↑s : set K)) F L) :=\n  by\n  classical\n    refine' Finset.induction_on s (fun H => _) fun a s has ih H => _\n    · rw [coe_empty, algebra.adjoin_empty]\n      exact ⟨(algebra.of_id F L).comp (algebra.bot_equiv F K)⟩\n    rw [forall_mem_insert] at H\n    rcases H with ⟨⟨H1, H2⟩, H3⟩\n    cases' ih H3 with f\n    choose H3 H4 using H3\n    rw [coe_insert, Set.insert_eq, Set.union_comm, algebra.adjoin_union_eq_adjoin_adjoin]\n    letI := (f : «expr →+* » (algebra.adjoin F (↑s : set K)) L).to_algebra\n    haveI : finite_dimensional F (algebra.adjoin F (↑s : set K)) :=\n      ((submodule.fg_iff_finite_dimensional _).1 (fg_adjoin_of_finite s.finite_to_set H3)).of_subalgebra_to_submodule\n    letI := field_of_finite_dimensional F (algebra.adjoin F (↑s : set K))\n    have H5 : is_integral (algebra.adjoin F (↑s : set K)) a := is_integral_of_is_scalar_tower H1\n    have H6 : (minpoly (algebra.adjoin F (↑s : set K)) a).splits (algebra_map (algebra.adjoin F (↑s : set K)) L) :=\n      by\n      refine'\n        polynomial.splits_of_splits_of_dvd _\n          (polynomial.map_ne_zero <| minpoly.ne_zero H1 : polynomial.map (algebra_map _ _) _ ≠ 0)\n          ((polynomial.splits_map_iff _ _).2 _) (minpoly.dvd _ _ _)\n      · rw [← is_scalar_tower.algebra_map_eq]\n        exact H2\n      · rw [polynomial.aeval_map_algebra_map, minpoly.aeval]\n    obtain ⟨y, hy⟩ := polynomial.exists_root_of_splits _ H6 (ne_of_lt (minpoly.degree_pos H5)).symm\n    refine' ⟨subalgebra.of_restrict_scalars _ _ _⟩\n    refine' (adjoin_root.lift_hom (minpoly (algebra.adjoin F (↑s : set K)) a) y hy).comp _\n    exact alg_equiv.adjoin_singleton_equiv_adjoin_root_minpoly (algebra.adjoin F (↑s : set K)) a\n#align lift_of_splits lift_of_splits\n\n"}