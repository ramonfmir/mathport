{"zpowers_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem zpowers_eq {k : «exprℕ+»} {ζ : «expr ˣ» R} (h : is_primitive_root ζ k) :\n    subgroup.zpowers ζ = roots_of_unity k R :=\n  by\n  apply SetLike.coe_injective\n  haveI F : fintype (subgroup.zpowers ζ) := fintype.of_equiv _ h.zmod_equiv_zpowers.to_equiv\n  refine'\n    @set.eq_of_subset_of_card_le («expr ˣ» R) (subgroup.zpowers ζ) (roots_of_unity k R) F (roots_of_unity.fintype R k)\n      (subgroup.zpowers_subset <| show ζ ∈ roots_of_unity k R from h.pow_eq_one) _\n  calc\n    fintype.card (roots_of_unity k R) ≤ k := card_roots_of_unity R k\n    _ = fintype.card (zmod k) := (zmod.card k).symm\n    _ = fintype.card (subgroup.zpowers ζ) := fintype.card_congr h.zmod_equiv_zpowers.to_equiv\n    \n#align zpowers_eq zpowers_eq\n\n",
 "zpow_of_gcd_eq_one":
 "theorem zpow_of_gcd_eq_one (h : is_primitive_root ζ k) (i : ℤ) (hi : i.gcd k = 1) : is_primitive_root (ζ ^ i) k :=\n  by\n  by_cases h0 : 0 ≤ i\n  · lift i to ℕ using h0\n    rw [zpow_ofNat]\n    exact h.pow_of_coprime i hi\n  have : 0 ≤ -i := by\n    simp only [not_le, neg_nonneg] at h0⊢\n    exact le_of_lt h0\n  lift -i to ℕ using this with i' hi'\n  rw [← inv_iff, ← zpow_neg, ← hi', zpow_ofNat]\n  apply h.pow_of_coprime\n  rw [int.gcd, ← Int.natAbs_neg, ← hi'] at hi\n  exact hi\n#align zpow_of_gcd_eq_one zpow_of_gcd_eq_one\n\n",
 "zpow_eq_one_iff_dvd":
 "theorem zpow_eq_one_iff_dvd (h : is_primitive_root ζ k) (l : ℤ) : ζ ^ l = 1 ↔ (k : ℤ) ∣ l :=\n  by\n  by_cases h0 : 0 ≤ l\n  · lift l to ℕ using h0\n    rw [zpow_ofNat]\n    norm_cast\n    exact h.pow_eq_one_iff_dvd l\n  · have : 0 ≤ -l := by\n      simp only [not_le, neg_nonneg] at h0⊢\n      exact le_of_lt h0\n    lift -l to ℕ using this with l' hl'\n    rw [← dvd_neg, ← hl']\n    norm_cast\n    rw [← h.pow_eq_one_iff_dvd, ← inv_inj, ← zpow_neg, ← hl', zpow_ofNat, inv_one]\n#align zpow_eq_one_iff_dvd zpow_eq_one_iff_dvd\n\n",
 "zpow_eq_one":
 "theorem zpow_eq_one (h : is_primitive_root ζ k) : ζ ^ (k : ℤ) = 1 :=\n  by\n  rw [zpow_ofNat]\n  exact h.pow_eq_one\n#align zpow_eq_one zpow_eq_one\n\n",
 "zmod_equiv_zpowers_symm_apply_zpow'":
 "@[simp]\ntheorem zmod_equiv_zpowers_symm_apply_zpow' (i : ℤ) : h.zmod_equiv_zpowers.symm ⟨ζ ^ i, i, rfl⟩ = i :=\n  h.zmod_equiv_zpowers_symm_apply_zpow i\n#align zmod_equiv_zpowers_symm_apply_zpow' zmod_equiv_zpowers_symm_apply_zpow'\n\n",
 "zmod_equiv_zpowers_symm_apply_zpow":
 "@[simp]\ntheorem zmod_equiv_zpowers_symm_apply_zpow (i : ℤ) :\n    h.zmod_equiv_zpowers.symm (Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : subgroup.zpowers ζ)) = i := by\n  rw [← h.zmod_equiv_zpowers.symm_apply_apply i, zmod_equiv_zpowers_apply_coe_int]\n#align zmod_equiv_zpowers_symm_apply_zpow zmod_equiv_zpowers_symm_apply_zpow\n\n",
 "zmod_equiv_zpowers_symm_apply_pow'":
 "@[simp]\ntheorem zmod_equiv_zpowers_symm_apply_pow' (i : ℕ) : h.zmod_equiv_zpowers.symm ⟨ζ ^ i, i, rfl⟩ = i :=\n  h.zmod_equiv_zpowers_symm_apply_pow i\n#align zmod_equiv_zpowers_symm_apply_pow' zmod_equiv_zpowers_symm_apply_pow'\n\n",
 "zmod_equiv_zpowers_symm_apply_pow":
 "@[simp]\ntheorem zmod_equiv_zpowers_symm_apply_pow (i : ℕ) :\n    h.zmod_equiv_zpowers.symm (Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : subgroup.zpowers ζ)) = i := by\n  rw [← h.zmod_equiv_zpowers.symm_apply_apply i, zmod_equiv_zpowers_apply_coe_nat]\n#align zmod_equiv_zpowers_symm_apply_pow zmod_equiv_zpowers_symm_apply_pow\n\n",
 "zmod_equiv_zpowers_apply_coe_nat":
 "@[simp]\ntheorem zmod_equiv_zpowers_apply_coe_nat (i : ℕ) :\n    h.zmod_equiv_zpowers i = Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : subgroup.zpowers ζ) :=\n  by\n  have : (i : zmod k) = (i : ℤ) := by norm_cast\n  simp only [this, zmod_equiv_zpowers_apply_coe_int, zpow_ofNat]\n  rfl\n#align zmod_equiv_zpowers_apply_coe_nat zmod_equiv_zpowers_apply_coe_nat\n\n",
 "zmod_equiv_zpowers_apply_coe_int":
 "@[simp]\ntheorem zmod_equiv_zpowers_apply_coe_int (i : ℤ) :\n    h.zmod_equiv_zpowers i = Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : subgroup.zpowers ζ) :=\n  add_monoid_hom.lift_of_right_inverse_comp_apply _ _ zmod.int_cast_right_inverse _ _\n#align zmod_equiv_zpowers_apply_coe_int zmod_equiv_zpowers_apply_coe_int\n\n",
 "zero":
 "theorem zero [nontrivial M₀] : is_primitive_root (0 : M₀) 0 :=\n  ⟨pow_zero 0, fun l hl => by simpa [zero_pow_eq, show ∀ p, ¬p → false ↔ p from @not_not] using hl⟩\n#align zero zero\n\n",
 "unique":
 "theorem unique {ζ : M} (hk : is_primitive_root ζ k) (hl : is_primitive_root ζ l) : k = l :=\n  nat.dvd_antisymm (hk.2 _ hl.1) (hl.2 _ hk.1)\n#align unique unique\n\n",
 "totient_le_degree_minpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The degree of the minimal polynomial of `μ` is at least `totient n`. -/\ntheorem totient_le_degree_minpoly : nat.totient n ≤ (minpoly ℤ μ).nat_degree :=\n  let P : polynomial ℤ := minpoly ℤ μ\n  let\n    P_K :-- minimal polynomial of `μ`\n      polynomial\n      K :=\n    map (Int.castRingHom K) P\n  -- minimal polynomial of `μ` sent to `K[X]`\n  calc\n    n.totient = (primitive_roots n K).card := h.card_primitive_roots.symm\n    _ ≤ P_K.roots.to_finset.card := finset.card_le_of_subset (is_roots_of_minpoly h)\n    _ ≤ P_K.roots.card := multiset.to_finset_card_le _\n    _ ≤ P_K.nat_degree := card_roots' _\n    _ ≤ P.nat_degree := nat_degree_map_le _ _\n    \n#align totient_le_degree_minpoly totient_le_degree_minpoly\n\n",
 "squarefree_minpoly_mod":
 "/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem squarefree_minpoly_mod {p : ℕ} [fact p.prime] (hdiv : ¬p ∣ n) :\n    squarefree (map (Int.castRingHom (zmod p)) (minpoly ℤ μ)) :=\n  (separable_minpoly_mod h hdiv).squarefree\n#align squarefree_minpoly_mod squarefree_minpoly_mod\n\n",
 "separable_minpoly_mod":
 "/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. -/\ntheorem separable_minpoly_mod {p : ℕ} [fact p.prime] (hdiv : ¬p ∣ n) :\n    separable (map (Int.castRingHom (zmod p)) (minpoly ℤ μ)) :=\n  by\n  have hdvd : map (Int.castRingHom (zmod p)) (minpoly ℤ μ) ∣ X ^ n - 1 := by\n    simpa [polynomial.map_pow, map_X, polynomial.map_one, polynomial.map_sub] using\n      RingHom.map_dvd (map_ring_hom (Int.castRingHom (zmod p))) (minpoly_dvd_X_pow_sub_one h)\n  refine' separable.of_dvd (separable_X_pow_sub_C 1 _ one_ne_zero) hdvd\n  by_contra hzero\n  exact hdiv ((zmod.nat_coe_zmod_eq_zero_iff_dvd n p).1 hzero)\n#align separable_minpoly_mod separable_minpoly_mod\n\n",
 "roots_of_unity_le_of_dvd":
 "theorem roots_of_unity_le_of_dvd (h : k ∣ l) : roots_of_unity k M ≤ roots_of_unity l M :=\n  by\n  obtain ⟨d, rfl⟩ := h\n  intro ζ h\n  simp_all only [mem_roots_of_unity, PNat.mul_coe, pow_mul, one_pow]\n#align roots_of_unity_le_of_dvd roots_of_unity_le_of_dvd\n\n",
 "roots_of_unity_equiv_nth_roots_symm_apply":
 "@[simp]\ntheorem roots_of_unity_equiv_nth_roots_symm_apply (x : { x // x ∈ nth_roots k (1 : R) }) :\n    ((roots_of_unity_equiv_nth_roots R k).symm x : R) = x :=\n  rfl\n#align roots_of_unity_equiv_nth_roots_symm_apply roots_of_unity_equiv_nth_roots_symm_apply\n\n",
 "roots_of_unity_equiv_nth_roots_apply":
 "@[simp]\ntheorem roots_of_unity_equiv_nth_roots_apply (x : roots_of_unity k R) :\n    (roots_of_unity_equiv_nth_roots R k x : R) = x :=\n  rfl\n#align roots_of_unity_equiv_nth_roots_apply roots_of_unity_equiv_nth_roots_apply\n\n",
 "restrict_roots_of_unity_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem ring_equiv.restrict_roots_of_unity_symm (σ : «expr ≃+* » R S) :\n    (σ.restrict_roots_of_unity k).symm = σ.symm.restrict_roots_of_unity k :=\n  rfl\n#align ring_equiv.restrict_roots_of_unity_symm ring_equiv.restrict_roots_of_unity_symm\n\n",
 "restrict_roots_of_unity_coe_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem ring_equiv.restrict_roots_of_unity_coe_apply (σ : «expr ≃+* » R S) (ζ : roots_of_unity k R) :\n    ↑(σ.restrict_roots_of_unity k ζ) = σ ↑ζ :=\n  rfl\n#align ring_equiv.restrict_roots_of_unity_coe_apply ring_equiv.restrict_roots_of_unity_coe_apply\n\n",
 "primitive_roots_zero":
 "@[simp]\ntheorem primitive_roots_zero : primitive_roots 0 R = ∅ := by\n  rw [primitive_roots, nth_roots_zero, Multiset.toFinset_zero, Finset.filter_empty]\n#align primitive_roots_zero primitive_roots_zero\n\n",
 "primitive_roots_one":
 "@[simp]\ntheorem primitive_roots_one : primitive_roots 1 R = {(1 : R)} :=\n  by\n  apply Finset.eq_singleton_iff_unique_mem.2\n  constructor\n  · simp only [is_primitive_root.one_right_iff, mem_primitive_roots zero_lt_one]\n  · intro x hx\n    rw [mem_primitive_roots zero_lt_one, is_primitive_root.one_right_iff] at hx\n    exact hx\n#align primitive_roots_one primitive_roots_one\n\n",
 "pow_sub_one_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If `1 < k`, then `ζ ^ k.pred = -(∑ i in range k.pred, ζ ^ i)`. -/\ntheorem pow_sub_one_eq [IsDomain R] {ζ : R} (hζ : is_primitive_root ζ k) (hk : 1 < k) :\n    ζ ^ k.pred =\n      -finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range k.pred)\n          (ζ ^ i) :=\n  by\n  rw [eq_neg_iff_add_eq_zero, add_comm, ← sum_range_succ, ← nat.succ_eq_add_one, nat.succ_pred_eq_of_pos (pos_of_gt hk),\n    hζ.geom_sum_eq_zero hk]\n#align pow_sub_one_eq pow_sub_one_eq\n\n",
 "pow_of_prime":
 "theorem pow_of_prime (h : is_primitive_root ζ k) {p : ℕ} (hprime : Nat.Prime p) (hdiv : ¬p ∣ k) :\n    is_primitive_root (ζ ^ p) k :=\n  h.pow_of_coprime p (hprime.coprime_iff_not_dvd.2 hdiv)\n#align pow_of_prime pow_of_prime\n\n",
 "pow_of_dvd":
 "theorem pow_of_dvd (h : is_primitive_root ζ k) {p : ℕ} (hp : p ≠ 0) (hdiv : p ∣ k) :\n    is_primitive_root (ζ ^ p) (k / p) :=\n  by\n  suffices order_of (ζ ^ p) = k / p by exact this ▸ is_primitive_root.order_of (ζ ^ p)\n  rw [order_of_pow' _ hp, ← eq_order_of h, nat.gcd_eq_right hdiv]\n#align pow_of_dvd pow_of_dvd\n\n",
 "pow_of_coprime":
 "theorem pow_of_coprime (h : is_primitive_root ζ k) (i : ℕ) (hi : i.coprime k) : is_primitive_root (ζ ^ i) k :=\n  by\n  by_cases h0 : k = 0\n  · subst k\n    simp_all only [pow_one, nat.coprime_zero_right]\n  rcases h.is_unit (nat.pos_of_ne_zero h0) with ⟨ζ, rfl⟩\n  rw [← Units.val_pow_eq_pow_val]\n  rw [coe_units_iff] at h⊢\n  refine'\n    { pow_eq_one := by rw [← pow_mul', pow_mul, h.pow_eq_one, one_pow]\n      dvd_of_pow_eq_one := _ }\n  intro l hl\n  apply h.dvd_of_pow_eq_one\n  rw [← pow_one ζ, ← zpow_ofNat ζ, ← hi.gcd_eq_one, Nat.gcd_eq_gcd_ab, zpow_add, mul_pow, ← zpow_ofNat, ← zpow_mul,\n    mul_right_comm]\n  simp only [zpow_mul, hl, h.pow_eq_one, one_zpow, one_pow, one_mul, zpow_ofNat]\n#align pow_of_coprime pow_of_coprime\n\n",
 "pow_ne_one_of_pos_of_lt":
 "theorem pow_ne_one_of_pos_of_lt (h0 : 0 < l) (hl : l < k) : ζ ^ l ≠ 1 :=\n  mt (nat.le_of_dvd h0 ∘ h.dvd_of_pow_eq_one _) <| not_le_of_lt hl\n#align pow_ne_one_of_pos_of_lt pow_ne_one_of_pos_of_lt\n\n",
 "pow_is_root_minpoly":
 "/-- If `m : ℕ` is coprime with `n`,\nthen the minimal polynomial of a primitive `n`-th root of unity `μ`\nhas `μ ^ m` as root. -/\ntheorem pow_is_root_minpoly {m : ℕ} (hcop : nat.coprime m n) :\n    is_root (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by\n  simpa [minpoly_eq_pow_coprime h hcop, eval_map, aeval_def (μ ^ m) _] using minpoly.aeval ℤ (μ ^ m)\n#align pow_is_root_minpoly pow_is_root_minpoly\n\n",
 "pow_inj":
 "theorem pow_inj (h : is_primitive_root ζ k) ⦃i j : ℕ⦄ (hi : i < k) (hj : j < k) (H : ζ ^ i = ζ ^ j) : i = j :=\n  by\n  wlog hij : i ≤ j\n  apply le_antisymm hij\n  rw [← tsub_eq_zero_iff_le]\n  apply Nat.eq_zero_of_dvd_of_lt _ (lt_of_le_of_lt tsub_le_self hj)\n  apply h.dvd_of_pow_eq_one\n  rw [← ((h.is_unit (lt_of_le_of_lt (nat.zero_le _) hi)).pow i).mul_left_inj, ← pow_add, tsub_add_cancel_of_le hij, H,\n    one_mul]\n#align pow_inj pow_inj\n\n",
 "pow_iff_coprime":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { occs := occurrences.pos[occurrences.pos] «expr[ ,]»([1]) } -/\ntheorem pow_iff_coprime (h : is_primitive_root ζ k) (h0 : 0 < k) (i : ℕ) : is_primitive_root (ζ ^ i) k ↔ i.coprime k :=\n  by\n  refine' ⟨_, h.pow_of_coprime i⟩\n  intro hi\n  obtain ⟨a, ha⟩ := i.gcd_dvd_left k\n  obtain ⟨b, hb⟩ := i.gcd_dvd_right k\n  suffices b = k by rwa [this, ← one_mul k, mul_left_inj' h0.ne', eq_comm] at hb\n  rw [ha] at hi\n  rw [mul_comm] at hb\n  apply nat.dvd_antisymm ⟨i.gcd k, hb⟩ (hi.dvd_of_pow_eq_one b _)\n  rw [← pow_mul', ← mul_assoc, ← hb, pow_mul, h.pow_eq_one, one_pow]\n#align pow_iff_coprime pow_iff_coprime\n\n",
 "pow_eq_one_iff_dvd":
 "theorem pow_eq_one_iff_dvd (l : ℕ) : ζ ^ l = 1 ↔ k ∣ l :=\n  ⟨h.dvd_of_pow_eq_one l, by\n    rintro ⟨i, rfl⟩\n    simp only [pow_mul, h.pow_eq_one, one_pow, PNat.mul_coe]⟩\n#align pow_eq_one_iff_dvd pow_eq_one_iff_dvd\n\n",
 "pow":
 "/-- If there is a `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem pow {n : ℕ} {a b : ℕ} (hn : 0 < n) (h : is_primitive_root ζ n) (hprod : n = a * b) :\n    is_primitive_root (ζ ^ a) b := by\n  subst n\n  simp only [iff_def, ← pow_mul, h.pow_eq_one, eq_self_iff_true, true_and_iff]\n  intro l hl\n  have ha0 : a ≠ 0 := by\n    rintro rfl\n    simpa only [nat.not_lt_zero, zero_mul] using hn\n  rwa [← mul_dvd_mul_iff_left ha0]\n  exact h.dvd_of_pow_eq_one _ hl\n#align pow pow\n\n",
 "order_of":
 "protected theorem order_of (ζ : M) : is_primitive_root ζ (order_of ζ) :=\n  ⟨pow_order_of_eq_one ζ, fun l => order_of_dvd_of_pow_eq_one⟩\n#align order_of order_of\n\n",
 "one_right_iff":
 "@[simp]\ntheorem one_right_iff : is_primitive_root ζ 1 ↔ ζ = 1 :=\n  by\n  constructor\n  · intro h\n    rw [← pow_one ζ, h.pow_eq_one]\n  · rintro rfl\n    exact one\n#align one_right_iff one_right_iff\n\n",
 "one":
 "theorem one : is_primitive_root (1 : M) 1 :=\n  { pow_eq_one := pow_one _\n    dvd_of_pow_eq_one := fun l hl => one_dvd _ }\n#align one one\n\n",
 "of_subsingleton":
 "@[nontriviality]\ntheorem of_subsingleton [subsingleton M] (x : M) : is_primitive_root x 1 :=\n  ⟨subsingleton.elim _ _, fun _ _ => one_dvd _⟩\n#align of_subsingleton of_subsingleton\n\n",
 "of_map_of_injective":
 "theorem of_map_of_injective [MonoidHomClass F M N] (h : is_primitive_root (f ζ) k) (hf : injective f) :\n    is_primitive_root ζ k :=\n  { pow_eq_one := by\n      apply_fun f\n      rw [map_pow, _root_.map_one, h.pow_eq_one]\n    dvd_of_pow_eq_one := by\n      rw [h.eq_order_of]\n      intro l hl\n      apply_fun f  at hl\n      rw [map_pow, _root_.map_one] at hl\n      exact order_of_dvd_of_pow_eq_one hl }\n#align of_map_of_injective of_map_of_injective\n\n",
 "nth_roots_one_eq_bUnion_primitive_roots'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- `nth_roots n` as a `finset` is equal to the union of `primitive_roots i R` for `i ∣ n`\nif there is a primitive root of unity in `R`.\nThis holds for any `nat`, not just `pnat`, see `nth_roots_one_eq_bUnion_primitive_roots`. -/\ntheorem nth_roots_one_eq_bUnion_primitive_roots' {ζ : R} {n : «exprℕ+»} (h : is_primitive_root ζ n) :\n    nth_roots_finset n R = (nat.divisors ↑n).bUnion fun i => primitive_roots i R :=\n  by\n  symm\n  apply finset.eq_of_subset_of_card_le\n  · intro x\n    simp only [nth_roots_finset, ← Multiset.toFinset_eq (nth_roots_nodup h), exists_prop, Finset.mem_bunionᵢ,\n      Finset.mem_filter, Finset.mem_range, mem_nth_roots, Finset.mem_mk, nat.mem_divisors, and_true_iff, ne.def,\n      PNat.ne_zero, PNat.pos, not_false_iff]\n    rintro ⟨a, ⟨d, hd⟩, ha⟩\n    have hazero : 0 < a := by\n      contrapose! hd with ha0\n      simp_all only [nonpos_iff_eq_zero, zero_mul]\n      exact n.ne_zero\n    rw [mem_primitive_roots hazero] at ha\n    rw [hd, pow_mul, ha.pow_eq_one, one_pow]\n  · apply le_of_eq\n    rw [h.card_nth_roots_finset, finset.card_bUnion]\n    · nth_rw_lhs 1 [← nat.sum_totient n]\n      refine' sum_congr rfl _\n      simp only [nat.mem_divisors]\n      rintro k ⟨⟨d, hd⟩, -⟩\n      rw [mul_comm] at hd\n      rw [(h.pow n.pos hd).card_primitive_roots]\n    · intro i hi j hj hdiff\n      exact Disjoint hdiff\n#align nth_roots_one_eq_bUnion_primitive_roots' nth_roots_one_eq_bUnion_primitive_roots'\n\n",
 "nth_roots_one_eq_bUnion_primitive_roots":
 "/-- `nth_roots n` as a `finset` is equal to the union of `primitive_roots i R` for `i ∣ n`\nif there is a primitive root of unity in `R`. -/\ntheorem nth_roots_one_eq_bUnion_primitive_roots {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) :\n    nth_roots_finset n R = (nat.divisors n).bUnion fun i => primitive_roots i R :=\n  by\n  by_cases hn : n = 0\n  · simp [hn]\n  exact @nth_roots_one_eq_bUnion_primitive_roots' _ _ _ _ ⟨n, nat.pos_of_ne_zero hn⟩ h\n#align nth_roots_one_eq_bUnion_primitive_roots nth_roots_one_eq_bUnion_primitive_roots\n\n",
 "nth_roots_nodup":
 "/-- The multiset `nth_roots ↑n (1 : R)` has no repeated elements\nif there is a primitive root of unity in `R`. -/\ntheorem nth_roots_nodup {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : (nth_roots n (1 : R)).nodup :=\n  by\n  cases' nat.eq_zero_or_pos n with hzero hpos\n  · simp only [hzero, Multiset.nodup_zero, nth_roots_zero]\n  apply (@Multiset.dedup_eq_self R _ _).1\n  rw [eq_iff_le_not_lt]\n  constructor\n  · exact Multiset.dedup_le (nth_roots n (1 : R))\n  · by_contra ha\n    replace ha := Multiset.card_lt_of_lt ha\n    rw [card_nth_roots h] at ha\n    have hrw : (nth_roots n (1 : R)).dedup.card = fintype.card { x // x ∈ nth_roots n (1 : R) } :=\n      by\n      set fs := (⟨(nth_roots n (1 : R)).dedup, Multiset.nodup_dedup _⟩ : Finset R)\n      rw [← finset.card_mk, ← fintype.card_of_subtype fs _]\n      intro x\n      simp only [Multiset.mem_dedup, Finset.mem_mk]\n    rw [← PNat.toPNat'_coe hpos] at h hrw ha\n    set m := Nat.toPNat' n\n    rw [hrw, ← fintype.card_congr (roots_of_unity_equiv_nth_roots R m), card_roots_of_unity h] at ha\n    exact nat.lt_asymm ha ha\n#align nth_roots_nodup nth_roots_nodup\n\n",
 "not_iff":
 "#print not_iff /-\nprotected theorem not_iff : ¬is_primitive_root ζ k ↔ order_of ζ ≠ k :=\n  ⟨fun h hk => h <| hk ▸ is_primitive_root.order_of ζ, fun h hk => h.symm <| hk.unique <| is_primitive_root.order_of ζ⟩\n#align not_iff not_iff\n-/\n\n",
 "neg_one":
 "theorem neg_one (p : ℕ) [nontrivial R] [h : char_p R p] (hp : p ≠ 2) : is_primitive_root (-1 : R) 2 :=\n  by\n  convert is_primitive_root.order_of (-1 : R)\n  rw [order_of_neg_one, if_neg]\n  rwa [ring_char.eq_iff.mpr h]\n#align neg_one neg_one\n\n",
 "ne_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem ne_zero' {n : «exprℕ+»} (hζ : is_primitive_root ζ n) : ne_zero ((n : ℕ) : R) :=\n  by\n  let p := ring_char R\n  have hfin := multiplicity.finite_nat_iff.2 ⟨char_p.char_ne_one R p, n.pos⟩\n  obtain ⟨m, hm⟩ := multiplicity.exists_eq_pow_mul_and_not_dvd hfin\n  by_cases hp : p ∣ n\n  · obtain ⟨k, hk⟩ := nat.exists_eq_succ_of_ne_zero (multiplicity.pos_of_dvd hfin hp).ne'\n    haveI : ne_zero p := ne_zero.of_pos (nat.pos_of_dvd_of_pos hp n.pos)\n    haveI hpri : fact p.prime := char_p.char_is_prime_of_pos R p\n    have := hζ.pow_eq_one\n    rw [hm.1, hk, pow_succ, mul_assoc, pow_mul', ← frobenius_def, ← frobenius_one p] at this\n    exfalso\n    have hpos : 0 < p ^ k * m :=\n      by\n      refine' mul_pos (pow_pos hpri.1.pos _) (nat.pos_of_ne_zero fun h => _)\n      have H := hm.1\n      rw [h] at H\n      simpa using H\n    refine' hζ.pow_ne_one_of_pos_of_lt hpos _ (frobenius_inj R p this)\n    · rw [hm.1, hk, pow_succ, mul_assoc, mul_comm p]\n      exact lt_mul_of_one_lt_right hpos hpri.1.one_lt\n  · exact ne_zero.of_not_dvd R hp\n#align ne_zero' ne_zero'\n\n",
 "ne_zero":
 "protected theorem ne_zero [nontrivial M₀] {ζ : M₀} (h : is_primitive_root ζ k) : k ≠ 0 → ζ ≠ 0 :=\n  mt fun hn => h.unique (hn.symm ▸ is_primitive_root.zero)\n#align ne_zero ne_zero\n\n",
 "ne_one":
 "theorem ne_one (hk : 1 < k) : ζ ≠ 1 :=\n  h.pow_ne_one_of_pos_of_lt zero_lt_one hk ∘ (pow_one ζ).trans\n#align ne_one ne_one\n\n",
 "mk_of_lt":
 "theorem mk_of_lt (ζ : M) (hk : 0 < k) (h1 : ζ ^ k = 1) (h : ∀ l : ℕ, 0 < l → l < k → ζ ^ l ≠ 1) :\n    is_primitive_root ζ k := by\n  refine' ⟨h1, fun l hl => _⟩\n  suffices k.gcd l = k by exact this ▸ k.gcd_dvd_right l\n  rw [eq_iff_le_not_lt]\n  refine' ⟨nat.le_of_dvd hk (k.gcd_dvd_left l), _⟩\n  intro h'\n  apply h _ (nat.gcd_pos_of_pos_left _ hk) h'\n  exact pow_gcd_eq_one _ h1 hl\n#align mk_of_lt mk_of_lt\n\n",
 "minpoly_eq_pow_coprime":
 "/-- If `m : ℕ` is coprime with `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\nand of `μ ^ m` are the same. -/\ntheorem minpoly_eq_pow_coprime {m : ℕ} (hcop : nat.coprime m n) : minpoly ℤ μ = minpoly ℤ (μ ^ m) :=\n  by\n  revert n hcop\n  refine' unique_factorization_monoid.induction_on_prime m _ _ _\n  · intro n hn h\n    congr\n    simpa [(nat.coprime_zero_left n).mp hn] using h\n  · intro u hunit n hcop h\n    congr\n    simp [nat.is_unit_iff.mp hunit]\n  · intro a p ha hprime hind n hcop h\n    rw [hind (nat.coprime.coprime_mul_left hcop) h]\n    clear hind\n    replace hprime := hprime.nat_prime\n    have hdiv := (Nat.Prime.coprime_iff_not_dvd hprime).1 (nat.coprime.coprime_mul_right hcop)\n    haveI := fact.mk hprime\n    rw [minpoly_eq_pow (h.pow_of_coprime a (nat.coprime.coprime_mul_left hcop)) hdiv]\n    congr 1\n    ring\n#align minpoly_eq_pow_coprime minpoly_eq_pow_coprime\n\n",
 "minpoly_eq_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\nand of `μ ^ p` are the same. -/\ntheorem minpoly_eq_pow {p : ℕ} [hprime : fact p.prime] (hdiv : ¬p ∣ n) : minpoly ℤ μ = minpoly ℤ (μ ^ p) :=\n  by\n  by_cases hn : n = 0\n  · simp_all\n  have hpos := nat.pos_of_ne_zero hn\n  by_contra hdiff\n  set P := minpoly ℤ μ\n  set Q := minpoly ℤ (μ ^ p)\n  have Pmonic : P.monic := minpoly.monic (h.is_integral hpos)\n  have Qmonic : Q.monic := minpoly.monic ((h.pow_of_prime hprime.1 hdiv).is_integral hpos)\n  have Pirr : Irreducible P := minpoly.irreducible (h.is_integral hpos)\n  have Qirr : Irreducible Q := minpoly.irreducible ((h.pow_of_prime hprime.1 hdiv).is_integral hpos)\n  have PQprim : is_primitive (P * Q) := Pmonic.is_primitive.mul Qmonic.is_primitive\n  have prod : P * Q ∣ X ^ n - 1 :=\n    by\n    rw [is_primitive.int.dvd_iff_map_cast_dvd_map_cast (P * Q) (X ^ n - 1) PQprim\n        (monic_X_pow_sub_C (1 : ℤ) (ne_of_gt hpos)).is_primitive,\n      polynomial.map_mul]\n    refine' IsCoprime.mul_dvd _ _ _\n    · have aux := is_primitive.int.irreducible_iff_irreducible_map_cast Pmonic.is_primitive\n      refine' (dvd_or_coprime _ _ (aux.1 Pirr)).resolve_left _\n      rw [map_dvd_map (Int.castRingHom (exprℚ)) Int.cast_injective Pmonic]\n      intro hdiv\n      refine' hdiff (eq_of_monic_of_associated Pmonic Qmonic _)\n      exact associated_of_dvd_dvd hdiv (Pirr.dvd_symm Qirr hdiv)\n    · apply (map_dvd_map (Int.castRingHom (exprℚ)) Int.cast_injective Pmonic).2\n      exact minpoly_dvd_X_pow_sub_one h\n    · apply (map_dvd_map (Int.castRingHom (exprℚ)) Int.cast_injective Qmonic).2\n      exact minpoly_dvd_X_pow_sub_one (pow_of_prime h hprime.1 hdiv)\n  replace prod := RingHom.map_dvd (map_ring_hom (Int.castRingHom (zmod p))) Prod\n  rw [coe_map_ring_hom, polynomial.map_mul, polynomial.map_sub, polynomial.map_one, polynomial.map_pow, map_X] at prod\n  obtain ⟨R, hR⟩ := minpoly_dvd_mod_p h hdiv\n  rw [hR, ← mul_assoc, ← polynomial.map_mul, ← sq, polynomial.map_pow] at prod\n  have habs : map (Int.castRingHom (zmod p)) P ^ 2 ∣ map (Int.castRingHom (zmod p)) P ^ 2 * R := by use R\n  replace habs :=\n    lt_of_lt_of_le (part_enat.coe_lt_coe.2 one_lt_two) (multiplicity.le_multiplicity_of_pow_dvd (dvd_trans habs Prod))\n  have hfree : squarefree (X ^ n - 1 : polynomial (zmod p)) :=\n    (separable_X_pow_sub_C 1 (fun h => hdiv <| (zmod.nat_coe_zmod_eq_zero_iff_dvd n p).1 h) one_ne_zero).squarefree\n  cases' (multiplicity.squarefree_iff_multiplicity_le_one (X ^ n - 1)).1 hfree (map (Int.castRingHom (zmod p)) P) with\n    hle hunit\n  · rw [Nat.cast_one] at habs\n    exact hle.not_lt habs\n  · replace hunit := degree_eq_zero_of_is_unit hunit\n    rw [degree_map_eq_of_leading_coeff_ne_zero (Int.castRingHom (zmod p)) _] at hunit\n    · exact (minpoly.degree_pos (is_integral h hpos)).ne' hunit\n    simp only [Pmonic, eq_intCast, monic.leading_coeff, Int.cast_one, ne.def, not_false_iff, one_ne_zero]\n#align minpoly_eq_pow minpoly_eq_pow\n\n",
 "minpoly_dvd_pow_mod":
 "/- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of\n`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `Q ^ p` modulo `p`. -/\ntheorem minpoly_dvd_pow_mod {p : ℕ} [hprime : fact p.prime] (hdiv : ¬p ∣ n) :\n    map (Int.castRingHom (zmod p)) (minpoly ℤ μ) ∣ map (Int.castRingHom (zmod p)) (minpoly ℤ (μ ^ p)) ^ p :=\n  by\n  set Q := minpoly ℤ (μ ^ p)\n  have hfrob : map (Int.castRingHom (zmod p)) Q ^ p = map (Int.castRingHom (zmod p)) (expand ℤ p Q) := by\n    rw [← zmod.expand_card, map_expand]\n  rw [hfrob]\n  apply RingHom.map_dvd (map_ring_hom (Int.castRingHom (zmod p)))\n  exact minpoly_dvd_expand h hprime.1 hdiv\n#align minpoly_dvd_pow_mod minpoly_dvd_pow_mod\n\n",
 "minpoly_dvd_mod_p":
 "/- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of\n`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `Q` modulo `p`. -/\ntheorem minpoly_dvd_mod_p {p : ℕ} [hprime : fact p.prime] (hdiv : ¬p ∣ n) :\n    map (Int.castRingHom (zmod p)) (minpoly ℤ μ) ∣ map (Int.castRingHom (zmod p)) (minpoly ℤ (μ ^ p)) :=\n  (unique_factorization_monoid.dvd_pow_iff_dvd_of_squarefree (squarefree_minpoly_mod h hdiv) hprime.1.ne_zero).1\n    (minpoly_dvd_pow_mod h hdiv)\n#align minpoly_dvd_mod_p minpoly_dvd_mod_p\n\n",
 "minpoly_dvd_expand":
 "/- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of\n`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `expand ℤ p Q`. -/\ntheorem minpoly_dvd_expand {p : ℕ} (hprime : Nat.Prime p) (hdiv : ¬p ∣ n) :\n    minpoly ℤ μ ∣ expand ℤ p (minpoly ℤ (μ ^ p)) :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hpos)\n  · simp_all\n  refine' minpoly.gcd_domain_dvd (h.is_integral hpos) _ _\n  · apply monic.ne_zero\n    rw [polynomial.monic, leading_coeff, nat_degree_expand, mul_comm, coeff_expand_mul' (Nat.Prime.pos hprime), ←\n      leading_coeff, ← polynomial.monic]\n    exact minpoly.monic (is_integral (pow_of_prime h hprime hdiv) hpos)\n  · rw [aeval_def, coe_expand, ← comp, eval₂_eq_eval_map, map_comp, polynomial.map_pow, map_X, eval_comp, eval_pow,\n      eval_X, ← eval₂_eq_eval_map, ← aeval_def]\n    exact minpoly.aeval _ _\n#align minpoly_dvd_expand minpoly_dvd_expand\n\n",
 "minpoly_dvd_X_pow_sub_one":
 "/-- The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/\ntheorem minpoly_dvd_X_pow_sub_one : minpoly ℤ μ ∣ X ^ n - 1 :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hpos)\n  · simp\n  apply minpoly.gcd_domain_dvd (is_integral h hpos) (monic_X_pow_sub_C 1 hpos.ne').ne_zero\n  simp only [((is_primitive_root.iff_def μ n).mp h).left, aeval_X_pow, eq_intCast, Int.cast_one, aeval_one,\n    alg_hom.map_sub, sub_self]\n#align minpoly_dvd_X_pow_sub_one minpoly_dvd_X_pow_sub_one\n\n",
 "mem_roots_of_unity_prime_pow_mul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem mem_roots_of_unity_prime_pow_mul_iff (p k : ℕ) (m : «exprℕ+») [hp : fact p.prime] [char_p R p]\n    {ζ : «expr ˣ» R} : ζ ∈ roots_of_unity (⟨p, hp.1.pos⟩ ^ k * m) R ↔ ζ ∈ roots_of_unity m R := by\n  simp [mem_roots_of_unity']\n#align mem_roots_of_unity_prime_pow_mul_iff mem_roots_of_unity_prime_pow_mul_iff\n\n",
 "mem_roots_of_unity_iff_mem_nth_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem mem_roots_of_unity_iff_mem_nth_roots {ζ : «expr ˣ» R} :\n    ζ ∈ roots_of_unity k R ↔ (ζ : R) ∈ nth_roots k (1 : R) := by\n  simp only [mem_roots_of_unity, mem_nth_roots k.pos, Units.ext_iff, Units.val_one, Units.val_pow_eq_pow_val]\n#align mem_roots_of_unity_iff_mem_nth_roots mem_roots_of_unity_iff_mem_nth_roots\n\n",
 "mem_roots_of_unity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem mem_roots_of_unity' (k : «exprℕ+») (ζ : «expr ˣ» M) : ζ ∈ roots_of_unity k M ↔ (ζ : M) ^ (k : ℕ) = 1 :=\n  by\n  rw [mem_roots_of_unity]\n  norm_cast\n#align mem_roots_of_unity' mem_roots_of_unity'\n\n",
 "mem_roots_of_unity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\nprotected theorem mem_roots_of_unity {ζ : «expr ˣ» M} {n : «exprℕ+»} (h : is_primitive_root ζ n) :\n    ζ ∈ roots_of_unity n M :=\n  h.pow_eq_one\n#align mem_roots_of_unity mem_roots_of_unity\n\n",
 "mem_primitive_roots":
 "@[simp]\ntheorem mem_primitive_roots {ζ : R} (h0 : 0 < k) : ζ ∈ primitive_roots k R ↔ is_primitive_root ζ k :=\n  by\n  rw [primitive_roots, mem_filter, Multiset.mem_toFinset, mem_nth_roots h0, and_iff_right_iff_imp]\n  exact is_primitive_root.pow_eq_one\n#align mem_primitive_roots mem_primitive_roots\n\n",
 "mem_nth_roots_finset":
 "theorem mem_nth_roots_finset (hζ : is_primitive_root ζ k) (hk : 0 < k) : ζ ∈ nth_roots_finset k R :=\n  (mem_nth_roots_finset hk).2 hζ.pow_eq_one\n#align mem_nth_roots_finset mem_nth_roots_finset\n\n",
 "map_roots_of_unity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem map_roots_of_unity (f : «expr →* » («expr ˣ» M) («expr ˣ» N)) (k : «exprℕ+») :\n    (roots_of_unity k M).map f ≤ roots_of_unity k N :=\n  by\n  rintro _ ⟨ζ, h, rfl⟩\n  simp_all only [← map_pow, mem_roots_of_unity, SetLike.mem_coe, MonoidHom.map_one]\n#align map_roots_of_unity map_roots_of_unity\n\n",
 "map_root_of_unity_eq_pow_self":
 "theorem map_root_of_unity_eq_pow_self [RingHomClass F R R] (σ : F) (ζ : roots_of_unity k R) : ∃ m : ℕ, σ ζ = ζ ^ m :=\n  by\n  obtain ⟨m, hm⟩ := monoid_hom.map_cyclic (restrict_roots_of_unity σ k)\n  rw [← restrict_roots_of_unity_coe_apply, hm, zpow_eq_mod_order_of, ←\n    Int.toNat_of_nonneg (m.mod_nonneg (int.coe_nat_ne_zero.mpr (pos_iff_ne_zero.mp (order_of_pos ζ)))), zpow_ofNat,\n    roots_of_unity.coe_pow]\n  exact ⟨(m % order_of ζ).to_nat, rfl⟩\n#align map_root_of_unity_eq_pow_self map_root_of_unity_eq_pow_self\n\n",
 "map_of_injective":
 "theorem map_of_injective [MonoidHomClass F M N] (h : is_primitive_root ζ k) (hf : injective f) :\n    is_primitive_root (f ζ) k :=\n  { pow_eq_one := by rw [← map_pow, h.pow_eq_one, _root_.map_one]\n    dvd_of_pow_eq_one := by\n      rw [h.eq_order_of]\n      intro l hl\n      rw [← map_pow, ← map_one f] at hl\n      exact order_of_dvd_of_pow_eq_one (hf hl) }\n#align map_of_injective map_of_injective\n\n",
 "map_iff_of_injective":
 "theorem map_iff_of_injective [MonoidHomClass F M N] (hf : injective f) :\n    is_primitive_root (f ζ) k ↔ is_primitive_root ζ k :=\n  ⟨fun h => h.of_map_of_injective hf, fun h => h.map_of_injective hf⟩\n#align map_iff_of_injective map_iff_of_injective\n\n",
 "is_unit":
 "theorem is_unit (h : is_primitive_root ζ k) (h0 : 0 < k) : is_unit ζ :=\n  by\n  apply isUnit_of_mul_eq_one ζ (ζ ^ (k - 1))\n  rw [← pow_succ, tsub_add_cancel_of_le h0.nat_succ_le, h.pow_eq_one]\n#align is_unit is_unit\n\n",
 "is_roots_of_minpoly":
 "/-- `primitive_roots n K` is a subset of the roots of the minimal polynomial of a primitive\n`n`-th root of unity `μ`. -/\ntheorem is_roots_of_minpoly : primitive_roots n K ⊆ (map (Int.castRingHom K) (minpoly ℤ μ)).roots.to_finset :=\n  by\n  by_cases hn : n = 0; · simp_all\n  have hpos := nat.pos_of_ne_zero hn\n  intro x hx\n  obtain ⟨m, hle, hcop, rfl⟩ := (is_primitive_root_iff h hpos).1 ((mem_primitive_roots hpos).1 hx)\n  simpa [Multiset.mem_toFinset, mem_roots (map_monic_ne_zero <| minpoly.monic <| is_integral h hpos)] using\n    pow_is_root_minpoly h hcop\n#align is_roots_of_minpoly is_roots_of_minpoly\n\n",
 "is_primitive_root_of_mem_primitive_roots":
 "theorem is_primitive_root_of_mem_primitive_roots {ζ : R} (h : ζ ∈ primitive_roots k R) : is_primitive_root ζ k :=\n  k.eq_zero_or_pos.elim (fun hk => false.elim <| by simpa [hk] using h) fun hk => (mem_primitive_roots hk).1 h\n#align is_primitive_root_of_mem_primitive_roots is_primitive_root_of_mem_primitive_roots\n\n",
 "is_primitive_root_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem is_primitive_root_iff' {k : «exprℕ+»} {ζ ξ : «expr ˣ» R} (h : is_primitive_root ζ k) :\n    is_primitive_root ξ k ↔ ∃ i < (k : ℕ), ∃ hi : i.coprime k, ζ ^ i = ξ :=\n  by\n  constructor\n  · intro hξ\n    obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_mem_roots_of_unity hξ.pow_eq_one\n    rw [h.pow_iff_coprime k.pos] at hξ\n    exact ⟨i, hik, hξ, rfl⟩\n  · rintro ⟨i, -, hi, rfl⟩\n    exact h.pow_of_coprime i hi\n#align is_primitive_root_iff' is_primitive_root_iff'\n\n",
 "is_primitive_root_iff":
 "theorem is_primitive_root_iff {k : ℕ} {ζ ξ : R} (h : is_primitive_root ζ k) (h0 : 0 < k) :\n    is_primitive_root ξ k ↔ ∃ i < k, ∃ hi : i.coprime k, ζ ^ i = ξ :=\n  by\n  constructor\n  · intro hξ\n    obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_pow_eq_one hξ.pow_eq_one h0\n    rw [h.pow_iff_coprime h0] at hξ\n    exact ⟨i, hik, hξ, rfl⟩\n  · rintro ⟨i, -, hi, rfl⟩\n    exact h.pow_of_coprime i hi\n#align is_primitive_root_iff is_primitive_root_iff\n\n",
 "is_integral":
 "/-- `μ` is integral over `ℤ`. -/\ntheorem is_integral : is_integral ℤ μ := by\n  use X ^ n - 1\n  constructor\n  · exact monic_X_pow_sub_C 1 (ne_of_lt hpos).symm\n  · simp only [((is_primitive_root.iff_def μ n).mp h).left, eval₂_one, eval₂_X_pow, eval₂_sub, sub_self]\n#align is_integral is_integral\n\n",
 "inv_iff":
 "@[simp]\ntheorem inv_iff : is_primitive_root ζ⁻¹ k ↔ is_primitive_root ζ k :=\n  by\n  refine' ⟨_, fun h => inv h⟩\n  intro h\n  rw [← inv_inv ζ]\n  exact inv h\n#align inv_iff inv_iff\n\n",
 "inv":
 "theorem inv (h : is_primitive_root ζ k) : is_primitive_root ζ⁻¹ k :=\n  { pow_eq_one := by simp only [h.pow_eq_one, inv_one, eq_self_iff_true, inv_pow]\n    dvd_of_pow_eq_one := by\n      intro l hl\n      apply h.dvd_of_pow_eq_one l\n      rw [← inv_inj, ← inv_pow, hl, inv_one] }\n#align inv inv\n\n",
 "iff_def":
 "#print iff_def /-\ntheorem iff_def (ζ : M) (k : ℕ) : is_primitive_root ζ k ↔ ζ ^ k = 1 ∧ ∀ l : ℕ, ζ ^ l = 1 → k ∣ l :=\n  ⟨fun ⟨h1, h2⟩ => ⟨h1, h2⟩, fun ⟨h1, h2⟩ => ⟨h1, h2⟩⟩\n#align iff_def iff_def\n-/\n\n",
 "iff":
 "protected theorem iff (hk : 0 < k) : is_primitive_root ζ k ↔ ζ ^ k = 1 ∧ ∀ l : ℕ, 0 < l → l < k → ζ ^ l ≠ 1 :=\n  by\n  refine' ⟨fun h => ⟨h.pow_eq_one, fun l hl' hl => _⟩, fun ⟨hζ, hl⟩ => is_primitive_root.mk_of_lt ζ hk hζ hl⟩\n  rw [h.eq_order_of] at hl\n  exact pow_ne_one_of_lt_order_of' hl'.ne' hl\n#align iff iff\n\n",
 "geom_sum_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. -/\ntheorem geom_sum_eq_zero [IsDomain R] {ζ : R} (hζ : is_primitive_root ζ k) (hk : 1 < k) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range k) (ζ ^ i) =\n      0 :=\n  by\n  refine' eq_zero_of_ne_zero_of_mul_left_eq_zero (sub_ne_zero_of_ne (hζ.ne_one hk).symm) _\n  rw [mul_neg_geom_sum, hζ.pow_eq_one, sub_self]\n#align geom_sum_eq_zero geom_sum_eq_zero\n\n",
 "eq_pow_of_pow_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem eq_pow_of_pow_eq_one {k : ℕ} {ζ ξ : R} (h : is_primitive_root ζ k) (hξ : ξ ^ k = 1) (h0 : 0 < k) :\n    ∃ i < k, ζ ^ i = ξ := by\n  lift ζ to «expr ˣ» R using h.is_unit h0\n  lift ξ to «expr ˣ» R using isUnit_ofPowEqOne hξ h0.ne'\n  lift k to «exprℕ+» using h0\n  simp only [← Units.val_pow_eq_pow_val, ← Units.ext_iff]\n  rw [coe_units_iff] at h\n  apply h.eq_pow_of_mem_roots_of_unity\n  rw [mem_roots_of_unity, Units.ext_iff, Units.val_pow_eq_pow_val, hξ, Units.val_one]\n#align eq_pow_of_pow_eq_one eq_pow_of_pow_eq_one\n\n",
 "eq_pow_of_mem_roots_of_unity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem eq_pow_of_mem_roots_of_unity {k : «exprℕ+»} {ζ ξ : «expr ˣ» R} (h : is_primitive_root ζ k)\n    (hξ : ξ ∈ roots_of_unity k R) : ∃ (i : ℕ)(hi : i < k), ζ ^ i = ξ :=\n  by\n  obtain ⟨n, rfl⟩ : ∃ n : ℤ, ζ ^ n = ξ := by rwa [← h.zpowers_eq] at hξ\n  have hk0 : (0 : ℤ) < k := by exact_mod_cast k.pos\n  let i := n % k\n  have hi0 : 0 ≤ i := Int.emod_nonneg _ (ne_of_gt hk0)\n  lift i to ℕ using hi0 with i₀ hi₀\n  refine' ⟨i₀, _, _⟩\n  · zify\n    rw [hi₀]\n    exact Int.emod_lt_of_pos _ hk0\n  · have aux := h.zpow_eq_one\n    rw [← coe_coe] at aux\n    rw [← zpow_ofNat, hi₀, ← Int.mod_add_div n k, zpow_add, zpow_mul, aux, one_zpow, mul_one]\n#align eq_pow_of_mem_roots_of_unity eq_pow_of_mem_roots_of_unity\n\n",
 "eq_order_of":
 "theorem eq_order_of : k = order_of ζ :=\n  h.unique (is_primitive_root.order_of ζ)\n#align eq_order_of eq_order_of\n\n",
 "eq_neg_one_of_two_right":
 "theorem eq_neg_one_of_two_right [no_zero_divisors R] {ζ : R} (h : is_primitive_root ζ 2) : ζ = -1 :=\n  by\n  apply (eq_or_eq_neg_of_sq_eq_sq ζ 1 _).resolve_left\n  · rw [← pow_one ζ]\n    apply h.pow_ne_one_of_pos_of_lt <;> decide\n  · simp only [h.pow_eq_one, one_pow]\n#align eq_neg_one_of_two_right eq_neg_one_of_two_right\n\n",
 "coe_units_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem coe_units_iff {ζ : «expr ˣ» M} : is_primitive_root (ζ : M) k ↔ is_primitive_root ζ k := by\n  simp only [iff_def, Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one]\n#align coe_units_iff coe_units_iff\n\n",
 "coe_submonoid_class_iff":
 "@[simp]\ntheorem coe_submonoid_class_iff {M B : Type _} [comm_monoid M] [SetLike B M] [SubmonoidClass B M] {N : B} {ζ : N} :\n    is_primitive_root (ζ : M) k ↔ is_primitive_root ζ k := by simp [iff_def, ← SubmonoidClass.coe_pow]\n#align coe_submonoid_class_iff coe_submonoid_class_iff\n\n",
 "coe_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[norm_cast]\ntheorem roots_of_unity.coe_pow [comm_monoid R] (ζ : roots_of_unity k R) (m : ℕ) : ↑(ζ ^ m) = (ζ ^ m : R) :=\n  by\n  change ↑(↑(ζ ^ m) : «expr ˣ» R) = ↑(ζ : «expr ˣ» R) ^ m\n  rw [subgroup.coe_pow, Units.val_pow_eq_pow_val]\n#align roots_of_unity.coe_pow roots_of_unity.coe_pow\n\n",
 "coe_mk_of_pow_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n@[simp]\ntheorem roots_of_unity.coe_mk_of_pow_eq {ζ : M} {n : «exprℕ+»} (h : ζ ^ (n : ℕ) = 1) :\n    (roots_of_unity.mk_of_pow_eq _ h : M) = ζ :=\n  rfl\n#align roots_of_unity.coe_mk_of_pow_eq roots_of_unity.coe_mk_of_pow_eq\n\n",
 "coe_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem roots_of_unity.coe_injective {n : «exprℕ+»} : function.injective (coe : roots_of_unity n M → M) :=\n  Units.ext.comp fun x y => subtype.ext\n#align roots_of_unity.coe_injective roots_of_unity.coe_injective\n\n",
 "coe_aut_to_pow_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n-- We are not using @[simps] in aut_to_pow to avoid a timeout.\ntheorem coe_aut_to_pow_apply (f : «expr ≃ₐ[ ] » S R S) :\n    (aut_to_pow R hμ f : zmod n) = ((map_root_of_unity_eq_pow_self f hμ.to_roots_of_unity).some : zmod n) :=\n  rfl\n#align coe_aut_to_pow_apply coe_aut_to_pow_apply\n\n",
 "card_roots_of_unity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem card_roots_of_unity' {n : «exprℕ+»} (h : is_primitive_root ζ n) : fintype.card (roots_of_unity n R) = n :=\n  by\n  let e := h.zmod_equiv_zpowers\n  haveI F : fintype (subgroup.zpowers ζ) := fintype.of_equiv _ e.to_equiv\n  calc\n    fintype.card (roots_of_unity n R) = fintype.card (subgroup.zpowers ζ) := fintype.card_congr <| by rw [h.zpowers_eq]\n    _ = fintype.card (zmod n) := fintype.card_congr e.to_equiv.symm\n    _ = n := zmod.card n\n    \n#align card_roots_of_unity' card_roots_of_unity'\n\n",
 "card_roots_of_unity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem card_roots_of_unity {ζ : R} {n : «exprℕ+»} (h : is_primitive_root ζ n) :\n    fintype.card (roots_of_unity n R) = n :=\n  by\n  obtain ⟨ζ, hζ⟩ := h.is_unit n.pos\n  rw [← hζ, is_primitive_root.coe_units_iff] at h\n  exact h.card_roots_of_unity'\n#align card_roots_of_unity card_roots_of_unity\n\n",
 "card_primitive_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/-- If an integral domain has a primitive `k`-th root of unity, then it has `φ k` of them. -/\ntheorem card_primitive_roots {ζ : R} {k : ℕ} (h : is_primitive_root ζ k) :\n    (primitive_roots k R).card = (nat.totient) k :=\n  by\n  by_cases h0 : k = 0\n  · simp [h0]\n  symm\n  refine' finset.card_congr (fun i _ => ζ ^ i) _ _ _\n  · simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]\n    rintro i - hi\n    rw [mem_primitive_roots (nat.pos_of_ne_zero h0)]\n    exact h.pow_of_coprime i hi.symm\n  · simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]\n    rintro i j hi - hj - H\n    exact h.pow_inj hi hj H\n  · simp only [exists_prop, true_and_iff, mem_filter, mem_range, mem_univ]\n    intro ξ hξ\n    rw [mem_primitive_roots (nat.pos_of_ne_zero h0), h.is_primitive_root_iff (nat.pos_of_ne_zero h0)] at hξ\n    rcases hξ with ⟨i, hin, hi, H⟩\n    exact ⟨i, ⟨hin, hi.symm⟩, H⟩\n#align card_primitive_roots card_primitive_roots\n\n",
 "card_nth_roots_finset":
 "@[simp]\ntheorem card_nth_roots_finset {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : (nth_roots_finset n R).card = n := by\n  rw [nth_roots_finset, ← Multiset.toFinset_eq (nth_roots_nodup h), card_mk, h.card_nth_roots]\n#align card_nth_roots_finset card_nth_roots_finset\n\n",
 "card_nth_roots":
 "/-- The cardinality of the multiset `nth_roots ↑n (1 : R)` is `n`\nif there is a primitive root of unity in `R`. -/\ntheorem card_nth_roots {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : (nth_roots n (1 : R)).card = n :=\n  by\n  cases' nat.eq_zero_or_pos n with hzero hpos\n  · simp only [hzero, Multiset.card_zero, nth_roots_zero]\n  rw [eq_iff_le_not_lt]\n  use card_nth_roots n 1\n  · rw [not_lt]\n    have hcard : fintype.card { x // x ∈ nth_roots n (1 : R) } ≤ (nth_roots n (1 : R)).attach.card :=\n      Multiset.card_le_of_le (Multiset.dedup_le _)\n    rw [Multiset.card_attach] at hcard\n    rw [← PNat.toPNat'_coe hpos] at hcard h⊢\n    set m := Nat.toPNat' n\n    rw [← fintype.card_congr (roots_of_unity_equiv_nth_roots R m), card_roots_of_unity h] at hcard\n    exact hcard\n#align card_nth_roots card_nth_roots\n\n",
 "aut_to_pow_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem aut_to_pow_spec (f : «expr ≃ₐ[ ] » S R S) : μ ^ (hμ.aut_to_pow R f : zmod n).val = f μ :=\n  by\n  rw [is_primitive_root.coe_aut_to_pow_apply]\n  generalize_proofs h\n  have := h.some_spec\n  dsimp only [alg_equiv.to_alg_hom_eq_coe, alg_equiv.coe_alg_hom] at this\n  refine' (_ : ↑hμ.to_roots_of_unity ^ _ = _).trans this.symm\n  rw [← roots_of_unity.coe_pow, ← roots_of_unity.coe_pow]\n  congr 1\n  rw [pow_eq_pow_iff_modeq, ← order_of_subgroup, ← order_of_units, hμ.coe_to_roots_of_unity_coe, ← hμ.eq_order_of,\n    zmod.val_nat_cast]\n  exact Nat.mod_modEq _ _\n#align aut_to_pow_spec aut_to_pow_spec\n\n",
 "Disjoint":
 "#print Disjoint /-\n/-- The sets `primitive_roots k R` are pairwise disjoint. -/\ntheorem Disjoint {k l : ℕ} (h : k ≠ l) : Disjoint (primitive_roots k R) (primitive_roots l R) :=\n  Finset.disjoint_left.2 fun z hk hl =>\n    h <| (is_primitive_root_of_mem_primitive_roots hk).unique <| is_primitive_root_of_mem_primitive_roots hl\n#align disjoint Disjoint\n-/\n\n"}