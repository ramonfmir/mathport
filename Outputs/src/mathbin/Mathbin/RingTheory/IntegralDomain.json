{"sum_hom_units_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\n-/\ntheorem sum_hom_units_eq_zero (f : «expr →* » G R) (hf : f ≠ 1) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (f g) =\n      0 :=\n  by\n  classical\n    obtain ⟨x, hx⟩ :\n      ∃ x : monoid_hom.range f.to_hom_units, ∀ y : monoid_hom.range f.to_hom_units, y ∈ submonoid.powers x\n    exact is_cyclic.exists_monoid_generator\n    have hx1 : x ≠ 1 := by\n      rintro rfl\n      apply hf\n      ext g\n      rw [MonoidHom.one_apply]\n      cases' hx ⟨f.to_hom_units g, g, rfl⟩ with n hn\n      rwa [subtype.ext_iff, Units.ext_iff, subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow, eq_comm] at hn\n    replace hx1 : (x : R) - 1 ≠ 0\n    exact fun h => hx1 (subtype.eq (Units.ext (sub_eq_zero.1 h)))\n    let c := (univ.filter fun g => f.to_hom_units g = 1).card\n    calc\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (f g) =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (f.to_hom_units g) :=\n        rfl\n      _ =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (univ.image f.to_hom_units) («expr • » (univ.filter fun g => f.to_hom_units g = u).card u) :=\n        sum_comp (coe : «expr ˣ» R → R) f.to_hom_units\n      _ =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (univ.image f.to_hom_units) («expr • » c u) :=\n        sum_congr rfl fun u hu => congr_arg₂ _ _ rfl\n      -- remaining goal 1, proven below\n          _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » c ↑b) :=\n        finset.sum_subtype _ (by simp) _\n      _ =\n          «expr • » c\n            (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              (b : R)) :=\n        smul_sum.symm\n      _ = «expr • » c 0 := congr_arg₂ _ rfl _\n      -- remaining goal 2, proven below\n          _ =\n          0 :=\n        smul_zero _\n      \n    · -- remaining goal 1\n      show (univ.filter fun g : G => f.to_hom_units g = u).card = c\n      apply card_fiber_eq_of_mem_range f.to_hom_units\n      · simpa only [mem_image, mem_univ, exists_prop_of_true, Set.mem_range] using hu\n      · exact ⟨1, f.to_hom_units.map_one⟩\n    -- remaining goal 2\n    show\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (b : R) =\n        0\n    calc\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (b : R) =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (range (order_of x)) (x ^ n) :=\n        eq.symm <|\n          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])\n            (by simp only [imp_true_iff, eq_self_iff_true, subgroup.coe_pow, Units.val_pow_eq_pow_val, coe_coe])\n            (fun m n hm hn =>\n              pow_injective_of_lt_order_of _ (by simpa only [mem_range] using hm) (by simpa only [mem_range] using hn))\n            fun b hb =>\n            let ⟨n, hn⟩ := hx b\n            ⟨n % order_of x, mem_range.2 (nat.mod_lt _ (order_of_pos _)), by rw [← pow_eq_mod_order_of, hn]⟩\n      _ = 0 := _\n      \n    rw [← mul_left_inj' hx1, zero_mul, geom_sum_mul, coe_coe]\n    norm_cast\n    simp [pow_order_of_eq_one]\n#align sum_hom_units_eq_zero sum_hom_units_eq_zero\n\n",
 "sum_hom_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- In an integral domain, a sum indexed by a homomorphism from a finite group is zero,\nunless the homomorphism is trivial, in which case the sum is equal to the cardinality of the group.\n-/\ntheorem sum_hom_units (f : «expr →* » G R) [decidable (f = 1)] :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (f g) =\n      if f = 1 then fintype.card G else 0 :=\n  by\n  split_ifs with h h\n  · simp [h, card_univ]\n  · exact sum_hom_units_eq_zero f h\n#align sum_hom_units sum_hom_units\n\n",
 "mul_right_bijective_of_finite₀":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Chris Hughes\n-/\n-- There doesn't seem to be a better home for these right now\ntheorem mul_right_bijective_of_finite₀ {a : M} (ha : a ≠ 0) : bijective fun b => a * b :=\n  finite.injective_iff_bijective.1 <| mul_right_injective₀ ha\n#align mul_right_bijective_of_finite₀ mul_right_bijective_of_finite₀\n\n",
 "mul_left_bijective_of_finite₀":
 "theorem mul_left_bijective_of_finite₀ {a : M} (ha : a ≠ 0) : bijective fun b => b * a :=\n  finite.injective_iff_bijective.1 <| mul_left_injective₀ ha\n#align mul_left_bijective_of_finite₀ mul_left_bijective_of_finite₀\n\n",
 "is_field_of_domain":
 "theorem finite.is_field_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=\n  by\n  cases nonempty_fintype R\n  exact @Field.toIsField R (@fintype.field_of_domain R _ _ (classical.dec_eq R) _)\n#align finite.is_field_of_domain finite.is_field_of_domain\n\n",
 "is_cyclic_of_subgroup_is_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem is_cyclic_of_subgroup_is_domain [Finite G] (f : «expr →* » G R) (hf : injective f) : is_cyclic G := by\n  classical\n    cases nonempty_fintype G\n    apply is_cyclic_of_card_pow_eq_one_le\n    intro n hn\n    convert le_trans (card_nth_roots_subgroup_units f hf hn 1) (card_nth_roots n (f 1))\n#align is_cyclic_of_subgroup_is_domain is_cyclic_of_subgroup_is_domain\n\n",
 "exists_eq_pow_of_mul_eq_pow_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (i j «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem finset.exists_eq_pow_of_mul_eq_pow_of_coprime {ι R : Type _} [CommSemiring R] [IsDomain R] [GCDMonoid R]\n    [unique («expr ˣ» R)] {n : ℕ} {c : R} {s : Finset ι} {f : ι → R}\n    (h : ∀ (i) (_ : i ∈ s) (j) (_ : j ∈ s), i ≠ j → IsCoprime (f i) (f j))\n    (hprod :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) =\n        c ^ n) :\n    ∀ i ∈ s, ∃ d : R, f i = d ^ n := by\n  classical\n    intro i hi\n    rw [← insert_erase hi, prod_insert (not_mem_erase i s)] at hprod\n    refine'\n      exists_eq_pow_of_mul_eq_pow_of_coprime\n        (is_coprime.prod_right fun j hj => h i hi j (erase_subset i s hj) fun hij => _) hprod\n    rw [hij] at hj\n    exact (s.not_mem_erase _) hj\n#align finset.exists_eq_pow_of_mul_eq_pow_of_coprime finset.exists_eq_pow_of_mul_eq_pow_of_coprime\n\n",
 "div_eq_quo_add_rem_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem div_eq_quo_add_rem_div (f : polynomial R) {g : polynomial R} (hg : g.monic) :\n    ∃ q r : polynomial R, r.degree < g.degree ∧ (↑f : K) / ↑g = ↑q + ↑r / ↑g :=\n  by\n  refine' ⟨«expr /ₘ » f g, «expr %ₘ » f g, _, _⟩\n  · exact degree_mod_by_monic_lt _ hg\n  · have hg' : (↑g : K) ≠ 0 := by exact_mod_cast monic.ne_zero hg\n    field_simp [hg']\n    norm_cast\n    rw [add_comm, mul_comm, mod_by_monic_add_div f hg]\n#align div_eq_quo_add_rem_div div_eq_quo_add_rem_div\n\n",
 "card_nth_roots_subgroup_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem card_nth_roots_subgroup_units [fintype G] (f : «expr →* » G R) (hf : injective f) {n : ℕ} (hn : 0 < n)\n    (g₀ : G) : ({ g ∈ univ | g ^ n = g₀ } : Finset G).card ≤ (nth_roots n (f g₀)).card :=\n  by\n  haveI : decidable_eq R := classical.dec_eq _\n  refine' le_trans _ (nth_roots n (f g₀)).to_finset_card_le\n  apply card_le_card_of_inj_on f\n  · intro g hg\n    rw [sep_def, mem_filter] at hg\n    rw [Multiset.mem_toFinset, mem_nth_roots hn, ← f.map_pow, hg.2]\n  · intros\n    apply hf\n    assumption\n#align card_nth_roots_subgroup_units card_nth_roots_subgroup_units\n\n",
 "card_fiber_eq_of_mem_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem card_fiber_eq_of_mem_range {H : Type _} [group H] [decidable_eq H] (f : «expr →* » G H) {x y : H}\n    (hx : x ∈ Set.range f) (hy : y ∈ Set.range f) :\n    (univ.filter fun g => f g = x).card = (univ.filter fun g => f g = y).card :=\n  by\n  rcases hx with ⟨x, rfl⟩\n  rcases hy with ⟨y, rfl⟩\n  refine' card_congr (fun g _ => g * x⁻¹ * y) _ _ fun g hg => ⟨g * y⁻¹ * x, _⟩\n  ·\n    simp (config := { contextual := true }) only [mem_filter, one_mul, MonoidHom.map_mul, mem_univ, mul_right_inv,\n      eq_self_iff_true, MonoidHom.map_mul_inv, and_self_iff, forall_true_iff]\n  · simp only [mul_left_inj, imp_self, forall₂_true_iff]\n  · simp only [true_and_iff, mem_filter, mem_univ] at hg\n    simp only [hg, mem_filter, one_mul, MonoidHom.map_mul, mem_univ, mul_right_inv, eq_self_iff_true,\n      exists_prop_of_true, MonoidHom.map_mul_inv, and_self_iff, mul_inv_cancel_right, inv_mul_cancel_right]\n#align card_fiber_eq_of_mem_range card_fiber_eq_of_mem_range\n\n"}