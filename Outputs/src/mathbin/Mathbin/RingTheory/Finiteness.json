{"trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n#print trans /-\ntheorem trans {R : Type _} (A B : Type _) [CommSemiring R] [CommSemiring A] [algebra R A] [Semiring B] [algebra R B]\n    [algebra A B] [IsScalarTower R A B] : ∀ [finite R A] [finite A B], finite R B\n  | ⟨⟨s, hs⟩⟩, ⟨⟨t, ht⟩⟩ =>\n    ⟨submodule.fg_def.2\n        ⟨Set.image2 («expr • » · ·) (↑s : set A) (↑t : set B), set.finite.image2 _ s.finite_to_set t.finite_to_set, by\n          rw [Set.image2_smul, submodule.span_smul_of_span_eq_top hs (↑t : set B), ht, submodule.restrict_scalars_top]⟩⟩\n#align trans trans\n-/\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem fg.sup {N₁ N₂ : submodule R M} (hN₁ : N₁.fg) (hN₂ : N₂.fg) : («expr ⊔ » N₁ N₂).fg :=\n  let ⟨t₁, ht₁⟩ := fg_def.1 hN₁\n  let ⟨t₂, ht₂⟩ := fg_def.1 hN₂\n  fg_def.2 ⟨t₁ ∪ t₂, ht₁.1.union ht₂.1, by rw [span_union, ht₁.2, ht₂.2]⟩\n#align fg.sup fg.sup\n\n",
 "stablizes_of_supr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\ntheorem fg.stablizes_of_supr_eq {M' : submodule R M} (hM' : M'.fg) (N : «expr →o » ℕ (submodule R M))\n    (H : supᵢ N = M') : ∃ n, M' = N n := by\n  obtain ⟨S, hS⟩ := hM'\n  have : ∀ s : S, ∃ n, (s : M) ∈ N n := fun s =>\n    (submodule.mem_supr_of_chain N s).mp\n      (by\n        rw [H, ← hS]\n        exact submodule.subset_span s.2)\n  choose f hf\n  use S.attach.sup f\n  apply le_antisymm\n  · conv_lhs => rw [← hS]\n    rw [submodule.span_le]\n    intro s hs\n    exact N.2 (finset.le_sup <| S.mem_attach ⟨s, hs⟩) (hf _)\n  · rw [← H]\n    exact le_supᵢ _ _\n#align fg.stablizes_of_supr_eq fg.stablizes_of_supr_eq\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem fg.prod {sb : submodule R M} {sc : submodule R P} (hsb : sb.fg) (hsc : sc.fg) : (sb.prod sc).fg :=\n  let ⟨tb, htb⟩ := fg_def.1 hsb\n  let ⟨tc, htc⟩ := fg_def.1 hsc\n  fg_def.2\n    ⟨«expr '' » (linear_map.inl R M P) tb ∪ «expr '' » (linear_map.inr R M P) tc, (htb.1.image _).union (htc.1.image _),\n      by rw [linear_map.span_inl_union_inr, htb.2, htc.2]⟩\n#align fg.prod fg.prod\n\n",
 "pow":
 "theorem fg.pow (h : M.fg) (n : ℕ) : (M ^ n).fg :=\n  nat.rec_on n ⟨{1}, by simp [one_eq_span]⟩ fun n ih => by simpa [pow_succ] using h.mul ih\n#align fg.pow fg.pow\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_surjective (f : «expr →ₐ[ ] » A R B) (hf : surjective f) : f.finite :=\n  ring_hom.finite.of_surjective f hf\n#align of_surjective of_surjective\n\n",
 "of_restrict_scalars_finite":
 "theorem of_restrict_scalars_finite (R A M : Type _) [CommSemiring R] [Semiring A] [add_comm_monoid M] [Module R M]\n    [Module A M] [algebra R A] [IsScalarTower R A M] [hM : finite R M] : finite A M :=\n  by\n  rw [finite_def, fg_def] at hM⊢\n  obtain ⟨S, hSfin, hSgen⟩ := hM\n  refine' ⟨S, hSfin, eq_top_iff.2 _⟩\n  have := submodule.span_le_restrict_scalars R A S\n  rw [hSgen] at this\n  exact this\n#align of_restrict_scalars_finite of_restrict_scalars_finite\n\n",
 "of_comp_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_comp_finite {f : «expr →ₐ[ ] » A R B} {g : «expr →ₐ[ ] » B R C} (h : (g.comp f).finite) : g.finite :=\n  ring_hom.finite.of_comp_finite h\n#align of_comp_finite of_comp_finite\n\n",
 "mul":
 "theorem fg.mul (hm : M.fg) (hn : N.fg) : (M * N).fg :=\n  hm.map₂ _ hn\n#align fg.mul fg.mul\n\n",
 "map₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem fg.map₂ (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R P)) {p : submodule R M} {q : submodule R N} (hp : p.fg)\n    (hq : q.fg) : (map₂ f p q).fg :=\n  let ⟨sm, hfm, hm⟩ := fg_def.1 hp\n  let ⟨sn, hfn, hn⟩ := fg_def.1 hq\n  fg_def.2 ⟨Set.image2 (fun m n => f m n) sm sn, hfm.image2 _ hfn, map₂_span_span R f sm sn ▸ hm ▸ hn ▸ rfl⟩\n#align fg.map₂ fg.map₂\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- The image of a finitely generated ideal is finitely generated.\n\nThis is the `ideal` version of `submodule.fg.map`. -/\ntheorem fg.map {R S : Type _} [Semiring R] [Semiring S] {I : ideal R} (h : I.fg) (f : «expr →+* » R S) : (I.map f).fg :=\n  by\n  classical\n    obtain ⟨s, hs⟩ := h\n    refine' ⟨s.image f, _⟩\n    rw [Finset.coe_image, ← ideal.map_span, hs]\n#align fg.map fg.map\n\n",
 "iff_add_monoid_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem iff_add_monoid_fg {M : Type _} [add_comm_monoid M] : module.finite ℕ M ↔ add_monoid.fg M :=\n  ⟨fun h => add_monoid.fg_def.2 <| (fg_iff_add_submonoid_fg («expr⊤»)).1 (finite_def.1 h), fun h =>\n    finite_def.2 <| (fg_iff_add_submonoid_fg («expr⊤»)).2 (add_monoid.fg_def.1 h)⟩\n#align iff_add_monoid_fg iff_add_monoid_fg\n\n",
 "iff_add_group_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem iff_add_group_fg {G : Type _} [add_comm_group G] : module.finite ℤ G ↔ add_group.fg G :=\n  ⟨fun h => add_group.fg_def.2 <| (fg_iff_add_subgroup_fg («expr⊤»)).1 (finite_def.1 h), fun h =>\n    finite_def.2 <| (fg_iff_add_subgroup_fg («expr⊤»)).2 (add_group.fg_def.1 h)⟩\n#align iff_add_group_fg iff_add_group_fg\n\n",
 "id":
 "#print id /-\ntheorem id : finite (alg_hom.id R A) :=\n  ring_hom.finite.id A\n#align id id\n-/\n\n",
 "finite_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem finite_def {R M} [Semiring R] [add_comm_monoid M] [Module R M] : finite R M ↔ («expr⊤» : submodule R M).fg :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align finite_def finite_def\n\n",
 "fg_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem fg_top (N : submodule R M) : («expr⊤» : submodule R N).fg ↔ N.fg :=\n  ⟨fun h => N.range_subtype ▸ map_top N.subtype ▸ h.map _, fun h =>\n    fg_of_fg_map_injective N.subtype subtype.val_injective <| by rwa [map_top, range_subtype]⟩\n#align fg_top fg_top\n\n",
 "fg_supr":
 "theorem fg_supr {ι : Type _} [Finite ι] (N : ι → submodule R M) (h : ∀ i, (N i).fg) : (supᵢ N).fg :=\n  by\n  cases nonempty_fintype ι\n  simpa using fg_bsupr finset.univ N fun i hi => h i\n#align fg_supr fg_supr\n\n",
 "fg_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem fg_span_singleton (x : M) : fg («expr ∙ » R x) :=\n  fg_span (finite_singleton x)\n#align fg_span_singleton fg_span_singleton\n\n",
 "fg_span":
 "theorem fg_span {s : set M} (hs : s.finite) : fg (span R s) :=\n  ⟨hs.to_finset, by rw [hs.coe_to_finset]⟩\n#align fg_span fg_span\n\n",
 "fg_restrict_scalars":
 "theorem fg_restrict_scalars {R S M : Type _} [CommSemiring R] [Semiring S] [algebra R S] [add_comm_group M] [Module S M]\n    [Module R M] [IsScalarTower R S M] (N : submodule S M) (hfin : N.fg) (h : function.surjective (algebra_map R S)) :\n    (submodule.restrict_scalars R N).fg := by\n  obtain ⟨X, rfl⟩ := hfin\n  use X\n  exact submodule.span_eq_restrict_scalars R S M X h\n#align fg_restrict_scalars fg_restrict_scalars\n\n",
 "fg_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem fg_pi {ι : Type _} {M : ι → Type _} [Finite ι] [∀ i, add_comm_monoid (M i)] [∀ i, Module R (M i)]\n    {p : ∀ i, submodule R (M i)} (hsb : ∀ i, (p i).fg) : (submodule.pi Set.univ p).fg := by\n  classical\n    simp_rw [fg_def] at hsb⊢\n    choose t htf hts using hsb\n    refine'\n      ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr '' » (linear_map.single i : «expr →ₗ[ ] » _ R _) (t i)),\n        set.finite_Union fun i => (htf i).image _, _⟩\n    simp_rw [span_Union, span_image, hts, submodule.supr_map_single]\n#align fg_pi fg_pi\n\n",
 "fg_of_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem fg_of_linear_equiv (e : «expr ≃ₗ[ ] » M R P) (h : («expr⊤» : submodule R P).fg) :\n    («expr⊤» : submodule R M).fg :=\n  e.symm.range ▸ map_top (e.symm : «expr →ₗ[ ] » P R M) ▸ h.map _\n#align fg_of_linear_equiv fg_of_linear_equiv\n\n",
 "fg_of_fg_map_of_fg_inf_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- If 0 → M' → M → M'' → 0 is exact and M' and M'' are\nfinitely generated then so is M. -/\ntheorem fg_of_fg_map_of_fg_inf_ker {R M P : Type _} [Ring R] [add_comm_group M] [Module R M] [add_comm_group P]\n    [Module R P] (f : «expr →ₗ[ ] » M R P) {s : submodule R M} (hs1 : (s.map f).fg) (hs2 : («expr ⊓ » s f.ker).fg) :\n    s.fg := by\n  haveI := classical.dec_eq R\n  haveI := classical.dec_eq M\n  haveI := classical.dec_eq P\n  cases' hs1 with t1 ht1\n  cases' hs2 with t2 ht2\n  have : ∀ y ∈ t1, ∃ x ∈ s, f x = y := by\n    intro y hy\n    have : y ∈ map f s := by\n      rw [← ht1]\n      exact subset_span hy\n    rcases mem_map.1 this with ⟨x, hx1, hx2⟩\n    exact ⟨x, hx1, hx2⟩\n  have : ∃ g : P → M, ∀ y ∈ t1, g y ∈ s ∧ f (g y) = y :=\n    by\n    choose g hg1 hg2\n    exists fun y => if H : y ∈ t1 then g y H else 0\n    intro y H\n    constructor\n    · simp only [dif_pos H]\n      apply hg1\n    · simp only [dif_pos H]\n      apply hg2\n  cases' this with g hg\n  clear this\n  exists t1.image g ∪ t2\n  rw [Finset.coe_union, span_union, Finset.coe_image]\n  apply le_antisymm\n  · refine' sup_le (span_le.2 <| image_subset_iff.2 _) (span_le.2 _)\n    · intro y hy\n      exact (hg y hy).1\n    · intro x hx\n      have := subset_span hx\n      rw [ht2] at this\n      exact this.1\n  intro x hx\n  have : f x ∈ map f s := by\n    rw [mem_map]\n    exact ⟨x, hx, rfl⟩\n  rw [← ht1, ← Set.image_id ↑t1, finsupp.mem_span_image_iff_total] at this\n  rcases this with ⟨l, hl1, hl2⟩\n  refine'\n    mem_sup.2\n      ⟨(finsupp.total M M R id).to_fun ((finsupp.lmap_domain R R g : «expr →₀ » P R → «expr →₀ » M R) l), _,\n        x - finsupp.total M M R id ((finsupp.lmap_domain R R g : «expr →₀ » P R → «expr →₀ » M R) l), _,\n        add_sub_cancel'_right _ _⟩\n  · rw [← Set.image_id («expr '' » g ↑t1), finsupp.mem_span_image_iff_total]\n    refine' ⟨_, _, rfl⟩\n    haveI : inhabited P := ⟨0⟩\n    rw [← finsupp.lmap_domain_supported _ _ g, mem_map]\n    refine' ⟨l, hl1, _⟩\n    rfl\n  rw [ht2, mem_inf]\n  constructor\n  · apply s.sub_mem hx\n    rw [finsupp.total_apply, finsupp.lmap_domain_apply, finsupp.sum_map_domain_index]\n    refine' s.sum_mem _\n    · intro y hy\n      exact s.smul_mem _ (hg y (hl1 hy)).1\n    · exact zero_smul _\n    · exact fun _ _ _ => add_smul _ _ _\n  · rw [linear_map.mem_ker, f.map_sub, ← hl2]\n    rw [finsupp.total_apply, finsupp.total_apply, finsupp.lmap_domain_apply]\n    rw [finsupp.sum_map_domain_index, finsupp.sum, finsupp.sum, f.map_sum]\n    rw [sub_eq_zero]\n    refine' finset.sum_congr rfl fun y hy => _\n    unfold id\n    rw [f.map_smul, (hg y (hl1 hy)).2]\n    · exact zero_smul _\n    · exact fun _ _ _ => add_smul _ _ _\n#align fg_of_fg_map_of_fg_inf_ker fg_of_fg_map_of_fg_inf_ker\n\n",
 "fg_of_fg_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem fg_of_fg_map_injective (f : «expr →ₗ[ ] » M R P) (hf : function.injective f) {N : submodule R M}\n    (hfn : (N.map f).fg) : N.fg :=\n  let ⟨t, ht⟩ := hfn\n  ⟨t.preimage f fun x _ y _ h => hf h,\n    submodule.map_injective_of_injective hf <|\n      by\n      rw [f.map_span, finset.coe_preimage, Set.image_preimage_eq_inter_range, Set.inter_eq_self_of_subset_left, ht]\n      rw [← linear_map.range_coe, ← span_le, ht, ← map_top]\n      exact map_mono le_top⟩\n#align fg_of_fg_map_injective fg_of_fg_map_injective\n\n",
 "fg_of_fg_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem fg_of_fg_map {R M P : Type _} [Ring R] [add_comm_group M] [Module R M] [add_comm_group P] [Module R P]\n    (f : «expr →ₗ[ ] » M R P) (hf : f.ker = «expr⊥») {N : submodule R M} (hfn : (N.map f).fg) : N.fg :=\n  fg_of_fg_map_injective f (linear_map.ker_eq_bot.1 hf) hfn\n#align fg_of_fg_map fg_of_fg_map\n\n",
 "fg_ker_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem fg_ker_comp {R S A : Type _} [CommRing R] [CommRing S] [CommRing A] (f : «expr →+* » R S) (g : «expr →+* » S A)\n    (hf : f.ker.fg) (hg : g.ker.fg) (hsur : function.surjective f) : (g.comp f).ker.fg :=\n  by\n  letI : algebra R S := ring_hom.to_algebra f\n  letI : algebra R A := ring_hom.to_algebra (g.comp f)\n  letI : algebra S A := ring_hom.to_algebra g\n  letI : IsScalarTower R S A := is_scalar_tower.of_algebra_map_eq fun _ => rfl\n  let f₁ := algebra.linear_map R S\n  let g₁ := (is_scalar_tower.to_alg_hom R S A).to_linear_map\n  exact submodule.fg_ker_comp f₁ g₁ hf (submodule.fg_restrict_scalars g.ker hg hsur) hsur\n#align fg_ker_comp fg_ker_comp\n\n",
 "fg_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem fg_induction (R M : Type _) [Semiring R] [add_comm_monoid M] [Module R M] (P : submodule R M → Prop)\n    (h₁ : ∀ x, P (submodule.span R {x})) (h₂ : ∀ M₁ M₂, P M₁ → P M₂ → P («expr ⊔ » M₁ M₂)) (N : submodule R M)\n    (hN : N.fg) : P N := by\n  classical\n    obtain ⟨s, rfl⟩ := hN\n    induction s using Finset.induction\n    · rw [Finset.coe_empty, submodule.span_empty, ← submodule.span_zero_singleton]\n      apply h₁\n    · rw [Finset.coe_insert, submodule.span_insert]\n      apply h₂ <;> apply_assumption\n#align fg_induction fg_induction\n\n",
 "fg_iff_exists_fin_generating_family":
 "theorem fg_iff_exists_fin_generating_family {N : submodule R M} :\n    N.fg ↔ ∃ (n : ℕ)(s : fin n → M), span R (range s) = N :=\n  by\n  rw [fg_def]\n  constructor\n  · rintro ⟨S, Sfin, hS⟩\n    obtain ⟨n, f, rfl⟩ := Sfin.fin_embedding\n    exact ⟨n, f, hS⟩\n  · rintro ⟨n, s, hs⟩\n    refine' ⟨range s, finite_range s, hs⟩\n#align fg_iff_exists_fin_generating_family fg_iff_exists_fin_generating_family\n\n",
 "fg_iff_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Finitely generated submodules are precisely compact elements in the submodule lattice. -/\ntheorem fg_iff_compact (s : submodule R M) : s.fg ↔ complete_lattice.is_compact_element s := by\n  classical\n    -- Introduce shorthand for span of an element\n    let sp : M → submodule R M := fun a => span R {a}\n    -- Trivial rewrite lemma; a small hack since simp (only) & rw can't accomplish this smoothly.\n    have supr_rw :\n      ∀ t : Finset M,\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (sp x) =\n          «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (sp x) :=\n      fun t => by rfl\n    constructor\n    · rintro ⟨t, rfl⟩\n      rw [span_eq_supr_of_singleton_spans, ← supr_rw, ← finset.sup_eq_supr t sp]\n      apply complete_lattice.finset_sup_compact_of_compact\n      exact fun n _ => singleton_span_is_compact_element n\n    · intro h\n      -- s is the Sup of the spans of its elements.\n      have sSup : s = Sup («expr '' » sp ↑s) := by\n        rw [supₛ_eq_supᵢ, supᵢ_image, ← span_eq_supr_of_singleton_spans, eq_comm, span_eq]\n      -- by h, s is then below (and equal to) the sup of the spans of finitely many elements.\n      obtain ⟨u, ⟨huspan, husup⟩⟩ := h («expr '' » sp ↑s) (le_of_eq sSup)\n      have ssup : s = u.sup id := by\n        suffices : u.sup id ≤ s\n        exact le_antisymm husup this\n        rw [sSup, finset.sup_id_eq_Sup]\n        exact supₛ_le_supₛ huspan\n      obtain ⟨t, ⟨hts, rfl⟩⟩ := finset.subset_image_iff.mp huspan\n      rw [finset.sup_finset_image, function.comp.left_id, finset.sup_eq_supr, supr_rw, ←\n        span_eq_supr_of_singleton_spans, eq_comm] at ssup\n      exact ⟨t, ssup⟩\n#align fg_iff_compact fg_iff_compact\n\n",
 "fg_iff_add_submonoid_fg":
 "theorem fg_iff_add_submonoid_fg (P : submodule ℕ M) : P.fg ↔ P.to_add_submonoid.fg :=\n  ⟨fun ⟨S, hS⟩ => ⟨S, by simpa [← span_nat_eq_add_submonoid_closure] using hS⟩, fun ⟨S, hS⟩ =>\n    ⟨S, by simpa [← span_nat_eq_add_submonoid_closure] using hS⟩⟩\n#align fg_iff_add_submonoid_fg fg_iff_add_submonoid_fg\n\n",
 "fg_iff_add_subgroup_fg":
 "theorem fg_iff_add_subgroup_fg {G : Type _} [add_comm_group G] (P : submodule ℤ G) : P.fg ↔ P.to_add_subgroup.fg :=\n  ⟨fun ⟨S, hS⟩ => ⟨S, by simpa [← span_int_eq_add_subgroup_closure] using hS⟩, fun ⟨S, hS⟩ =>\n    ⟨S, by simpa [← span_int_eq_add_subgroup_closure] using hS⟩⟩\n#align fg_iff_add_subgroup_fg fg_iff_add_subgroup_fg\n\n",
 "fg_finset_sup":
 "theorem fg_finset_sup {ι : Type _} (s : Finset ι) (N : ι → submodule R M) (h : ∀ i ∈ s, (N i).fg) : (s.sup N).fg :=\n  finset.sup_induction fg_bot (fun a ha b hb => ha.sup hb) h\n#align fg_finset_sup fg_finset_sup\n\n",
 "fg_def":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem fg_def {N : submodule R M} : N.fg ↔ ∃ S : set M, S.finite ∧ span R S = N :=\n  ⟨fun ⟨t, h⟩ => ⟨_, finset.finite_to_set t, h⟩, by\n    rintro ⟨t', h, rfl⟩\n    rcases finite.exists_finset_coe h with ⟨t, rfl⟩\n    exact ⟨t, rfl⟩⟩\n#align fg_def fg_def\n\n",
 "fg_bsupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem fg_bsupr {ι : Type _} (s : Finset ι) (N : ι → submodule R M) (h : ∀ i ∈ s, (N i).fg) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (N i)).fg := by\n  simpa only [finset.sup_eq_supr] using fg_finset_sup s N h\n#align fg_bsupr fg_bsupr\n\n",
 "fg_bot_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem _root_.subalgebra.fg_bot_to_submodule {R A : Type _} [CommSemiring R] [Semiring A] [algebra R A] :\n    («expr⊥» : subalgebra R A).to_submodule.fg :=\n  ⟨{1}, by simp [algebra.to_submodule_bot]⟩\n#align subalgebra.fg_bot_to_submodule subalgebra.fg_bot_to_submodule\n\n",
 "fg_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem fg_bot : («expr⊥» : submodule R M).fg :=\n  ⟨∅, by rw [Finset.coe_empty, span_empty]⟩\n#align fg_bot fg_bot\n\n",
 "exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- **Nakayama's Lemma**. Atiyah-Macdonald 2.5, Eisenbud 4.7, Matsumura 2.2,\n[Stacks 00DV](https://stacks.math.columbia.edu/tag/00DV) -/\ntheorem exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul {R : Type _} [CommRing R] {M : Type _} [add_comm_group M]\n    [Module R M] (I : ideal R) (N : submodule R M) (hn : N.fg) (hin : N ≤ «expr • » I N) :\n    ∃ r : R, r - 1 ∈ I ∧ ∀ n ∈ N, «expr • » r n = (0 : M) :=\n  by\n  rw [fg_def] at hn\n  rcases hn with ⟨s, hfs, hs⟩\n  have : ∃ r : R, r - 1 ∈ I ∧ N ≤ («expr • » I (span R s)).comap (linear_map.lsmul R M r) ∧ s ⊆ N :=\n    by\n    refine' ⟨1, _, _, _⟩\n    · rw [sub_self]\n      exact I.zero_mem\n    · rw [hs]\n      intro n hn\n      rw [mem_comap]\n      change «expr • » (1 : R) n ∈ «expr • » I N\n      rw [one_smul]\n      exact hin hn\n    · rw [← span_le, hs]\n      exact le_refl N\n  clear hin hs\n  revert this\n  refine' set.finite.dinduction_on hfs (fun H => _) fun i s his hfs ih H => _\n  · rcases H with ⟨r, hr1, hrn, hs⟩\n    refine' ⟨r, hr1, fun n hn => _⟩\n    specialize hrn hn\n    rwa [mem_comap, span_empty, smul_bot, mem_bot] at hrn\n  apply ih\n  rcases H with ⟨r, hr1, hrn, hs⟩\n  rw [← Set.singleton_union, span_union, smul_sup] at hrn\n  rw [Set.insert_subset] at hs\n  have : ∃ c : R, c - 1 ∈ I ∧ «expr • » c i ∈ «expr • » I (span R s) :=\n    by\n    specialize hrn hs.1\n    rw [mem_comap, mem_sup] at hrn\n    rcases hrn with ⟨y, hy, z, hz, hyz⟩\n    change y + z = «expr • » r i at hyz\n    rw [mem_smul_span_singleton] at hy\n    rcases hy with ⟨c, hci, rfl⟩\n    use r - c\n    constructor\n    · rw [sub_right_comm]\n      exact I.sub_mem hr1 hci\n    · rw [sub_smul, ← hyz, add_sub_cancel']\n      exact hz\n  rcases this with ⟨c, hc1, hci⟩\n  refine' ⟨c * r, _, _, hs.2⟩\n  · rw [← ideal.quotient.eq, RingHom.map_one] at hr1 hc1⊢\n    rw [RingHom.map_mul, hc1, hr1, mul_one]\n  · intro n hn\n    specialize hrn hn\n    rw [mem_comap, mem_sup] at hrn\n    rcases hrn with ⟨y, hy, z, hz, hyz⟩\n    change y + z = «expr • » r n at hyz\n    rw [mem_smul_span_singleton] at hy\n    rcases hy with ⟨d, hdi, rfl⟩\n    change «expr • » _ _ ∈ «expr • » I (span R s)\n    rw [mul_smul, ← hyz, smul_add, smul_smul, mul_comm, mul_smul]\n    exact add_mem (smul_mem _ _ hci) (smul_mem _ _ hz)\n#align exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul\n\n",
 "exists_radical_pow_le_of_fg":
 "theorem exists_radical_pow_le_of_fg {R : Type _} [CommSemiring R] (I : ideal R) (h : I.radical.fg) :\n    ∃ n : ℕ, I.radical ^ n ≤ I := by\n  have := le_refl I.radical; revert this\n  refine' submodule.fg_induction _ _ (fun J => J ≤ I.radical → ∃ n : ℕ, J ^ n ≤ I) _ _ _ h\n  · intro x hx\n    obtain ⟨n, hn⟩ := hx (subset_span (Set.mem_singleton x))\n    exact ⟨n, by rwa [← ideal.span, span_singleton_pow, span_le, Set.singleton_subset_iff]⟩\n  · intro J K hJ hK hJK\n    obtain ⟨n, hn⟩ := hJ fun x hx => hJK <| ideal.mem_sup_left hx\n    obtain ⟨m, hm⟩ := hK fun x hx => hJK <| ideal.mem_sup_right hx\n    use n + m\n    rw [← ideal.add_eq_sup, add_pow, ideal.sum_eq_sup, finset.sup_le_iff]\n    refine' fun i hi => ideal.mul_le_right.trans _\n    obtain h | h := le_or_lt n i\n    · exact ideal.mul_le_right.trans ((ideal.pow_le_pow h).trans hn)\n    · refine' ideal.mul_le_left.trans ((ideal.pow_le_pow _).trans hm)\n      rw [add_comm, nat.add_sub_assoc h.le]\n      apply nat.le_add_right\n#align exists_radical_pow_le_of_fg exists_radical_pow_le_of_fg\n\n",
 "exists_mem_and_smul_eq_self_of_fg_of_le_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_mem_and_smul_eq_self_of_fg_of_le_smul {R : Type _} [CommRing R] {M : Type _} [add_comm_group M]\n    [Module R M] (I : ideal R) (N : submodule R M) (hn : N.fg) (hin : N ≤ «expr • » I N) :\n    ∃ r ∈ I, ∀ n ∈ N, «expr • » r n = n :=\n  by\n  obtain ⟨r, hr, hr'⟩ := N.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul I hn hin\n  exact ⟨-(r - 1), I.neg_mem hr, fun n hn => by simpa [sub_smul] using hr' n hn⟩\n#align exists_mem_and_smul_eq_self_of_fg_of_le_smul exists_mem_and_smul_eq_self_of_fg_of_le_smul\n\n",
 "exists_fin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem exists_fin [finite R M] : ∃ (n : ℕ)(s : fin n → M), span R (range s) = «expr⊤» :=\n  submodule.fg_iff_exists_fin_generating_family.mp out\n#align exists_fin exists_fin\n\n",
 "equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem equiv [hM : finite R M] (e : «expr ≃ₗ[ ] » M R N) : finite R N :=\n  of_surjective (e : «expr →ₗ[ ] » M R N) e.surjective\n#align equiv equiv\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp {g : «expr →ₐ[ ] » B R C} {f : «expr →ₐ[ ] » A R B} (hg : g.finite) (hf : f.finite) : (g.comp f).finite :=\n  ring_hom.finite.comp hg hf\n#align comp comp\n\n"}