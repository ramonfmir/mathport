{"trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n#print trans /-\ntheorem trans {R : Type _} (A M : Type _) [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid M] [Module R M]\n    [Module A M] [IsScalarTower R A M] : ∀ [Finite R A] [Finite A M], Finite R M\n  | ⟨⟨s, hs⟩⟩, ⟨⟨t, ht⟩⟩ =>\n    ⟨Submodule.fg_def.2\n        ⟨Set.image2 («expr • » · ·) (↑s : Set A) (↑t : Set M), Set.Finite.image2 _ s.finite_to_set t.finite_to_set, by\n          rw [Set.image2_smul, Submodule.span_smul_of_span_eq_top hs (↑t : Set M), ht, Submodule.restrictScalars_top]⟩⟩\n#align trans trans\n-/\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem fg.sup {N₁ N₂ : Submodule R M} (hN₁ : N₁.fg) (hN₂ : N₂.fg) : («expr ⊔ » N₁ N₂).fg :=\n  let ⟨t₁, ht₁⟩ := fg_def.1 hN₁\n  let ⟨t₂, ht₂⟩ := fg_def.1 hN₂\n  fg_def.2 ⟨t₁ ∪ t₂, ht₁.1.union ht₂.1, by rw [span_union, ht₁.2, ht₂.2]⟩\n#align fg.sup fg.sup\n\n",
 "stablizes_of_supr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\ntheorem fg.stablizes_of_supr_eq {M' : Submodule R M} (hM' : M'.fg) (N : «expr →o » ℕ (Submodule R M))\n    (H : supᵢ N = M') : ∃ n, M' = N n := by\n  obtain ⟨S, hS⟩ := hM'\n  have : ∀ s : S, ∃ n, (s : M) ∈ N n := fun s =>\n    (Submodule.mem_supᵢ_of_chain N s).mp\n      (by\n        rw [H, ← hS]\n        exact Submodule.subset_span s.2)\n  choose f hf\n  use S.attach.sup f\n  apply le_antisymm\n  · conv_lhs => rw [← hS]\n    rw [Submodule.span_le]\n    intro s hs\n    exact N.2 (Finset.le_sup <| S.mem_attach ⟨s, hs⟩) (hf _)\n  · rw [← H]\n    exact le_supᵢ _ _\n#align fg.stablizes_of_supr_eq fg.stablizes_of_supr_eq\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem fg.prod {sb : Submodule R M} {sc : Submodule R P} (hsb : sb.fg) (hsc : sc.fg) : (sb.prod sc).fg :=\n  let ⟨tb, htb⟩ := fg_def.1 hsb\n  let ⟨tc, htc⟩ := fg_def.1 hsc\n  fg_def.2\n    ⟨«expr '' » (LinearMap.inl R M P) tb ∪ «expr '' » (LinearMap.inr R M P) tc, (htb.1.image _).union (htc.1.image _),\n      by rw [LinearMap.span_inl_union_inr, htb.2, htc.2]⟩\n#align fg.prod fg.prod\n\n",
 "pow":
 "theorem fg.pow (h : M.fg) (n : ℕ) : (M ^ n).fg :=\n  nat.rec_on n ⟨{1}, by simp [one_eq_span]⟩ fun n ih => by simpa [pow_succ] using h.mul ih\n#align fg.pow fg.pow\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_surjective (f : «expr →ₐ[ ] » A R B) (hf : surjective f) : f.finite :=\n  RingHom.Finite.of_surjective f hf\n#align of_surjective of_surjective\n\n",
 "of_restrict_scalars_finite":
 "theorem of_restrict_scalars_finite (R A M : Type _) [CommSemiring R] [Semiring A] [AddCommMonoid M] [Module R M]\n    [Module A M] [Algebra R A] [IsScalarTower R A M] [hM : Finite R M] : Finite A M :=\n  by\n  rw [finite_def, fg_def] at hM⊢\n  obtain ⟨S, hSfin, hSgen⟩ := hM\n  refine' ⟨S, hSfin, eq_top_iff.2 _⟩\n  have := Submodule.span_le_restrictScalars R A S\n  rw [hSgen] at this\n  exact this\n#align of_restrict_scalars_finite of_restrict_scalars_finite\n\n",
 "of_comp_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_comp_finite {f : «expr →ₐ[ ] » A R B} {g : «expr →ₐ[ ] » B R C} (h : (g.comp f).finite) : g.finite :=\n  RingHom.Finite.of_comp_finite h\n#align of_comp_finite of_comp_finite\n\n",
 "mul":
 "theorem fg.mul (hm : M.fg) (hn : N.fg) : (M * N).fg :=\n  hm.map₂ _ hn\n#align fg.mul fg.mul\n\n",
 "map₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem fg.map₂ (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R P)) {p : Submodule R M} {q : Submodule R N} (hp : p.fg)\n    (hq : q.fg) : (map₂ f p q).fg :=\n  let ⟨sm, hfm, hm⟩ := fg_def.1 hp\n  let ⟨sn, hfn, hn⟩ := fg_def.1 hq\n  fg_def.2 ⟨Set.image2 (fun m n => f m n) sm sn, hfm.image2 _ hfn, map₂_span_span R f sm sn ▸ hm ▸ hn ▸ rfl⟩\n#align fg.map₂ fg.map₂\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- The image of a finitely generated ideal is finitely generated.\n\nThis is the `ideal` version of `submodule.fg.map`. -/\ntheorem fg.map {R S : Type _} [Semiring R] [Semiring S] {I : Ideal R} (h : I.fg) (f : «expr →+* » R S) : (I.map f).fg :=\n  by\n  classical\n    obtain ⟨s, hs⟩ := h\n    refine' ⟨s.image f, _⟩\n    rw [Finset.coe_image, ← Ideal.map_span, hs]\n#align fg.map fg.map\n\n",
 "iff_add_monoid_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem iff_add_monoid_fg {M : Type _} [AddCommMonoid M] : Module.Finite ℕ M ↔ AddMonoid.Fg M :=\n  ⟨fun h => AddMonoid.fg_def.2 <| (fg_iff_addSubmonoid_fg («expr⊤»)).1 (finite_def.1 h), fun h =>\n    finite_def.2 <| (fg_iff_addSubmonoid_fg («expr⊤»)).2 (AddMonoid.fg_def.1 h)⟩\n#align iff_add_monoid_fg iff_add_monoid_fg\n\n",
 "iff_add_group_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem iff_add_group_fg {G : Type _} [AddCommGroup G] : Module.Finite ℤ G ↔ AddGroup.Fg G :=\n  ⟨fun h => AddGroup.fg_def.2 <| (fg_iff_add_subgroup_fg («expr⊤»)).1 (finite_def.1 h), fun h =>\n    finite_def.2 <| (fg_iff_add_subgroup_fg («expr⊤»)).2 (AddGroup.fg_def.1 h)⟩\n#align iff_add_group_fg iff_add_group_fg\n\n",
 "id":
 "#print id /-\ntheorem id : Finite (AlgHom.id R A) :=\n  RingHom.Finite.id A\n#align id id\n-/\n\n",
 "finite_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem finite_def {R M} [Semiring R] [AddCommMonoid M] [Module R M] : Finite R M ↔ («expr⊤» : Submodule R M).fg :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align finite_def finite_def\n\n",
 "fg_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem fg_unit {R A : Type _} [CommSemiring R] [Semiring A] [Algebra R A] (I : «expr ˣ» (Submodule R A)) :\n    (I : Submodule R A).fg :=\n  by\n  have : (1 : A) ∈ (I * ↑I⁻¹ : Submodule R A) := by\n    rw [I.mul_inv]\n    exact one_le.mp le_rfl\n  obtain ⟨T, T', hT, hT', one_mem⟩ := mem_span_mul_finite_of_mem_mul this\n  refine' ⟨T, span_eq_of_le _ hT _⟩\n  rw [← one_mul ↑I, ← mul_one (span R ↑T)]\n  conv_rhs => rw [← I.inv_mul, ← mul_assoc]\n  refine' mul_le_mul_left (le_trans _ <| mul_le_mul_right <| span_le.mpr hT')\n  rwa [one_le, span_mul_span]\n#align fg_unit fg_unit\n\n",
 "fg_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem fg_top (N : Submodule R M) : («expr⊤» : Submodule R N).fg ↔ N.fg :=\n  ⟨fun h => N.range_subtype ▸ map_top N.subtype ▸ h.map _, fun h =>\n    fg_of_fg_map_injective N.subtype Subtype.val_injective <| by rwa [map_top, range_subtype]⟩\n#align fg_top fg_top\n\n",
 "fg_supr":
 "theorem fg_supr {ι : Type _} [Finite ι] (N : ι → Submodule R M) (h : ∀ i, (N i).fg) : (supᵢ N).fg :=\n  by\n  cases nonempty_fintype ι\n  simpa using fg_bsupr Finset.univ N fun i hi => h i\n#align fg_supr fg_supr\n\n",
 "fg_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem fg_span_singleton (x : M) : Fg («expr ∙ » R x) :=\n  fg_span (finite_singleton x)\n#align fg_span_singleton fg_span_singleton\n\n",
 "fg_span":
 "theorem fg_span {s : Set M} (hs : s.finite) : Fg (span R s) :=\n  ⟨hs.to_finset, by rw [hs.coe_to_finset]⟩\n#align fg_span fg_span\n\n",
 "fg_restrict_scalars":
 "theorem fg_restrict_scalars {R S M : Type _} [CommSemiring R] [Semiring S] [Algebra R S] [AddCommGroup M] [Module S M]\n    [Module R M] [IsScalarTower R S M] (N : Submodule S M) (hfin : N.fg) (h : function.surjective (algebraMap R S)) :\n    (Submodule.restrictScalars R N).fg := by\n  obtain ⟨X, rfl⟩ := hfin\n  use X\n  exact (Submodule.restrictScalars_span R S h ↑X).symm\n#align fg_restrict_scalars fg_restrict_scalars\n\n",
 "fg_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem fg_pi {ι : Type _} {M : ι → Type _} [Finite ι] [∀ i, AddCommMonoid (M i)] [∀ i, Module R (M i)]\n    {p : ∀ i, Submodule R (M i)} (hsb : ∀ i, (p i).fg) : (Submodule.pi Set.univ p).fg := by\n  classical\n    simp_rw [fg_def] at hsb⊢\n    choose t htf hts using hsb\n    refine'\n      ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr '' » (LinearMap.single i : «expr →ₗ[ ] » _ R _) (t i)),\n        Set.finite_unionᵢ fun i => (htf i).image _, _⟩\n    simp_rw [span_Union, span_image, hts, Submodule.supᵢ_map_single]\n#align fg_pi fg_pi\n\n",
 "fg_of_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem fg_of_linear_equiv (e : «expr ≃ₗ[ ] » M R P) (h : («expr⊤» : Submodule R P).fg) :\n    («expr⊤» : Submodule R M).fg :=\n  e.symm.range ▸ map_top (e.symm : «expr →ₗ[ ] » P R M) ▸ h.map _\n#align fg_of_linear_equiv fg_of_linear_equiv\n\n",
 "fg_of_is_unit":
 "theorem fg_of_is_unit {R A : Type _} [CommSemiring R] [Semiring A] [Algebra R A] {I : Submodule R A} (hI : IsUnit I) :\n    I.fg :=\n  fg_unit hI.unit\n#align fg_of_is_unit fg_of_is_unit\n\n",
 "fg_of_fg_map_of_fg_inf_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- If 0 → M' → M → M'' → 0 is exact and M' and M'' are\nfinitely generated then so is M. -/\ntheorem fg_of_fg_map_of_fg_inf_ker {R M P : Type _} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup P] [Module R P]\n    (f : «expr →ₗ[ ] » M R P) {s : Submodule R M} (hs1 : (s.map f).fg) (hs2 : («expr ⊓ » s f.ker).fg) : s.fg :=\n  by\n  haveI := Classical.decEq R\n  haveI := Classical.decEq M\n  haveI := Classical.decEq P\n  cases' hs1 with t1 ht1\n  cases' hs2 with t2 ht2\n  have : ∀ y ∈ t1, ∃ x ∈ s, f x = y := by\n    intro y hy\n    have : y ∈ map f s := by\n      rw [← ht1]\n      exact subset_span hy\n    rcases mem_map.1 this with ⟨x, hx1, hx2⟩\n    exact ⟨x, hx1, hx2⟩\n  have : ∃ g : P → M, ∀ y ∈ t1, g y ∈ s ∧ f (g y) = y :=\n    by\n    choose g hg1 hg2\n    exists fun y => if H : y ∈ t1 then g y H else 0\n    intro y H\n    constructor\n    · simp only [dif_pos H]\n      apply hg1\n    · simp only [dif_pos H]\n      apply hg2\n  cases' this with g hg\n  clear this\n  exists t1.image g ∪ t2\n  rw [Finset.coe_union, span_union, Finset.coe_image]\n  apply le_antisymm\n  · refine' sup_le (span_le.2 <| image_subset_iff.2 _) (span_le.2 _)\n    · intro y hy\n      exact (hg y hy).1\n    · intro x hx\n      have := subset_span hx\n      rw [ht2] at this\n      exact this.1\n  intro x hx\n  have : f x ∈ map f s := by\n    rw [mem_map]\n    exact ⟨x, hx, rfl⟩\n  rw [← ht1, ← Set.image_id ↑t1, Finsupp.mem_span_image_iff_total] at this\n  rcases this with ⟨l, hl1, hl2⟩\n  refine'\n    mem_sup.2\n      ⟨(Finsupp.total M M R id).to_fun ((Finsupp.lmapDomain R R g : «expr →₀ » P R → «expr →₀ » M R) l), _,\n        x - Finsupp.total M M R id ((Finsupp.lmapDomain R R g : «expr →₀ » P R → «expr →₀ » M R) l), _,\n        add_sub_cancel'_right _ _⟩\n  · rw [← Set.image_id («expr '' » g ↑t1), Finsupp.mem_span_image_iff_total]\n    refine' ⟨_, _, rfl⟩\n    haveI : Inhabited P := ⟨0⟩\n    rw [← Finsupp.lmapDomain_supported _ _ g, mem_map]\n    refine' ⟨l, hl1, _⟩\n    rfl\n  rw [ht2, mem_inf]\n  constructor\n  · apply s.sub_mem hx\n    rw [Finsupp.total_apply, Finsupp.lmapDomain_apply, Finsupp.sum_mapDomain_index]\n    refine' s.sum_mem _\n    · intro y hy\n      exact s.smul_mem _ (hg y (hl1 hy)).1\n    · exact zero_smul _\n    · exact fun _ _ _ => add_smul _ _ _\n  · rw [LinearMap.mem_ker, f.map_sub, ← hl2]\n    rw [Finsupp.total_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply]\n    rw [Finsupp.sum_mapDomain_index, Finsupp.sum, Finsupp.sum, f.map_sum]\n    rw [sub_eq_zero]\n    refine' Finset.sum_congr rfl fun y hy => _\n    unfold id\n    rw [f.map_smul, (hg y (hl1 hy)).2]\n    · exact zero_smul _\n    · exact fun _ _ _ => add_smul _ _ _\n#align fg_of_fg_map_of_fg_inf_ker fg_of_fg_map_of_fg_inf_ker\n\n",
 "fg_of_fg_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem fg_of_fg_map_injective (f : «expr →ₗ[ ] » M R P) (hf : function.injective f) {N : Submodule R M}\n    (hfn : (N.map f).fg) : N.fg :=\n  let ⟨t, ht⟩ := hfn\n  ⟨t.preimage f fun x _ y _ h => hf h,\n    Submodule.map_injective_of_injective hf <|\n      by\n      rw [f.map_span, Finset.coe_preimage, Set.image_preimage_eq_inter_range, Set.inter_eq_self_of_subset_left, ht]\n      rw [← LinearMap.range_coe, ← span_le, ht, ← map_top]\n      exact map_mono le_top⟩\n#align fg_of_fg_map_injective fg_of_fg_map_injective\n\n",
 "fg_of_fg_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem fg_of_fg_map {R M P : Type _} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup P] [Module R P]\n    (f : «expr →ₗ[ ] » M R P) (hf : f.ker = «expr⊥») {N : Submodule R M} (hfn : (N.map f).fg) : N.fg :=\n  fg_of_fg_map_injective f (LinearMap.ker_eq_bot.1 hf) hfn\n#align fg_of_fg_map fg_of_fg_map\n\n",
 "fg_ker_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem fg_ker_comp {R S A : Type _} [CommRing R] [CommRing S] [CommRing A] (f : «expr →+* » R S) (g : «expr →+* » S A)\n    (hf : f.ker.fg) (hg : g.ker.fg) (hsur : function.surjective f) : (g.comp f).ker.fg :=\n  by\n  letI : Algebra R S := RingHom.toAlgebra f\n  letI : Algebra R A := RingHom.toAlgebra (g.comp f)\n  letI : Algebra S A := RingHom.toAlgebra g\n  letI : IsScalarTower R S A := IsScalarTower.of_algebraMap_eq fun _ => rfl\n  let f₁ := Algebra.linearMap R S\n  let g₁ := (IsScalarTower.toAlgHom R S A).to_linear_map\n  exact Submodule.fg_ker_comp f₁ g₁ hf (Submodule.fg_restrictScalars g.ker hg hsur) hsur\n#align fg_ker_comp fg_ker_comp\n\n",
 "fg_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem fg_induction (R M : Type _) [Semiring R] [AddCommMonoid M] [Module R M] (P : Submodule R M → Prop)\n    (h₁ : ∀ x, P (Submodule.span R {x})) (h₂ : ∀ M₁ M₂, P M₁ → P M₂ → P («expr ⊔ » M₁ M₂)) (N : Submodule R M)\n    (hN : N.fg) : P N := by\n  classical\n    obtain ⟨s, rfl⟩ := hN\n    induction s using Finset.induction\n    · rw [Finset.coe_empty, Submodule.span_empty, ← Submodule.span_zero_singleton]\n      apply h₁\n    · rw [Finset.coe_insert, Submodule.span_insert]\n      apply h₂ <;> apply_assumption\n#align fg_induction fg_induction\n\n",
 "fg_iff_exists_fin_generating_family":
 "theorem fg_iff_exists_fin_generating_family {N : Submodule R M} :\n    N.fg ↔ ∃ (n : ℕ)(s : Fin n → M), span R (range s) = N :=\n  by\n  rw [fg_def]\n  constructor\n  · rintro ⟨S, Sfin, hS⟩\n    obtain ⟨n, f, rfl⟩ := Sfin.fin_embedding\n    exact ⟨n, f, hS⟩\n  · rintro ⟨n, s, hs⟩\n    refine' ⟨range s, finite_range s, hs⟩\n#align fg_iff_exists_fin_generating_family fg_iff_exists_fin_generating_family\n\n",
 "fg_iff_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Finitely generated submodules are precisely compact elements in the submodule lattice. -/\ntheorem fg_iff_compact (s : Submodule R M) : s.fg ↔ CompleteLattice.IsCompactElement s := by\n  classical\n    -- Introduce shorthand for span of an element\n    let sp : M → Submodule R M := fun a => span R {a}\n    -- Trivial rewrite lemma; a small hack since simp (only) & rw can't accomplish this smoothly.\n    have supr_rw :\n      ∀ t : Finset M,\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (sp x) =\n          «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (sp x) :=\n      fun t => by rfl\n    constructor\n    · rintro ⟨t, rfl⟩\n      rw [span_eq_supr_of_singleton_spans, ← supr_rw, ← Finset.sup_eq_supᵢ t sp]\n      apply CompleteLattice.finset_sup_compact_of_compact\n      exact fun n _ => singleton_span_is_compact_element n\n    · intro h\n      -- s is the Sup of the spans of its elements.\n      have sSup : s = Sup («expr '' » sp ↑s) := by\n        rw [supₛ_eq_supᵢ, supᵢ_image, ← span_eq_supr_of_singleton_spans, eq_comm, span_eq]\n      -- by h, s is then below (and equal to) the sup of the spans of finitely many elements.\n      obtain ⟨u, ⟨huspan, husup⟩⟩ := h («expr '' » sp ↑s) (le_of_eq sSup)\n      have ssup : s = u.sup id := by\n        suffices : u.sup id ≤ s\n        exact le_antisymm husup this\n        rw [sSup, Finset.sup_id_eq_supₛ]\n        exact supₛ_le_supₛ huspan\n      obtain ⟨t, ⟨hts, rfl⟩⟩ := finset.subset_image_iff.mp huspan\n      rw [Finset.sup_image, function.comp.left_id, Finset.sup_eq_supᵢ, supr_rw, ← span_eq_supr_of_singleton_spans,\n        eq_comm] at ssup\n      exact ⟨t, ssup⟩\n#align fg_iff_compact fg_iff_compact\n\n",
 "fg_iff_add_submonoid_fg":
 "theorem fg_iff_add_submonoid_fg (P : Submodule ℕ M) : P.fg ↔ P.to_add_submonoid.fg :=\n  ⟨fun ⟨S, hS⟩ => ⟨S, by simpa [← span_nat_eq_add_submonoid_closure] using hS⟩, fun ⟨S, hS⟩ =>\n    ⟨S, by simpa [← span_nat_eq_add_submonoid_closure] using hS⟩⟩\n#align fg_iff_add_submonoid_fg fg_iff_add_submonoid_fg\n\n",
 "fg_iff_add_subgroup_fg":
 "theorem fg_iff_add_subgroup_fg {G : Type _} [AddCommGroup G] (P : Submodule ℤ G) : P.fg ↔ P.to_add_subgroup.fg :=\n  ⟨fun ⟨S, hS⟩ => ⟨S, by simpa [← span_int_eq_add_subgroup_closure] using hS⟩, fun ⟨S, hS⟩ =>\n    ⟨S, by simpa [← span_int_eq_add_subgroup_closure] using hS⟩⟩\n#align fg_iff_add_subgroup_fg fg_iff_add_subgroup_fg\n\n",
 "fg_finset_sup":
 "theorem fg_finset_sup {ι : Type _} (s : Finset ι) (N : ι → Submodule R M) (h : ∀ i ∈ s, (N i).fg) : (s.sup N).fg :=\n  Finset.sup_induction fg_bot (fun a ha b hb => ha.sup hb) h\n#align fg_finset_sup fg_finset_sup\n\n",
 "fg_def":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem fg_def {N : Submodule R M} : N.fg ↔ ∃ S : Set M, S.finite ∧ span R S = N :=\n  ⟨fun ⟨t, h⟩ => ⟨_, Finset.finite_toSet t, h⟩, by\n    rintro ⟨t', h, rfl⟩\n    rcases finite.exists_finset_coe h with ⟨t, rfl⟩\n    exact ⟨t, rfl⟩⟩\n#align fg_def fg_def\n\n",
 "fg_bsupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem fg_bsupr {ι : Type _} (s : Finset ι) (N : ι → Submodule R M) (h : ∀ i ∈ s, (N i).fg) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (N i)).fg := by\n  simpa only [Finset.sup_eq_supᵢ] using fg_finset_sup s N h\n#align fg_bsupr fg_bsupr\n\n",
 "fg_bot_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Subalgebra.fg_bot_toSubmodule /-\ntheorem Subalgebra.fg_bot_toSubmodule {R A : Type _} [CommSemiring R] [Semiring A] [Algebra R A] :\n    («expr⊥» : Subalgebra R A).to_submodule.fg :=\n  ⟨{1}, by simp [Algebra.toSubmodule_bot]⟩\n#align subalgebra.fg_bot_to_submodule Subalgebra.fg_bot_toSubmodule\n-/\n\n",
 "fg_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem fg_bot : («expr⊥» : Submodule R M).fg :=\n  ⟨∅, by rw [Finset.coe_empty, span_empty]⟩\n#align fg_bot fg_bot\n\n",
 "exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- **Nakayama's Lemma**. Atiyah-Macdonald 2.5, Eisenbud 4.7, Matsumura 2.2,\n[Stacks 00DV](https://stacks.math.columbia.edu/tag/00DV) -/\ntheorem exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul {R : Type _} [CommRing R] {M : Type _} [AddCommGroup M]\n    [Module R M] (I : Ideal R) (N : Submodule R M) (hn : N.fg) (hin : N ≤ «expr • » I N) :\n    ∃ r : R, r - 1 ∈ I ∧ ∀ n ∈ N, «expr • » r n = (0 : M) :=\n  by\n  rw [fg_def] at hn\n  rcases hn with ⟨s, hfs, hs⟩\n  have : ∃ r : R, r - 1 ∈ I ∧ N ≤ («expr • » I (span R s)).comap (LinearMap.lsmul R M r) ∧ s ⊆ N :=\n    by\n    refine' ⟨1, _, _, _⟩\n    · rw [sub_self]\n      exact I.zero_mem\n    · rw [hs]\n      intro n hn\n      rw [mem_comap]\n      change «expr • » (1 : R) n ∈ «expr • » I N\n      rw [one_smul]\n      exact hin hn\n    · rw [← span_le, hs]\n      exact le_refl N\n  clear hin hs\n  revert this\n  refine' Set.Finite.dinduction_on hfs (fun H => _) fun i s his hfs ih H => _\n  · rcases H with ⟨r, hr1, hrn, hs⟩\n    refine' ⟨r, hr1, fun n hn => _⟩\n    specialize hrn hn\n    rwa [mem_comap, span_empty, smul_bot, mem_bot] at hrn\n  apply ih\n  rcases H with ⟨r, hr1, hrn, hs⟩\n  rw [← Set.singleton_union, span_union, smul_sup] at hrn\n  rw [Set.insert_subset] at hs\n  have : ∃ c : R, c - 1 ∈ I ∧ «expr • » c i ∈ «expr • » I (span R s) :=\n    by\n    specialize hrn hs.1\n    rw [mem_comap, mem_sup] at hrn\n    rcases hrn with ⟨y, hy, z, hz, hyz⟩\n    change y + z = «expr • » r i at hyz\n    rw [mem_smul_span_singleton] at hy\n    rcases hy with ⟨c, hci, rfl⟩\n    use r - c\n    constructor\n    · rw [sub_right_comm]\n      exact I.sub_mem hr1 hci\n    · rw [sub_smul, ← hyz, add_sub_cancel']\n      exact hz\n  rcases this with ⟨c, hc1, hci⟩\n  refine' ⟨c * r, _, _, hs.2⟩\n  · simpa only [mul_sub, mul_one, sub_add_sub_cancel] using I.add_mem (I.mul_mem_left c hr1) hc1\n  · intro n hn\n    specialize hrn hn\n    rw [mem_comap, mem_sup] at hrn\n    rcases hrn with ⟨y, hy, z, hz, hyz⟩\n    change y + z = «expr • » r n at hyz\n    rw [mem_smul_span_singleton] at hy\n    rcases hy with ⟨d, hdi, rfl⟩\n    change «expr • » _ _ ∈ «expr • » I (span R s)\n    rw [mul_smul, ← hyz, smul_add, smul_smul, mul_comm, mul_smul]\n    exact add_mem (smul_mem _ _ hci) (smul_mem _ _ hz)\n#align exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul\n\n",
 "exists_radical_pow_le_of_fg":
 "theorem exists_radical_pow_le_of_fg {R : Type _} [CommSemiring R] (I : Ideal R) (h : I.radical.fg) :\n    ∃ n : ℕ, I.radical ^ n ≤ I := by\n  have := le_refl I.radical; revert this\n  refine' Submodule.fg_induction _ _ (fun J => J ≤ I.radical → ∃ n : ℕ, J ^ n ≤ I) _ _ _ h\n  · intro x hx\n    obtain ⟨n, hn⟩ := hx (subset_span (Set.mem_singleton x))\n    exact ⟨n, by rwa [← Ideal.span, span_singleton_pow, span_le, Set.singleton_subset_iff]⟩\n  · intro J K hJ hK hJK\n    obtain ⟨n, hn⟩ := hJ fun x hx => hJK <| Ideal.mem_sup_left hx\n    obtain ⟨m, hm⟩ := hK fun x hx => hJK <| Ideal.mem_sup_right hx\n    use n + m\n    rw [← Ideal.add_eq_sup, add_pow, Ideal.sum_eq_sup, Finset.sup_le_iff]\n    refine' fun i hi => ideal.mul_le_right.trans _\n    obtain h | h := le_or_lt n i\n    · exact ideal.mul_le_right.trans ((Ideal.pow_le_pow h).trans hn)\n    · refine' ideal.mul_le_left.trans ((Ideal.pow_le_pow _).trans hm)\n      rw [add_comm, nat.add_sub_assoc h.le]\n      apply nat.le_add_right\n#align exists_radical_pow_le_of_fg exists_radical_pow_le_of_fg\n\n",
 "exists_mem_and_smul_eq_self_of_fg_of_le_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_mem_and_smul_eq_self_of_fg_of_le_smul {R : Type _} [CommRing R] {M : Type _} [AddCommGroup M]\n    [Module R M] (I : Ideal R) (N : Submodule R M) (hn : N.fg) (hin : N ≤ «expr • » I N) :\n    ∃ r ∈ I, ∀ n ∈ N, «expr • » r n = n :=\n  by\n  obtain ⟨r, hr, hr'⟩ := N.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul I hn hin\n  exact ⟨-(r - 1), I.neg_mem hr, fun n hn => by simpa [sub_smul] using hr' n hn⟩\n#align exists_mem_and_smul_eq_self_of_fg_of_le_smul exists_mem_and_smul_eq_self_of_fg_of_le_smul\n\n",
 "exists_fin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem exists_fin [Finite R M] : ∃ (n : ℕ)(s : Fin n → M), span R (range s) = «expr⊤» :=\n  Submodule.fg_iff_exists_fin_generating_family.mp out\n#align exists_fin exists_fin\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp {g : «expr →ₐ[ ] » B R C} {f : «expr →ₐ[ ] » A R B} (hg : g.finite) (hf : f.finite) : (g.comp f).finite :=\n  RingHom.Finite.comp hg hf\n#align comp comp\n\n",
 "Equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print Equiv /-\ntheorem Equiv [hM : Finite R M] (e : «expr ≃ₗ[ ] » M R N) : Finite R N :=\n  of_surjective (e : «expr →ₗ[ ] » M R N) e.surjective\n#align equiv Equiv\n-/\n\n"}