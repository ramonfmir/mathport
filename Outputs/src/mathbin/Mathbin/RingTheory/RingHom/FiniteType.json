{"finite_type_stable_under_composition":
 "/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem finite_type_stable_under_composition : stable_under_composition @finite_type :=\n  by\n  introv R hf hg\n  exact hg.comp hf\n#align finite_type_stable_under_composition finite_type_stable_under_composition\n\n",
 "finite_type_respects_iso":
 "theorem finite_type_respects_iso : ring_hom.respects_iso @ring_hom.finite_type :=\n  ring_hom.finite_type_is_local.respects_iso\n#align finite_type_respects_iso finite_type_respects_iso\n\n",
 "finite_type_of_localization_span_target":
 "theorem finite_type_of_localization_span_target : of_localization_span_target @finite_type :=\n  by\n  -- Setup algebra intances.\n  rw [of_localization_span_target_iff_finite]\n  introv R hs H\n  skip\n  classical\n    letI := f.to_algebra\n    replace H : ∀ r : s, algebra.finite_type R (localization.away (r : S))\n    · intro r\n      convert H r\n      ext\n      rw [algebra.smul_def]\n      rfl\n    replace H := fun r => (H r).1\n    constructor\n    -- Suppose `s : finset S` spans `S`, and each `Sᵣ` is finitely generated as an `R`-algebra.\n    -- Say `t r : finset Sᵣ` generates `Sᵣ`. By assumption, we may find `lᵢ` such that\n    -- `∑ lᵢ * sᵢ = 1`. I claim that all `s` and `l` and the numerators of `t` and generates `S`.\n    choose t ht using H\n    obtain ⟨l, hl⟩ :=\n      (finsupp.mem_span_iff_total S (s : set S) 1).mp\n        (show (1 : S) ∈ ideal.span (s : set S) by\n          rw [hs]\n          trivial)\n    let sf := fun x : s => is_localization.finset_integer_multiple (submonoid.powers (x : S)) (t x)\n    use s.attach.bUnion sf ∪ s ∪ l.support.image l\n    rw [eq_top_iff]\n    -- We need to show that every `x` falls in the subalgebra generated by those elements.\n    -- Since all `s` and `l` are in the subalgebra, it suffices to check that `sᵢ ^ nᵢ • x` falls in\n    -- the algebra for each `sᵢ` and some `nᵢ`.\n    rintro x -\n    apply subalgebra.mem_of_span_eq_top_of_smul_pow_mem _ (s : set S) l hl _ _ x _\n    · intro x hx\n      apply algebra.subset_adjoin\n      rw [Finset.coe_union, Finset.coe_union]\n      exact or.inl (or.inr hx)\n    · intro i\n      by_cases h : l i = 0\n      · rw [h]\n        exact zero_mem _\n      apply algebra.subset_adjoin\n      rw [Finset.coe_union, Finset.coe_image]\n      exact or.inr (Set.mem_image_of_mem _ (finsupp.mem_support_iff.mpr h))\n    · intro r\n      rw [Finset.coe_union, Finset.coe_union, Finset.coe_bunionᵢ]\n      -- Since all `sᵢ` and numerators of `t r` are in the algebra, it suffices to show that the\n      -- image of `x` in `Sᵣ` falls in the `R`-adjoin of `t r`, which is of course true.\n      obtain ⟨⟨_, n₂, rfl⟩, hn₂⟩ :=\n        is_localization.exists_smul_mem_of_mem_adjoin (submonoid.powers (r : S)) x (t r) (algebra.adjoin R _) _ _ _\n      · exact ⟨n₂, hn₂⟩\n      · intro x hx\n        apply algebra.subset_adjoin\n        refine' or.inl (or.inl ⟨_, ⟨r, rfl⟩, _, ⟨s.mem_attach r, rfl⟩, hx⟩)\n      · rw [submonoid.powers_eq_closure, Submonoid.closure_le, Set.singleton_subset_iff]\n        apply algebra.subset_adjoin\n        exact or.inl (or.inr r.2)\n      · rw [ht]\n        trivial\n#align finite_type_of_localization_span_target finite_type_of_localization_span_target\n\n",
 "finite_type_is_local":
 "theorem finite_type_is_local : property_is_local @finite_type :=\n  ⟨localization_finite_type, finite_type_of_localization_span_target, finite_type_stable_under_composition,\n    finite_type_holds_for_localization_away⟩\n#align finite_type_is_local finite_type_is_local\n\n",
 "finite_type_holds_for_localization_away":
 "theorem finite_type_holds_for_localization_away : holds_for_localization_away @finite_type :=\n  by\n  introv R _\n  skip\n  suffices algebra.finite_type R S by\n    change algebra.finite_type _ _\n    convert this\n    ext\n    rw [algebra.smul_def]\n    rfl\n  exact is_localization.finite_type_of_monoid_fg (submonoid.powers r) S\n#align finite_type_holds_for_localization_away finite_type_holds_for_localization_away\n\n"}