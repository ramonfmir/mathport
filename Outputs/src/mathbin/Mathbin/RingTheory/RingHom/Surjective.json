{"surjective_stable_under_composition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprsurjective -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem surjective_stable_under_composition : stable_under_composition (exprsurjective) :=\n  by\n  introv R hf hg\n  exact hg.comp hf\n#align surjective_stable_under_composition surjective_stable_under_composition\n\n",
 "surjective_stable_under_base_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprsurjective -/\ntheorem surjective_stable_under_base_change : stable_under_base_change (exprsurjective) :=\n  by\n  refine' stable_under_base_change.mk _ surjective_respects_iso _\n  classical\n    introv h x\n    skip\n    induction' x using tensor_product.induction_on with x y x y ex ey\n    · exact ⟨0, map_zero _⟩\n    · obtain ⟨y, rfl⟩ := h y\n      use «expr • » y x\n      dsimp\n      rw [tensor_product.smul_tmul, algebra.algebra_map_eq_smul_one]\n    · obtain ⟨⟨x, rfl⟩, ⟨y, rfl⟩⟩ := ex, ey\n      exact ⟨x + y, map_add _ x y⟩\n#align surjective_stable_under_base_change surjective_stable_under_base_change\n\n",
 "surjective_respects_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprsurjective -/\ntheorem surjective_respects_iso : respects_iso (exprsurjective) :=\n  by\n  apply surjective_stable_under_composition.respects_iso\n  intros\n  exact e.surjective\n#align surjective_respects_iso surjective_respects_iso\n\n",
 "surjective_of_localization_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprsurjective -/\ntheorem surjective_of_localization_span : of_localization_span (exprsurjective) :=\n  by\n  introv R hs H\n  skip\n  letI := f.to_algebra\n  show function.surjective (algebra.of_id R S)\n  rw [← algebra.range_top_iff_surjective, eq_top_iff]\n  rintro x -\n  obtain ⟨l, hl⟩ :=\n    (finsupp.mem_span_iff_total R s 1).mp\n      (show _ ∈ ideal.span s by\n        rw [hs]\n        trivial)\n  fapply subalgebra.mem_of_finset_sum_eq_one_of_pow_smul_mem _ l.support (fun x : s => f x) fun x : s => f (l x)\n  · dsimp only\n    simp_rw [← _root_.map_mul, ← map_sum, ← f.map_one]\n    exact f.congr_arg hl\n  · exact fun _ => Set.mem_range_self _\n  · exact fun _ => Set.mem_range_self _\n  · intro r\n    obtain ⟨y, hy⟩ := H r (is_localization.mk' _ x (1 : submonoid.powers (f r)))\n    obtain ⟨z, ⟨_, n, rfl⟩, rfl⟩ := is_localization.mk'_surjective (submonoid.powers (r : R)) y\n    erw [is_localization.map_mk', is_localization.eq] at hy\n    obtain ⟨⟨_, m, rfl⟩, hm⟩ := hy\n    dsimp at hm\n    simp_rw [_root_.mul_assoc, _root_.one_mul, ← map_pow, ← f.map_mul, ← pow_add, mul_comm x] at hm\n    rw [map_pow] at hm\n    refine' ⟨n + m, _, hm⟩\n#align surjective_of_localization_span surjective_of_localization_span\n\n"}