{"map_eq_C_mul_X_pow_of_forall_coeff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n-- Section for auxiliary lemmas used in the proof of `irreducible_of_eisenstein_criterion`\ntheorem map_eq_C_mul_X_pow_of_forall_coeff_mem {f : polynomial R} {P : ideal R}\n    (hfP : ∀ n : ℕ, ↑n < f.degree → f.coeff n ∈ P) : map (mk P) f = C ((mk P) f.leading_coeff) * X ^ f.nat_degree :=\n  polynomial.ext fun n => by\n    by_cases hf0 : f = 0; · simp [hf0]\n    rcases lt_trichotomy (↑n) (degree f) with (h | h | h)\n    · erw [coeff_map, eq_zero_iff_mem.2 (hfP n h), coeff_C_mul, coeff_X_pow, if_neg, mul_zero]\n      rintro rfl\n      exact not_lt_of_ge degree_le_nat_degree h\n    · have : nat_degree f = n := nat_degree_eq_of_degree_eq_some h.symm\n      rw [coeff_C_mul, coeff_X_pow, if_pos this.symm, mul_one, leading_coeff, this, coeff_map]\n    · rw [coeff_eq_zero_of_degree_lt, coeff_eq_zero_of_degree_lt]\n      · refine' lt_of_le_of_lt (degree_C_mul_X_pow_le _ _) _\n        rwa [← degree_eq_nat_degree hf0]\n      · exact lt_of_le_of_lt (degree_map_le _ _) h\n#align map_eq_C_mul_X_pow_of_forall_coeff_mem map_eq_C_mul_X_pow_of_forall_coeff_mem\n\n",
 "le_nat_degree_of_map_eq_mul_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem le_nat_degree_of_map_eq_mul_X_pow {n : ℕ} {P : ideal R} (hP : P.is_prime) {q : polynomial R}\n    {c : polynomial («expr ⧸ » R P)} (hq : map (mk P) q = c * X ^ n) (hc0 : c.degree = 0) : n ≤ q.nat_degree :=\n  WithBot.coe_le_coe.1\n    (calc\n      ↑n = degree (q.map (mk P)) := by\n        rw [hq, degree_mul, hc0, zero_add, degree_pow, degree_X, nsmul_one, Nat.cast_withBot]\n      _ ≤ degree q := degree_map_le _ _\n      _ ≤ nat_degree q := degree_le_nat_degree\n      )\n#align le_nat_degree_of_map_eq_mul_X_pow le_nat_degree_of_map_eq_mul_X_pow\n\n",
 "is_unit_of_nat_degree_eq_zero_of_forall_dvd_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_unit_of_nat_degree_eq_zero_of_forall_dvd_is_unit {p q : polynomial R} (hu : ∀ x : R, C x ∣ p * q → is_unit x)\n    (hpm : p.nat_degree = 0) : is_unit p :=\n  by\n  rw [eq_C_of_degree_le_zero (nat_degree_eq_zero_iff_degree_le_zero.1 hpm), is_unit_C]\n  refine' hu _ _\n  rw [← eq_C_of_degree_le_zero (nat_degree_eq_zero_iff_degree_le_zero.1 hpm)]\n  exact dvd_mul_right _ _\n#align is_unit_of_nat_degree_eq_zero_of_forall_dvd_is_unit is_unit_of_nat_degree_eq_zero_of_forall_dvd_is_unit\n\n",
 "irreducible_of_eisenstein_criterion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\nirreducible. -/\ntheorem irreducible_of_eisenstein_criterion {f : polynomial R} {P : ideal R} (hP : P.is_prime)\n    (hfl : f.leading_coeff ∉ P) (hfP : ∀ n : ℕ, ↑n < degree f → f.coeff n ∈ P) (hfd0 : 0 < degree f)\n    (h0 : f.coeff 0 ∉ P ^ 2) (hu : f.is_primitive) : Irreducible f :=\n  have hf0 : f ≠ 0 := fun _ => by simp_all only [not_true, submodule.zero_mem, coeff_zero]\n  have hf : f.map (mk P) = C (mk P (leading_coeff f)) * X ^ nat_degree f := map_eq_C_mul_X_pow_of_forall_coeff_mem hfP\n  have hfd0 : 0 < f.nat_degree := WithBot.coe_lt_coe.1 (lt_of_lt_of_le hfd0 degree_le_nat_degree)\n  ⟨mt degree_eq_zero_of_is_unit fun h => by simp_all only [lt_irrefl],\n    by\n    rintro p q rfl\n    rw [polynomial.map_mul] at hf\n    rcases mul_eq_mul_prime_pow\n        (show Prime (X : polynomial («expr ⧸ » R P)) from monic_X.prime_of_degree_eq_one degree_X) hf with\n      ⟨m, n, b, c, hmnd, hbc, hp, hq⟩\n    have hmn : 0 < m → 0 < n → false := by\n      intro hm0 hn0\n      refine' h0 _\n      rw [coeff_zero_eq_eval_zero, eval_mul, sq]\n      exact ideal.mul_mem_mul (eval_zero_mem_ideal_of_eq_mul_X_pow hp hm0) (eval_zero_mem_ideal_of_eq_mul_X_pow hq hn0)\n    have hpql0 : (mk P) (p * q).leading_coeff ≠ 0 := by rwa [ne.def, eq_zero_iff_mem]\n    have hp0 : p ≠ 0 := fun h => by simp_all only [zero_mul, eq_self_iff_true, not_true, ne.def]\n    have hq0 : q ≠ 0 := fun h => by simp_all only [eq_self_iff_true, not_true, ne.def, mul_zero]\n    have hbc0 : degree b = 0 ∧ degree c = 0 := by\n      apply_fun degree  at hbc\n      rwa [degree_C hpql0, degree_mul, eq_comm, Nat.WithBot.add_eq_zero_iff] at hbc\n    have hmp : m ≤ nat_degree p := le_nat_degree_of_map_eq_mul_X_pow hP hp hbc0.1\n    have hnq : n ≤ nat_degree q := le_nat_degree_of_map_eq_mul_X_pow hP hq hbc0.2\n    have hpmqn : p.nat_degree = m ∧ q.nat_degree = n :=\n      by\n      rw [nat_degree_mul hp0 hq0] at hmnd\n      clear * - hmnd hmp hnq\n      contrapose hmnd\n      apply ne_of_lt\n      rw [not_and_or] at hmnd\n      cases hmnd\n      · exact add_lt_add_of_lt_of_le (lt_of_le_of_ne hmp (ne.symm hmnd)) hnq\n      · exact add_lt_add_of_le_of_lt hmp (lt_of_le_of_ne hnq (ne.symm hmnd))\n    obtain rfl | rfl : m = 0 ∨ n = 0 := by\n      rwa [pos_iff_ne_zero, pos_iff_ne_zero, imp_false, not_not, ← or_iff_not_imp_left] at hmn\n    · exact or.inl (is_unit_of_nat_degree_eq_zero_of_forall_dvd_is_unit hu hpmqn.1)\n    · exact or.inr (is_unit_of_nat_degree_eq_zero_of_forall_dvd_is_unit (by simpa only [mul_comm] using hu) hpmqn.2)⟩\n#align irreducible_of_eisenstein_criterion irreducible_of_eisenstein_criterion\n\n",
 "eval_zero_mem_ideal_of_eq_mul_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem eval_zero_mem_ideal_of_eq_mul_X_pow {n : ℕ} {P : ideal R} {q : polynomial R} {c : polynomial («expr ⧸ » R P)}\n    (hq : map (mk P) q = c * X ^ n) (hn0 : 0 < n) : eval 0 q ∈ P := by\n  rw [← coeff_zero_eq_eval_zero, ← eq_zero_iff_mem, ← coeff_map, coeff_zero_eq_eval_zero, hq, eval_mul, eval_pow,\n    eval_X, zero_pow hn0, mul_zero]\n#align eval_zero_mem_ideal_of_eq_mul_X_pow eval_zero_mem_ideal_of_eq_mul_X_pow\n\n"}