{"surjective_of_localization_span":
 "theorem surjective_of_localization_span : ring_hom.of_localization_span fun R S _ _ f => function.surjective f :=\n  by\n  introv R e H\n  rw [← Set.range_iff_surjective, Set.eq_univ_iff_forall]\n  skip\n  letI := f.to_algebra\n  intro x\n  apply submodule.mem_of_span_eq_top_of_smul_pow_mem (algebra.of_id R S).to_linear_map.range s e\n  intro r\n  obtain ⟨a, e'⟩ := H r (algebra_map _ _ x)\n  obtain ⟨b, ⟨_, n, rfl⟩, rfl⟩ := is_localization.mk'_surjective (submonoid.powers (r : R)) a\n  erw [is_localization.map_mk'] at e'\n  rw [eq_comm, is_localization.eq_mk'_iff_mul_eq, subtype.coe_mk, subtype.coe_mk, ← map_mul] at e'\n  obtain ⟨⟨_, n', rfl⟩, e''⟩ := (is_localization.eq_iff_exists (submonoid.powers (f r)) _).mp e'\n  rw [subtype.coe_mk, mul_assoc, ← map_pow, ← map_mul, ← map_mul, ← pow_add, mul_comm] at e''\n  exact ⟨n + n', _, e''.symm⟩\n#align surjective_of_localization_span surjective_of_localization_span\n\n",
 "smul_mem_finset_integer_multiple_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Let `S` be an `R`-algebra, `M` an submonoid of `R`, and `S' = M⁻¹S`.\nIf the image of some `x : S` falls in the span of some finite `s ⊆ S'` over `R`,\nthen there exists some `m : M` such that `m • x` falls in the\nspan of `finset_integer_multiple _ s` over `R`.\n-/\ntheorem is_localization.smul_mem_finset_integer_multiple_span [algebra R S] [algebra R S'] [IsScalarTower R S S']\n    [is_localization (M.map (algebra_map R S)) S'] (x : S) (s : Finset S')\n    (hx : algebra_map S S' x ∈ submodule.span R (s : set S')) :\n    ∃ m : M,\n      «expr • » m x ∈ submodule.span R (is_localization.finset_integer_multiple (M.map (algebra_map R S)) s : set S) :=\n  by\n  let g : «expr →ₐ[ ] » S R S' := alg_hom.mk' (algebra_map S S') fun c x => by simp [algebra.algebra_map_eq_smul_one]\n  -- We first obtain the `y' ∈ M` such that `s' = y' • s` is falls in the image of `S` in `S'`.\n  let y := is_localization.common_denom_of_finset (M.map (algebra_map R S)) s\n  have hx₁ : «expr • » (y : S) ↑s = «expr '' » g _ := (is_localization.finset_integer_multiple_image _ s).symm\n  obtain ⟨y', hy', e : algebra_map R S y' = y⟩ := y.prop\n  have : «expr • » (algebra_map R S y') (s : set S') = «expr • » y' s := by\n    simp_rw [algebra.algebra_map_eq_smul_one, smul_assoc, one_smul]\n  rw [← e, this] at hx₁\n  replace hx₁ := congr_arg (submodule.span R) hx₁\n  rw [submodule.span_smul] at hx₁\n  replace hx : _ ∈ «expr • » y' (submodule.span R (s : set S')) := Set.smul_mem_smul_set hx\n  rw [hx₁] at hx\n  erw [← g.map_smul, ← submodule.map_span (g : «expr →ₗ[ ] » S R S')] at hx\n  -- Since `x` falls in the span of `s` in `S'`, `y' • x : S` falls in the span of `s'` in `S'`.\n  -- That is, there exists some `x' : S` in the span of `s'` in `S` and `x' = y' • x` in `S'`.\n  -- Thus `a • (y' • x) = a • x' ∈ span s'` in `S` for some `a ∈ M`.\n  obtain ⟨x', hx', hx'' : algebra_map _ _ _ = _⟩ := hx\n  obtain ⟨⟨_, a, ha₁, rfl⟩, ha₂⟩ := (is_localization.eq_iff_exists (M.map (algebra_map R S)) S').mp hx''\n  use (⟨a, ha₁⟩ : M) * (⟨y', hy'⟩ : M)\n  convert\n    (submodule.span R (is_localization.finset_integer_multiple (Submonoid.map (algebra_map R S) M) s : set S)).smul_mem\n      a hx' using\n    1\n  convert ha₂.symm\n  · rw [mul_comm («expr • » y' x), subtype.coe_mk, Submonoid.smul_def, Submonoid.coe_mul, ← smul_smul]\n    exact algebra.smul_def _ _\n  · rw [mul_comm]\n    exact algebra.smul_def _ _\n#align is_localization.smul_mem_finset_integer_multiple_span is_localization.smul_mem_finset_integer_multiple_span\n\n",
 "respects_iso":
 "theorem _root_.ring_hom.property_is_local.respects_iso (hP : ring_hom.property_is_local @P) :\n    ring_hom.respects_iso @P := by\n  apply hP.stable_under_composition.respects_iso\n  introv\n  skip\n  letI := e.to_ring_hom.to_algebra\n  apply (config := { instances := false }) hP.holds_for_localization_away\n  apply is_localization.away_of_is_unit_of_bijective _ isUnit_one\n  exact e.bijective\n#align ring_hom.property_is_local.respects_iso ring_hom.property_is_local.respects_iso\n\n",
 "of_localization_span_target_iff_finite":
 "theorem ring_hom.of_localization_span_target_iff_finite :\n    ring_hom.of_localization_span_target @P ↔ ring_hom.of_localization_finite_span_target @P :=\n  by\n  delta ring_hom.of_localization_span_target ring_hom.of_localization_finite_span_target\n  apply forall₅_congr\n  -- TODO: Using `refine` here breaks `resetI`.\n  intros\n  constructor\n  · intro h s\n    exact h s\n  · intro h s hs hs'\n    obtain ⟨s', h₁, h₂⟩ := (ideal.span_eq_top_iff_finite s).mp hs\n    exact h s' h₂ fun x => hs' ⟨_, h₁ x.prop⟩\n#align ring_hom.of_localization_span_target_iff_finite ring_hom.of_localization_span_target_iff_finite\n\n",
 "of_localization_span_iff_finite":
 "/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem ring_hom.of_localization_span_iff_finite :\n    ring_hom.of_localization_span @P ↔ ring_hom.of_localization_finite_span @P :=\n  by\n  delta ring_hom.of_localization_span ring_hom.of_localization_finite_span\n  apply forall₅_congr\n  -- TODO: Using `refine` here breaks `resetI`.\n  intros\n  constructor\n  · intro h s\n    exact h s\n  · intro h s hs hs'\n    obtain ⟨s', h₁, h₂⟩ := (ideal.span_eq_top_iff_finite s).mp hs\n    exact h s' h₂ fun x => hs' ⟨_, h₁ x.prop⟩\n#align ring_hom.of_localization_span_iff_finite ring_hom.of_localization_span_iff_finite\n\n",
 "of_localization_span":
 "theorem ring_hom.property_is_local.of_localization_span (hP : ring_hom.property_is_local @P) :\n    ring_hom.of_localization_span @P := by\n  introv R hs hs'\n  skip\n  apply_fun ideal.map f  at hs\n  rw [ideal.map_span, ideal.map_top] at hs\n  apply hP.of_localization_span_target _ _ hs\n  rintro ⟨_, r, hr, rfl⟩\n  have := hs' ⟨r, hr⟩\n  convert hP.stable_under_composition _ _ (hP.holds_for_localization_away (localization.away r) r) (hs' ⟨r, hr⟩) using 1\n  exact (is_localization.map_comp _).symm\n#align ring_hom.property_is_local.of_localization_span ring_hom.property_is_local.of_localization_span\n\n",
 "multiple_mem_span_of_mem_localization_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `S` is an `R' = M⁻¹R` algebra, and `x ∈ span R' s`,\nthen `t • x ∈ span R s` for some `t : M`.-/\ntheorem multiple_mem_span_of_mem_localization_span [algebra R' S] [algebra R S] [IsScalarTower R R' S]\n    [is_localization M R'] (s : set S) (x : S) (hx : x ∈ submodule.span R' s) :\n    ∃ t : M, «expr • » t x ∈ submodule.span R s := by\n  classical\n    obtain ⟨s', hss', hs'⟩ := submodule.mem_span_finite_of_mem_span hx\n    rsuffices ⟨t, ht⟩ : ∃ t : M, «expr • » t x ∈ submodule.span R (s' : set S)\n    · exact ⟨t, submodule.span_mono hss' ht⟩\n    clear hx hss' s\n    revert x\n    apply s'.induction_on\n    · intro x hx\n      use 1\n      simpa using hx\n    rintro a s ha hs x hx\n    simp only [Finset.coe_insert, Finset.image_insert, Finset.coe_image, subtype.coe_mk, submodule.mem_span_insert] at\n      hx⊢\n    rcases hx with ⟨y, z, hz, rfl⟩\n    rcases is_localization.surj M y with ⟨⟨y', s'⟩, e⟩\n    replace e : _ * a = _ * a := (congr_arg (fun x => algebra_map R' S x * a) e : _)\n    simp_rw [RingHom.map_mul, ← is_scalar_tower.algebra_map_apply, mul_comm (algebra_map R' S y), mul_assoc, ←\n      algebra.smul_def] at e\n    rcases hs _ hz with ⟨t, ht⟩\n    refine' ⟨t * s', t * y', _, (submodule.span R (s : set S)).smul_mem s' ht, _⟩\n    rw [smul_add, ← smul_smul, mul_comm, ← smul_smul, ← smul_smul, ← e]\n    rfl\n#align multiple_mem_span_of_mem_localization_span multiple_mem_span_of_mem_localization_span\n\n",
 "multiple_mem_adjoin_of_mem_localization_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `S` is an `R' = M⁻¹R` algebra, and `x ∈ adjoin R' s`,\nthen `t • x ∈ adjoin R s` for some `t : M`.-/\ntheorem multiple_mem_adjoin_of_mem_localization_adjoin [algebra R' S] [algebra R S] [IsScalarTower R R' S]\n    [is_localization M R'] (s : set S) (x : S) (hx : x ∈ algebra.adjoin R' s) :\n    ∃ t : M, «expr • » t x ∈ algebra.adjoin R s :=\n  by\n  change ∃ t : M, «expr • » t x ∈ (algebra.adjoin R s).to_submodule\n  change x ∈ (algebra.adjoin R' s).to_submodule at hx\n  simp_rw [algebra.adjoin_eq_span] at hx⊢\n  exact multiple_mem_span_of_mem_localization_span M R' _ _ hx\n#align multiple_mem_adjoin_of_mem_localization_adjoin multiple_mem_adjoin_of_mem_localization_adjoin\n\n",
 "localization_preserves_surjective":
 "theorem localization_preserves_surjective : ring_hom.localization_preserves fun R S _ _ f => function.surjective f :=\n  by\n  introv R H x\n  skip\n  obtain ⟨x, ⟨_, s, hs, rfl⟩, rfl⟩ := is_localization.mk'_surjective (M.map f) x\n  obtain ⟨y, rfl⟩ := H x\n  use is_localization.mk' R' y ⟨s, hs⟩\n  rw [is_localization.map_mk']\n  rfl\n#align localization_preserves_surjective localization_preserves_surjective\n\n",
 "localization_is_reduced":
 "theorem localization_is_reduced : localization_preserves fun R hR => is_reduced R :=\n  by\n  introv R _ _\n  skip\n  constructor\n  rintro x ⟨_ | n, e⟩\n  · simpa using congr_arg (· * x) e\n  obtain ⟨⟨y, m⟩, hx⟩ := is_localization.surj M x\n  dsimp only at hx\n  let hx' := congr_arg (· ^ n.succ) hx\n  simp only [mul_pow, e, zero_mul, ← RingHom.map_pow] at hx'\n  rw [← (algebra_map R S).map_zero] at hx'\n  obtain ⟨m', hm'⟩ := (is_localization.eq_iff_exists M S).mp hx'\n  apply_fun (· * m' ^ n)  at hm'\n  simp only [mul_assoc, zero_mul] at hm'\n  rw [mul_comm, ← pow_succ, ← mul_pow] at hm'\n  replace hm' := is_nilpotent.eq_zero ⟨_, hm'.symm⟩\n  rw [← (is_localization.map_units S m).mul_left_inj, hx, zero_mul, is_localization.map_eq_zero_iff M]\n  exact ⟨m', by rw [← hm', mul_comm]⟩\n#align localization_is_reduced localization_is_reduced\n\n",
 "localization_finite_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem localization_finite_type : ring_hom.localization_preserves @ring_hom.finite_type :=\n  by\n  introv R hf\n  -- mirrors the proof of `localization_map_finite`\n  skip\n  letI := f.to_algebra\n  letI := ((algebra_map S S').comp f).to_algebra\n  let f' : «expr →+* » R' S' := is_localization.map S' f (Submonoid.le_comap_map M)\n  letI := f'.to_algebra\n  haveI : IsScalarTower R R' S' := is_scalar_tower.of_algebra_map_eq' (is_localization.map_comp _).symm\n  let fₐ : «expr →ₐ[ ] » S R S' := alg_hom.mk' (algebra_map S S') fun c x => RingHom.map_mul _ _ _\n  obtain ⟨T, hT⟩ := id hf\n  use T.image (algebra_map S S')\n  rw [eq_top_iff]\n  rintro x -\n  obtain ⟨y, ⟨_, ⟨r, hr, rfl⟩⟩, rfl⟩ := is_localization.mk'_surjective (M.map f) x\n  rw [is_localization.mk'_eq_mul_mk'_one, mul_comm, Finset.coe_image]\n  have hy : y ∈ algebra.adjoin R (T : set S) := by\n    rw [hT]\n    trivial\n  replace hy : algebra_map S S' y ∈ (algebra.adjoin R (T : set S)).map fₐ := subalgebra.mem_map.mpr ⟨_, hy, rfl⟩\n  rw [fₐ.map_adjoin T] at hy\n  have H :\n    algebra.adjoin R («expr '' » (algebra_map S S') T) ≤\n      (algebra.adjoin R' («expr '' » (algebra_map S S') T)).restrict_scalars R :=\n    by\n    rw [algebra.adjoin_le_iff]\n    exact algebra.subset_adjoin\n  convert\n    (algebra.adjoin R' («expr '' » (algebra_map S S') T)).smul_mem (H hy) (is_localization.mk' R' (1 : R) ⟨r, hr⟩) using\n    1\n  rw [algebra.smul_def]\n  erw [is_localization.map_mk']\n  rw [map_one]\n  rfl\n#align localization_finite_type localization_finite_type\n\n",
 "localization_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. -/\ntheorem localization_finite : ring_hom.localization_preserves @ring_hom.finite :=\n  by\n  introv R hf\n  -- Setting up the `algebra` and `is_scalar_tower` instances needed\n  skip\n  letI := f.to_algebra\n  letI := ((algebra_map S S').comp f).to_algebra\n  let f' : «expr →+* » R' S' := is_localization.map S' f (Submonoid.le_comap_map M)\n  letI := f'.to_algebra\n  haveI : IsScalarTower R R' S' := is_scalar_tower.of_algebra_map_eq' (is_localization.map_comp _).symm\n  let fₐ : «expr →ₐ[ ] » S R S' := alg_hom.mk' (algebra_map S S') fun c x => RingHom.map_mul _ _ _\n  -- We claim that if `S` is generated by `T` as an `R`-module,\n  -- then `S'` is generated by `T` as an `R'`-module.\n  obtain ⟨T, hT⟩ := hf\n  use T.image (algebra_map S S')\n  rw [eq_top_iff]\n  rintro x -\n  -- By the hypotheses, for each `x : S'`, we have `x = y / (f r)` for some `y : S` and `r : M`.\n  -- Since `S` is generated by `T`, the image of `y` should fall in the span of the image of `T`.\n  obtain ⟨y, ⟨_, ⟨r, hr, rfl⟩⟩, rfl⟩ := is_localization.mk'_surjective (M.map f) x\n  rw [is_localization.mk'_eq_mul_mk'_one, mul_comm, Finset.coe_image]\n  have hy : y ∈ submodule.span R ↑T := by\n    rw [hT]\n    trivial\n  replace hy : algebra_map S S' y ∈ submodule.map fₐ.to_linear_map (submodule.span R T) := submodule.mem_map_of_mem hy\n  rw [submodule.map_span fₐ.to_linear_map T] at hy\n  have H :\n    submodule.span R («expr '' » (algebra_map S S') T) ≤\n      (submodule.span R' («expr '' » (algebra_map S S') T)).restrict_scalars R :=\n    by\n    rw [submodule.span_le]\n    exact submodule.subset_span\n  -- Now, since `y ∈ span T`, and `(f r)⁻¹ ∈ R'`, `x / (f r)` is in `span T` as well.\n  convert\n    (submodule.span R' («expr '' » (algebra_map S S') T)).smul_mem (is_localization.mk' R' (1 : R) ⟨r, hr⟩) (H hy) using\n    1\n  rw [algebra.smul_def]\n  erw [is_localization.map_mk']\n  rw [map_one]\n  rfl\n#align localization_finite localization_finite\n\n",
 "localization_away_map_finite_type":
 "theorem localization_away_map_finite_type (r : R) [is_localization.away r R'] [is_localization.away (f r) S']\n    (hf : f.finite_type) : (is_localization.away.map R' S' f r).finite_type :=\n  localization_finite_type.away r hf\n#align localization_away_map_finite_type localization_away_map_finite_type\n\n",
 "localization_away_map_finite":
 "theorem localization_away_map_finite (r : R) [is_localization.away r R'] [is_localization.away (f r) S']\n    (hf : f.finite) : (is_localization.away.map R' S' f r).finite :=\n  localization_finite.away r hf\n#align localization_away_map_finite localization_away_map_finite\n\n",
 "lift_mem_adjoin_finset_integer_multiple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Let `S` be an `R`-algebra, `M` an submonoid of `R`, and `S' = M⁻¹S`.\nIf the image of some `x : S` falls in the adjoin of some finite `s ⊆ S'` over `R`,\nthen there exists some `m : M` such that `m • x` falls in the\nadjoin of `finset_integer_multiple _ s` over `R`.\n-/\ntheorem is_localization.lift_mem_adjoin_finset_integer_multiple [algebra R S] [algebra R S'] [IsScalarTower R S S']\n    [is_localization (M.map (algebra_map R S)) S'] (x : S) (s : Finset S')\n    (hx : algebra_map S S' x ∈ algebra.adjoin R (s : set S')) :\n    ∃ m : M,\n      «expr • » m x ∈ algebra.adjoin R (is_localization.finset_integer_multiple (M.map (algebra_map R S)) s : set S) :=\n  by\n  obtain ⟨⟨_, a, ha, rfl⟩, e⟩ :=\n    is_localization.exists_smul_mem_of_mem_adjoin (M.map (algebra_map R S)) x s (algebra.adjoin R _)\n      algebra.subset_adjoin _ hx\n  · exact ⟨⟨a, ha⟩, by simpa [Submonoid.smul_def] using e⟩\n  · rintro _ ⟨a, ha, rfl⟩\n    exact subalgebra.algebra_map_mem _ a\n#align is_localization.lift_mem_adjoin_finset_integer_multiple is_localization.lift_mem_adjoin_finset_integer_multiple\n\n",
 "le_of_localization_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Let `I J : ideal R`. If the localization of `I` at each maximal ideal `P` is included in\nthe localization of `J` at `P`, then `I ≤ J`. -/\ntheorem ideal.le_of_localization_maximal {I J : ideal R}\n    (h :\n      ∀ (P : ideal R) (hP : P.is_maximal),\n        ideal.map (algebra_map R (localization.at_prime P)) I ≤ ideal.map (algebra_map R (localization.at_prime P)) J) :\n    I ≤ J := by\n  intro x hx\n  suffices J.colon (ideal.span {x}) = «expr⊤» by\n    simpa using\n      submodule.mem_colon.mp (show (1 : R) ∈ J.colon (ideal.span {x}) from this.symm ▸ submodule.mem_top) x\n        (ideal.mem_span_singleton_self x)\n  refine' not.imp_symm (J.colon (ideal.span {x})).exists_le_maximal _\n  push_neg\n  intro P hP le\n  obtain ⟨⟨⟨a, ha⟩, ⟨s, hs⟩⟩, eq⟩ :=\n    (is_localization.mem_map_algebra_map_iff P.prime_compl _).mp (h P hP (ideal.mem_map_of_mem _ hx))\n  rw [← _root_.map_mul, ← sub_eq_zero, ← map_sub] at eq\n  obtain ⟨⟨m, hm⟩, eq⟩ := (is_localization.map_eq_zero_iff P.prime_compl _ _).mp eq\n  refine' hs ((hP.is_prime.mem_or_mem (le (ideal.mem_colon_singleton.mpr _))).resolve_right hm)\n  simp only [subtype.coe_mk, sub_mul, sub_eq_zero, mul_assoc] at eq\n  simpa only [eq, mul_comm] using J.mul_mem_right m ha\n#align ideal.le_of_localization_maximal ideal.le_of_localization_maximal\n\n",
 "is_reduced_of_localization_maximal":
 "theorem is_reduced_of_localization_maximal : of_localization_maximal fun R hR => is_reduced R :=\n  by\n  introv R h\n  constructor\n  intro x hx\n  apply eq_zero_of_localization\n  intro J hJ\n  specialize h J hJ\n  skip\n  exact (hx.map <| algebra_map R <| localization.at_prime J).eq_zero\n#align is_reduced_of_localization_maximal is_reduced_of_localization_maximal\n\n",
 "ideal_eq_bot_of_localization'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- An ideal is trivial if its localization at every maximal ideal is trivial. -/\ntheorem ideal_eq_bot_of_localization' (I : ideal R)\n    (h : ∀ (J : ideal R) (hJ : J.is_maximal), ideal.map (algebra_map R (localization.at_prime J)) I = «expr⊥») :\n    I = «expr⊥» :=\n  ideal.eq_of_localization_maximal fun P hP => by simpa using h P hP\n#align ideal_eq_bot_of_localization' ideal_eq_bot_of_localization'\n\n",
 "ideal_eq_bot_of_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- TODO: This proof should work for all modules, once we have enough material on submodules of\n-- localized modules.\n/-- An ideal is trivial if its localization at every maximal ideal is trivial. -/\ntheorem ideal_eq_bot_of_localization (I : ideal R)\n    (h : ∀ (J : ideal R) (hJ : J.is_maximal), is_localization.coe_submodule (localization.at_prime J) I = «expr⊥») :\n    I = «expr⊥» :=\n  ideal_eq_bot_of_localization' _ fun P hP =>\n    (ideal.map_eq_bot_iff_le_ker _).mpr fun x hx =>\n      by\n      rw [ring_hom.mem_ker, ← submodule.mem_bot R, ← h P hP, is_localization.mem_coe_submodule]\n      exact ⟨x, hx, rfl⟩\n#align ideal_eq_bot_of_localization ideal_eq_bot_of_localization\n\n",
 "finite_type_of_localization_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem finite_type_of_localization_span : ring_hom.of_localization_span @ring_hom.finite_type :=\n  by\n  rw [ring_hom.of_localization_span_iff_finite]\n  introv R hs H\n  -- mirrors the proof of `finite_of_localization_span`\n  skip\n  letI := f.to_algebra\n  letI := fun r : s => (localization.away_map f r).to_algebra\n  have : ∀ r : s, is_localization ((submonoid.powers (r : R)).map (algebra_map R S)) (localization.away (f r)) :=\n    by\n    intro r\n    rw [submonoid.map_powers]\n    exact localization.is_localization\n  haveI : ∀ r : s, IsScalarTower R (localization.away (r : R)) (localization.away (f r)) := fun r =>\n    is_scalar_tower.of_algebra_map_eq' (is_localization.map_comp _).symm\n  constructor\n  replace H := fun r => (H r).1\n  choose s₁ s₂ using H\n  let sf := fun x : s => is_localization.finset_integer_multiple (submonoid.powers (f x)) (s₁ x)\n  use s.attach.bUnion sf\n  convert (algebra.adjoin_attach_bUnion sf).trans _\n  rw [eq_top_iff]\n  rintro x -\n  apply\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            (algebra.adjoin R (sf x : set S))).to_submodule.mem_of_span_eq_top_of_smul_pow_mem\n      _ hs _ _\n  intro r\n  obtain ⟨⟨_, n₁, rfl⟩, hn₁⟩ :=\n    multiple_mem_adjoin_of_mem_localization_adjoin (submonoid.powers (r : R)) (localization.away (r : R))\n      (s₁ r : set (localization.away (f r))) (algebra_map S (localization.away (f r)) x)\n      (by\n        rw [s₂ r]\n        trivial)\n  rw [Submonoid.smul_def, algebra.smul_def, is_scalar_tower.algebra_map_apply R S, subtype.coe_mk, ← map_mul] at hn₁\n  obtain ⟨⟨_, n₂, rfl⟩, hn₂⟩ :=\n    is_localization.lift_mem_adjoin_finset_integer_multiple (submonoid.powers (r : R)) _ (s₁ r) hn₁\n  rw [Submonoid.smul_def, ← algebra.smul_def, smul_smul, subtype.coe_mk, ← pow_add] at hn₂\n  simp_rw [submonoid.map_powers] at hn₂\n  use n₂ + n₁\n  exact le_supᵢ (fun x : s => algebra.adjoin R (sf x : set S)) r hn₂\n#align finite_type_of_localization_span finite_type_of_localization_span\n\n",
 "finite_of_localization_span":
 "theorem finite_of_localization_span : ring_hom.of_localization_span @ring_hom.finite :=\n  by\n  rw [ring_hom.of_localization_span_iff_finite]\n  introv R hs H\n  -- We first setup the instances\n  skip\n  letI := f.to_algebra\n  letI := fun r : s => (localization.away_map f r).to_algebra\n  have : ∀ r : s, is_localization ((submonoid.powers (r : R)).map (algebra_map R S)) (localization.away (f r)) :=\n    by\n    intro r\n    rw [submonoid.map_powers]\n    exact localization.is_localization\n  haveI : ∀ r : s, IsScalarTower R (localization.away (r : R)) (localization.away (f r)) := fun r =>\n    is_scalar_tower.of_algebra_map_eq' (is_localization.map_comp _).symm\n  -- By the hypothesis, we may find a finite generating set for each `Sᵣ`. This set can then be\n  -- lifted into `R` by multiplying a sufficiently large power of `r`. I claim that the union of\n  -- these generates `S`.\n  constructor\n  replace H := fun r => (H r).1\n  choose s₁ s₂ using H\n  let sf := fun x : s => is_localization.finset_integer_multiple (submonoid.powers (f x)) (s₁ x)\n  use s.attach.bUnion sf\n  rw [submodule.span_attach_bUnion, eq_top_iff]\n  -- It suffices to show that `r ^ n • x ∈ span T` for each `r : s`, since `{ r ^ n }` spans `R`.\n  -- This then follows from the fact that each `x : R` is a linear combination of the generating set\n  -- of `Sᵣ`. By multiplying a sufficiently large power of `r`, we can cancel out the `r`s in the\n  -- denominators of both the generating set and the coefficients.\n  rintro x -\n  apply submodule.mem_of_span_eq_top_of_smul_pow_mem _ (s : set R) hs _ _\n  intro r\n  obtain ⟨⟨_, n₁, rfl⟩, hn₁⟩ :=\n    multiple_mem_span_of_mem_localization_span (submonoid.powers (r : R)) (localization.away (r : R))\n      (s₁ r : set (localization.away (f r))) (algebra_map S _ x)\n      (by\n        rw [s₂ r]\n        trivial)\n  rw [Submonoid.smul_def, algebra.smul_def, is_scalar_tower.algebra_map_apply R S, subtype.coe_mk, ← map_mul] at hn₁\n  obtain ⟨⟨_, n₂, rfl⟩, hn₂⟩ :=\n    is_localization.smul_mem_finset_integer_multiple_span (submonoid.powers (r : R)) (localization.away (f r)) _ (s₁ r)\n      hn₁\n  rw [Submonoid.smul_def, ← algebra.smul_def, smul_smul, subtype.coe_mk, ← pow_add] at hn₂\n  simp_rw [submonoid.map_powers] at hn₂\n  use n₂ + n₁\n  exact le_supᵢ (fun x : s => submodule.span R (sf x : set S)) r hn₂\n#align finite_of_localization_span finite_of_localization_span\n\n",
 "exists_smul_mem_of_mem_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Let `S` be an `R`-algebra, `M` a submonoid of `S`, `S' = M⁻¹S`.\nSuppose the image of some `x : S` falls in the adjoin of some finite `s ⊆ S'` over `R`,\nand `A` is an `R`-subalgebra of `S` containing both `M` and the numerators of `s`.\nThen, there exists some `m : M` such that `m • x` falls in `A`.\n-/\ntheorem is_localization.exists_smul_mem_of_mem_adjoin [algebra R S] [algebra R S'] [IsScalarTower R S S']\n    (M : Submonoid S) [is_localization M S'] (x : S) (s : Finset S') (A : subalgebra R S)\n    (hA₁ : (is_localization.finset_integer_multiple M s : set S) ⊆ A) (hA₂ : M ≤ A.to_submonoid)\n    (hx : algebra_map S S' x ∈ algebra.adjoin R (s : set S')) : ∃ m : M, «expr • » m x ∈ A :=\n  by\n  let g : «expr →ₐ[ ] » S R S' := is_scalar_tower.to_alg_hom R S S'\n  let y := is_localization.common_denom_of_finset M s\n  have hx₁ : «expr • » (y : S) ↑s = «expr '' » g _ := (is_localization.finset_integer_multiple_image _ s).symm\n  obtain ⟨n, hn⟩ :=\n    algebra.pow_smul_mem_of_smul_subset_of_mem_adjoin (y : S) (s : set S') (A.map g)\n      (by\n        rw [hx₁]\n        exact Set.image_subset _ hA₁)\n      hx (Set.mem_image_of_mem _ (hA₂ y.2))\n  obtain ⟨x', hx', hx''⟩ := hn n (le_of_eq rfl)\n  rw [algebra.smul_def, ← _root_.map_mul] at hx''\n  obtain ⟨a, ha₂⟩ := (is_localization.eq_iff_exists M S').mp hx''\n  use a * y ^ n\n  convert A.mul_mem hx' (hA₂ a.2)\n  convert ha₂.symm\n  simp only [Submonoid.smul_def, [anonymous], smul_eq_mul, Submonoid.coe_mul]\n  ring\n#align is_localization.exists_smul_mem_of_mem_adjoin is_localization.exists_smul_mem_of_mem_adjoin\n\n",
 "eq_zero_of_localization":
 "theorem eq_zero_of_localization (r : R)\n    (h : ∀ (J : ideal R) (hJ : J.is_maximal), algebra_map R (localization.at_prime J) r = 0) : r = 0 :=\n  by\n  rw [← ideal.span_singleton_eq_bot]\n  apply ideal_eq_bot_of_localization\n  intro J hJ\n  delta is_localization.coe_submodule\n  erw [submodule.map_span, submodule.span_eq_bot]\n  rintro _ ⟨_, h', rfl⟩\n  cases set.mem_singleton_iff.mpr h'\n  exact h J hJ\n#align eq_zero_of_localization eq_zero_of_localization\n\n",
 "eq_of_localization_maximal":
 "/-- Let `I J : ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\nthe localization of `J` at `P`, then `I = J`. -/\ntheorem ideal.eq_of_localization_maximal {I J : ideal R}\n    (h :\n      ∀ (P : ideal R) (hP : P.is_maximal),\n        ideal.map (algebra_map R (localization.at_prime P)) I = ideal.map (algebra_map R (localization.at_prime P)) J) :\n    I = J :=\n  le_antisymm (ideal.le_of_localization_maximal fun P hP => (h P hP).le)\n    (ideal.le_of_localization_maximal fun P hP => (h P hP).ge)\n#align ideal.eq_of_localization_maximal ideal.eq_of_localization_maximal\n\n",
 "away":
 "-- Almost all arguments are implicit since this is not intended to use mid-proof.\ntheorem ring_hom.localization_preserves.away (H : ring_hom.localization_preserves @P) (r : R)\n    [is_localization.away r R'] [is_localization.away (f r) S'] (hf : P f) : P (is_localization.away.map R' S' f r) :=\n  by\n  skip\n  have : is_localization ((submonoid.powers r).map f) S' :=\n    by\n    rw [submonoid.map_powers]\n    assumption\n  exact H f (submonoid.powers r) R' S' hf\n#align ring_hom.localization_preserves.away ring_hom.localization_preserves.away\n\n"}