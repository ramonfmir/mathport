{"surjective_of_localization_span":
 "theorem surjective_of_localization_span : ring_hom.of_localization_span fun R S _ _ f => function.surjective f :=\n  by\n  introv R e H\n  rw [← Set.range_iff_surjective, Set.eq_univ_iff_forall]\n  skip\n  letI := f.to_algebra\n  intro x\n  apply Submodule.mem_of_span_eq_top_of_smul_pow_mem (Algebra.ofId R S).to_linear_map.range s e\n  intro r\n  obtain ⟨a, e'⟩ := H r (algebraMap _ _ x)\n  obtain ⟨b, ⟨_, n, rfl⟩, rfl⟩ := IsLocalization.mk'_surjective (Submonoid.powers (r : R)) a\n  erw [IsLocalization.map_mk'] at e'\n  rw [eq_comm, IsLocalization.eq_mk'_iff_mul_eq, Subtype.coe_mk, Subtype.coe_mk, ← map_mul] at e'\n  obtain ⟨⟨_, n', rfl⟩, e''⟩ := (is_localization.eq_iff_exists (Submonoid.powers (f r)) _).mp e'\n  rw [Subtype.coe_mk, mul_comm x, ← mul_assoc, ← map_pow, ← map_mul, ← map_mul, ← pow_add] at e''\n  exact ⟨n' + n, _, e''.symm⟩\n#align surjective_of_localization_span surjective_of_localization_span\n\n",
 "smul_mem_finset_integer_multiple_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Let `S` be an `R`-algebra, `M` an submonoid of `R`, and `S' = M⁻¹S`.\nIf the image of some `x : S` falls in the span of some finite `s ⊆ S'` over `R`,\nthen there exists some `m : M` such that `m • x` falls in the\nspan of `finset_integer_multiple _ s` over `R`.\n-/\ntheorem is_localization.smul_mem_finset_integer_multiple_span [Algebra R S] [Algebra R S'] [IsScalarTower R S S']\n    [IsLocalization (M.map (algebraMap R S)) S'] (x : S) (s : Finset S')\n    (hx : algebraMap S S' x ∈ Submodule.span R (s : Set S')) :\n    ∃ m : M,\n      «expr • » m x ∈ Submodule.span R (IsLocalization.finsetIntegerMultiple (M.map (algebraMap R S)) s : Set S) :=\n  by\n  let g : «expr →ₐ[ ] » S R S' := AlgHom.mk' (algebraMap S S') fun c x => by simp [Algebra.algebraMap_eq_smul_one]\n  -- We first obtain the `y' ∈ M` such that `s' = y' • s` is falls in the image of `S` in `S'`.\n  let y := IsLocalization.commonDenomOfFinset (M.map (algebraMap R S)) s\n  have hx₁ : «expr • » (y : S) ↑s = «expr '' » g _ := (IsLocalization.finsetIntegerMultiple_image _ s).symm\n  obtain ⟨y', hy', e : algebraMap R S y' = y⟩ := y.prop\n  have : «expr • » (algebraMap R S y') (s : Set S') = «expr • » y' s := by\n    simp_rw [Algebra.algebraMap_eq_smul_one, smul_assoc, one_smul]\n  rw [← e, this] at hx₁\n  replace hx₁ := congr_arg (Submodule.span R) hx₁\n  rw [Submodule.span_smul] at hx₁\n  replace hx : _ ∈ «expr • » y' (Submodule.span R (s : Set S')) := Set.smul_mem_smul_set hx\n  rw [hx₁] at hx\n  erw [← g.map_smul, ← Submodule.map_span (g : «expr →ₗ[ ] » S R S')] at hx\n  -- Since `x` falls in the span of `s` in `S'`, `y' • x : S` falls in the span of `s'` in `S'`.\n  -- That is, there exists some `x' : S` in the span of `s'` in `S` and `x' = y' • x` in `S'`.\n  -- Thus `a • (y' • x) = a • x' ∈ span s'` in `S` for some `a ∈ M`.\n  obtain ⟨x', hx', hx'' : algebraMap _ _ _ = _⟩ := hx\n  obtain ⟨⟨_, a, ha₁, rfl⟩, ha₂⟩ := (is_localization.eq_iff_exists (M.map (algebraMap R S)) S').mp hx''\n  use (⟨a, ha₁⟩ : M) * (⟨y', hy'⟩ : M)\n  convert(Submodule.span R (IsLocalization.finsetIntegerMultiple (Submonoid.map (algebraMap R S) M) s : Set S)).smul_mem\n      a hx' using\n    1\n  convert ha₂.symm\n  · rw [Subtype.coe_mk, Submonoid.smul_def, Submonoid.coe_mul, ← smul_smul]\n    exact Algebra.smul_def _ _\n  · exact Algebra.smul_def _ _\n#align is_localization.smul_mem_finset_integer_multiple_span is_localization.smul_mem_finset_integer_multiple_span\n\n",
 "respects_iso":
 "theorem _root_.ring_hom.property_is_local.respects_iso (hP : ring_hom.property_is_local @P) :\n    ring_hom.respects_iso @P := by\n  apply hP.stable_under_composition.respects_iso\n  introv\n  skip\n  letI := e.to_ring_hom.to_algebra\n  apply (config := { instances := false }) hP.holds_for_localization_away\n  apply is_localization.away_of_is_unit_of_bijective _ isUnit_one\n  exact e.bijective\n#align ring_hom.property_is_local.respects_iso ring_hom.property_is_local.respects_iso\n\n",
 "of_localization_span_target_iff_finite":
 "theorem ring_hom.of_localization_span_target_iff_finite :\n    ring_hom.of_localization_span_target @P ↔ ring_hom.of_localization_finite_span_target @P :=\n  by\n  delta ring_hom.of_localization_span_target ring_hom.of_localization_finite_span_target\n  apply forall₅_congr\n  -- TODO: Using `refine` here breaks `resetI`.\n  intros\n  constructor\n  · intro h s\n    exact h s\n  · intro h s hs hs'\n    obtain ⟨s', h₁, h₂⟩ := (Ideal.span_eq_top_iff_finite s).mp hs\n    exact h s' h₂ fun x => hs' ⟨_, h₁ x.prop⟩\n#align ring_hom.of_localization_span_target_iff_finite ring_hom.of_localization_span_target_iff_finite\n\n",
 "of_localization_span_iff_finite":
 "/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem ring_hom.of_localization_span_iff_finite :\n    ring_hom.of_localization_span @P ↔ ring_hom.of_localization_finite_span @P :=\n  by\n  delta ring_hom.of_localization_span ring_hom.of_localization_finite_span\n  apply forall₅_congr\n  -- TODO: Using `refine` here breaks `resetI`.\n  intros\n  constructor\n  · intro h s\n    exact h s\n  · intro h s hs hs'\n    obtain ⟨s', h₁, h₂⟩ := (Ideal.span_eq_top_iff_finite s).mp hs\n    exact h s' h₂ fun x => hs' ⟨_, h₁ x.prop⟩\n#align ring_hom.of_localization_span_iff_finite ring_hom.of_localization_span_iff_finite\n\n",
 "of_localization_span":
 "theorem ring_hom.property_is_local.of_localization_span (hP : ring_hom.property_is_local @P) :\n    ring_hom.of_localization_span @P := by\n  introv R hs hs'\n  skip\n  apply_fun Ideal.map f  at hs\n  rw [Ideal.map_span, Ideal.map_top] at hs\n  apply hP.of_localization_span_target _ _ hs\n  rintro ⟨_, r, hr, rfl⟩\n  have := hs' ⟨r, hr⟩\n  convert hP.stable_under_composition _ _ (hP.holds_for_localization_away (Localization.Away r) r) (hs' ⟨r, hr⟩) using 1\n  exact (IsLocalization.map_comp _).symm\n#align ring_hom.property_is_local.of_localization_span ring_hom.property_is_local.of_localization_span\n\n",
 "multiple_mem_span_of_mem_localization_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `S` is an `R' = M⁻¹R` algebra, and `x ∈ span R' s`,\nthen `t • x ∈ span R s` for some `t : M`.-/\ntheorem multiple_mem_span_of_mem_localization_span [Algebra R' S] [Algebra R S] [IsScalarTower R R' S]\n    [IsLocalization M R'] (s : Set S) (x : S) (hx : x ∈ Submodule.span R' s) :\n    ∃ t : M, «expr • » t x ∈ Submodule.span R s := by\n  classical\n    obtain ⟨s', hss', hs'⟩ := Submodule.mem_span_finite_of_mem_span hx\n    rsuffices ⟨t, ht⟩ : ∃ t : M, «expr • » t x ∈ Submodule.span R (s' : Set S)\n    · exact ⟨t, Submodule.span_mono hss' ht⟩\n    clear hx hss' s\n    revert x\n    apply s'.induction_on\n    · intro x hx\n      use 1\n      simpa using hx\n    rintro a s ha hs x hx\n    simp only [Finset.coe_insert, Finset.image_insert, Finset.coe_image, Subtype.coe_mk, Submodule.mem_span_insert] at\n      hx⊢\n    rcases hx with ⟨y, z, hz, rfl⟩\n    rcases is_localization.surj M y with ⟨⟨y', s'⟩, e⟩\n    replace e : _ * a = _ * a := (congr_arg (fun x => algebraMap R' S x * a) e : _)\n    simp_rw [RingHom.map_mul, ← IsScalarTower.algebraMap_apply, mul_comm (algebraMap R' S y), mul_assoc, ←\n      Algebra.smul_def] at e\n    rcases hs _ hz with ⟨t, ht⟩\n    refine' ⟨t * s', t * y', _, (Submodule.span R (s : Set S)).smul_mem s' ht, _⟩\n    rw [smul_add, ← smul_smul, mul_comm, ← smul_smul, ← smul_smul, ← e]\n    rfl\n#align multiple_mem_span_of_mem_localization_span multiple_mem_span_of_mem_localization_span\n\n",
 "multiple_mem_adjoin_of_mem_localization_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `S` is an `R' = M⁻¹R` algebra, and `x ∈ adjoin R' s`,\nthen `t • x ∈ adjoin R s` for some `t : M`.-/\ntheorem multiple_mem_adjoin_of_mem_localization_adjoin [Algebra R' S] [Algebra R S] [IsScalarTower R R' S]\n    [IsLocalization M R'] (s : Set S) (x : S) (hx : x ∈ Algebra.adjoin R' s) :\n    ∃ t : M, «expr • » t x ∈ Algebra.adjoin R s :=\n  by\n  change ∃ t : M, «expr • » t x ∈ (Algebra.adjoin R s).to_submodule\n  change x ∈ (Algebra.adjoin R' s).to_submodule at hx\n  simp_rw [Algebra.adjoin_eq_span] at hx⊢\n  exact multiple_mem_span_of_mem_localization_span M R' _ _ hx\n#align multiple_mem_adjoin_of_mem_localization_adjoin multiple_mem_adjoin_of_mem_localization_adjoin\n\n",
 "localization_preserves_surjective":
 "theorem localization_preserves_surjective : ring_hom.localization_preserves fun R S _ _ f => function.surjective f :=\n  by\n  introv R H x\n  skip\n  obtain ⟨x, ⟨_, s, hs, rfl⟩, rfl⟩ := IsLocalization.mk'_surjective (M.map f) x\n  obtain ⟨y, rfl⟩ := H x\n  use IsLocalization.mk' R' y ⟨s, hs⟩\n  rw [IsLocalization.map_mk']\n  rfl\n#align localization_preserves_surjective localization_preserves_surjective\n\n",
 "localization_is_reduced":
 "theorem localization_is_reduced : localization_preserves fun R hR => IsReduced R :=\n  by\n  introv R _ _\n  skip\n  constructor\n  rintro x ⟨_ | n, e⟩\n  · simpa using congr_arg (· * x) e\n  obtain ⟨⟨y, m⟩, hx⟩ := is_localization.surj M x\n  dsimp only at hx\n  let hx' := congr_arg (· ^ n.succ) hx\n  simp only [mul_pow, e, MulZeroClass.zero_mul, ← RingHom.map_pow] at hx'\n  rw [← (algebraMap R S).map_zero] at hx'\n  obtain ⟨m', hm'⟩ := (is_localization.eq_iff_exists M S).mp hx'\n  apply_fun (· * m' ^ n)  at hm'\n  simp only [mul_assoc, MulZeroClass.zero_mul, MulZeroClass.mul_zero] at hm'\n  rw [← mul_left_comm, ← pow_succ, ← mul_pow] at hm'\n  replace hm' := IsNilpotent.eq_zero ⟨_, hm'.symm⟩\n  rw [← (is_localization.map_units S m).mul_left_inj, hx, MulZeroClass.zero_mul, IsLocalization.map_eq_zero_iff M]\n  exact ⟨m', by rw [← hm', mul_comm]⟩\n#align localization_is_reduced localization_is_reduced\n\n",
 "localization_finite_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem localization_finite_type : ring_hom.localization_preserves @RingHom.FiniteType :=\n  by\n  introv R hf\n  -- mirrors the proof of `localization_map_finite`\n  skip\n  letI := f.to_algebra\n  letI := ((algebraMap S S').comp f).to_algebra\n  let f' : «expr →+* » R' S' := IsLocalization.map S' f (Submonoid.le_comap_map M)\n  letI := f'.to_algebra\n  haveI : IsScalarTower R R' S' := IsScalarTower.of_algebraMap_eq' (IsLocalization.map_comp _).symm\n  let fₐ : «expr →ₐ[ ] » S R S' := AlgHom.mk' (algebraMap S S') fun c x => RingHom.map_mul _ _ _\n  obtain ⟨T, hT⟩ := id hf\n  use T.image (algebraMap S S')\n  rw [eq_top_iff]\n  rintro x -\n  obtain ⟨y, ⟨_, ⟨r, hr, rfl⟩⟩, rfl⟩ := IsLocalization.mk'_surjective (M.map f) x\n  rw [IsLocalization.mk'_eq_mul_mk'_one, mul_comm, Finset.coe_image]\n  have hy : y ∈ Algebra.adjoin R (T : Set S) := by\n    rw [hT]\n    trivial\n  replace hy : algebraMap S S' y ∈ (Algebra.adjoin R (T : Set S)).map fₐ := subalgebra.mem_map.mpr ⟨_, hy, rfl⟩\n  rw [fₐ.map_adjoin T] at hy\n  have H :\n    Algebra.adjoin R («expr '' » (algebraMap S S') T) ≤\n      (Algebra.adjoin R' («expr '' » (algebraMap S S') T)).restrict_scalars R :=\n    by\n    rw [Algebra.adjoin_le_iff]\n    exact Algebra.subset_adjoin\n  convert(Algebra.adjoin R' («expr '' » (algebraMap S S') T)).smul_mem (H hy)\n      (IsLocalization.mk' R' (1 : R) ⟨r, hr⟩) using\n    1\n  rw [Algebra.smul_def]\n  erw [IsLocalization.map_mk']\n  rw [map_one]\n  rfl\n#align localization_finite_type localization_finite_type\n\n",
 "localization_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. -/\ntheorem localization_finite : ring_hom.localization_preserves @RingHom.Finite :=\n  by\n  introv R hf\n  -- Setting up the `algebra` and `is_scalar_tower` instances needed\n  skip\n  letI := f.to_algebra\n  letI := ((algebraMap S S').comp f).to_algebra\n  let f' : «expr →+* » R' S' := IsLocalization.map S' f (Submonoid.le_comap_map M)\n  letI := f'.to_algebra\n  haveI : IsScalarTower R R' S' := IsScalarTower.of_algebraMap_eq' (IsLocalization.map_comp _).symm\n  let fₐ : «expr →ₐ[ ] » S R S' := AlgHom.mk' (algebraMap S S') fun c x => RingHom.map_mul _ _ _\n  -- We claim that if `S` is generated by `T` as an `R`-module,\n  -- then `S'` is generated by `T` as an `R'`-module.\n  obtain ⟨T, hT⟩ := hf\n  use T.image (algebraMap S S')\n  rw [eq_top_iff]\n  rintro x -\n  -- By the hypotheses, for each `x : S'`, we have `x = y / (f r)` for some `y : S` and `r : M`.\n  -- Since `S` is generated by `T`, the image of `y` should fall in the span of the image of `T`.\n  obtain ⟨y, ⟨_, ⟨r, hr, rfl⟩⟩, rfl⟩ := IsLocalization.mk'_surjective (M.map f) x\n  rw [IsLocalization.mk'_eq_mul_mk'_one, mul_comm, Finset.coe_image]\n  have hy : y ∈ Submodule.span R ↑T := by\n    rw [hT]\n    trivial\n  replace hy : algebraMap S S' y ∈ Submodule.map fₐ.to_linear_map (Submodule.span R T) := Submodule.mem_map_of_mem hy\n  rw [Submodule.map_span fₐ.to_linear_map T] at hy\n  have H :\n    Submodule.span R («expr '' » (algebraMap S S') T) ≤\n      (Submodule.span R' («expr '' » (algebraMap S S') T)).restrict_scalars R :=\n    by\n    rw [Submodule.span_le]\n    exact Submodule.subset_span\n  -- Now, since `y ∈ span T`, and `(f r)⁻¹ ∈ R'`, `x / (f r)` is in `span T` as well.\n  convert(Submodule.span R' («expr '' » (algebraMap S S') T)).smul_mem (IsLocalization.mk' R' (1 : R) ⟨r, hr⟩)\n      (H hy) using\n    1\n  rw [Algebra.smul_def]\n  erw [IsLocalization.map_mk']\n  rw [map_one]\n  rfl\n#align localization_finite localization_finite\n\n",
 "localization_away_map_finite_type":
 "theorem localization_away_map_finite_type (r : R) [is_localization.away r R'] [is_localization.away (f r) S']\n    (hf : f.finite_type) : (is_localization.away.map R' S' f r).finite_type :=\n  localization_finite_type.away r hf\n#align localization_away_map_finite_type localization_away_map_finite_type\n\n",
 "localization_away_map_finite":
 "theorem localization_away_map_finite (r : R) [is_localization.away r R'] [is_localization.away (f r) S']\n    (hf : f.finite) : (is_localization.away.map R' S' f r).finite :=\n  localization_finite.away r hf\n#align localization_away_map_finite localization_away_map_finite\n\n",
 "lift_mem_adjoin_finset_integer_multiple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Let `S` be an `R`-algebra, `M` an submonoid of `R`, and `S' = M⁻¹S`.\nIf the image of some `x : S` falls in the adjoin of some finite `s ⊆ S'` over `R`,\nthen there exists some `m : M` such that `m • x` falls in the\nadjoin of `finset_integer_multiple _ s` over `R`.\n-/\ntheorem is_localization.lift_mem_adjoin_finset_integer_multiple [Algebra R S] [Algebra R S'] [IsScalarTower R S S']\n    [IsLocalization (M.map (algebraMap R S)) S'] (x : S) (s : Finset S')\n    (hx : algebraMap S S' x ∈ Algebra.adjoin R (s : Set S')) :\n    ∃ m : M,\n      «expr • » m x ∈ Algebra.adjoin R (IsLocalization.finsetIntegerMultiple (M.map (algebraMap R S)) s : Set S) :=\n  by\n  obtain ⟨⟨_, a, ha, rfl⟩, e⟩ :=\n    is_localization.exists_smul_mem_of_mem_adjoin (M.map (algebraMap R S)) x s (Algebra.adjoin R _)\n      Algebra.subset_adjoin _ hx\n  · exact ⟨⟨a, ha⟩, by simpa [Submonoid.smul_def] using e⟩\n  · rintro _ ⟨a, ha, rfl⟩\n    exact Subalgebra.algebraMap_mem _ a\n#align is_localization.lift_mem_adjoin_finset_integer_multiple is_localization.lift_mem_adjoin_finset_integer_multiple\n\n",
 "le_of_localization_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Let `I J : ideal R`. If the localization of `I` at each maximal ideal `P` is included in\nthe localization of `J` at `P`, then `I ≤ J`. -/\ntheorem ideal.le_of_localization_maximal {I J : Ideal R}\n    (h :\n      ∀ (P : Ideal R) (hP : P.is_maximal),\n        Ideal.map (algebraMap R (localization.at_prime P)) I ≤ Ideal.map (algebraMap R (localization.at_prime P)) J) :\n    I ≤ J := by\n  intro x hx\n  suffices J.colon (Ideal.span {x}) = «expr⊤» by\n    simpa using\n      submodule.mem_colon.mp (show (1 : R) ∈ J.colon (Ideal.span {x}) from this.symm ▸ Submodule.mem_top) x\n        (Ideal.mem_span_singleton_self x)\n  refine' Not.imp_symm (J.colon (Ideal.span {x})).exists_le_maximal _\n  push_neg\n  intro P hP le\n  obtain ⟨⟨⟨a, ha⟩, ⟨s, hs⟩⟩, eq⟩ :=\n    (IsLocalization.mem_map_algebraMap_iff P.prime_compl _).mp (h P hP (Ideal.mem_map_of_mem _ hx))\n  rw [← _root_.map_mul, ← sub_eq_zero, ← map_sub] at eq\n  obtain ⟨⟨m, hm⟩, eq⟩ := (IsLocalization.map_eq_zero_iff P.prime_compl _ _).mp Eq\n  refine' hs ((hP.is_prime.mem_or_mem (le (ideal.mem_colon_singleton.mpr _))).resolve_right hm)\n  simp only [Subtype.coe_mk, mul_sub, sub_eq_zero, mul_comm x s, mul_left_comm] at eq\n  simpa only [mul_assoc, Eq] using J.mul_mem_left m ha\n#align ideal.le_of_localization_maximal ideal.le_of_localization_maximal\n\n",
 "is_reduced_of_localization_maximal":
 "theorem is_reduced_of_localization_maximal : of_localization_maximal fun R hR => IsReduced R :=\n  by\n  introv R h\n  constructor\n  intro x hx\n  apply eq_zero_of_localization\n  intro J hJ\n  specialize h J hJ\n  skip\n  exact (hx.map <| algebraMap R <| localization.at_prime J).eq_zero\n#align is_reduced_of_localization_maximal is_reduced_of_localization_maximal\n\n",
 "ideal_eq_bot_of_localization'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- An ideal is trivial if its localization at every maximal ideal is trivial. -/\ntheorem ideal_eq_bot_of_localization' (I : Ideal R)\n    (h : ∀ (J : Ideal R) (hJ : J.is_maximal), Ideal.map (algebraMap R (localization.at_prime J)) I = «expr⊥») :\n    I = «expr⊥» :=\n  ideal.eq_of_localization_maximal fun P hP => by simpa using h P hP\n#align ideal_eq_bot_of_localization' ideal_eq_bot_of_localization'\n\n",
 "ideal_eq_bot_of_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- TODO: This proof should work for all modules, once we have enough material on submodules of\n-- localized modules.\n/-- An ideal is trivial if its localization at every maximal ideal is trivial. -/\ntheorem ideal_eq_bot_of_localization (I : Ideal R)\n    (h : ∀ (J : Ideal R) (hJ : J.is_maximal), IsLocalization.coeSubmodule (localization.at_prime J) I = «expr⊥») :\n    I = «expr⊥» :=\n  ideal_eq_bot_of_localization' _ fun P hP =>\n    (Ideal.map_eq_bot_iff_le_ker _).mpr fun x hx =>\n      by\n      rw [RingHom.mem_ker, ← Submodule.mem_bot R, ← h P hP, IsLocalization.mem_coeSubmodule]\n      exact ⟨x, hx, rfl⟩\n#align ideal_eq_bot_of_localization ideal_eq_bot_of_localization\n\n",
 "finite_type_of_localization_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem finite_type_of_localization_span : ring_hom.of_localization_span @RingHom.FiniteType :=\n  by\n  rw [ring_hom.of_localization_span_iff_finite]\n  introv R hs H\n  -- mirrors the proof of `finite_of_localization_span`\n  skip\n  letI := f.to_algebra\n  letI := fun r : s => (localization.away_map f r).to_algebra\n  have : ∀ r : s, IsLocalization ((Submonoid.powers (r : R)).map (algebraMap R S)) (Localization.Away (f r)) :=\n    by\n    intro r\n    rw [Submonoid.map_powers]\n    exact localization.is_localization\n  haveI : ∀ r : s, IsScalarTower R (Localization.Away (r : R)) (Localization.Away (f r)) := fun r =>\n    IsScalarTower.of_algebraMap_eq' (IsLocalization.map_comp _).symm\n  constructor\n  replace H := fun r => (H r).1\n  choose s₁ s₂ using H\n  let sf := fun x : s => IsLocalization.finsetIntegerMultiple (Submonoid.powers (f x)) (s₁ x)\n  use s.attach.bUnion sf\n  convert(Algebra.adjoin_attach_bunionᵢ sf).trans _\n  rw [eq_top_iff]\n  rintro x -\n  apply\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            (Algebra.adjoin R (sf x : Set S))).to_submodule.mem_of_span_eq_top_of_smul_pow_mem\n      _ hs _ _\n  intro r\n  obtain ⟨⟨_, n₁, rfl⟩, hn₁⟩ :=\n    multiple_mem_adjoin_of_mem_localization_adjoin (Submonoid.powers (r : R)) (Localization.Away (r : R))\n      (s₁ r : Set (Localization.Away (f r))) (algebraMap S (Localization.Away (f r)) x)\n      (by\n        rw [s₂ r]\n        trivial)\n  rw [Submonoid.smul_def, Algebra.smul_def, IsScalarTower.algebraMap_apply R S, Subtype.coe_mk, ← map_mul] at hn₁\n  obtain ⟨⟨_, n₂, rfl⟩, hn₂⟩ :=\n    is_localization.lift_mem_adjoin_finset_integer_multiple (Submonoid.powers (r : R)) _ (s₁ r) hn₁\n  rw [Submonoid.smul_def, ← Algebra.smul_def, smul_smul, Subtype.coe_mk, ← pow_add] at hn₂\n  simp_rw [Submonoid.map_powers] at hn₂\n  use n₂ + n₁\n  exact le_supᵢ (fun x : s => Algebra.adjoin R (sf x : Set S)) r hn₂\n#align finite_type_of_localization_span finite_type_of_localization_span\n\n",
 "finite_of_localization_span":
 "theorem finite_of_localization_span : ring_hom.of_localization_span @RingHom.Finite :=\n  by\n  rw [ring_hom.of_localization_span_iff_finite]\n  introv R hs H\n  -- We first setup the instances\n  skip\n  letI := f.to_algebra\n  letI := fun r : s => (localization.away_map f r).to_algebra\n  have : ∀ r : s, IsLocalization ((Submonoid.powers (r : R)).map (algebraMap R S)) (Localization.Away (f r)) :=\n    by\n    intro r\n    rw [Submonoid.map_powers]\n    exact localization.is_localization\n  haveI : ∀ r : s, IsScalarTower R (Localization.Away (r : R)) (Localization.Away (f r)) := fun r =>\n    IsScalarTower.of_algebraMap_eq' (IsLocalization.map_comp _).symm\n  -- By the hypothesis, we may find a finite generating set for each `Sᵣ`. This set can then be\n  -- lifted into `R` by multiplying a sufficiently large power of `r`. I claim that the union of\n  -- these generates `S`.\n  constructor\n  replace H := fun r => (H r).1\n  choose s₁ s₂ using H\n  let sf := fun x : s => IsLocalization.finsetIntegerMultiple (Submonoid.powers (f x)) (s₁ x)\n  use s.attach.bUnion sf\n  rw [Submodule.span_attach_bunionᵢ, eq_top_iff]\n  -- It suffices to show that `r ^ n • x ∈ span T` for each `r : s`, since `{ r ^ n }` spans `R`.\n  -- This then follows from the fact that each `x : R` is a linear combination of the generating set\n  -- of `Sᵣ`. By multiplying a sufficiently large power of `r`, we can cancel out the `r`s in the\n  -- denominators of both the generating set and the coefficients.\n  rintro x -\n  apply Submodule.mem_of_span_eq_top_of_smul_pow_mem _ (s : Set R) hs _ _\n  intro r\n  obtain ⟨⟨_, n₁, rfl⟩, hn₁⟩ :=\n    multiple_mem_span_of_mem_localization_span (Submonoid.powers (r : R)) (Localization.Away (r : R))\n      (s₁ r : Set (Localization.Away (f r))) (algebraMap S _ x)\n      (by\n        rw [s₂ r]\n        trivial)\n  rw [Submonoid.smul_def, Algebra.smul_def, IsScalarTower.algebraMap_apply R S, Subtype.coe_mk, ← map_mul] at hn₁\n  obtain ⟨⟨_, n₂, rfl⟩, hn₂⟩ :=\n    is_localization.smul_mem_finset_integer_multiple_span (Submonoid.powers (r : R)) (Localization.Away (f r)) _ (s₁ r)\n      hn₁\n  rw [Submonoid.smul_def, ← Algebra.smul_def, smul_smul, Subtype.coe_mk, ← pow_add] at hn₂\n  simp_rw [Submonoid.map_powers] at hn₂\n  use n₂ + n₁\n  exact le_supᵢ (fun x : s => Submodule.span R (sf x : Set S)) r hn₂\n#align finite_of_localization_span finite_of_localization_span\n\n",
 "exists_smul_mem_of_mem_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Let `S` be an `R`-algebra, `M` a submonoid of `S`, `S' = M⁻¹S`.\nSuppose the image of some `x : S` falls in the adjoin of some finite `s ⊆ S'` over `R`,\nand `A` is an `R`-subalgebra of `S` containing both `M` and the numerators of `s`.\nThen, there exists some `m : M` such that `m • x` falls in `A`.\n-/\ntheorem is_localization.exists_smul_mem_of_mem_adjoin [Algebra R S] [Algebra R S'] [IsScalarTower R S S']\n    (M : Submonoid S) [IsLocalization M S'] (x : S) (s : Finset S') (A : Subalgebra R S)\n    (hA₁ : (IsLocalization.finsetIntegerMultiple M s : Set S) ⊆ A) (hA₂ : M ≤ A.to_submonoid)\n    (hx : algebraMap S S' x ∈ Algebra.adjoin R (s : Set S')) : ∃ m : M, «expr • » m x ∈ A :=\n  by\n  let g : «expr →ₐ[ ] » S R S' := IsScalarTower.toAlgHom R S S'\n  let y := IsLocalization.commonDenomOfFinset M s\n  have hx₁ : «expr • » (y : S) ↑s = «expr '' » g _ := (IsLocalization.finsetIntegerMultiple_image _ s).symm\n  obtain ⟨n, hn⟩ :=\n    Algebra.pow_smul_mem_of_smul_subset_of_mem_adjoin (y : S) (s : Set S') (A.map g)\n      (by\n        rw [hx₁]\n        exact Set.image_subset _ hA₁)\n      hx (Set.mem_image_of_mem _ (hA₂ y.2))\n  obtain ⟨x', hx', hx''⟩ := hn n (le_of_eq rfl)\n  rw [Algebra.smul_def, ← _root_.map_mul] at hx''\n  obtain ⟨a, ha₂⟩ := (is_localization.eq_iff_exists M S').mp hx''\n  use a * y ^ n\n  convert A.mul_mem hx' (hA₂ a.prop)\n  rw [Submonoid.smul_def, smul_eq_mul, Submonoid.coe_mul, [anonymous], mul_assoc, ← ha₂, mul_comm]\n#align is_localization.exists_smul_mem_of_mem_adjoin is_localization.exists_smul_mem_of_mem_adjoin\n\n",
 "eq_zero_of_localization":
 "theorem eq_zero_of_localization (r : R)\n    (h : ∀ (J : Ideal R) (hJ : J.is_maximal), algebraMap R (localization.at_prime J) r = 0) : r = 0 :=\n  by\n  rw [← Ideal.span_singleton_eq_bot]\n  apply ideal_eq_bot_of_localization\n  intro J hJ\n  delta IsLocalization.coeSubmodule\n  erw [Submodule.map_span, Submodule.span_eq_bot]\n  rintro _ ⟨_, h', rfl⟩\n  cases set.mem_singleton_iff.mpr h'\n  exact h J hJ\n#align eq_zero_of_localization eq_zero_of_localization\n\n",
 "eq_of_localization_maximal":
 "/-- Let `I J : ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\nthe localization of `J` at `P`, then `I = J`. -/\ntheorem ideal.eq_of_localization_maximal {I J : Ideal R}\n    (h :\n      ∀ (P : Ideal R) (hP : P.is_maximal),\n        Ideal.map (algebraMap R (localization.at_prime P)) I = Ideal.map (algebraMap R (localization.at_prime P)) J) :\n    I = J :=\n  le_antisymm (ideal.le_of_localization_maximal fun P hP => (h P hP).le)\n    (ideal.le_of_localization_maximal fun P hP => (h P hP).ge)\n#align ideal.eq_of_localization_maximal ideal.eq_of_localization_maximal\n\n",
 "away":
 "-- Almost all arguments are implicit since this is not intended to use mid-proof.\ntheorem ring_hom.localization_preserves.away (H : ring_hom.localization_preserves @P) (r : R)\n    [is_localization.away r R'] [is_localization.away (f r) S'] (hf : P f) : P (is_localization.away.map R' S' f r) :=\n  by\n  skip\n  have : IsLocalization ((Submonoid.powers r).map f) S' :=\n    by\n    rw [Submonoid.map_powers]\n    assumption\n  exact H f (Submonoid.powers r) R' S' hf\n#align ring_hom.localization_preserves.away ring_hom.localization_preserves.away\n\n"}