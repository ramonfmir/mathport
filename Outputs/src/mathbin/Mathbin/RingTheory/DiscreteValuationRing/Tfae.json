{"tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (I «expr ≠ » «expr⊥»()) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem discrete_valuation_ring.tfae [IsNoetherianRing R] [local_ring R] [IsDomain R] (h : ¬IsField R) :\n    TFAE\n      [discrete_valuation_ring R, valuation_ring R, is_dedekind_domain R,\n        is_integrally_closed R ∧ ∃! P : Ideal R, P ≠ «expr⊥» ∧ P.is_prime, (maximal_ideal R).is_principal,\n        FiniteDimensional.finrank (residue_field R) (cotangent_space R) = 1,\n        ∀ (I) (_ : I ≠ «expr⊥»), ∃ n : ℕ, I = maximal_ideal R ^ n] :=\n  by\n  have ne_bot := Ring.ne_bot_of_isMaximal_of_not_isField (maximal_ideal.is_maximal R) h\n  classical\n    rw [finrank_eq_one_iff']\n    tfae_have 1 → 2\n    · intro\n      infer_instance\n    tfae_have 2 → 1\n    · intro\n      haveI := is_bezout.to_gcd_domain R\n      haveI : UniqueFactorizationMonoid R := ufm_of_gcd_of_wfDvdMonoid\n      apply discrete_valuation_ring.of_ufd_of_unique_irreducible\n      · obtain ⟨x, hx₁, hx₂⟩ := Ring.exists_not_isUnit_of_not_isField h\n        obtain ⟨p, hp₁, hp₂⟩ := WfDvdMonoid.exists_irreducible_factor hx₂ hx₁\n        exact ⟨p, hp₁⟩\n      · exact valuation_ring.unique_irreducible\n    tfae_have 1 → 4\n    · intro H\n      exact ⟨inferInstance, ((discrete_valuation_ring.iff_pid_with_one_nonzero_prime R).mp H).2⟩\n    tfae_have 4 → 3\n    · rintro ⟨h₁, h₂⟩\n      exact\n        ⟨inferInstance, fun I hI hI' =>\n          ExistsUnique.unique h₂ ⟨ne_bot, inferInstance⟩ ⟨hI, hI'⟩ ▸ maximal_ideal.is_maximal R, h₁⟩\n    tfae_have 3 → 5\n    · intro h\n      exact maximal_ideal_is_principal_of_is_dedekind_domain R\n    tfae_have 5 → 6\n    · rintro ⟨x, hx⟩\n      have : x ∈ maximal_ideal R := by\n        rw [hx]\n        exact Submodule.subset_span (Set.mem_singleton x)\n      let x' : maximal_ideal R := ⟨x, this⟩\n      use Submodule.Quotient.mk x'\n      constructor\n      · intro e\n        rw [Submodule.Quotient.mk_eq_zero] at e\n        apply Ring.ne_bot_of_isMaximal_of_not_isField (maximal_ideal.is_maximal R) h\n        apply submodule.eq_bot_of_le_smul_of_le_jacobson_bot (maximal_ideal R)\n        · exact ⟨{x}, (Finset.coe_singleton x).symm ▸ hx.symm⟩\n        · conv_lhs => rw [hx]\n          rw [Submodule.mem_smul_top_iff] at e\n          rwa [Submodule.span_le, Set.singleton_subset_iff]\n        · rw [local_ring.jacobson_eq_maximal_ideal («expr⊥» : Ideal R) bot_ne_top]\n          exact le_refl _\n      · refine' fun w => Quotient.inductionOn' w fun y => _\n        obtain ⟨y, hy⟩ := y\n        rw [hx, Submodule.mem_span_singleton] at hy\n        obtain ⟨a, rfl⟩ := hy\n        exact ⟨Ideal.Quotient.mk _ a, rfl⟩\n    tfae_have 6 → 5\n    · rintro ⟨x, hx, hx'⟩\n      induction x using Quotient.inductionOn'\n      use x\n      apply le_antisymm\n      swap\n      · rw [Submodule.span_le, Set.singleton_subset_iff]\n        exact x.prop\n      have h₁ :\n        «expr ⊔ » (Ideal.span {x} : Ideal R) (maximal_ideal R) ≤\n          «expr ⊔ » (Ideal.span {x}) («expr • » (maximal_ideal R) (maximal_ideal R)) :=\n        by\n        refine' sup_le le_sup_left _\n        rintro m hm\n        obtain ⟨c, hc⟩ := hx' (Submodule.Quotient.mk ⟨m, hm⟩)\n        induction c using Quotient.inductionOn'\n        rw [← sub_sub_cancel (c * x) m]\n        apply sub_mem _ _\n        · infer_instance\n        · refine' Ideal.mem_sup_left (ideal.mem_span_singleton'.mpr ⟨c, rfl⟩)\n        · have := (Submodule.Quotient.eq _).mp hc\n          rw [Submodule.mem_smul_top_iff] at this\n          exact Ideal.mem_sup_right this\n      have h₂ : maximal_ideal R ≤ («expr⊥» : Ideal R).jacobson :=\n        by\n        rw [local_ring.jacobson_eq_maximal_ideal]\n        exacts[le_refl _, bot_ne_top]\n      have := submodule.smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson (is_noetherian.noetherian _) h₂ h₁\n      rw [Submodule.bot_smul, sup_bot_eq] at this\n      rw [← sup_eq_left, eq_comm]\n      exact le_sup_left.antisymm (h₁.trans <| le_of_eq this)\n    tfae_have 5 → 7\n    · exact exists_maximal_ideal_pow_eq_of_principal R h\n    tfae_have 7 → 2\n    · rw [valuation_ring.iff_ideal_total]\n      intro H\n      constructor\n      intro I J\n      by_cases hI : I = «expr⊥»\n      · subst hI\n        left\n        exact bot_le\n      by_cases hJ : J = «expr⊥»\n      · subst hJ\n        right\n        exact bot_le\n      obtain ⟨n, rfl⟩ := H I hI\n      obtain ⟨m, rfl⟩ := H J hJ\n      cases' le_total m n with h' h'\n      · left\n        exact Ideal.pow_le_pow h'\n      · right\n        exact Ideal.pow_le_pow h'\n    tfae_finish\n#align discrete_valuation_ring.tfae discrete_valuation_ring.tfae\n\n",
 "maximal_ideal_is_principal_of_is_dedekind_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem maximal_ideal_is_principal_of_is_dedekind_domain [local_ring R] [IsDomain R] [is_dedekind_domain R] :\n    (maximal_ideal R).is_principal := by\n  classical\n    by_cases ne_bot : maximal_ideal R = «expr⊥»\n    · rw [ne_bot]\n      infer_instance\n    obtain ⟨a, ha₁, ha₂⟩ : ∃ a ∈ maximal_ideal R, a ≠ (0 : R) :=\n      by\n      by_contra h'\n      push_neg  at h'\n      apply ne_bot\n      rwa [eq_bot_iff]\n    have hle : Ideal.span {a} ≤ maximal_ideal R := by rwa [Ideal.span_le, Set.singleton_subset_iff]\n    have : (Ideal.span {a}).radical = maximal_ideal R :=\n      by\n      rw [Ideal.radical_eq_infₛ]\n      apply le_antisymm\n      · exact infₛ_le ⟨hle, inferInstance⟩\n      · refine' le_infₛ fun I hI => (eq_maximal_ideal <| is_dedekind_domain.dimension_le_one _ (fun e => ha₂ _) hI.2).ge\n        rw [← Ideal.span_singleton_eq_bot, eq_bot_iff, ← e]\n        exact hI.1\n    have : ∃ n, maximal_ideal R ^ n ≤ Ideal.span {a} := by\n      rw [← this]\n      apply Ideal.exists_radical_pow_le_of_fg\n      exact is_noetherian.noetherian _\n    cases hn : nat.find this\n    · have := nat.find_spec this\n      rw [hn, pow_zero, Ideal.one_eq_top] at this\n      exact (Ideal.IsMaximal.ne_top inferInstance (eq_top_iff.mpr <| this.trans hle)).elim\n    obtain ⟨b, hb₁, hb₂⟩ : ∃ b ∈ maximal_ideal R ^ n, ¬b ∈ Ideal.span {a} :=\n      by\n      by_contra h'\n      push_neg  at h'\n      rw [Nat.find_eq_iff] at hn\n      exact hn.2 n n.lt_succ_self fun x hx => not_not.mp (h' x hx)\n    have hb₃ : ∀ m ∈ maximal_ideal R, ∃ k : R, k * a = b * m :=\n      by\n      intro m hm\n      rw [← Ideal.mem_span_singleton']\n      apply nat.find_spec this\n      rw [hn, pow_succ']\n      exact Ideal.mul_mem_mul hb₁ hm\n    have hb₄ : b ≠ 0 := by\n      rintro rfl\n      apply hb₂\n      exact zero_mem _\n    let K := FractionRing R\n    let x : K := algebraMap R K b / algebraMap R K a\n    let M := Submodule.map (Algebra.ofId R K).to_linear_map (maximal_ideal R)\n    have ha₃ : algebraMap R K a ≠ 0 := is_fraction_ring.to_map_eq_zero_iff.not.mpr ha₂\n    by_cases hx : ∀ y ∈ M, x * y ∈ M\n    · have := is_integral_of_smul_mem_submodule M _ _ x hx\n      · obtain ⟨y, e⟩ := is_integrally_closed.algebra_map_eq_of_integral this\n        refine' (hb₂ (ideal.mem_span_singleton'.mpr ⟨y, _⟩)).elim\n        apply IsFractionRing.injective R K\n        rw [map_mul, e, div_mul_cancel _ ha₃]\n      · rw [Submodule.ne_bot_iff]\n        refine' ⟨_, ⟨a, ha₁, rfl⟩, _⟩\n        exact is_fraction_ring.to_map_eq_zero_iff.not.mpr ha₂\n      · apply Submodule.Fg.map\n        exact is_noetherian.noetherian _\n    · have : (M.map (DistribMulAction.toLinearMap R K x)).comap (Algebra.ofId R K).to_linear_map = «expr⊤» :=\n        by\n        by_contra h\n        apply hx\n        rintro m' ⟨m, hm, rfl : algebraMap R K m = m'⟩\n        obtain ⟨k, hk⟩ := hb₃ m hm\n        have hk' : x * algebraMap R K m = algebraMap R K k := by\n          rw [← mul_div_right_comm, ← map_mul, ← hk, map_mul, mul_div_cancel _ ha₃]\n        exact ⟨k, le_maximal_ideal h ⟨_, ⟨_, hm, rfl⟩, hk'⟩, hk'.symm⟩\n      obtain ⟨y, hy₁, hy₂⟩ : ∃ y ∈ maximal_ideal R, b * y = a :=\n        by\n        rw [Ideal.eq_top_iff_one, Submodule.mem_comap] at this\n        obtain ⟨_, ⟨y, hy, rfl⟩, hy' : x * algebraMap R K y = algebraMap R K 1⟩ := this\n        rw [map_one, ← mul_div_right_comm, div_eq_one_iff_eq ha₃, ← map_mul] at hy'\n        exact ⟨y, hy, IsFractionRing.injective R K hy'⟩\n      refine' ⟨⟨y, _⟩⟩\n      apply le_antisymm\n      · intro m hm\n        obtain ⟨k, hk⟩ := hb₃ m hm\n        rw [← hy₂, mul_comm, mul_assoc] at hk\n        rw [← mul_left_cancel₀ hb₄ hk, mul_comm]\n        exact ideal.mem_span_singleton'.mpr ⟨_, rfl⟩\n      · rwa [Submodule.span_le, Set.singleton_subset_iff]\n#align maximal_ideal_is_principal_of_is_dedekind_domain maximal_ideal_is_principal_of_is_dedekind_domain\n\n",
 "exists_maximal_ideal_pow_eq_of_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem exists_maximal_ideal_pow_eq_of_principal [IsNoetherianRing R] [local_ring R] [IsDomain R] (h : ¬IsField R)\n    (h' : (maximal_ideal R).is_principal) (I : Ideal R) (hI : I ≠ «expr⊥») : ∃ n : ℕ, I = maximal_ideal R ^ n := by\n  classical\n    obtain ⟨x, hx : _ = Ideal.span _⟩ := h'\n    by_cases hI' : I = «expr⊤»\n    · use 0\n      rw [pow_zero, hI', Ideal.one_eq_top]\n    have H : ∀ r : R, ¬IsUnit r ↔ x ∣ r := fun r => (set_like.ext_iff.mp hx r).trans Ideal.mem_span_singleton\n    have : x ≠ 0 := by\n      rintro rfl\n      apply Ring.ne_bot_of_isMaximal_of_not_isField (maximal_ideal.is_maximal R) h\n      simp [hx]\n    have hx' := discrete_valuation_ring.irreducible_of_span_eq_maximal_ideal x this hx\n    have H' : ∀ r : R, r ≠ 0 → r ∈ nonunits R → ∃ n : ℕ, Associated (x ^ n) r :=\n      by\n      intro r hr₁ hr₂\n      obtain ⟨f, hf₁, rfl, hf₂⟩ := (WfDvdMonoid.not_unit_iff_exists_factors_eq r hr₁).mp hr₂\n      have : ∀ b ∈ f, Associated x b := by\n        intro b hb\n        exact Irreducible.associated_of_dvd hx' (hf₁ b hb) ((H b).mp (hf₁ b hb).1)\n      clear hr₁ hr₂ hf₁\n      induction' f using Multiset.induction with fa fs fh\n      · exact (hf₂ rfl).elim\n      rcases eq_or_ne fs ∅ with (rfl | hf')\n      · use 1\n        rw [pow_one, Multiset.prod_cons, Multiset.empty_eq_zero, Multiset.prod_zero, mul_one]\n        exact this _ (Multiset.mem_cons_self _ _)\n      · obtain ⟨n, hn⟩ := fh hf' fun b hb => this _ (Multiset.mem_cons_of_mem hb)\n        use n + 1\n        rw [pow_add, Multiset.prod_cons, mul_comm, pow_one]\n        exact Associated.mul_mul (this _ (Multiset.mem_cons_self _ _)) hn\n    have : ∃ n : ℕ, x ^ n ∈ I :=\n      by\n      obtain ⟨r, hr₁, hr₂⟩ : ∃ r : R, r ∈ I ∧ r ≠ 0 := by\n        by_contra h\n        push_neg  at h\n        apply hI\n        rw [eq_bot_iff]\n        exact h\n      obtain ⟨n, u, rfl⟩ := H' r hr₂ (le_maximal_ideal hI' hr₁)\n      use n\n      rwa [← I.unit_mul_mem_iff_mem u.is_unit, mul_comm]\n    use nat.find this\n    apply le_antisymm\n    · change ∀ s ∈ I, s ∈ _\n      by_contra hI''\n      push_neg  at hI''\n      obtain ⟨s, hs₁, hs₂⟩ := hI''\n      apply hs₂\n      by_cases hs₃ : s = 0\n      · rw [hs₃]\n        exact zero_mem _\n      obtain ⟨n, u, rfl⟩ := H' s hs₃ (le_maximal_ideal hI' hs₁)\n      rw [mul_comm, Ideal.unit_mul_mem_iff_mem _ u.is_unit] at hs₁⊢\n      apply Ideal.pow_le_pow (nat.find_min' this hs₁)\n      apply Ideal.pow_mem_pow\n      exact (H _).mpr (dvd_refl _)\n    · rw [hx, Ideal.span_singleton_pow, Ideal.span_le, Set.singleton_subset_iff]\n      exact nat.find_spec this\n#align exists_maximal_ideal_pow_eq_of_principal exists_maximal_ideal_pow_eq_of_principal\n\n"}