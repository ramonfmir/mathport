{"zero_coeff":
 "@[simp]\ntheorem zero_coeff {a : Γ} : (0 : hahn_series Γ R).coeff a = 0 :=\n  rfl\n#align zero_coeff zero_coeff\n\n",
 "zero_apply":
 "theorem zero_apply {a : α} : (0 : summable_family Γ R α) a = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "unit_aux":
 "theorem unit_aux (x : hahn_series Γ R) {r : R} (hr : r * x.coeff x.order = 1) :\n    0 < add_val Γ R (1 - C r * single (-x.order) 1 * x) :=\n  by\n  have h10 : (1 : R) ≠ 0 := one_ne_zero\n  have x0 : x ≠ 0 := ne_zero_of_coeff_ne_zero (right_ne_zero_of_mul_eq_one hr)\n  refine' lt_of_le_of_ne ((add_val Γ R).map_le_sub (ge_of_eq (add_val Γ R).map_one) _) _\n  · simp only [AddValuation.map_mul]\n    rw [add_val_apply_of_ne x0, add_val_apply_of_ne (single_ne_zero h10), add_val_apply_of_ne _, order_C,\n      order_single h10, WithTop.coe_zero, zero_add, ← WithTop.coe_add, neg_add_self, WithTop.coe_zero]\n    · exact le_refl 0\n    · exact C_ne_zero (left_ne_zero_of_mul_eq_one hr)\n  · rw [add_val_apply, ← WithTop.coe_zero]\n    split_ifs\n    · apply WithTop.coe_ne_top\n    rw [ne.def, WithTop.coe_eq_coe]\n    intro con\n    apply coeff_order_ne_zero h\n    rw [← Con, mul_assoc, sub_coeff, one_coeff, if_pos rfl, C_mul_eq_smul, smul_coeff, smul_eq_mul, ←\n      add_neg_self x.order, single_mul_coeff_add, one_mul, hr, sub_self]\n#align unit_aux unit_aux\n\n",
 "support_zero":
 "@[simp]\ntheorem support_zero : support (0 : hahn_series Γ R) = ∅ :=\n  Function.support_zero\n#align support_zero support_zero\n\n",
 "support_single_subset":
 "theorem support_single_subset : support (single a r) ⊆ {a} :=\n  Pi.support_single_subset\n#align support_single_subset support_single_subset\n\n",
 "support_single_of_ne":
 "@[simp]\ntheorem support_single_of_ne (h : r ≠ 0) : support (single a r) = {a} :=\n  Pi.support_single_of_ne h\n#align support_single_of_ne support_single_of_ne\n\n",
 "support_one":
 "@[simp]\ntheorem support_one [MulZeroOneClass R] [Nontrivial R] : support (1 : hahn_series Γ R) = {0} :=\n  support_single_of_ne one_ne_zero\n#align support_one support_one\n\n",
 "support_nonempty_iff":
 "@[simp]\ntheorem support_nonempty_iff {x : hahn_series Γ R} : x.support.nonempty ↔ x ≠ 0 := by\n  rw [support, support_nonempty_iff, ne.def, coeff_fun_eq_zero_iff]\n#align support_nonempty_iff support_nonempty_iff\n\n",
 "support_neg":
 "@[simp]\ntheorem support_neg {x : hahn_series Γ R} : (-x).support = x.support :=\n  by\n  ext\n  simp\n#align support_neg support_neg\n\n",
 "support_mul_subset_add_support":
 "theorem support_mul_subset_add_support [NonUnitalNonAssocSemiring R] {x y : hahn_series Γ R} :\n    support (x * y) ⊆ support x + support y :=\n  by\n  apply Set.Subset.trans (fun x hx => _) support_add_antidiagonal_subset_add\n  · exact x.is_pwo_support\n  · exact y.is_pwo_support\n  contrapose! hx\n  simp only [not_nonempty_iff_eq_empty, ne.def, Set.mem_setOf_eq] at hx\n  simp [hx]\n#align support_mul_subset_add_support support_mul_subset_add_support\n\n",
 "support_hsum_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem support_hsum_subset {s : summable_family Γ R α} :\n    s.hsum.support ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s a).support :=\n  fun g hg => by\n  rw [mem_support, hsum_coeff, finsum_eq_sum _ (s.finite_co_support _)] at hg\n  obtain ⟨a, h1, h2⟩ := exists_ne_zero_of_sum_ne_zero hg\n  rw [Set.mem_unionᵢ]\n  exact ⟨a, h2⟩\n#align support_hsum_subset support_hsum_subset\n\n",
 "support_eq_empty_iff":
 "@[simp]\ntheorem support_eq_empty_iff {x : hahn_series Γ R} : x.support = ∅ ↔ x = 0 :=\n  support_eq_empty_iff.trans coeff_fun_eq_zero_iff\n#align support_eq_empty_iff support_eq_empty_iff\n\n",
 "support_emb_domain_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem support_emb_domain_subset {f : «expr ↪o » Γ Γ'} {x : hahn_series Γ R} :\n    support (emb_domain f x) ⊆ «expr '' » f x.support :=\n  by\n  intro g hg\n  contrapose! hg\n  rw [mem_support, emb_domain_notin_image_support hg, Classical.not_not]\n#align support_emb_domain_subset support_emb_domain_subset\n\n",
 "support_add_subset":
 "theorem support_add_subset {x y : hahn_series Γ R} : support (x + y) ⊆ support x ∪ support y := fun a ha =>\n  by\n  rw [mem_support, add_coeff] at ha\n  rw [Set.mem_union, mem_support, mem_support]\n  contrapose! ha\n  rw [ha.1, ha.2, add_zero]\n#align support_add_subset support_add_subset\n\n",
 "sub_coeff'":
 "@[simp]\ntheorem sub_coeff' {x y : hahn_series Γ R} : (x - y).coeff = x.coeff - y.coeff :=\n  by\n  ext\n  simp [sub_eq_add_neg]\n#align sub_coeff' sub_coeff'\n\n",
 "sub_coeff":
 "theorem sub_coeff {x y : hahn_series Γ R} {a : Γ} : (x - y).coeff a = x.coeff a - y.coeff a := by simp\n#align sub_coeff sub_coeff\n\n",
 "sub_apply":
 "theorem sub_apply : (s - t) a = s a - t a :=\n  rfl\n#align sub_apply sub_apply\n\n",
 "smul_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_coeff {r : R} {x : hahn_series Γ V} {a : Γ} : («expr • » r x).coeff a = «expr • » r (x.coeff a) :=\n  rfl\n#align smul_coeff smul_coeff\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_apply {x : hahn_series Γ R} {s : summable_family Γ R α} {a : α} : («expr • » x s) a = x * s a :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "single_zero_one":
 "@[simp]\ntheorem single_zero_one [Zero R] [One R] : single 0 (1 : R) = 1 :=\n  rfl\n#align single_zero_one single_zero_one\n\n",
 "single_zero_mul_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem single_zero_mul_eq_smul [Semiring R] {r : R} {x : hahn_series Γ R} : single 0 r * x = «expr • » r x :=\n  by\n  ext\n  exact single_zero_mul_coeff\n#align single_zero_mul_eq_smul single_zero_mul_eq_smul\n\n",
 "single_zero_mul_coeff":
 "theorem single_zero_mul_coeff [NonUnitalNonAssocSemiring R] {r : R} {x : hahn_series Γ R} {a : Γ} :\n    (single 0 r * x).coeff a = r * x.coeff a := by rw [← add_zero a, single_mul_coeff_add, add_zero]\n#align single_zero_mul_coeff single_zero_mul_coeff\n\n",
 "single_ne_zero":
 "theorem single_ne_zero (h : r ≠ 0) : single a r ≠ 0 := fun con => h (single_injective a (Con.trans single_eq_zero.symm))\n#align single_ne_zero single_ne_zero\n\n",
 "single_mul_single":
 "@[simp]\ntheorem single_mul_single {a b : Γ} {r s : R} : single a r * single b s = single (a + b) (r * s) :=\n  by\n  ext x\n  by_cases h : x = a + b\n  · rw [h, mul_single_coeff_add]\n    simp\n  · rw [single_coeff_of_ne h, mul_coeff, sum_eq_zero]\n    simp_rw [mem_add_antidiagonal]\n    rintro ⟨y, z⟩ ⟨hy, hz, rfl⟩\n    rw [eq_of_mem_support_single hy, eq_of_mem_support_single hz] at h\n    exact (h rfl).elim\n#align single_mul_single single_mul_single\n\n",
 "single_mul_coeff_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem single_mul_coeff_add [NonUnitalNonAssocSemiring R] {r : R} {x : hahn_series Γ R} {a : Γ} {b : Γ} :\n    (single b r * x).coeff (a + b) = r * x.coeff a :=\n  by\n  by_cases hr : r = 0\n  · simp [hr]\n  simp only [hr, smul_coeff, mul_coeff, support_single_of_ne, ne.def, not_false_iff, smul_eq_mul]\n  by_cases hx : x.coeff a = 0\n  · simp only [hx, MulZeroClass.mul_zero]\n    rw [sum_congr _ fun _ _ => rfl, sum_empty]\n    ext ⟨a1, a2⟩\n    simp only [not_mem_empty, not_and, Set.mem_singleton_iff, Classical.not_not, mem_add_antidiagonal, Set.mem_setOf_eq,\n      iff_false_iff]\n    rintro rfl h2 h1\n    rw [add_comm] at h1\n    rw [← add_right_cancel h1] at hx\n    exact h2 hx\n  trans\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" {(b, a)}\n      ((single b r).coeff ij.fst * x.coeff ij.snd)\n  · apply sum_congr _ fun _ _ => rfl\n    ext ⟨a1, a2⟩\n    simp only [Set.mem_singleton_iff, Prod.mk.inj_iff, mem_add_antidiagonal, mem_singleton, Set.mem_setOf_eq]\n    constructor\n    · rintro ⟨rfl, h2, h1⟩\n      rw [add_comm] at h1\n      refine' ⟨rfl, add_right_cancel h1⟩\n    · rintro ⟨rfl, rfl⟩\n      exact ⟨rfl, by simp [hx], add_comm _ _⟩\n  · simp\n#align single_mul_coeff_add single_mul_coeff_add\n\n",
 "single_injective":
 "theorem single_injective (a : Γ) : function.injective (single a : R → hahn_series Γ R) := fun r s rs => by\n  rw [← single_coeff_same a r, ← single_coeff_same a s, rs]\n#align single_injective single_injective\n\n",
 "single_eq_zero_iff":
 "@[simp]\ntheorem single_eq_zero_iff {a : Γ} {r : R} : single a r = 0 ↔ r = 0 :=\n  by\n  constructor\n  · contrapose!\n    exact single_ne_zero\n  · simp (config := { contextual := true })\n#align single_eq_zero_iff single_eq_zero_iff\n\n",
 "single_eq_zero":
 "@[simp]\ntheorem single_eq_zero : single a (0 : R) = 0 :=\n  (single a).map_zero\n#align single_eq_zero single_eq_zero\n\n",
 "single_coeff_same":
 "@[simp]\ntheorem single_coeff_same (a : Γ) (r : R) : (single a r).coeff a = r :=\n  Pi.single_eq_same a r\n#align single_coeff_same single_coeff_same\n\n",
 "single_coeff_of_ne":
 "@[simp]\ntheorem single_coeff_of_ne (h : b ≠ a) : (single a r).coeff b = 0 :=\n  Pi.single_eq_of_ne h r\n#align single_coeff_of_ne single_coeff_of_ne\n\n",
 "single_coeff":
 "theorem single_coeff : (single a r).coeff b = if b = a then r else 0 := by split_ifs with h <;> simp [h]\n#align single_coeff single_coeff\n\n",
 "order_zero":
 "@[simp]\ntheorem order_zero : order (0 : hahn_series Γ R) = 0 :=\n  dif_pos rfl\n#align order_zero order_zero\n\n",
 "order_single":
 "@[simp]\ntheorem order_single (h : r ≠ 0) : (single a r).order = a :=\n  (order_of_ne (single_ne_zero h)).trans\n    (support_single_subset ((single a r).is_wf_support.min_mem (support_nonempty_iff.2 (single_ne_zero h))))\n#align order_single order_single\n\n",
 "order_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem order_pow {Γ} [LinearOrderedCancelAddCommMonoid Γ] [Semiring R] [NoZeroDivisors R] (x : hahn_series Γ R)\n    (n : ℕ) : (x ^ n).order = «expr • » n x.order :=\n  by\n  induction' n with h IH\n  · simp\n  rcases eq_or_ne x 0 with (rfl | hx)\n  · simp\n  rw [pow_succ', order_mul (pow_ne_zero _ hx) hx, succ_nsmul', IH]\n#align order_pow order_pow\n\n",
 "order_one":
 "@[simp]\ntheorem order_one [MulZeroOneClass R] : order (1 : hahn_series Γ R) = 0 :=\n  by\n  cases' subsingleton_or_nontrivial R with h h <;> haveI := h\n  · rw [subsingleton.elim (1 : hahn_series Γ R) 0, order_zero]\n  · exact order_single one_ne_zero\n#align order_one order_one\n\n",
 "order_of_ne":
 "theorem order_of_ne {x : hahn_series Γ R} (hx : x ≠ 0) : order x = x.is_wf_support.min (support_nonempty_iff.2 hx) :=\n  dif_neg hx\n#align order_of_ne order_of_ne\n\n",
 "order_neg":
 "@[simp]\ntheorem order_neg [Zero Γ] {f : hahn_series Γ R} : (-f).order = f.order :=\n  by\n  by_cases hf : f = 0\n  · simp only [hf, neg_zero]\n  simp only [order, support_neg, neg_eq_zero]\n#align order_neg order_neg\n\n",
 "order_mul":
 "@[simp]\ntheorem order_mul {Γ} [LinearOrderedCancelAddCommMonoid Γ] [NonUnitalNonAssocSemiring R] [NoZeroDivisors R]\n    {x y : hahn_series Γ R} (hx : x ≠ 0) (hy : y ≠ 0) : (x * y).order = x.order + y.order :=\n  by\n  apply le_antisymm\n  · apply order_le_of_coeff_ne_zero\n    rw [mul_coeff_order_add_order x y]\n    exact mul_ne_zero (coeff_order_ne_zero hx) (coeff_order_ne_zero hy)\n  · rw [order_of_ne hx, order_of_ne hy, order_of_ne (mul_ne_zero hx hy), ← Set.IsWf.min_add]\n    exact Set.IsWf.min_le_min_of_subset support_mul_subset_add_support\n#align order_mul order_mul\n\n",
 "order_le_of_coeff_ne_zero":
 "theorem order_le_of_coeff_ne_zero {Γ} [LinearOrderedCancelAddCommMonoid Γ] {x : hahn_series Γ R} {g : Γ}\n    (h : x.coeff g ≠ 0) : x.order ≤ g :=\n  le_trans (le_of_eq (order_of_ne (ne_zero_of_coeff_ne_zero h))) (Set.IsWf.min_le _ _ ((mem_support _ _).2 h))\n#align order_le_of_coeff_ne_zero order_le_of_coeff_ne_zero\n\n",
 "order_C":
 "theorem order_C {r : R} : order (C r : hahn_series Γ R) = 0 :=\n  by\n  by_cases h : r = 0\n  · rw [h, C_zero, order_zero]\n  · exact order_single h\n#align order_C order_C\n\n",
 "one_sub_self_mul_hsum_powers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem one_sub_self_mul_hsum_powers : (1 - x) * (powers x hx).hsum = 1 :=\n  by\n  rw [← hsum_smul, sub_smul, one_smul, hsum_sub, ←\n    hsum_emb_domain («expr • » x (powers x hx)) ⟨nat.succ, Nat.succ_injective⟩, emb_domain_succ_smul_powers]\n  simp\n#align one_sub_self_mul_hsum_powers one_sub_self_mul_hsum_powers\n\n",
 "one_coeff":
 "@[simp]\ntheorem one_coeff [Zero R] [One R] {a : Γ} : (1 : hahn_series Γ R).coeff a = if a = 0 then 1 else 0 :=\n  single_coeff\n#align one_coeff one_coeff\n\n",
 "of_power_series_injective":
 "theorem of_power_series_injective : function.injective (of_power_series Γ R) :=\n  emb_domain_injective.comp to_power_series.symm.injective\n#align of_power_series_injective of_power_series_injective\n\n",
 "of_power_series_apply_coeff":
 "theorem of_power_series_apply_coeff (x : power_series R) (n : ℕ) :\n    (of_power_series Γ R x).coeff n = power_series.coeff R n x := by simp\n#align of_power_series_apply_coeff of_power_series_apply_coeff\n\n",
 "of_power_series_apply":
 "@[simp]\ntheorem of_power_series_apply (x : power_series R) :\n    of_power_series Γ R x =\n      hahn_series.emb_domain\n        ⟨⟨(coe : ℕ → Γ), Nat.strictMono_cast.injective⟩, fun a b =>\n          by\n          simp only [Function.Embedding.coeFn_mk]\n          exact Nat.cast_le⟩\n        (to_power_series.symm x) :=\n  rfl\n#align of_power_series_apply of_power_series_apply\n\n",
 "of_power_series_X_pow":
 "@[simp]\ntheorem of_power_series_X_pow {R} [CommSemiring R] (n : ℕ) :\n    of_power_series Γ R (power_series.X ^ n) = single (n : Γ) 1 :=\n  by\n  rw [RingHom.map_pow]\n  induction' n with n ih\n  · simp\n    rfl\n  rw [pow_succ, ih, of_power_series_X, mul_comm, single_mul_single, one_mul, Nat.cast_succ]\n#align of_power_series_X_pow of_power_series_X_pow\n\n",
 "of_power_series_X":
 "@[simp]\ntheorem of_power_series_X : of_power_series Γ R power_series.X = single 1 1 :=\n  by\n  ext n\n  simp only [single_coeff, of_power_series_apply, RingHom.coe_mk]\n  split_ifs with hn hn\n  · rw [hn]\n    convert@emb_domain_coeff _ _ _ _ _ _ _ _ 1 <;> simp\n  · rw [emb_domain_notin_image_support]\n    simp only [not_exists, Set.mem_image, to_power_series_symm_apply_coeff, mem_support, power_series.coeff_X]\n    intro\n    simp (config := { contextual := true }) [ne.symm hn]\n#align of_power_series_X of_power_series_X\n\n",
 "of_power_series_C":
 "@[simp]\ntheorem of_power_series_C (r : R) : of_power_series Γ R (power_series.C R r) = hahn_series.C r :=\n  by\n  ext n\n  simp only [C, single_coeff, of_power_series_apply, RingHom.coe_mk]\n  split_ifs with hn hn\n  · subst hn\n    convert@emb_domain_coeff _ _ _ _ _ _ _ _ 0 <;> simp\n  · rw [emb_domain_notin_image_support]\n    simp only [not_exists, Set.mem_image, to_power_series_symm_apply_coeff, mem_support, power_series.coeff_C]\n    intro\n    simp (config := { contextual := true }) [ne.symm hn]\n#align of_power_series_C of_power_series_C\n\n",
 "neg_coeff'":
 "@[simp]\ntheorem neg_coeff' {x : hahn_series Γ R} : (-x).coeff = -x.coeff :=\n  rfl\n#align neg_coeff' neg_coeff'\n\n",
 "neg_coeff":
 "theorem neg_coeff {x : hahn_series Γ R} {a : Γ} : (-x).coeff a = -x.coeff a :=\n  rfl\n#align neg_coeff neg_coeff\n\n",
 "neg_apply":
 "theorem neg_apply : (-s) a = -s a :=\n  rfl\n#align neg_apply neg_apply\n\n",
 "ne_zero_of_coeff_ne_zero":
 "theorem ne_zero_of_coeff_ne_zero {x : hahn_series Γ R} {g : Γ} (h : x.coeff g ≠ 0) : x ≠ 0 :=\n  mt (fun x0 => (x0.symm ▸ zero_coeff : x.coeff g = 0)) h\n#align ne_zero_of_coeff_ne_zero ne_zero_of_coeff_ne_zero\n\n",
 "mul_single_zero_coeff":
 "@[simp]\ntheorem mul_single_zero_coeff [NonUnitalNonAssocSemiring R] {r : R} {x : hahn_series Γ R} {a : Γ} :\n    (x * single 0 r).coeff a = x.coeff a * r := by rw [← add_zero a, mul_single_coeff_add, add_zero]\n#align mul_single_zero_coeff mul_single_zero_coeff\n\n",
 "mul_single_coeff_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mul_single_coeff_add [NonUnitalNonAssocSemiring R] {r : R} {x : hahn_series Γ R} {a : Γ} {b : Γ} :\n    (x * single b r).coeff (a + b) = x.coeff a * r :=\n  by\n  by_cases hr : r = 0\n  · simp [hr]\n  simp only [hr, smul_coeff, mul_coeff, support_single_of_ne, ne.def, not_false_iff, smul_eq_mul]\n  by_cases hx : x.coeff a = 0\n  · simp only [hx, MulZeroClass.zero_mul]\n    rw [sum_congr _ fun _ _ => rfl, sum_empty]\n    ext ⟨a1, a2⟩\n    simp only [not_mem_empty, not_and, Set.mem_singleton_iff, Classical.not_not, mem_add_antidiagonal, Set.mem_setOf_eq,\n      iff_false_iff]\n    rintro h2 rfl h1\n    rw [← add_right_cancel h1] at hx\n    exact h2 hx\n  trans\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" {(a, b)}\n      (x.coeff ij.fst * (single b r).coeff ij.snd)\n  · apply sum_congr _ fun _ _ => rfl\n    ext ⟨a1, a2⟩\n    simp only [Set.mem_singleton_iff, Prod.mk.inj_iff, mem_add_antidiagonal, mem_singleton, Set.mem_setOf_eq]\n    constructor\n    · rintro ⟨h2, rfl, h1⟩\n      refine' ⟨add_right_cancel h1, rfl⟩\n    · rintro ⟨rfl, rfl⟩\n      simp [hx]\n  · simp\n#align mul_single_coeff_add mul_single_coeff_add\n\n",
 "mul_coeff_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mul_coeff_right' [NonUnitalNonAssocSemiring R] {x y : hahn_series Γ R} {a : Γ} {s : Set Γ} (hs : s.is_pwo)\n    (hys : y.support ⊆ s) :\n    (x * y).coeff a =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (addAntidiagonal x.is_pwo_support hs a) (x.coeff ij.fst * y.coeff ij.snd) :=\n  by\n  rw [mul_coeff]\n  apply sum_subset_zero_on_sdiff (add_antidiagonal_mono_right hys) _ fun _ _ => rfl\n  intro b hb\n  simp only [not_and, mem_sdiff, mem_add_antidiagonal, mem_support, not_imp_not] at hb\n  rw [hb.2 hb.1.1 hb.1.2.2, MulZeroClass.mul_zero]\n#align mul_coeff_right' mul_coeff_right'\n\n",
 "mul_coeff_order_add_order":
 "theorem mul_coeff_order_add_order {Γ} [LinearOrderedCancelAddCommMonoid Γ] [NonUnitalNonAssocSemiring R]\n    (x y : hahn_series Γ R) : (x * y).coeff (x.order + y.order) = x.coeff x.order * y.coeff y.order :=\n  by\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0; · simp [hy]\n  rw [order_of_ne hx, order_of_ne hy, mul_coeff, Finset.addAntidiagonal_min_add_min, Finset.sum_singleton]\n#align mul_coeff_order_add_order mul_coeff_order_add_order\n\n",
 "mul_coeff_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mul_coeff_left' [NonUnitalNonAssocSemiring R] {x y : hahn_series Γ R} {a : Γ} {s : Set Γ} (hs : s.is_pwo)\n    (hxs : x.support ⊆ s) :\n    (x * y).coeff a =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (addAntidiagonal hs y.is_pwo_support a) (x.coeff ij.fst * y.coeff ij.snd) :=\n  by\n  rw [mul_coeff]\n  apply sum_subset_zero_on_sdiff (add_antidiagonal_mono_left hxs) _ fun _ _ => rfl\n  intro b hb\n  simp only [not_and', mem_sdiff, mem_add_antidiagonal, mem_support, not_ne_iff] at hb\n  rw [hb.2 ⟨hb.1.2.1, hb.1.2.2⟩, MulZeroClass.zero_mul]\n#align mul_coeff_left' mul_coeff_left'\n\n",
 "mul_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem mul_coeff [NonUnitalNonAssocSemiring R] {x y : hahn_series Γ R} {a : Γ} :\n    (x * y).coeff a =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (addAntidiagonal x.is_pwo_support y.is_pwo_support a) (x.coeff ij.fst * y.coeff ij.snd) :=\n  rfl\n#align mul_coeff mul_coeff\n\n",
 "mul_assoc'":
 "private theorem mul_assoc' [NonUnitalSemiring R] (x y z : hahn_series Γ R) : x * y * z = x * (y * z) :=\n  by\n  ext b\n  rw [mul_coeff_left' (x.is_pwo_support.add y.is_pwo_support) support_mul_subset_add_support,\n    mul_coeff_right' (y.is_pwo_support.add z.is_pwo_support) support_mul_subset_add_support]\n  simp only [mul_coeff, add_coeff, sum_mul, mul_sum, sum_sigma']\n  refine' sum_bij_ne_zero (fun a has ha0 => ⟨⟨a.2.1, a.2.2 + a.1.2⟩, ⟨a.2.2, a.1.2⟩⟩) _ _ _ _\n  · rintro ⟨⟨i, j⟩, ⟨k, l⟩⟩ H1 H2\n    simp only [and_true_iff, Set.image2_add, eq_self_iff_true, mem_add_antidiagonal, ne.def, Set.image_prod, mem_sigma,\n      Set.mem_setOf_eq] at H1 H2⊢\n    obtain ⟨⟨H3, nz, rfl⟩, nx, ny, rfl⟩ := H1\n    exact ⟨⟨nx, Set.add_mem_add ny nz, (add_assoc _ _ _).symm⟩, ny, nz⟩\n  · rintro ⟨⟨i1, j1⟩, k1, l1⟩ ⟨⟨i2, j2⟩, k2, l2⟩ H1 H2 H3 H4 H5\n    simp only [Set.image2_add, Prod.mk.inj_iff, mem_add_antidiagonal, ne.def, Set.image_prod, mem_sigma,\n      Set.mem_setOf_eq, heq_iff_eq] at H1 H3 H5\n    obtain ⟨⟨rfl, H⟩, rfl, rfl⟩ := H5\n    simp only [and_true_iff, Prod.mk.inj_iff, eq_self_iff_true, heq_iff_eq, ← H1.2.2.2, ← H3.2.2.2]\n  · rintro ⟨⟨i, j⟩, ⟨k, l⟩⟩ H1 H2\n    simp only [exists_prop, Set.image2_add, Prod.mk.inj_iff, mem_add_antidiagonal, Sigma.exists, ne.def, Set.image_prod,\n      mem_sigma, Set.mem_setOf_eq, heq_iff_eq, Prod.exists] at H1 H2⊢\n    obtain ⟨⟨nx, H, rfl⟩, ny, nz, rfl⟩ := H1\n    exact\n      ⟨i + k, l, i, k, ⟨⟨Set.add_mem_add nx ny, nz, add_assoc _ _ _⟩, nx, ny, rfl⟩, fun con =>\n        H2 ((mul_assoc _ _ _).symm.trans Con), ⟨rfl, rfl⟩, rfl, rfl⟩\n  · rintro ⟨⟨i, j⟩, ⟨k, l⟩⟩ H1 H2\n    simp [mul_assoc]\n#align mul_assoc' mul_assoc'\n\n",
 "min_order_le_order_add":
 "theorem min_order_le_order_add {Γ} [LinearOrderedCancelAddCommMonoid Γ] {x y : hahn_series Γ R} (hxy : x + y ≠ 0) :\n    min x.order y.order ≤ (x + y).order := by\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0; · simp [hy]\n  rw [order_of_ne hx, order_of_ne hy, order_of_ne hxy]\n  refine' le_trans _ (Set.IsWf.min_le_min_of_subset support_add_subset)\n  · exact x.is_wf_support.union y.is_wf_support\n  · exact Set.Nonempty.mono (Set.subset_union_left _ _) (support_nonempty_iff.2 hx)\n  rw [Set.IsWf.min_union]\n#align min_order_le_order_add min_order_le_order_add\n\n",
 "mem_support":
 "@[simp]\ntheorem mem_support (x : hahn_series Γ R) (a : Γ) : a ∈ x.support ↔ x.coeff a ≠ 0 :=\n  iff.refl _\n#align mem_support mem_support\n\n",
 "is_wf_support":
 "@[simp]\ntheorem is_wf_support (x : hahn_series Γ R) : x.support.is_wf :=\n  x.is_pwo_support.is_wf\n#align is_wf_support is_wf_support\n\n",
 "is_unit_iff":
 "theorem is_unit_iff {x : hahn_series Γ R} : IsUnit x ↔ IsUnit (x.coeff x.order) :=\n  by\n  constructor\n  · rintro ⟨⟨u, i, ui, iu⟩, rfl⟩\n    refine' isUnit_of_mul_eq_one (u.coeff u.order) (i.coeff i.order) ((mul_coeff_order_add_order u i).symm.trans _)\n    rw [ui, one_coeff, if_pos]\n    rw [← order_mul (left_ne_zero_of_mul_eq_one ui) (right_ne_zero_of_mul_eq_one ui), ui, order_one]\n  · rintro ⟨⟨u, i, ui, iu⟩, h⟩\n    rw [Units.val_mk] at h\n    rw [h] at iu\n    have h := summable_family.one_sub_self_mul_hsum_powers (unit_aux x iu)\n    rw [sub_sub_cancel] at h\n    exact isUnit_of_mul_isUnit_right (isUnit_of_mul_eq_one _ _ h)\n#align is_unit_iff is_unit_iff\n\n",
 "is_pwo_support":
 "@[simp]\ntheorem is_pwo_support (x : hahn_series Γ R) : x.support.is_pwo :=\n  x.is_pwo_support'\n#align is_pwo_support is_pwo_support\n\n",
 "is_pwo_Union_support_powers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_pwo_Union_support_powers [LinearOrderedCancelAddCommMonoid Γ] [Ring R] [IsDomain R] {x : hahn_series Γ R}\n    (hx : 0 < add_val Γ R x) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (x ^ n).support).is_pwo :=\n  by\n  apply (x.is_wf_support.is_pwo.add_submonoid_closure fun g hg => _).mono _\n  · exact WithTop.coe_le_coe.1 (le_trans (le_of_lt hx) (add_val_le_of_coeff_ne_zero hg))\n  refine' Set.unionᵢ_subset fun n => _\n  induction' n with n ih <;> intro g hn\n  · simp only [exists_prop, and_true_iff, Set.mem_singleton_iff, Set.setOf_eq_eq_singleton, mem_support,\n      ite_eq_right_iff, ne.def, not_false_iff, one_ne_zero, pow_zero, not_forall, one_coeff] at hn\n    rw [hn, SetLike.mem_coe]\n    exact AddSubmonoid.zero_mem _\n  · obtain ⟨i, j, hi, hj, rfl⟩ := support_mul_subset_add_support hn\n    exact SetLike.mem_coe.2 (AddSubmonoid.add_mem _ (AddSubmonoid.subset_closure hi) (ih hj))\n#align is_pwo_Union_support_powers is_pwo_Union_support_powers\n\n",
 "is_pwo_Union_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_pwo_Union_support (s : summable_family Γ R α) :\n    Set.IsPwo\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s a).support) :=\n  s.is_pwo_Union_support'\n#align is_pwo_Union_support is_pwo_Union_support\n\n",
 "hsum_sub":
 "@[simp]\ntheorem hsum_sub {R : Type _} [Ring R] {s t : summable_family Γ R α} : (s - t).hsum = s.hsum - t.hsum := by\n  rw [← lsum_apply, LinearMap.map_sub, lsum_apply, lsum_apply]\n#align hsum_sub hsum_sub\n\n",
 "hsum_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem hsum_smul {x : hahn_series Γ R} {s : summable_family Γ R α} : («expr • » x s).hsum = x * s.hsum :=\n  by\n  ext g\n  simp only [mul_coeff, hsum_coeff, smul_apply]\n  have h :\n    ∀ i,\n      (s i).support ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s j).support :=\n    Set.subset_unionᵢ _\n  refine'\n    (Eq.trans (finsum_congr fun a => _)\n          (finsum_sum_comm (add_antidiagonal x.is_pwo_support s.is_pwo_Union_support g)\n            (fun i ij => x.coeff (Prod.fst ij) * (s i).coeff ij.snd) _)).trans\n      _\n  · refine' sum_subset (add_antidiagonal_mono_right (Set.subset_unionᵢ _ a)) _\n    rintro ⟨i, j⟩ hU ha\n    rw [mem_add_antidiagonal] at *\n    rw [Classical.not_not.1 fun con => ha ⟨hU.1, Con, hU.2.2⟩, MulZeroClass.mul_zero]\n  · rintro ⟨i, j⟩ hij\n    refine' (s.finite_co_support j).subset _\n    simp_rw [Function.support_subset_iff', Function.mem_support, Classical.not_not]\n    intro a ha\n    rw [ha, MulZeroClass.mul_zero]\n  · refine' (sum_congr rfl _).trans (sum_subset (add_antidiagonal_mono_right _) _).symm\n    · rintro ⟨i, j⟩ hij\n      rw [mul_finsum]\n      apply s.finite_co_support\n    · intro x hx\n      simp only [Set.mem_unionᵢ, ne.def, mem_support]\n      contrapose! hx\n      simp [hx]\n    · rintro ⟨i, j⟩ hU ha\n      rw [mem_add_antidiagonal] at *\n      rw [← hsum_coeff, Classical.not_not.1 fun con => ha ⟨hU.1, Con, hU.2.2⟩, MulZeroClass.mul_zero]\n#align hsum_smul hsum_smul\n\n",
 "hsum_of_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem hsum_of_finsupp {f : «expr →₀ » α (hahn_series Γ R)} : (of_finsupp f).hsum = f.sum fun a => id :=\n  by\n  ext g\n  simp only [hsum_coeff, coe_of_finsupp, Finsupp.sum, ne.def]\n  simp_rw [← coeff.add_monoid_hom_apply, id.def]\n  rw [AddMonoidHom.map_sum, finsum_eq_sum_of_support_subset]\n  intro x h\n  simp only [coeff.add_monoid_hom_apply, mem_coe, Finsupp.mem_support_iff, ne.def]\n  contrapose! h\n  simp [h]\n#align hsum_of_finsupp hsum_of_finsupp\n\n",
 "hsum_emb_domain":
 "@[simp]\ntheorem hsum_emb_domain : (s.emb_domain f).hsum = s.hsum :=\n  by\n  ext g\n  simp only [hsum_coeff, emb_domain_apply, apply_dite hahn_series.coeff, dite_apply, zero_coeff]\n  exact finsum_emb_domain f fun a => (s a).coeff g\n#align hsum_emb_domain hsum_emb_domain\n\n",
 "hsum_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum -/\n@[simp]\ntheorem hsum_coeff {s : summable_family Γ R α} {g : Γ} :\n    s.hsum.coeff g =\n      finsum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum\" ((s i).coeff g) :=\n  rfl\n#align hsum_coeff hsum_coeff\n\n",
 "hsum_add":
 "@[simp]\ntheorem hsum_add {s t : summable_family Γ R α} : (s + t).hsum = s.hsum + t.hsum :=\n  by\n  ext g\n  simp only [hsum_coeff, add_coeff, add_apply]\n  exact finsum_add_distrib (s.finite_co_support _) (t.finite_co_support _)\n#align hsum_add hsum_add\n\n",
 "finite_co_support":
 "theorem finite_co_support (s : summable_family Γ R α) (g : Γ) : (Function.support fun a => (s a).coeff g).finite :=\n  s.finite_co_support' g\n#align finite_co_support finite_co_support\n\n",
 "ext":
 "@[ext]\ntheorem ext {s t : summable_family Γ R α} (h : ∀ a : α, s a = t a) : s = t :=\n  coe_injective <| funext h\n#align ext ext\n\n",
 "eq_of_mem_support_single":
 "theorem eq_of_mem_support_single {b : Γ} (h : b ∈ support (single a r)) : b = a :=\n  support_single_subset h\n#align eq_of_mem_support_single eq_of_mem_support_single\n\n",
 "emb_domain_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n@[simp]\ntheorem emb_domain_zero {f : «expr ↪o » Γ Γ'} : emb_domain f (0 : hahn_series Γ R) = 0 :=\n  by\n  ext\n  simp [emb_domain_notin_image_support]\n#align emb_domain_zero emb_domain_zero\n\n",
 "emb_domain_succ_smul_powers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem emb_domain_succ_smul_powers :\n    («expr • » x (powers x hx)).emb_domain ⟨nat.succ, Nat.succ_injective⟩ =\n      powers x hx - of_finsupp (Finsupp.single 0 1) :=\n  by\n  apply summable_family.ext fun n => _\n  cases n\n  · rw [emb_domain_notin_range, sub_apply, coe_powers, pow_zero, coe_of_finsupp, Finsupp.single_eq_same, sub_self]\n    rw [Set.mem_range, not_exists]\n    exact nat.succ_ne_zero\n  · refine' Eq.trans (emb_domain_image _ ⟨nat.succ, Nat.succ_injective⟩) _\n    simp only [pow_succ, coe_powers, coe_sub, smul_apply, coe_of_finsupp, Pi.sub_apply]\n    rw [Finsupp.single_eq_of_ne n.succ_ne_zero.symm, sub_zero]\n#align emb_domain_succ_smul_powers emb_domain_succ_smul_powers\n\n",
 "emb_domain_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem emb_domain_smul (f : «expr ↪o » Γ Γ') (r : R) (x : hahn_series Γ R) :\n    emb_domain f («expr • » r x) = «expr • » r (emb_domain f x) :=\n  by\n  ext g\n  by_cases hg : g ∈ Set.range f\n  · obtain ⟨a, rfl⟩ := hg\n    simp\n  · simp [emb_domain_notin_range, hg]\n#align emb_domain_smul emb_domain_smul\n\n",
 "emb_domain_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n@[simp]\ntheorem emb_domain_single {f : «expr ↪o » Γ Γ'} {g : Γ} {r : R} : emb_domain f (single g r) = single (f g) r :=\n  by\n  ext g'\n  by_cases h : g' = f g\n  · simp [h]\n  rw [emb_domain_notin_image_support, single_coeff_of_ne h]\n  by_cases hr : r = 0\n  · simp [hr]\n  rwa [support_single_of_ne hr, Set.image_singleton, Set.mem_singleton_iff]\n#align emb_domain_single emb_domain_single\n\n",
 "emb_domain_ring_hom_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\ntheorem emb_domain_ring_hom_C [NonAssocSemiring R] {f : «expr →+ » Γ Γ'} {hfi : function.injective f}\n    {hf : ∀ g g' : Γ, f g ≤ f g' ↔ g ≤ g'} {r : R} : emb_domain_ring_hom f hfi hf (C r) = C r :=\n  emb_domain_single.trans (by simp)\n#align emb_domain_ring_hom_C emb_domain_ring_hom_C\n\n",
 "emb_domain_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem emb_domain_one [NonAssocSemiring R] (f : «expr ↪o » Γ Γ') (hf : f 0 = 0) :\n    emb_domain f (1 : hahn_series Γ R) = (1 : hahn_series Γ' R) :=\n  emb_domain_single.trans <| hf.symm ▸ rfl\n#align emb_domain_one emb_domain_one\n\n",
 "emb_domain_notin_range":
 "@[simp]\ntheorem emb_domain_notin_range (h : b ∉ Set.range f) : s.emb_domain f b = 0 := by rw [emb_domain_apply, dif_neg h]\n#align emb_domain_notin_range emb_domain_notin_range\n\n",
 "emb_domain_notin_image_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem emb_domain_notin_image_support {f : «expr ↪o » Γ Γ'} {x : hahn_series Γ R} {b : Γ'}\n    (hb : b ∉ «expr '' » f x.support) : (emb_domain f x).coeff b = 0 :=\n  dif_neg hb\n#align emb_domain_notin_image_support emb_domain_notin_image_support\n\n",
 "emb_domain_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem emb_domain_mul [NonUnitalNonAssocSemiring R] (f : «expr ↪o » Γ Γ') (hf : ∀ x y, f (x + y) = f x + f y)\n    (x y : hahn_series Γ R) : emb_domain f (x * y) = emb_domain f x * emb_domain f y :=\n  by\n  ext g\n  by_cases hg : g ∈ Set.range f\n  · obtain ⟨g, rfl⟩ := hg\n    simp only [mul_coeff, emb_domain_coeff]\n    trans\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        ((add_antidiagonal x.is_pwo_support y.is_pwo_support g).map\n          (Function.Embedding.prodMap f.to_embedding f.to_embedding))\n        ((emb_domain f x).coeff ij.1 * (emb_domain f y).coeff ij.2)\n    · simp\n    apply sum_subset\n    · rintro ⟨i, j⟩ hij\n      simp only [exists_prop, mem_map, Prod.mk.inj_iff, mem_add_antidiagonal, Function.Embedding.coe_prodMap,\n        mem_support, Prod.exists] at hij\n      obtain ⟨i, j, ⟨hx, hy, rfl⟩, rfl, rfl⟩ := hij\n      simp [hx, hy, hf]\n    · rintro ⟨_, _⟩ h1 h2\n      contrapose! h2\n      obtain ⟨i, hi, rfl⟩ := support_emb_domain_subset (ne_zero_and_ne_zero_of_mul h2).1\n      obtain ⟨j, hj, rfl⟩ := support_emb_domain_subset (ne_zero_and_ne_zero_of_mul h2).2\n      simp only [exists_prop, mem_map, Prod.mk.inj_iff, mem_add_antidiagonal, Function.Embedding.coe_prodMap,\n        mem_support, Prod.exists]\n      simp only [mem_add_antidiagonal, emb_domain_coeff, mem_support, ← hf, OrderEmbedding.eq_iff_eq] at h1\n      exact ⟨i, j, h1, rfl⟩\n  · rw [emb_domain_notin_range hg, eq_comm]\n    contrapose! hg\n    obtain ⟨_, _, hi, hj, rfl⟩ := support_mul_subset_add_support ((mem_support _ _).2 hg)\n    obtain ⟨i, hi, rfl⟩ := support_emb_domain_subset hi\n    obtain ⟨j, hj, rfl⟩ := support_emb_domain_subset hj\n    refine' ⟨i + j, hf i j⟩\n#align emb_domain_mul emb_domain_mul\n\n",
 "emb_domain_mk_coeff":
 "@[simp]\ntheorem emb_domain_mk_coeff {f : Γ → Γ'} (hfi : function.injective f) (hf : ∀ g g' : Γ, f g ≤ f g' ↔ g ≤ g')\n    {x : hahn_series Γ R} {a : Γ} : (emb_domain ⟨⟨f, hfi⟩, hf⟩ x).coeff (f a) = x.coeff a :=\n  emb_domain_coeff\n#align emb_domain_mk_coeff emb_domain_mk_coeff\n\n",
 "emb_domain_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem emb_domain_injective {f : «expr ↪o » Γ Γ'} :\n    function.injective (emb_domain f : hahn_series Γ R → hahn_series Γ' R) := fun x y xy =>\n  by\n  ext g\n  rw [ext_iff, Function.funext_iff] at xy\n  have xyg := xy (f g)\n  rwa [emb_domain_coeff, emb_domain_coeff] at xyg\n#align emb_domain_injective emb_domain_injective\n\n",
 "emb_domain_image":
 "@[simp]\ntheorem emb_domain_image : s.emb_domain f (f a) = s a :=\n  by\n  rw [emb_domain_apply, dif_pos (Set.mem_range_self a)]\n  exact congr rfl (f.injective (Classical.choose_spec (Set.mem_range_self a)))\n#align emb_domain_image emb_domain_image\n\n",
 "emb_domain_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n@[simp]\ntheorem emb_domain_coeff {f : «expr ↪o » Γ Γ'} {x : hahn_series Γ R} {a : Γ} :\n    (emb_domain f x).coeff (f a) = x.coeff a := by\n  rw [emb_domain]\n  dsimp only\n  by_cases ha : a ∈ x.support\n  · rw [dif_pos (Set.mem_image_of_mem f ha)]\n    exact congr rfl (f.injective (Classical.choose_spec (Set.mem_image_of_mem f ha)).2)\n  · rw [dif_neg, Classical.not_not.1 fun c => ha ((mem_support _ _).2 c)]\n    contrapose! ha\n    obtain ⟨b, hb1, hb2⟩ := (Set.mem_image _ _ _).1 ha\n    rwa [f.injective hb2] at hb1\n#align emb_domain_coeff emb_domain_coeff\n\n",
 "emb_domain_apply":
 "theorem emb_domain_apply : s.emb_domain f b = if h : b ∈ Set.range f then s (Classical.choose h) else 0 :=\n  rfl\n#align emb_domain_apply emb_domain_apply\n\n",
 "emb_domain_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem emb_domain_add (f : «expr ↪o » Γ Γ') (x y : hahn_series Γ R) :\n    emb_domain f (x + y) = emb_domain f x + emb_domain f y :=\n  by\n  ext g\n  by_cases hg : g ∈ Set.range f\n  · obtain ⟨a, rfl⟩ := hg\n    simp\n  · simp [emb_domain_notin_range, hg]\n#align emb_domain_add emb_domain_add\n\n",
 "coeff_to_power_series_symm":
 "theorem coeff_to_power_series_symm {f : power_series R} {n : ℕ} :\n    (hahn_series.to_power_series.symm f).coeff n = power_series.coeff R n f :=\n  rfl\n#align coeff_to_power_series_symm coeff_to_power_series_symm\n\n",
 "coeff_to_power_series":
 "theorem coeff_to_power_series {f : hahn_series ℕ R} {n : ℕ} : power_series.coeff R n f.to_power_series = f.coeff n :=\n  power_series.coeff_mk _ _\n#align coeff_to_power_series coeff_to_power_series\n\n",
 "coeff_to_mv_power_series_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem coeff_to_mv_power_series_symm {f : mv_power_series σ R} {n : «expr →₀ » σ ℕ} :\n    (hahn_series.to_mv_power_series.symm f).coeff n = mv_power_series.coeff R n f :=\n  rfl\n#align coeff_to_mv_power_series_symm coeff_to_mv_power_series_symm\n\n",
 "coeff_to_mv_power_series":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n-- Lemmas about converting hahn_series over fintype to and from mv_power_series\ntheorem coeff_to_mv_power_series {f : hahn_series («expr →₀ » σ ℕ) R} {n : «expr →₀ » σ ℕ} :\n    mv_power_series.coeff R n f.to_mv_power_series = f.coeff n :=\n  rfl\n#align coeff_to_mv_power_series coeff_to_mv_power_series\n\n",
 "coeff_order_ne_zero":
 "theorem coeff_order_ne_zero {x : hahn_series Γ R} (hx : x ≠ 0) : x.coeff x.order ≠ 0 :=\n  by\n  rw [order_of_ne hx]\n  exact x.is_wf_support.min_mem (support_nonempty_iff.2 hx)\n#align coeff_order_ne_zero coeff_order_ne_zero\n\n",
 "coeff_injective":
 "/-\nCopyright (c) 2021 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem coeff_injective : injective (coeff : hahn_series Γ R → Γ → R) :=\n  ext\n#align coeff_injective coeff_injective\n\n",
 "coeff_inj":
 "@[simp]\ntheorem coeff_inj {x y : hahn_series Γ R} : x.coeff = y.coeff ↔ x = y :=\n  coeff_injective.eq_iff\n#align coeff_inj coeff_inj\n\n",
 "coeff_fun_eq_zero_iff":
 "@[simp]\ntheorem coeff_fun_eq_zero_iff {x : hahn_series Γ R} : x.coeff = 0 ↔ x = 0 :=\n  coeff_injective.eq_iff' rfl\n#align coeff_fun_eq_zero_iff coeff_fun_eq_zero_iff\n\n",
 "coeff_eq_zero_of_lt_order":
 "theorem coeff_eq_zero_of_lt_order {x : hahn_series Γ R} {i : Γ} (hi : i < x.order) : x.coeff i = 0 :=\n  by\n  rcases eq_or_ne x 0 with (rfl | hx)\n  · simp\n  contrapose! hi\n  rw [← ne.def, ← mem_support] at hi\n  rw [order_of_ne hx]\n  exact Set.IsWf.not_lt_min _ _ hi\n#align coeff_eq_zero_of_lt_order coeff_eq_zero_of_lt_order\n\n",
 "coe_zero":
 "@[simp]\ntheorem coe_zero : ((0 : summable_family Γ R α) : α → hahn_series Γ R) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_sub : «expr⇑ » (s - t) = s - t :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_powers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_powers : «expr⇑ » (powers x hx) = pow x :=\n  rfl\n#align coe_powers coe_powers\n\n",
 "coe_of_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_of_finsupp {f : «expr →₀ » α (hahn_series Γ R)} : «expr⇑ » (summable_family.of_finsupp f) = f :=\n  rfl\n#align coe_of_finsupp coe_of_finsupp\n\n",
 "coe_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_neg : «expr⇑ » (-s) = -s :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_injective":
 "theorem coe_injective : @function.injective (summable_family Γ R α) (α → hahn_series Γ R) coe_fn\n  | ⟨f1, hU1, hf1⟩, ⟨f2, hU2, hf2⟩, h => by\n    change f1 = f2 at h\n    subst h\n#align coe_injective coe_injective\n\n",
 "coe_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_add {s t : summable_family Γ R α} : «expr⇑ » (s + t) = s + t :=\n  rfl\n#align coe_add coe_add\n\n",
 "algebra_map_hahn_series_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem _root_.polynomial.algebra_map_hahn_series_injective :\n    function.injective (algebraMap (polynomial R) (hahn_series Γ R)) :=\n  of_power_series_injective.comp (polynomial.coe_injective R)\n#align polynomial.algebra_map_hahn_series_injective polynomial.algebra_map_hahn_series_injective\n\n",
 "algebra_map_hahn_series_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem _root_.polynomial.algebra_map_hahn_series_apply (f : polynomial R) :\n    algebraMap (polynomial R) (hahn_series Γ R) f = of_power_series Γ R f :=\n  rfl\n#align polynomial.algebra_map_hahn_series_apply polynomial.algebra_map_hahn_series_apply\n\n",
 "algebra_map_apply'":
 "theorem algebra_map_apply' (x : S) :\n    algebraMap S (hahn_series Γ R) x = of_power_series Γ R (algebraMap S (power_series R) x) :=\n  rfl\n#align algebra_map_apply' algebra_map_apply'\n\n",
 "algebraMap_apply":
 "#print algebraMap_apply /-\ntheorem algebraMap_apply {r : R} : algebraMap R (hahn_series Γ A) r = C (algebraMap R A r) :=\n  rfl\n#align algebra_map_apply algebraMap_apply\n-/\n\n",
 "add_val_le_of_coeff_ne_zero":
 "theorem add_val_le_of_coeff_ne_zero {x : hahn_series Γ R} {g : Γ} (h : x.coeff g ≠ 0) : add_val Γ R x ≤ g :=\n  by\n  rw [add_val_apply_of_ne (ne_zero_of_coeff_ne_zero h), WithTop.coe_le_coe]\n  exact order_le_of_coeff_ne_zero h\n#align add_val_le_of_coeff_ne_zero add_val_le_of_coeff_ne_zero\n\n",
 "add_val_apply_of_ne":
 "@[simp]\ntheorem add_val_apply_of_ne {x : hahn_series Γ R} (hx : x ≠ 0) : add_val Γ R x = x.order :=\n  if_neg hx\n#align add_val_apply_of_ne add_val_apply_of_ne\n\n",
 "add_val_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem add_val_apply {x : hahn_series Γ R} :\n    add_val Γ R x = if x = (0 : hahn_series Γ R) then («expr⊤» : WithTop Γ) else x.order :=\n  AddValuation.of_apply _\n#align add_val_apply add_val_apply\n\n",
 "add_coeff'":
 "@[simp]\ntheorem add_coeff' {x y : hahn_series Γ R} : (x + y).coeff = x.coeff + y.coeff :=\n  rfl\n#align add_coeff' add_coeff'\n\n",
 "add_coeff":
 "theorem add_coeff {x y : hahn_series Γ R} {a : Γ} : (x + y).coeff a = x.coeff a + y.coeff a :=\n  rfl\n#align add_coeff add_coeff\n\n",
 "add_apply":
 "theorem add_apply {s t : summable_family Γ R α} {a : α} : (s + t) a = s a + t a :=\n  rfl\n#align add_apply add_apply\n\n",
 "C_zero":
 "@[simp]\ntheorem C_zero : C (0 : R) = (0 : hahn_series Γ R) :=\n  C.map_zero\n#align C_zero C_zero\n\n",
 "C_one":
 "@[simp]\ntheorem C_one : C (1 : R) = (1 : hahn_series Γ R) :=\n  C.map_one\n#align C_one C_one\n\n",
 "C_ne_zero":
 "theorem C_ne_zero {r : R} (h : r ≠ 0) : (C r : hahn_series Γ R) ≠ 0 :=\n  by\n  contrapose! h\n  rw [← C_zero] at h\n  exact C_injective h\n#align C_ne_zero C_ne_zero\n\n",
 "C_mul_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem C_mul_eq_smul {r : R} {x : hahn_series Γ R} : C r * x = «expr • » r x :=\n  single_zero_mul_eq_smul\n#align C_mul_eq_smul C_mul_eq_smul\n\n",
 "C_injective":
 "theorem C_injective : function.injective (C : R → hahn_series Γ R) :=\n  by\n  intro r s rs\n  rw [ext_iff, Function.funext_iff] at rs\n  have h := rs 0\n  rwa [C_apply, single_coeff_same, C_apply, single_coeff_same] at h\n#align C_injective C_injective\n\n",
 "C_eq_algebra_map":
 "theorem C_eq_algebra_map : C = algebraMap R (hahn_series Γ R) :=\n  rfl\n#align C_eq_algebra_map C_eq_algebra_map\n\n"}