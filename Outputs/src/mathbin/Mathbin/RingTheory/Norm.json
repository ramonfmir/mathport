{"prod_embeddings_eq_finrank_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem prod_embeddings_eq_finrank_pow [algebra L F] [IsScalarTower K L F] [is_alg_closed E] [is_separable K F]\n    [finite_dimensional K F] (pb : power_basis K L) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (σ (algebra_map L F pb.gen)) =\n      ((@finset.univ pb).prod fun σ : «expr →ₐ[ ] » L K E => σ pb.gen) ^ finrank L F :=\n  by\n  haveI : finite_dimensional L F := finite_dimensional.right K L F\n  haveI : is_separable L F := is_separable_tower_top_of_is_separable K L F\n  letI : fintype («expr →ₐ[ ] » L K E) := power_basis.alg_hom.fintype pb\n  letI : ∀ f : «expr →ₐ[ ] » L K E, fintype (@alg_hom L F E _ _ _ _ f.to_ring_hom.to_algebra) := _\n  rw [fintype.prod_equiv alg_hom_equiv_sigma (fun σ : «expr →ₐ[ ] » F K E => _) fun σ => σ.1 pb.gen, ←\n    finset.univ_sigma_univ, finset.prod_sigma, ← finset.prod_pow]\n  refine' finset.prod_congr rfl fun σ _ => _\n  · letI : algebra L E := σ.to_ring_hom.to_algebra\n    simp only [finset.prod_const, finset.card_univ]\n    congr\n    rw [alg_hom.card L F E]\n  · intro σ\n    simp only [alg_hom_equiv_sigma, equiv.coe_fn_mk, alg_hom.restrict_domain, alg_hom.comp_apply,\n      is_scalar_tower.coe_to_alg_hom']\n#align prod_embeddings_eq_finrank_pow prod_embeddings_eq_finrank_pow\n\n",
 "norm_ne_zero_iff_of_basis":
 "theorem norm_ne_zero_iff_of_basis [IsDomain R] [IsDomain S] (b : basis ι R S) {x : S} : algebra.norm R x ≠ 0 ↔ x ≠ 0 :=\n  not_iff_not.mpr (algebra.norm_eq_zero_iff_of_basis b)\n#align norm_ne_zero_iff_of_basis norm_ne_zero_iff_of_basis\n\n",
 "norm_gen_eq_prod_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem _root_.intermediate_field.adjoin_simple.norm_gen_eq_prod_roots (x : L)\n    (hf : (minpoly K x).splits (algebra_map K F)) :\n    (algebra_map K F) (norm K (adjoin_simple.gen K x)) = ((minpoly K x).map (algebra_map K F)).roots.prod :=\n  by\n  have injKxL :=\n    (algebra_map («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n        L).injective\n  by_cases hx : _root_.is_integral K x\n  swap\n  · simp [minpoly.eq_zero hx, intermediate_field.adjoin_simple.norm_gen_eq_one hx]\n  have hx' : _root_.is_integral K (adjoin_simple.gen K x) :=\n    by\n    rwa [← is_integral_algebra_map_iff injKxL, adjoin_simple.algebra_map_gen]\n    infer_instance\n  rw [← adjoin.power_basis_gen hx, power_basis.norm_gen_eq_prod_roots] <;>\n      rw [adjoin.power_basis_gen hx, minpoly.eq_of_algebra_map_eq injKxL hx'] <;>\n    try simp only [adjoin_simple.algebra_map_gen _ _]\n  exact hf\n#align intermediate_field.adjoin_simple.norm_gen_eq_prod_roots intermediate_field.adjoin_simple.norm_gen_eq_prod_roots\n\n",
 "norm_gen_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem _root_.intermediate_field.adjoin_simple.norm_gen_eq_one {x : L} (hx : ¬_root_.is_integral K x) :\n    norm K (adjoin_simple.gen K x) = 1 :=\n  by\n  rw [norm_eq_one_of_not_exists_basis]\n  contrapose! hx\n  obtain ⟨s, ⟨b⟩⟩ := hx\n  refine'\n    is_integral_of_mem_of_fg\n      («expr ⟮ ,⟯» K\n          \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").to_subalgebra\n      _ x _\n  · exact (submodule.fg_iff_finite_dimensional _).mpr (of_fintype_basis b)\n  · exact intermediate_field.subset_adjoin K _ (Set.mem_singleton x)\n#align intermediate_field.adjoin_simple.norm_gen_eq_one intermediate_field.adjoin_simple.norm_gen_eq_one\n\n",
 "norm_gen_eq_coeff_zero_minpoly":
 "/-- Given `pb : power_basis K S`, then the norm of `pb.gen` is\n`(-1) ^ pb.dim * coeff (minpoly K pb.gen) 0`. -/\ntheorem power_basis.norm_gen_eq_coeff_zero_minpoly (pb : power_basis R S) :\n    norm R pb.gen = (-1) ^ pb.dim * coeff (minpoly R pb.gen) 0 := by\n  rw [norm_eq_matrix_det pb.basis, det_eq_sign_charpoly_coeff, charpoly_left_mul_matrix, fintype.card_fin]\n#align power_basis.norm_gen_eq_coeff_zero_minpoly power_basis.norm_gen_eq_coeff_zero_minpoly\n\n",
 "norm_eq_zero_iff_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem norm_eq_zero_iff_of_basis [IsDomain R] [IsDomain S] (b : basis ι R S) {x : S} : algebra.norm R x = 0 ↔ x = 0 :=\n  by\n  cases nonempty_fintype ι\n  have hι : nonempty ι := b.index_nonempty\n  letI := classical.dec_eq ι\n  rw [algebra.norm_eq_matrix_det b]\n  constructor\n  · rw [← matrix.exists_mul_vec_eq_zero_iff]\n    rintro ⟨v, v_ne, hv⟩\n    rw [← b.equiv_fun.apply_symm_apply v, b.equiv_fun_symm_apply, b.equiv_fun_apply,\n      algebra.left_mul_matrix_mul_vec_repr] at hv\n    refine'\n      (mul_eq_zero.mp (b.ext_elem fun i => _)).resolve_right\n        (show\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (v i) (b i)) ≠\n            0\n          from _)\n    · simpa only [linear_equiv.map_zero, pi.zero_apply] using congr_fun hv i\n    · contrapose! v_ne with sum_eq\n      apply b.equiv_fun.symm.injective\n      rw [b.equiv_fun_symm_apply, sum_eq, linear_equiv.map_zero]\n  · rintro rfl\n    rw [alg_hom.map_zero, matrix.det_zero hι]\n#align norm_eq_zero_iff_of_basis norm_eq_zero_iff_of_basis\n\n",
 "norm_eq_zero_iff'":
 "/-- This is `algebra.norm_eq_zero_iff` composed with `algebra.norm_apply`. -/\n@[simp]\ntheorem norm_eq_zero_iff' {K L : Type _} [Field K] [CommRing L] [algebra K L] [IsDomain L] [finite_dimensional K L]\n    {x : L} : linear_map.det (linear_map.mul K L x) = 0 ↔ x = 0 :=\n  algebra.norm_eq_zero_iff_of_basis (basis.of_vector_space K L)\n#align norm_eq_zero_iff' norm_eq_zero_iff'\n\n",
 "norm_eq_zero_iff":
 "/-- See also `algebra.norm_eq_zero_iff'` if you already have rewritten with `algebra.norm_apply`. -/\n@[simp]\ntheorem norm_eq_zero_iff {K L : Type _} [Field K] [CommRing L] [algebra K L] [IsDomain L] [finite_dimensional K L]\n    {x : L} : algebra.norm K x = 0 ↔ x = 0 :=\n  algebra.norm_eq_zero_iff_of_basis (basis.of_vector_space K L)\n#align norm_eq_zero_iff norm_eq_zero_iff\n\n",
 "norm_eq_prod_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem norm_eq_prod_roots [is_separable K L] [finite_dimensional K L] {x : L}\n    (hF : (minpoly K x).splits (algebra_map K F)) :\n    algebra_map K F (norm K x) =\n      ((minpoly K x).map (algebra_map K F)).roots.prod ^\n        finrank («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          L :=\n  by rw [norm_eq_norm_adjoin K x, map_pow, intermediate_field.adjoin_simple.norm_gen_eq_prod_roots _ hF]\n#align norm_eq_prod_roots norm_eq_prod_roots\n\n",
 "norm_eq_prod_embeddings_gen":
 "theorem norm_eq_prod_embeddings_gen [algebra R F] (pb : power_basis R S)\n    (hE : (minpoly R pb.gen).splits (algebra_map R F)) (hfx : (minpoly R pb.gen).separable) :\n    algebra_map R F (norm R pb.gen) = (@finset.univ pb).prod fun σ => σ pb.gen :=\n  by\n  letI := classical.dec_eq F\n  rw [pb.norm_gen_eq_prod_roots hE, fintype.prod_equiv pb.lift_equiv', finset.prod_mem_multiset,\n    finset.prod_eq_multiset_prod, Multiset.toFinset_val, multiset.dedup_eq_self.mpr, Multiset.map_id]\n  · exact nodup_roots hfx.map\n  · intro x\n    rfl\n  · intro σ\n    rw [pb.lift_equiv'_apply_coe, id.def]\n#align norm_eq_prod_embeddings_gen norm_eq_prod_embeddings_gen\n\n",
 "norm_eq_prod_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- For `L/K` a finite separable extension of fields and `E` an algebraically closed extension\nof `K`, the norm (down to `K`) of an element `x` of `L` is equal to the product of the images\nof `x` over all the `K`-embeddings `σ`  of `L` into `E`. -/\ntheorem norm_eq_prod_embeddings [finite_dimensional K L] [is_separable K L] [is_alg_closed E] {x : L} :\n    algebra_map K E (norm K x) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (σ x) :=\n  by\n  have hx := is_separable.is_integral K x\n  rw [norm_eq_norm_adjoin K x, RingHom.map_pow, ← adjoin.power_basis_gen hx,\n    norm_eq_prod_embeddings_gen E (adjoin.power_basis hx) (is_alg_closed.splits_codomain _)]\n  · exact (prod_embeddings_eq_finrank_pow L E (adjoin.power_basis hx)).symm\n  · haveI :=\n      is_separable_tower_bot_of_is_separable K\n        («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") L\n    exact is_separable.separable K _\n#align norm_eq_prod_embeddings norm_eq_prod_embeddings\n\n",
 "norm_eq_prod_automorphisms":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem norm_eq_prod_automorphisms [finite_dimensional K L] [is_galois K L] (x : L) :\n    algebra_map K L (norm K x) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (σ x) :=\n  by\n  apply no_zero_smul_divisors.algebra_map_injective L (algebraic_closure L)\n  rw [map_prod (algebra_map L (algebraic_closure L))]\n  rw [← fintype.prod_equiv (normal.alg_hom_equiv_aut K (algebraic_closure L) L)]\n  · rw [← norm_eq_prod_embeddings]\n    simp only [algebra_map_eq_smul_one, smul_one_smul]\n  · intro σ\n    simp only [normal.alg_hom_equiv_aut, alg_hom.restrict_normal', equiv.coe_fn_mk, alg_equiv.coe_of_bijective,\n      alg_hom.restrict_normal_commutes, id.map_eq_id, RingHom.id_apply]\n#align norm_eq_prod_automorphisms norm_eq_prod_automorphisms\n\n",
 "norm_eq_one_of_not_exists_basis":
 "theorem norm_eq_one_of_not_exists_basis (h : ¬∃ s : Finset S, nonempty (basis s R S)) (x : S) : norm R x = 1 :=\n  by\n  rw [norm_apply, linear_map.det]\n  split_ifs with h\n  rfl\n#align norm_eq_one_of_not_exists_basis norm_eq_one_of_not_exists_basis\n\n",
 "norm_eq_norm_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem norm_eq_norm_adjoin [finite_dimensional K L] [is_separable K L] (x : L) :\n    norm K x =\n      norm K (adjoin_simple.gen K x) ^\n        finrank («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          L :=\n  by\n  letI :=\n    is_separable_tower_top_of_is_separable K\n      («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") L\n  let pbL :=\n    field.power_basis_of_finite_of_separable\n      («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") L\n  let pbx := intermediate_field.adjoin.power_basis (is_separable.is_integral K x)\n  rw [← adjoin_simple.algebra_map_gen K x, norm_eq_matrix_det (pbx.basis.smul pbL.basis) _,\n    smul_left_mul_matrix_algebra_map, det_block_diagonal, norm_eq_matrix_det pbx.basis]\n  simp only [finset.card_fin, finset.prod_const]\n  congr\n  rw [← power_basis.finrank, adjoin_simple.algebra_map_gen K x]\n#align norm_eq_norm_adjoin norm_eq_norm_adjoin\n\n",
 "norm_eq_matrix_det":
 "-- Can't be a `simp` lemma because it depends on a choice of basis\ntheorem norm_eq_matrix_det [fintype ι] [decidable_eq ι] (b : basis ι R S) (s : S) :\n    norm R s = matrix.det (algebra.left_mul_matrix b s) :=\n  by\n  rwa [norm_apply, ← linear_map.det_to_matrix b, ← to_matrix_lmul_eq]\n  rfl\n#align norm_eq_matrix_det norm_eq_matrix_det\n\n",
 "norm_apply":
 "/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\ntheorem norm_apply (x : S) : norm R x = linear_map.det (lmul R S x) :=\n  rfl\n#align norm_apply norm_apply\n\n",
 "norm_algebra_map_of_basis":
 "/-- If `x` is in the base ring `K`, then the norm is `x ^ [L : K]`. -/\ntheorem norm_algebra_map_of_basis [fintype ι] (b : basis ι R S) (x : R) :\n    norm R (algebra_map R S x) = x ^ fintype.card ι :=\n  by\n  haveI := classical.dec_eq ι\n  rw [norm_apply, ← det_to_matrix b, lmul_algebra_map]\n  convert @det_diagonal _ _ _ _ _ fun i : ι => x\n  · ext (i j)\n    rw [to_matrix_lsmul, matrix.diagonal]\n  · rw [finset.prod_const, finset.card_univ]\n#align norm_algebra_map_of_basis norm_algebra_map_of_basis\n\n",
 "norm_algebra_map":
 "/-- If `x` is in the base field `K`, then the norm is `x ^ [L : K]`.\n\n(If `L` is not finite-dimensional over `K`, then `norm = 1 = x ^ 0 = x ^ (finrank L K)`.)\n-/\n@[simp]\nprotected theorem norm_algebra_map {L : Type _} [Ring L] [algebra K L] (x : K) :\n    norm K (algebra_map K L x) = x ^ finrank K L :=\n  by\n  by_cases H : ∃ s : Finset L, nonempty (basis s K L)\n  · rw [norm_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some]\n  · rw [norm_eq_one_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis, pow_zero]\n    rintro ⟨s, ⟨b⟩⟩\n    exact H ⟨s, ⟨b⟩⟩\n#align norm_algebra_map norm_algebra_map\n\n",
 "is_integral_norm":
 "theorem is_integral_norm [algebra R L] [algebra R K] [IsScalarTower R K L] [is_separable K L] [finite_dimensional K L]\n    {x : L} (hx : _root_.is_integral R x) : _root_.is_integral R (norm K x) :=\n  by\n  have hx' : _root_.is_integral K x := is_integral_of_is_scalar_tower hx\n  rw [← is_integral_algebra_map_iff (algebra_map K (algebraic_closure L)).injective, norm_eq_prod_roots]\n  · refine' (is_integral.multiset_prod fun y hy => _).pow _\n    rw [mem_roots_map (minpoly.ne_zero hx')] at hy\n    use minpoly R x, minpoly.monic hx\n    rw [← aeval_def] at hy⊢\n    exact minpoly.aeval_of_is_scalar_tower R x y hy\n  · apply is_alg_closed.splits_codomain\n  · infer_instance\n#align is_integral_norm is_integral_norm\n\n"}