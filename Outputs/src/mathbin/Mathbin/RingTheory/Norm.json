{"prod_embeddings_eq_finrank_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem prod_embeddings_eq_finrank_pow [Algebra L F] [IsScalarTower K L F] [is_alg_closed E] [is_separable K F]\n    [FiniteDimensional K F] (pb : power_basis K L) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (σ (algebraMap L F pb.gen)) =\n      ((@Finset.univ pb.alg_hom.fintype).prod fun σ : «expr →ₐ[ ] » L K E => σ pb.gen) ^ finrank L F :=\n  by\n  haveI : FiniteDimensional L F := FiniteDimensional.right K L F\n  haveI : is_separable L F := is_separable_tower_top_of_is_separable K L F\n  letI : Fintype («expr →ₐ[ ] » L K E) := power_basis.alg_hom.fintype pb\n  letI : ∀ f : «expr →ₐ[ ] » L K E, Fintype (@AlgHom L F E _ _ _ _ f.to_ring_hom.to_algebra) := _\n  rw [Fintype.prod_equiv algHomEquivSigma (fun σ : «expr →ₐ[ ] » F K E => _) fun σ => σ.1 pb.gen, ←\n    Finset.univ_sigma_univ, Finset.prod_sigma, ← Finset.prod_pow]\n  refine' Finset.prod_congr rfl fun σ _ => _\n  · letI : Algebra L E := σ.to_ring_hom.to_algebra\n    simp only [Finset.prod_const, Finset.card_univ]\n    congr\n    rw [alg_hom.card L F E]\n  · intro σ\n    simp only [algHomEquivSigma, Equiv.coe_fn_mk, AlgHom.restrictDomain, AlgHom.comp_apply, IsScalarTower.coe_toAlgHom']\n#align prod_embeddings_eq_finrank_pow prod_embeddings_eq_finrank_pow\n\n",
 "norm_zero":
 "#print norm_zero /-\n@[simp]\ntheorem norm_zero [Nontrivial S] [Module.Free R S] [Module.Finite R S] : norm R (0 : S) = 0 :=\n  by\n  nontriviality\n  rw [norm_apply, coe_lmul_eq_mul, map_zero, LinearMap.det_zero' (Module.Free.chooseBasis R S)]\n#align norm_zero norm_zero\n-/\n\n",
 "norm_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print norm_norm /-\n-- TODO. Generalize this proof to rings\ntheorem norm_norm [Algebra L F] [IsScalarTower K L F] [is_separable K F] (x : F) : norm K (norm L x) = norm K x :=\n  by\n  by_cases hKF : FiniteDimensional K F\n  · haveI := hKF\n    let A := algebraic_closure K\n    apply (algebraMap K A).injective\n    haveI : FiniteDimensional L F := FiniteDimensional.right K L F\n    haveI : FiniteDimensional K L := FiniteDimensional.left K L F\n    haveI : is_separable K L := is_separable_tower_bot_of_is_separable K L F\n    haveI : is_separable L F := is_separable_tower_top_of_is_separable K L F\n    letI :\n      ∀ σ : «expr →ₐ[ ] » L K A,\n        haveI := σ.to_ring_hom.to_algebra\n        Fintype («expr →ₐ[ ] » F L A) :=\n      fun _ => inferInstance\n    rw [norm_eq_prod_embeddings K A (_ : F),\n      Fintype.prod_equiv algHomEquivSigma (fun σ : «expr →ₐ[ ] » F K A => σ x)\n        (fun π : Σf : «expr →ₐ[ ] » L K A, _ => (π.2 : F → A) x) fun _ => rfl]\n    suffices\n      ∀ σ : «expr →ₐ[ ] » L K A,\n        haveI := σ.to_ring_hom.to_algebra\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (π x) =\n          σ (norm L x)\n      by simp_rw [← Finset.univ_sigma_univ, Finset.prod_sigma, this, norm_eq_prod_embeddings]\n    · intro σ\n      letI : Algebra L A := σ.to_ring_hom.to_algebra\n      rw [← norm_eq_prod_embeddings L A (_ : F)]\n      rfl\n  · rw [norm_eq_one_of_not_module_finite hKF]\n    by_cases hKL : FiniteDimensional K L\n    · have hLF : ¬FiniteDimensional L F := by\n        refine' (mt _) hKF\n        intro hKF\n        exact FiniteDimensional.trans K L F\n      rw [norm_eq_one_of_not_module_finite hLF, _root_.map_one]\n    · rw [norm_eq_one_of_not_module_finite hKL]\n#align norm_norm norm_norm\n-/\n\n",
 "norm_ne_zero_iff_of_basis":
 "theorem norm_ne_zero_iff_of_basis [IsDomain R] [IsDomain S] (b : Basis ι R S) {x : S} : algebra.norm R x ≠ 0 ↔ x ≠ 0 :=\n  not_iff_not.mpr (norm_eq_zero_iff_of_basis b)\n#align norm_ne_zero_iff_of_basis norm_ne_zero_iff_of_basis\n\n",
 "norm_ne_zero_iff":
 "#print norm_ne_zero_iff /-\ntheorem norm_ne_zero_iff [IsDomain R] [IsDomain S] [Module.Free R S] [Module.Finite R S] {x : S} :\n    norm R x ≠ 0 ↔ x ≠ 0 :=\n  not_iff_not.mpr norm_eq_zero_iff\n#align norm_ne_zero_iff norm_ne_zero_iff\n-/\n\n",
 "norm_gen_eq_prod_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem _root_.intermediate_field.adjoin_simple.norm_gen_eq_prod_roots (x : L)\n    (hf : (minpoly K x).splits (algebraMap K F)) :\n    (algebraMap K F) (norm K (adjoin_simple.gen K x)) = ((minpoly K x).map (algebraMap K F)).roots.prod :=\n  by\n  have injKxL :=\n    (algebraMap («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n        L).injective\n  by_cases hx : is_integral K x\n  swap\n  · simp [minpoly.eq_zero hx, intermediate_field.adjoin_simple.norm_gen_eq_one hx]\n  have hx' : is_integral K (adjoin_simple.gen K x) :=\n    by\n    rwa [← is_integral_algebra_map_iff injKxL, adjoin_simple.algebra_map_gen]\n    infer_instance\n  rw [← adjoin.power_basis_gen hx, power_basis.norm_gen_eq_prod_roots] <;>\n      rw [adjoin.power_basis_gen hx, minpoly.eq_of_algebra_map_eq injKxL hx'] <;>\n    try simp only [adjoin_simple.algebra_map_gen _ _]\n  exact hf\n#align intermediate_field.adjoin_simple.norm_gen_eq_prod_roots intermediate_field.adjoin_simple.norm_gen_eq_prod_roots\n\n",
 "norm_gen_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem _root_.intermediate_field.adjoin_simple.norm_gen_eq_one {x : L} (hx : ¬is_integral K x) :\n    norm K (adjoin_simple.gen K x) = 1 :=\n  by\n  rw [norm_eq_one_of_not_exists_basis]\n  contrapose! hx\n  obtain ⟨s, ⟨b⟩⟩ := hx\n  refine'\n    is_integral_of_mem_of_fg\n      («expr ⟮ ,⟯» K\n          \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").to_subalgebra\n      _ x _\n  · exact (Submodule.fg_iff_finiteDimensional _).mpr (of_fintype_basis b)\n  · exact intermediate_field.subset_adjoin K _ (Set.mem_singleton x)\n#align intermediate_field.adjoin_simple.norm_gen_eq_one intermediate_field.adjoin_simple.norm_gen_eq_one\n\n",
 "norm_gen_eq_coeff_zero_minpoly":
 "/-- Given `pb : power_basis K S`, then the norm of `pb.gen` is\n`(-1) ^ pb.dim * coeff (minpoly K pb.gen) 0`. -/\ntheorem power_basis.norm_gen_eq_coeff_zero_minpoly (pb : power_basis R S) :\n    norm R pb.gen = (-1) ^ pb.dim * coeff (minpoly R pb.gen) 0 := by\n  rw [norm_eq_matrix_det pb.basis, det_eq_sign_charpoly_coeff, charpoly_left_mul_matrix, Fintype.card_fin]\n#align power_basis.norm_gen_eq_coeff_zero_minpoly power_basis.norm_gen_eq_coeff_zero_minpoly\n\n",
 "norm_eq_zero_iff_of_basis":
 "theorem norm_eq_zero_iff_of_basis [IsDomain R] [IsDomain S] (b : Basis ι R S) {x : S} : algebra.norm R x = 0 ↔ x = 0 :=\n  by\n  haveI : Module.Free R S := Module.Free.of_basis b\n  haveI : Module.Finite R S := Module.Finite.of_basis b\n  exact norm_eq_zero_iff\n#align norm_eq_zero_iff_of_basis norm_eq_zero_iff_of_basis\n\n",
 "norm_eq_zero_iff'":
 "/-- This is `algebra.norm_eq_zero_iff` composed with `algebra.norm_apply`. -/\n@[simp]\ntheorem norm_eq_zero_iff' [IsDomain R] [IsDomain S] [Module.Free R S] [Module.Finite R S] {x : S} :\n    LinearMap.det (LinearMap.mul R S x) = 0 ↔ x = 0 :=\n  norm_eq_zero_iff\n#align norm_eq_zero_iff' norm_eq_zero_iff'\n\n",
 "norm_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem norm_eq_zero_iff [IsDomain R] [IsDomain S] [Module.Free R S] [Module.Finite R S] {x : S} :\n    norm R x = 0 ↔ x = 0 := by\n  constructor\n  let b := Module.Free.chooseBasis R S\n  swap;\n  · rintro rfl\n    exact norm_zero\n  · letI := Classical.decEq (Module.Free.ChooseBasisIndex R S)\n    rw [norm_eq_matrix_det b, ← matrix.exists_mul_vec_eq_zero_iff]\n    rintro ⟨v, v_ne, hv⟩\n    rw [← b.equiv_fun.apply_symm_apply v, b.equiv_fun_symm_apply, b.equiv_fun_apply, left_mul_matrix_mul_vec_repr] at hv\n    refine'\n      (mul_eq_zero.mp (b.ext_elem fun i => _)).resolve_right\n        (show\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (v i) (b i)) ≠\n            0\n          from _)\n    · simpa only [LinearEquiv.map_zero, Pi.zero_apply] using congr_fun hv i\n    · contrapose! v_ne with sum_eq\n      apply b.equiv_fun.symm.injective\n      rw [b.equiv_fun_symm_apply, sum_eq, LinearEquiv.map_zero]\n#align norm_eq_zero_iff norm_eq_zero_iff\n\n",
 "norm_eq_prod_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem norm_eq_prod_roots [is_separable K L] [FiniteDimensional K L] {x : L}\n    (hF : (minpoly K x).splits (algebraMap K F)) :\n    algebraMap K F (norm K x) =\n      ((minpoly K x).map (algebraMap K F)).roots.prod ^\n        finrank («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          L :=\n  by rw [norm_eq_norm_adjoin K x, map_pow, intermediate_field.adjoin_simple.norm_gen_eq_prod_roots _ hF]\n#align norm_eq_prod_roots norm_eq_prod_roots\n\n",
 "norm_eq_prod_embeddings_gen":
 "theorem norm_eq_prod_embeddings_gen [Algebra R F] (pb : power_basis R S)\n    (hE : (minpoly R pb.gen).splits (algebraMap R F)) (hfx : (minpoly R pb.gen).separable) :\n    algebraMap R F (norm R pb.gen) = (@Finset.univ pb.alg_hom.fintype).prod fun σ => σ pb.gen :=\n  by\n  letI := Classical.decEq F\n  rw [pb.norm_gen_eq_prod_roots hE, Fintype.prod_equiv pb.lift_equiv', Finset.prod_mem_multiset,\n    Finset.prod_eq_multiset_prod, Multiset.toFinset_val, multiset.dedup_eq_self.mpr, Multiset.map_id]\n  · exact nodup_roots hfx.map\n  · intro x\n    rfl\n  · intro σ\n    rw [pb.lift_equiv'_apply_coe, id.def]\n#align norm_eq_prod_embeddings_gen norm_eq_prod_embeddings_gen\n\n",
 "norm_eq_prod_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- For `L/K` a finite separable extension of fields and `E` an algebraically closed extension\nof `K`, the norm (down to `K`) of an element `x` of `L` is equal to the product of the images\nof `x` over all the `K`-embeddings `σ`  of `L` into `E`. -/\ntheorem norm_eq_prod_embeddings [FiniteDimensional K L] [is_separable K L] [is_alg_closed E] (x : L) :\n    algebraMap K E (norm K x) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (σ x) :=\n  by\n  have hx := is_separable.is_integral K x\n  rw [norm_eq_norm_adjoin K x, RingHom.map_pow, ← adjoin.power_basis_gen hx,\n    norm_eq_prod_embeddings_gen E (adjoin.power_basis hx) (is_alg_closed.splits_codomain _)]\n  · exact (prod_embeddings_eq_finrank_pow L E (adjoin.power_basis hx)).symm\n  · haveI :=\n      is_separable_tower_bot_of_is_separable K\n        («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") L\n    exact is_separable.separable K _\n#align norm_eq_prod_embeddings norm_eq_prod_embeddings\n\n",
 "norm_eq_prod_automorphisms":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem norm_eq_prod_automorphisms [FiniteDimensional K L] [is_galois K L] (x : L) :\n    algebraMap K L (norm K x) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (σ x) :=\n  by\n  apply NoZeroSMulDivisors.algebraMap_injective L (algebraic_closure L)\n  rw [map_prod (algebraMap L (algebraic_closure L))]\n  rw [← Fintype.prod_equiv (normal.alg_hom_equiv_aut K (algebraic_closure L) L)]\n  · rw [← norm_eq_prod_embeddings]\n    simp only [algebra_map_eq_smul_one, smul_one_smul]\n  · intro σ\n    simp only [normal.alg_hom_equiv_aut, alg_hom.restrict_normal', Equiv.coe_fn_mk, AlgEquiv.coe_ofBijective,\n      alg_hom.restrict_normal_commutes, id.map_eq_id, RingHom.id_apply]\n#align norm_eq_prod_automorphisms norm_eq_prod_automorphisms\n\n",
 "norm_eq_one_of_not_module_finite":
 "theorem norm_eq_one_of_not_module_finite (h : ¬Module.Finite R S) (x : S) : norm R x = 1 :=\n  by\n  refine' norm_eq_one_of_not_exists_basis _ (mt _ h) _\n  rintro ⟨s, ⟨b⟩⟩\n  exact Module.Finite.of_basis b\n#align norm_eq_one_of_not_module_finite norm_eq_one_of_not_module_finite\n\n",
 "norm_eq_one_of_not_exists_basis":
 "theorem norm_eq_one_of_not_exists_basis (h : ¬∃ s : Finset S, Nonempty (Basis s R S)) (x : S) : norm R x = 1 :=\n  by\n  rw [norm_apply, LinearMap.det]\n  split_ifs with h\n  rfl\n#align norm_eq_one_of_not_exists_basis norm_eq_one_of_not_exists_basis\n\n",
 "norm_eq_norm_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem norm_eq_norm_adjoin [FiniteDimensional K L] [is_separable K L] (x : L) :\n    norm K x =\n      norm K (adjoin_simple.gen K x) ^\n        finrank («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          L :=\n  by\n  letI :=\n    is_separable_tower_top_of_is_separable K\n      («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") L\n  let pbL :=\n    field.power_basis_of_finite_of_separable\n      («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") L\n  let pbx := intermediate_field.adjoin.power_basis (is_separable.is_integral K x)\n  rw [← adjoin_simple.algebra_map_gen K x, norm_eq_matrix_det (pbx.basis.smul pbL.basis) _,\n    smul_left_mul_matrix_algebra_map, det_block_diagonal, norm_eq_matrix_det pbx.basis]\n  simp only [Finset.card_fin, Finset.prod_const]\n  congr\n  rw [← power_basis.finrank, adjoin_simple.algebra_map_gen K x]\n#align norm_eq_norm_adjoin norm_eq_norm_adjoin\n\n",
 "norm_eq_matrix_det":
 "-- Can't be a `simp` lemma because it depends on a choice of basis\ntheorem norm_eq_matrix_det [Fintype ι] [DecidableEq ι] (b : Basis ι R S) (s : S) :\n    norm R s = Matrix.det (Algebra.leftMulMatrix b s) :=\n  by\n  rwa [norm_apply, ← LinearMap.det_toMatrix b, ← to_matrix_lmul_eq]\n  rfl\n#align norm_eq_matrix_det norm_eq_matrix_det\n\n",
 "norm_apply":
 "/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\ntheorem norm_apply (x : S) : norm R x = LinearMap.det (lmul R S x) :=\n  rfl\n#align norm_apply norm_apply\n\n",
 "norm_algebra_map_of_basis":
 "/-- If `x` is in the base ring `K`, then the norm is `x ^ [L : K]`. -/\ntheorem norm_algebra_map_of_basis [Fintype ι] (b : Basis ι R S) (x : R) :\n    norm R (algebraMap R S x) = x ^ Fintype.card ι :=\n  by\n  haveI := Classical.decEq ι\n  rw [norm_apply, ← det_to_matrix b, lmul_algebra_map]\n  convert@det_diagonal _ _ _ _ _ fun i : ι => x\n  · ext (i j)\n    rw [to_matrix_lsmul, Matrix.diagonal]\n  · rw [Finset.prod_const, Finset.card_univ]\n#align norm_algebra_map_of_basis norm_algebra_map_of_basis\n\n",
 "norm_algebraMap":
 "#print norm_algebraMap /-\n/-- If `x` is in the base field `K`, then the norm is `x ^ [L : K]`.\n\n(If `L` is not finite-dimensional over `K`, then `norm = 1 = x ^ 0 = x ^ (finrank L K)`.)\n-/\n@[simp]\nprotected theorem norm_algebraMap {L : Type _} [Ring L] [Algebra K L] (x : K) :\n    norm K (algebraMap K L x) = x ^ finrank K L :=\n  by\n  by_cases H : ∃ s : Finset L, Nonempty (Basis s K L)\n  · rw [norm_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some]\n  · rw [norm_eq_one_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis, pow_zero]\n    rintro ⟨s, ⟨b⟩⟩\n    exact H ⟨s, ⟨b⟩⟩\n#align norm_algebra_map norm_algebraMap\n-/\n\n",
 "is_integral_norm":
 "theorem is_integral_norm [Algebra R L] [Algebra R K] [IsScalarTower R K L] [is_separable K L] [FiniteDimensional K L]\n    {x : L} (hx : is_integral R x) : is_integral R (norm K x) :=\n  by\n  have hx' : is_integral K x := is_integral_of_is_scalar_tower hx\n  rw [← is_integral_algebra_map_iff (algebraMap K (algebraic_closure L)).injective, norm_eq_prod_roots]\n  · refine' (is_integral.multiset_prod fun y hy => _).pow _\n    rw [mem_roots_map (minpoly.ne_zero hx')] at hy\n    use minpoly R x, minpoly.monic hx\n    rw [← aeval_def] at hy⊢\n    exact minpoly.aeval_of_is_scalar_tower R x y hy\n  · apply is_alg_closed.splits_codomain\n  · infer_instance\n#align is_integral_norm is_integral_norm\n\n"}