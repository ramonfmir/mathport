{"tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `henselian_local_ring.tfae [])\n      (Command.declSig\n       [(Term.explicitBinder \"(\" [`R] [\":\" (Term.type \"Type\" [`u])] [] \")\")\n        (Term.instBinder \"[\" [] (Term.app `CommRing [`R]) \"]\")\n        (Term.instBinder \"[\" [] (Term.app `local_ring [`R]) \"]\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `henselian_local_ring [`R])\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder \"(\" [`f] [\":\" (Term.app `polynomial [`R])] [] \")\")\n              (Term.explicitBinder \"(\" [`hf] [\":\" (Term.proj `f \".\" `monic)] [] \")\")\n              (Term.explicitBinder \"(\" [`a₀] [\":\" (Term.app `residue_field [`R])] [] \")\")\n              (Term.explicitBinder \"(\" [`h₁] [\":\" («term_=_» (Term.app `aeval [`a₀ `f]) \"=\" (num \"0\"))] [] \")\")\n              (Term.explicitBinder\n               \"(\"\n               [`h₂]\n               [\":\" («term_≠_» (Term.app `aeval [`a₀ (Term.proj `f \".\" `derivative)]) \"≠\" (num \"0\"))]\n               []\n               \")\")]\n             []\n             \",\"\n             («term∃_,_»\n              \"∃\"\n              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `a)] [\":\" `R]))\n              \",\"\n              («term_∧_»\n               (Term.app (Term.proj `f \".\" `is_root) [`a])\n               \"∧\"\n               («term_=_» (Term.app `residue [`R `a]) \"=\" `a₀))))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.implicitBinder \"{\" [`K] [\":\" (Term.type \"Type\" [`u])] \"}\")\n              (Term.instBinder \"[\" [] (Term.app `Field [`K]) \"]\")]\n             []\n             \",\"\n             (Term.forall\n              \"∀\"\n              [(Term.explicitBinder \"(\" [`φ] [\":\" (Term.app `«expr →+* » [`R `K])] [] \")\")\n               (Term.explicitBinder \"(\" [`hφ] [\":\" (Term.app `surjective [`φ])] [] \")\")\n               (Term.explicitBinder \"(\" [`f] [\":\" (Term.app `polynomial [`R])] [] \")\")\n               (Term.explicitBinder \"(\" [`hf] [\":\" (Term.proj `f \".\" `monic)] [] \")\")\n               (Term.explicitBinder \"(\" [`a₀] [\":\" `K] [] \")\")\n               (Term.explicitBinder\n                \"(\"\n                [`h₁]\n                [\":\" («term_=_» (Term.app (Term.proj `f \".\" `eval₂) [`φ `a₀]) \"=\" (num \"0\"))]\n                []\n                \")\")\n               (Term.explicitBinder\n                \"(\"\n                [`h₂]\n                [\":\" («term_≠_» (Term.app `f.derivative.eval₂ [`φ `a₀]) \"≠\" (num \"0\"))]\n                []\n                \")\")]\n              []\n              \",\"\n              («term∃_,_»\n               \"∃\"\n               (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `a)] [\":\" `R]))\n               \",\"\n               («term_∧_» (Term.app (Term.proj `f \".\" `is_root) [`a]) \"∧\" («term_=_» (Term.app `φ [`a]) \"=\" `a₀)))))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [`_3_2 \":\"] (num \"3\") \"→\" (num \"2\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H])\n             []\n             (Tactic.exact \"exact\" (Term.app `H [(Term.app `residue [`R]) `ideal.quotient.mk_surjective]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [`_2_1 \":\"] (num \"2\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H])\n             []\n             (Tactic.constructor \"constructor\")\n             []\n             (Tactic.intro \"intro\" [`f `hf `a₀ `h₁ `h₂])\n             []\n             (Tactic.specialize \"specialize\" (Term.app `H [`f `hf (Term.app `residue [`R `a₀])]))\n             []\n             (Tactic.tacticHave_\n              \"have\"\n              (Term.haveDecl (Term.haveIdDecl [`aux []] [] \":=\" (Term.app `flip [`mem_nonunits_iff.mp `h₂]))))\n             []\n             (Tactic.simp\n              \"simp\"\n              []\n              []\n              [\"only\"]\n              [\"[\"\n               [(Tactic.simpLemma [] [] `aeval_def)\n                \",\"\n                (Tactic.simpLemma [] [] `residue_field.algebra_map_eq)\n                \",\"\n                (Tactic.simpLemma [] [] `eval₂_at_apply)\n                \",\"\n                (Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `ideal.quotient.eq_zero_iff_mem)\n                \",\"\n                (Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `local_ring.mem_maximal_ideal)]\n               \"]\"]\n              [(Tactic.location \"at\" (Tactic.locationHyp [`H `h₁ `aux] []))])\n             []\n             (Std.Tactic.obtain\n              \"obtain\"\n              [(Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₁)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₂)])\n                    [])]\n                  \"⟩\")])]\n              []\n              [\":=\" [(Term.app `H [`h₁ `aux])]])\n             []\n             (Tactic.refine' \"refine'\" (Term.anonymousCtor \"⟨\" [`a \",\" `ha₁ \",\" (Term.hole \"_\")] \"⟩\"))\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.quotient.eq_zero_iff_mem)]\n               \"]\")\n              [])\n             []\n             (Std.Tactic.tacticRwa__\n              \"rwa\"\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `sub_eq_zero)\n                \",\"\n                (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `RingHom.map_sub)]\n               \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`ha₂] []))])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [`_1_3 \":\"] (num \"1\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`hR `K `_K `φ `hφ `f `hf `a₀ `h₁ `h₂])\n             []\n             (Std.Tactic.obtain\n              \"obtain\"\n              [(Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a₀)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                    [])]\n                  \"⟩\")])]\n              []\n              [\":=\" [(Term.app `hφ [`a₀])]])\n             []\n             (Tactic.tacticHave_\n              \"have\"\n              (Term.haveDecl\n               (Term.haveIdDecl [`H []] [] \":=\" (Term.app `henselian_local_ring.is_henselian [`f `hf `a₀]))))\n             []\n             (Tactic.simp\n              \"simp\"\n              []\n              []\n              [\"only\"]\n              [\"[\"\n               [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] (Term.app `ker_eq_maximal_ideal [`φ `hφ]))\n                \",\"\n                (Tactic.simpLemma [] [] `eval₂_at_apply)\n                \",\"\n                (Tactic.simpLemma [] [] `φ.mem_ker)]\n               \"]\"]\n              [(Tactic.location \"at\" (Tactic.locationHyp [`H `h₁ `h₂] []))])\n             []\n             (Std.Tactic.obtain\n              \"obtain\"\n              [(Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₁)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₂)])\n                    [])]\n                  \"⟩\")])]\n              []\n              [\":=\" [(Term.app `H [`h₁ (Term.hole \"_\")])]])\n             []\n             (tactic__\n              (cdotTk (patternIgnore (token.«· » \"·\")))\n              [(Tactic.refine' \"refine'\" (Term.anonymousCtor \"⟨\" [`a \",\" `ha₁ \",\" (Term.hole \"_\")] \"⟩\"))\n               []\n               (Std.Tactic.tacticRwa__\n                \"rwa\"\n                (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `φ.map_sub) \",\" (Tactic.rwRule [] `sub_eq_zero)] \"]\")\n                [(Tactic.location \"at\" (Tactic.locationHyp [`ha₂] []))])])\n             []\n             (tactic__\n              (cdotTk (patternIgnore (token.«· » \"·\")))\n              [(Mathlib.Tactic.Contrapose.contrapose! \"contrapose!\" [`h₂ []])\n               []\n               (Std.Tactic.tacticRwa__\n                \"rwa\"\n                (Tactic.rwRuleSeq\n                 \"[\"\n                 [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `mem_nonunits_iff)\n                  \",\"\n                  (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `local_ring.mem_maximal_ideal)\n                  \",\"\n                  (Tactic.rwRule\n                   [(patternIgnore (token.«← » \"←\"))]\n                   (Term.app `local_ring.ker_eq_maximal_ideal [`φ `hφ]))\n                  \",\"\n                  (Tactic.rwRule [] `φ.mem_ker)]\n                 \"]\")\n                [(Tactic.location \"at\" (Tactic.locationHyp [`h₂] []))])])])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [`_3_2 \":\"] (num \"3\") \"→\" (num \"2\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.exact \"exact\" (Term.app `H [(Term.app `residue [`R]) `ideal.quotient.mk_surjective]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [`_2_1 \":\"] (num \"2\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.constructor \"constructor\")\n            []\n            (Tactic.intro \"intro\" [`f `hf `a₀ `h₁ `h₂])\n            []\n            (Tactic.specialize \"specialize\" (Term.app `H [`f `hf (Term.app `residue [`R `a₀])]))\n            []\n            (Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl (Term.haveIdDecl [`aux []] [] \":=\" (Term.app `flip [`mem_nonunits_iff.mp `h₂]))))\n            []\n            (Tactic.simp\n             \"simp\"\n             []\n             []\n             [\"only\"]\n             [\"[\"\n              [(Tactic.simpLemma [] [] `aeval_def)\n               \",\"\n               (Tactic.simpLemma [] [] `residue_field.algebra_map_eq)\n               \",\"\n               (Tactic.simpLemma [] [] `eval₂_at_apply)\n               \",\"\n               (Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `ideal.quotient.eq_zero_iff_mem)\n               \",\"\n               (Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `local_ring.mem_maximal_ideal)]\n              \"]\"]\n             [(Tactic.location \"at\" (Tactic.locationHyp [`H `h₁ `aux] []))])\n            []\n            (Std.Tactic.obtain\n             \"obtain\"\n             [(Std.Tactic.RCases.rcasesPatMed\n               [(Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₁)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₂)])\n                   [])]\n                 \"⟩\")])]\n             []\n             [\":=\" [(Term.app `H [`h₁ `aux])]])\n            []\n            (Tactic.refine' \"refine'\" (Term.anonymousCtor \"⟨\" [`a \",\" `ha₁ \",\" (Term.hole \"_\")] \"⟩\"))\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `ideal.quotient.eq_zero_iff_mem)]\n              \"]\")\n             [])\n            []\n            (Std.Tactic.tacticRwa__\n             \"rwa\"\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `sub_eq_zero)\n               \",\"\n               (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `RingHom.map_sub)]\n              \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`ha₂] []))])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [`_1_3 \":\"] (num \"1\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`hR `K `_K `φ `hφ `f `hf `a₀ `h₁ `h₂])\n            []\n            (Std.Tactic.obtain\n             \"obtain\"\n             [(Std.Tactic.RCases.rcasesPatMed\n               [(Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a₀)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                   [])]\n                 \"⟩\")])]\n             []\n             [\":=\" [(Term.app `hφ [`a₀])]])\n            []\n            (Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl\n              (Term.haveIdDecl [`H []] [] \":=\" (Term.app `henselian_local_ring.is_henselian [`f `hf `a₀]))))\n            []\n            (Tactic.simp\n             \"simp\"\n             []\n             []\n             [\"only\"]\n             [\"[\"\n              [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] (Term.app `ker_eq_maximal_ideal [`φ `hφ]))\n               \",\"\n               (Tactic.simpLemma [] [] `eval₂_at_apply)\n               \",\"\n               (Tactic.simpLemma [] [] `φ.mem_ker)]\n              \"]\"]\n             [(Tactic.location \"at\" (Tactic.locationHyp [`H `h₁ `h₂] []))])\n            []\n            (Std.Tactic.obtain\n             \"obtain\"\n             [(Std.Tactic.RCases.rcasesPatMed\n               [(Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₁)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₂)])\n                   [])]\n                 \"⟩\")])]\n             []\n             [\":=\" [(Term.app `H [`h₁ (Term.hole \"_\")])]])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Tactic.refine' \"refine'\" (Term.anonymousCtor \"⟨\" [`a \",\" `ha₁ \",\" (Term.hole \"_\")] \"⟩\"))\n              []\n              (Std.Tactic.tacticRwa__\n               \"rwa\"\n               (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `φ.map_sub) \",\" (Tactic.rwRule [] `sub_eq_zero)] \"]\")\n               [(Tactic.location \"at\" (Tactic.locationHyp [`ha₂] []))])])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Mathlib.Tactic.Contrapose.contrapose! \"contrapose!\" [`h₂ []])\n              []\n              (Std.Tactic.tacticRwa__\n               \"rwa\"\n               (Tactic.rwRuleSeq\n                \"[\"\n                [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `mem_nonunits_iff)\n                 \",\"\n                 (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `local_ring.mem_maximal_ideal)\n                 \",\"\n                 (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] (Term.app `local_ring.ker_eq_maximal_ideal [`φ `hφ]))\n                 \",\"\n                 (Tactic.rwRule [] `φ.mem_ker)]\n                \"]\")\n               [(Tactic.location \"at\" (Tactic.locationHyp [`h₂] []))])])])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.intro \"intro\" [`hR `K `_K `φ `hφ `f `hf `a₀ `h₁ `h₂])\n        []\n        (Std.Tactic.obtain\n         \"obtain\"\n         [(Std.Tactic.RCases.rcasesPatMed\n           [(Std.Tactic.RCases.rcasesPat.tuple\n             \"⟨\"\n             [(Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a₀)])\n               [])\n              \",\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n               [])]\n             \"⟩\")])]\n         []\n         [\":=\" [(Term.app `hφ [`a₀])]])\n        []\n        (Tactic.tacticHave_\n         \"have\"\n         (Term.haveDecl (Term.haveIdDecl [`H []] [] \":=\" (Term.app `henselian_local_ring.is_henselian [`f `hf `a₀]))))\n        []\n        (Tactic.simp\n         \"simp\"\n         []\n         []\n         [\"only\"]\n         [\"[\"\n          [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] (Term.app `ker_eq_maximal_ideal [`φ `hφ]))\n           \",\"\n           (Tactic.simpLemma [] [] `eval₂_at_apply)\n           \",\"\n           (Tactic.simpLemma [] [] `φ.mem_ker)]\n          \"]\"]\n         [(Tactic.location \"at\" (Tactic.locationHyp [`H `h₁ `h₂] []))])\n        []\n        (Std.Tactic.obtain\n         \"obtain\"\n         [(Std.Tactic.RCases.rcasesPatMed\n           [(Std.Tactic.RCases.rcasesPat.tuple\n             \"⟨\"\n             [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)]) [])\n              \",\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₁)])\n               [])\n              \",\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₂)])\n               [])]\n             \"⟩\")])]\n         []\n         [\":=\" [(Term.app `H [`h₁ (Term.hole \"_\")])]])\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.«· » \"·\")))\n         [(Tactic.refine' \"refine'\" (Term.anonymousCtor \"⟨\" [`a \",\" `ha₁ \",\" (Term.hole \"_\")] \"⟩\"))\n          []\n          (Std.Tactic.tacticRwa__\n           \"rwa\"\n           (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `φ.map_sub) \",\" (Tactic.rwRule [] `sub_eq_zero)] \"]\")\n           [(Tactic.location \"at\" (Tactic.locationHyp [`ha₂] []))])])\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.«· » \"·\")))\n         [(Mathlib.Tactic.Contrapose.contrapose! \"contrapose!\" [`h₂ []])\n          []\n          (Std.Tactic.tacticRwa__\n           \"rwa\"\n           (Tactic.rwRuleSeq\n            \"[\"\n            [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `mem_nonunits_iff)\n             \",\"\n             (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `local_ring.mem_maximal_ideal)\n             \",\"\n             (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] (Term.app `local_ring.ker_eq_maximal_ideal [`φ `hφ]))\n             \",\"\n             (Tactic.rwRule [] `φ.mem_ker)]\n            \"]\")\n           [(Tactic.location \"at\" (Tactic.locationHyp [`h₂] []))])])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Mathlib.Tactic.Contrapose.contrapose! \"contrapose!\" [`h₂ []])\n        []\n        (Std.Tactic.tacticRwa__\n         \"rwa\"\n         (Tactic.rwRuleSeq\n          \"[\"\n          [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `mem_nonunits_iff)\n           \",\"\n           (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `local_ring.mem_maximal_ideal)\n           \",\"\n           (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] (Term.app `local_ring.ker_eq_maximal_ideal [`φ `hφ]))\n           \",\"\n           (Tactic.rwRule [] `φ.mem_ker)]\n          \"]\")\n         [(Tactic.location \"at\" (Tactic.locationHyp [`h₂] []))])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.tacticRwa__\n       \"rwa\"\n       (Tactic.rwRuleSeq\n        \"[\"\n        [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `mem_nonunits_iff)\n         \",\"\n         (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `local_ring.mem_maximal_ideal)\n         \",\"\n         (Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] (Term.app `local_ring.ker_eq_maximal_ideal [`φ `hφ]))\n         \",\"\n         (Tactic.rwRule [] `φ.mem_ker)]\n        \"]\")\n       [(Tactic.location \"at\" (Tactic.locationHyp [`h₂] []))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h₂\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `φ.mem_ker\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `local_ring.ker_eq_maximal_ideal [`φ `hφ])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hφ\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `φ\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `local_ring.ker_eq_maximal_ideal\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `local_ring.mem_maximal_ideal\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `mem_nonunits_iff\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Mathlib.Tactic.Contrapose.contrapose! \"contrapose!\" [`h₂ []])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.refine' \"refine'\" (Term.anonymousCtor \"⟨\" [`a \",\" `ha₁ \",\" (Term.hole \"_\")] \"⟩\"))\n        []\n        (Std.Tactic.tacticRwa__\n         \"rwa\"\n         (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `φ.map_sub) \",\" (Tactic.rwRule [] `sub_eq_zero)] \"]\")\n         [(Tactic.location \"at\" (Tactic.locationHyp [`ha₂] []))])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.tacticRwa__\n       \"rwa\"\n       (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `φ.map_sub) \",\" (Tactic.rwRule [] `sub_eq_zero)] \"]\")\n       [(Tactic.location \"at\" (Tactic.locationHyp [`ha₂] []))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `ha₂\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `sub_eq_zero\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `φ.map_sub\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine' \"refine'\" (Term.anonymousCtor \"⟨\" [`a \",\" `ha₁ \",\" (Term.hole \"_\")] \"⟩\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"⟨\" [`a \",\" `ha₁ \",\" (Term.hole \"_\")] \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `ha₁\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `a\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.obtain\n       \"obtain\"\n       [(Std.Tactic.RCases.rcasesPatMed\n         [(Std.Tactic.RCases.rcasesPat.tuple\n           \"⟨\"\n           [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)]) [])\n            \",\"\n            (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₁)]) [])\n            \",\"\n            (Std.Tactic.RCases.rcasesPatLo\n             (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ha₂)])\n             [])]\n           \"⟩\")])]\n       []\n       [\":=\" [(Term.app `H [`h₁ (Term.hole \"_\")])]])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `H [`h₁ (Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      `h₁\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.simp\n       \"simp\"\n       []\n       []\n       [\"only\"]\n       [\"[\"\n        [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] (Term.app `ker_eq_maximal_ideal [`φ `hφ]))\n         \",\"\n         (Tactic.simpLemma [] [] `eval₂_at_apply)\n         \",\"\n         (Tactic.simpLemma [] [] `φ.mem_ker)]\n        \"]\"]\n       [(Tactic.location \"at\" (Tactic.locationHyp [`H `h₁ `h₂] []))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h₂\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `h₁\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `φ.mem_ker\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `eval₂_at_apply\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `ker_eq_maximal_ideal [`φ `hφ])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hφ\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `φ\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `ker_eq_maximal_ideal\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticHave_\n       \"have\"\n       (Term.haveDecl (Term.haveIdDecl [`H []] [] \":=\" (Term.app `henselian_local_ring.is_henselian [`f `hf `a₀]))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `henselian_local_ring.is_henselian [`f `hf `a₀])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `a₀\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hf\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `henselian_local_ring.is_henselian\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.obtain\n       \"obtain\"\n       [(Std.Tactic.RCases.rcasesPatMed\n         [(Std.Tactic.RCases.rcasesPat.tuple\n           \"⟨\"\n           [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a₀)]) [])\n            \",\"\n            (Std.Tactic.RCases.rcasesPatLo\n             (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n             [])]\n           \"⟩\")])]\n       []\n       [\":=\" [(Term.app `hφ [`a₀])]])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `hφ [`a₀])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `a₀\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `hφ\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`hR `K `_K `φ `hφ `f `hf `a₀ `h₁ `h₂])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h₂\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `h₁\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `a₀\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hf\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hφ\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `φ\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `_K\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `K\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hR\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [`_1_3 \":\"] (num \"1\") \"→\" (num \"3\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  henselian_local_ring.tfae\n  ( R : Type u ) [ CommRing R ] [ local_ring R ]\n    :\n      TFAE\n        [\n          henselian_local_ring R\n            ,\n            ∀\n              ( f : polynomial R )\n                ( hf : f . monic )\n                ( a₀ : residue_field R )\n                ( h₁ : aeval a₀ f = 0 )\n                ( h₂ : aeval a₀ f . derivative ≠ 0 )\n              ,\n              ∃ a : R , f . is_root a ∧ residue R a = a₀\n            ,\n            ∀\n              { K : Type u } [ Field K ]\n              ,\n              ∀\n                ( φ : «expr →+* » R K )\n                  ( hφ : surjective φ )\n                  ( f : polynomial R )\n                  ( hf : f . monic )\n                  ( a₀ : K )\n                  ( h₁ : f . eval₂ φ a₀ = 0 )\n                  ( h₂ : f.derivative.eval₂ φ a₀ ≠ 0 )\n                ,\n                ∃ a : R , f . is_root a ∧ φ a = a₀\n          ]\n  :=\n    by\n      tfae_have _3_2 : 3 → 2\n        ;\n        · intro H exact H residue R ideal.quotient.mk_surjective\n        tfae_have _2_1 : 2 → 1\n        ·\n          intro H\n            constructor\n            intro f hf a₀ h₁ h₂\n            specialize H f hf residue R a₀\n            have aux := flip mem_nonunits_iff.mp h₂\n            simp\n              only\n              [\n                aeval_def\n                  ,\n                  residue_field.algebra_map_eq\n                  ,\n                  eval₂_at_apply\n                  ,\n                  ← ideal.quotient.eq_zero_iff_mem\n                  ,\n                  ← local_ring.mem_maximal_ideal\n                ]\n              at H h₁ aux\n            obtain ⟨ a , ha₁ , ha₂ ⟩ := H h₁ aux\n            refine' ⟨ a , ha₁ , _ ⟩\n            rw [ ← ideal.quotient.eq_zero_iff_mem ]\n            rwa [ ← sub_eq_zero , ← RingHom.map_sub ] at ha₂\n        tfae_have _1_3 : 1 → 3\n        ·\n          intro hR K _K φ hφ f hf a₀ h₁ h₂\n            obtain ⟨ a₀ , rfl ⟩ := hφ a₀\n            have H := henselian_local_ring.is_henselian f hf a₀\n            simp only [ ← ker_eq_maximal_ideal φ hφ , eval₂_at_apply , φ.mem_ker ] at H h₁ h₂\n            obtain ⟨ a , ha₁ , ha₂ ⟩ := H h₁ _\n            · refine' ⟨ a , ha₁ , _ ⟩ rwa [ φ.map_sub , sub_eq_zero ] at ha₂\n            ·\n              contrapose! h₂\n                rwa\n                  [\n                    ← mem_nonunits_iff\n                      ,\n                      ← local_ring.mem_maximal_ideal\n                      ,\n                      ← local_ring.ker_eq_maximal_ideal φ hφ\n                      ,\n                      φ.mem_ker\n                    ]\n                  at h₂\n        tfae_finish\n#align henselian_local_ring.tfae henselian_local_ring.tfae\n\n",
 "is_local_ring_hom_of_le_jacobson_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-\nCopyright (c) 2021 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem is_local_ring_hom_of_le_jacobson_bot {R : Type _} [CommRing R] (I : ideal R)\n    (h : I ≤ ideal.jacobson («expr⊥»)) : is_local_ring_hom (ideal.quotient.mk I) :=\n  by\n  constructor\n  intro a h\n  have : is_unit (ideal.quotient.mk (ideal.jacobson («expr⊥»)) a) :=\n    by\n    rw [isUnit_iff_exists_inv] at *\n    obtain ⟨b, hb⟩ := h\n    obtain ⟨b, rfl⟩ := ideal.quotient.mk_surjective b\n    use ideal.quotient.mk _ b\n    rw [← (ideal.quotient.mk _).map_one, ← (ideal.quotient.mk _).map_mul, ideal.quotient.eq] at hb⊢\n    exact h hb\n  obtain ⟨⟨x, y, h1, h2⟩, rfl : x = _⟩ := this\n  obtain ⟨y, rfl⟩ := ideal.quotient.mk_surjective y\n  rw [← (ideal.quotient.mk _).map_mul, ← (ideal.quotient.mk _).map_one, ideal.quotient.eq, ideal.mem_jacobson_bot] at\n    h1 h2\n  specialize h1 1\n  simp at h1\n  exact h1.1\n#align is_local_ring_hom_of_le_jacobson_bot is_local_ring_hom_of_le_jacobson_bot\n\n"}