{"tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n-- see Note [lower instance priority]\ntheorem henselian_local_ring.tfae (R : Type u) [CommRing R] [local_ring R] :\n    TFAE\n      [henselian_local_ring R,\n        ∀ (f : polynomial R) (hf : f.monic) (a₀ : residue_field R) (h₁ : aeval a₀ f = 0)\n          (h₂ : aeval a₀ f.derivative ≠ 0), ∃ a : R, f.is_root a ∧ residue R a = a₀,\n        ∀ {K : Type u} [Field K],\n          ∀ (φ : «expr →+* » R K) (hφ : surjective φ) (f : polynomial R) (hf : f.monic) (a₀ : K) (h₁ : f.eval₂ φ a₀ = 0)\n            (h₂ : f.derivative.eval₂ φ a₀ ≠ 0), ∃ a : R, f.is_root a ∧ φ a = a₀] :=\n  by\n  tfae_have _3_2 : 3 → 2;\n  · intro H\n    exact H (residue R) Ideal.Quotient.mk_surjective\n  tfae_have _2_1 : 2 → 1\n  · intro H\n    constructor\n    intro f hf a₀ h₁ h₂\n    specialize H f hf (residue R a₀)\n    have aux := flip mem_nonunits_iff.mp h₂\n    simp only [aeval_def, residue_field.algebra_map_eq, eval₂_at_apply, ← Ideal.Quotient.eq_zero_iff_mem, ←\n      local_ring.mem_maximal_ideal] at H h₁ aux\n    obtain ⟨a, ha₁, ha₂⟩ := H h₁ aux\n    refine' ⟨a, ha₁, _⟩\n    rw [← Ideal.Quotient.eq_zero_iff_mem]\n    rwa [← sub_eq_zero, ← RingHom.map_sub] at ha₂\n  tfae_have _1_3 : 1 → 3\n  · intro hR K _K φ hφ f hf a₀ h₁ h₂\n    obtain ⟨a₀, rfl⟩ := hφ a₀\n    have H := henselian_local_ring.is_henselian f hf a₀\n    simp only [← ker_eq_maximal_ideal φ hφ, eval₂_at_apply, φ.mem_ker] at H h₁ h₂\n    obtain ⟨a, ha₁, ha₂⟩ := H h₁ _\n    · refine' ⟨a, ha₁, _⟩\n      rwa [φ.map_sub, sub_eq_zero] at ha₂\n    · contrapose! h₂\n      rwa [← mem_nonunits_iff, ← local_ring.mem_maximal_ideal, ← local_ring.ker_eq_maximal_ideal φ hφ, φ.mem_ker] at h₂\n  tfae_finish\n#align henselian_local_ring.tfae henselian_local_ring.tfae\n\n",
 "is_local_ring_hom_of_le_jacobson_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-\nCopyright (c) 2021 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem is_local_ring_hom_of_le_jacobson_bot {R : Type _} [CommRing R] (I : Ideal R)\n    (h : I ≤ ideal.jacobson («expr⊥»)) : is_local_ring_hom (Ideal.Quotient.mk I) :=\n  by\n  constructor\n  intro a h\n  have : IsUnit (Ideal.Quotient.mk (ideal.jacobson («expr⊥»)) a) :=\n    by\n    rw [isUnit_iff_exists_inv] at *\n    obtain ⟨b, hb⟩ := h\n    obtain ⟨b, rfl⟩ := Ideal.Quotient.mk_surjective b\n    use Ideal.Quotient.mk _ b\n    rw [← (Ideal.Quotient.mk _).map_one, ← (Ideal.Quotient.mk _).map_mul, Ideal.Quotient.eq] at hb⊢\n    exact h hb\n  obtain ⟨⟨x, y, h1, h2⟩, rfl : x = _⟩ := this\n  obtain ⟨y, rfl⟩ := Ideal.Quotient.mk_surjective y\n  rw [← (Ideal.Quotient.mk _).map_mul, ← (Ideal.Quotient.mk _).map_one, Ideal.Quotient.eq, ideal.mem_jacobson_bot] at\n    h1 h2\n  specialize h1 1\n  simp at h1\n  exact h1.1\n#align is_local_ring_hom_of_le_jacobson_bot is_local_ring_hom_of_le_jacobson_bot\n\n"}