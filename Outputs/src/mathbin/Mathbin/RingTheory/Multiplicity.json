{"zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\nprotected theorem zero (a : α) : multiplicity a 0 = «expr⊤» :=\n  Part.eq_none_iff.2 fun n ⟨⟨k, hk⟩, _⟩ => hk (dvd_zero _)\n#align zero zero\n\n",
 "unit_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem unit_right {a : α} (ha : ¬is_unit a) (u : «expr ˣ» α) : multiplicity a u = 0 :=\n  is_unit_right ha u.is_unit\n#align unit_right unit_right\n\n",
 "unit_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem unit_left (a : α) (u : «expr ˣ» α) : multiplicity (u : α) a = «expr⊤» :=\n  is_unit_left a u.is_unit\n#align unit_left unit_left\n\n",
 "unique'":
 "theorem unique' {a b : α} {k : ℕ} (hk : a ^ k ∣ b) (hsucc : ¬a ^ (k + 1) ∣ b) : k = get (multiplicity a b) ⟨k, hsucc⟩ :=\n  by rw [← part_enat.coe_inj, part_enat.coe_get, unique hk hsucc]\n#align unique' unique'\n\n",
 "unique":
 "theorem unique {a b : α} {k : ℕ} (hk : a ^ k ∣ b) (hsucc : ¬a ^ (k + 1) ∣ b) : (k : part_enat) = multiplicity a b :=\n  le_antisymm (le_of_not_gt fun hk' => is_greatest hk' hk) <|\n    by\n    have : finite a b := ⟨k, hsucc⟩\n    rw [part_enat.le_coe_iff]\n    exact ⟨this, nat.find_min' _ hsucc⟩\n#align unique unique\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem finset.prod {β : Type _} {p : α} (hp : Prime p) (s : Finset β) (f : β → α) :\n    multiplicity p\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (multiplicity p (f x)) :=\n  by\n  classical\n    induction' s using Finset.induction with a s has ih h\n    · simp only [finset.sum_empty, finset.prod_empty]\n      convert one_right hp.not_unit\n    · simp [has, ← ih]\n      convert multiplicity.mul hp\n#align finset.prod finset.prod\n\n",
 "pow_multiplicity_dvd":
 "theorem pow_multiplicity_dvd {a b : α} (h : finite a b) : a ^ get (multiplicity a b) h ∣ b :=\n  pow_dvd_of_le_multiplicity (by rw [part_enat.coe_get])\n#align pow_multiplicity_dvd pow_multiplicity_dvd\n\n",
 "pow_dvd_of_le_multiplicity":
 "theorem pow_dvd_of_le_multiplicity {a b : α} {k : ℕ} : (k : part_enat) ≤ multiplicity a b → a ^ k ∣ b :=\n  by\n  rw [← part_enat.some_eq_coe]\n  exact\n    nat.cases_on k\n      (fun _ => by\n        rw [pow_zero]\n        exact one_dvd _)\n      fun k ⟨h₁, h₂⟩ => by_contradiction fun hk => nat.find_min _ (lt_of_succ_le (h₂ ⟨k, hk⟩)) hk\n#align pow_dvd_of_le_multiplicity pow_dvd_of_le_multiplicity\n\n",
 "pow_dvd_iff_le_multiplicity":
 "theorem pow_dvd_iff_le_multiplicity {a b : α} {k : ℕ} : a ^ k ∣ b ↔ (k : part_enat) ≤ multiplicity a b :=\n  ⟨le_multiplicity_of_pow_dvd, pow_dvd_of_le_multiplicity⟩\n#align pow_dvd_iff_le_multiplicity pow_dvd_iff_le_multiplicity\n\n",
 "pow'":
 "protected theorem pow' {p a : α} (hp : Prime p) (ha : finite p a) :\n    ∀ {k : ℕ}, get (multiplicity p (a ^ k)) (finite_pow hp ha) = k * get (multiplicity p a) ha\n  | 0 => by simp [one_right hp.not_unit]\n  | k + 1 => by\n    have : multiplicity p (a ^ (k + 1)) = multiplicity p (a * a ^ k) := by rw [pow_succ]\n    rw [get_eq_get_of_eq _ _ this, multiplicity.mul' hp, pow', add_mul, one_mul, add_comm]\n#align pow' pow'\n\n",
 "pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem pow {p a : α} (hp : Prime p) : ∀ {k : ℕ}, multiplicity p (a ^ k) = «expr • » k (multiplicity p a)\n  | 0 => by simp [one_right hp.not_unit]\n  | succ k => by simp [pow_succ, succ_nsmul, pow, multiplicity.mul hp]\n#align pow pow\n\n",
 "pos_of_dvd":
 "theorem pos_of_dvd {a b : α} (hfin : finite a b) (hdiv : a ∣ b) : 0 < (multiplicity a b).get hfin :=\n  by\n  refine' zero_lt_iff.2 fun h => _\n  simpa [hdiv] using is_greatest' hfin (lt_one_iff.mpr h)\n#align pos_of_dvd pos_of_dvd\n\n",
 "one_right":
 "theorem one_right {a : α} (ha : ¬is_unit a) : multiplicity a 1 = 0 :=\n  is_unit_right ha isUnit_one\n#align one_right one_right\n\n",
 "one_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem one_left (b : α) : multiplicity 1 b = «expr⊤» :=\n  is_unit_left b isUnit_one\n#align one_left one_left\n\n",
 "not_unit_of_finite":
 "theorem not_unit_of_finite {a b : α} (h : finite a b) : ¬is_unit a :=\n  let ⟨n, hn⟩ := h\n  hn ∘ is_unit.dvd ∘ IsUnit.pow (n + 1)\n#align not_unit_of_finite not_unit_of_finite\n\n",
 "not_finite_iff_forall":
 "theorem not_finite_iff_forall {a b : α} : ¬finite a b ↔ ∀ n : ℕ, a ^ n ∣ b :=\n  ⟨fun h n =>\n    nat.cases_on n\n      (by\n        rw [pow_zero]\n        exact one_dvd _)\n      (by simpa [Finite, not_not] using h),\n    by simp [Finite, multiplicity, not_not] <;> tauto⟩\n#align not_finite_iff_forall not_finite_iff_forall\n\n",
 "not_dvd_one_of_finite_one_right":
 "theorem not_dvd_one_of_finite_one_right {a : α} : finite a 1 → ¬a ∣ 1 := fun ⟨n, hn⟩ ⟨d, hd⟩ =>\n  hn ⟨d ^ (n + 1), (pow_mul_pow_eq_one (n + 1) hd.symm).symm⟩\n#align not_dvd_one_of_finite_one_right not_dvd_one_of_finite_one_right\n\n",
 "neg":
 "@[simp]\nprotected theorem neg (a b : α) : multiplicity a (-b) = multiplicity a b :=\n  Part.ext' (by simp only [multiplicity, part_enat.find, dvd_neg]) fun h₁ h₂ =>\n    part_enat.coe_inj.1\n      (by\n        rw [part_enat.coe_get] <;>\n          exact\n            eq.symm\n              (unique ((dvd_neg _ _).2 (pow_multiplicity_dvd _))\n                (mt (dvd_neg _ _).1 (is_greatest' _ (lt_succ_self _)))))\n#align neg neg\n\n",
 "ne_zero_of_finite":
 "theorem ne_zero_of_finite {a b : α} (h : finite a b) : b ≠ 0 :=\n  let ⟨n, hn⟩ := h\n  fun hb => by simpa [hb] using hn\n#align ne_zero_of_finite ne_zero_of_finite\n\n",
 "ne_top_iff_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ne_top_iff_finite {a b : α} : multiplicity a b ≠ «expr⊤» ↔ finite a b := by\n  rw [ne.def, eq_top_iff_not_finite, not_not]\n#align ne_top_iff_finite ne_top_iff_finite\n\n",
 "natAbs":
 "#print Int.natAbs /-\ntheorem Int.natAbs (a : ℕ) (b : ℤ) : multiplicity a b.nat_abs = multiplicity (a : ℤ) b :=\n  by\n  cases' Int.natAbs_eq b with h h <;> conv_rhs => rw [h]\n  · rw [int.coe_nat_multiplicity]\n  · rw [multiplicity.neg, int.coe_nat_multiplicity]\n#align int.nat_abs Int.natAbs\n-/\n\n",
 "multiplicity_zero_eq_zero_of_ne_zero":
 "@[simp]\ntheorem multiplicity_zero_eq_zero_of_ne_zero (a : α) (ha : a ≠ 0) : multiplicity 0 a = 0 :=\n  multiplicity.multiplicity_eq_zero.2 <| mt zero_dvd_iff.1 ha\n#align multiplicity_zero_eq_zero_of_ne_zero multiplicity_zero_eq_zero_of_ne_zero\n\n",
 "multiplicity_sub_of_gt":
 "theorem multiplicity_sub_of_gt {p a b : α} (h : multiplicity p b < multiplicity p a) :\n    multiplicity p (a - b) = multiplicity p b := by\n  rw [sub_eq_add_neg, multiplicity_add_of_gt] <;> rwa [multiplicity.neg]\n#align multiplicity_sub_of_gt multiplicity_sub_of_gt\n\n",
 "multiplicity_self":
 "@[simp]\ntheorem multiplicity_self {a : α} (ha : ¬is_unit a) (ha0 : a ≠ 0) : multiplicity a a = 1 :=\n  by\n  rw [← Nat.cast_one]\n  exact\n    eq_coe_iff.2\n      ⟨by simp, fun ⟨b, hb⟩ =>\n        ha\n          (isUnit_iff_dvd_one.2\n            ⟨b,\n              mul_left_cancel₀ ha0 <| by\n                clear _fun_match\n                simpa [pow_succ, mul_assoc] using hb⟩)⟩\n#align multiplicity_self multiplicity_self\n\n",
 "multiplicity_pow_self_of_prime":
 "theorem multiplicity_pow_self_of_prime {p : α} (hp : Prime p) (n : ℕ) : multiplicity p (p ^ n) = n :=\n  multiplicity_pow_self hp.ne_zero hp.not_unit n\n#align multiplicity_pow_self_of_prime multiplicity_pow_self_of_prime\n\n",
 "multiplicity_pow_self":
 "theorem multiplicity_pow_self {p : α} (h0 : p ≠ 0) (hu : ¬is_unit p) (n : ℕ) : multiplicity p (p ^ n) = n :=\n  by\n  rw [eq_coe_iff]\n  use dvd_rfl\n  rw [pow_dvd_pow_iff h0 hu]\n  apply nat.not_succ_le_self\n#align multiplicity_pow_self multiplicity_pow_self\n\n",
 "multiplicity_mk_eq_multiplicity":
 "theorem multiplicity_mk_eq_multiplicity [decidable_rel ((· ∣ ·) : Associates α → Associates α → Prop)] {a b : α} :\n    multiplicity (Associates.mk a) (Associates.mk b) = multiplicity a b :=\n  by\n  by_cases h : Finite a b\n  · rw [← part_enat.coe_get (finite_iff_dom.mp h)]\n    refine' (multiplicity.unique (show Associates.mk a ^ (multiplicity a b).get h ∣ Associates.mk b from _) _).symm <;>\n      rw [← Associates.mk_pow, Associates.mk_dvd_mk]\n    · exact pow_multiplicity_dvd h\n    · exact IsGreatest ((part_enat.lt_coe_iff _ _).mpr (exists.intro (finite_iff_dom.mp h) (nat.lt_succ_self _)))\n  · suffices ¬Finite (Associates.mk a) (Associates.mk b)\n      by\n      rw [finite_iff_dom, part_enat.not_dom_iff_eq_top] at h this\n      rw [h, this]\n    refine'\n      not_finite_iff_forall.mpr fun n =>\n        by\n        rw [← Associates.mk_pow, Associates.mk_dvd_mk]\n        exact not_finite_iff_forall.mp h n\n#align multiplicity_mk_eq_multiplicity multiplicity_mk_eq_multiplicity\n\n",
 "multiplicity_lt_iff_neg_dvd":
 "theorem multiplicity_lt_iff_neg_dvd {a b : α} {k : ℕ} : multiplicity a b < (k : part_enat) ↔ ¬a ^ k ∣ b := by\n  rw [pow_dvd_iff_le_multiplicity, not_le]\n#align multiplicity_lt_iff_neg_dvd multiplicity_lt_iff_neg_dvd\n\n",
 "multiplicity_le_multiplicity_of_dvd_right":
 "theorem multiplicity_le_multiplicity_of_dvd_right {a b c : α} (h : b ∣ c) : multiplicity a b ≤ multiplicity a c :=\n  multiplicity_le_multiplicity_iff.2 fun n hb => hb.trans h\n#align multiplicity_le_multiplicity_of_dvd_right multiplicity_le_multiplicity_of_dvd_right\n\n",
 "multiplicity_le_multiplicity_of_dvd_left":
 "theorem multiplicity_le_multiplicity_of_dvd_left {a b c : α} (hdvd : a ∣ b) : multiplicity b c ≤ multiplicity a c :=\n  multiplicity_le_multiplicity_iff.2 fun n h => (pow_dvd_pow_of_dvd hdvd n).trans h\n#align multiplicity_le_multiplicity_of_dvd_left multiplicity_le_multiplicity_of_dvd_left\n\n",
 "multiplicity_le_multiplicity_iff":
 "theorem multiplicity_le_multiplicity_iff {a b c d : α} :\n    multiplicity a b ≤ multiplicity c d ↔ ∀ n : ℕ, a ^ n ∣ b → c ^ n ∣ d :=\n  ⟨fun h n hab => pow_dvd_of_le_multiplicity (le_trans (le_multiplicity_of_pow_dvd hab) h), fun h =>\n    if hab : finite a b then by\n      rw [← part_enat.coe_get (finite_iff_dom.1 hab)] <;>\n        exact le_multiplicity_of_pow_dvd (h _ (pow_multiplicity_dvd _))\n    else by\n      have : ∀ n : ℕ, c ^ n ∣ d := fun n => h n (not_finite_iff_forall.1 hab _)\n      rw [eq_top_iff_not_finite.2 hab, eq_top_iff_not_finite.2 (not_finite_iff_forall.2 this)]⟩\n#align multiplicity_le_multiplicity_iff multiplicity_le_multiplicity_iff\n\n",
 "multiplicity_eq_zero_of_coprime":
 "theorem multiplicity_eq_zero_of_coprime {p a b : ℕ} (hp : p ≠ 1) (hle : multiplicity p a ≤ multiplicity p b)\n    (hab : nat.coprime a b) : multiplicity p a = 0 :=\n  by\n  rw [multiplicity_le_multiplicity_iff] at hle\n  rw [← nonpos_iff_eq_zero, ← not_lt, part_enat.pos_iff_one_le, ← Nat.cast_one, ← pow_dvd_iff_le_multiplicity]\n  intro h\n  have := nat.dvd_gcd h (hle _ h)\n  rw [coprime.gcd_eq_one hab, Nat.dvd_one, pow_one] at this\n  exact hp this\n#align multiplicity_eq_zero_of_coprime multiplicity_eq_zero_of_coprime\n\n",
 "multiplicity_eq_zero":
 "theorem multiplicity_eq_zero {a b : α} : multiplicity a b = 0 ↔ ¬a ∣ b :=\n  by\n  rw [← Nat.cast_zero, eq_coe_iff]\n  simp\n#align multiplicity_eq_zero multiplicity_eq_zero\n\n",
 "multiplicity_eq_multiplicity_iff":
 "theorem multiplicity_eq_multiplicity_iff {a b c d : α} :\n    multiplicity a b = multiplicity c d ↔ ∀ n : ℕ, a ^ n ∣ b ↔ c ^ n ∣ d :=\n  ⟨fun h n => ⟨multiplicity_le_multiplicity_iff.mp h.le n, multiplicity_le_multiplicity_iff.mp h.ge n⟩, fun h =>\n    le_antisymm (multiplicity_le_multiplicity_iff.mpr fun n => (h n).mp)\n      (multiplicity_le_multiplicity_iff.mpr fun n => (h n).mpr)⟩\n#align multiplicity_eq_multiplicity_iff multiplicity_eq_multiplicity_iff\n\n",
 "multiplicity_add_of_gt":
 "theorem multiplicity_add_of_gt {p a b : α} (h : multiplicity p b < multiplicity p a) :\n    multiplicity p (a + b) = multiplicity p b := by\n  apply le_antisymm\n  · apply part_enat.le_of_lt_add_one\n    cases' part_enat.ne_top_iff.mp (part_enat.ne_top_of_lt h) with k hk\n    rw [hk]\n    rw_mod_cast [multiplicity_lt_iff_neg_dvd]\n    intro h_dvd\n    rw [← dvd_add_iff_right] at h_dvd\n    apply multiplicity.is_greatest _ h_dvd\n    rw [hk]\n    apply_mod_cast nat.lt_succ_self\n    rw [pow_dvd_iff_le_multiplicity, Nat.cast_add, ← hk, Nat.cast_one]\n    exact part_enat.add_one_le_of_lt h\n  · convert min_le_multiplicity_add\n    rw [min_eq_right (le_of_lt h)]\n#align multiplicity_add_of_gt multiplicity_add_of_gt\n\n",
 "multiplicity_add_eq_min":
 "theorem multiplicity_add_eq_min {p a b : α} (h : multiplicity p a ≠ multiplicity p b) :\n    multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b) :=\n  by\n  rcases lt_trichotomy (multiplicity p a) (multiplicity p b) with (hab | hab | hab)\n  · rw [add_comm, multiplicity_add_of_gt hab, min_eq_left]\n    exact le_of_lt hab\n  · contradiction\n  · rw [multiplicity_add_of_gt hab, min_eq_right]\n    exact le_of_lt hab\n#align multiplicity_add_eq_min multiplicity_add_eq_min\n\n",
 "mul'":
 "protected theorem mul' {p a b : α} (hp : Prime p) (h : (multiplicity p (a * b)).dom) :\n    get (multiplicity p (a * b)) h =\n      get (multiplicity p a) ((finite_mul_iff hp).1 h).1 + get (multiplicity p b) ((finite_mul_iff hp).1 h).2 :=\n  by\n  have hdiva : p ^ get (multiplicity p a) ((finite_mul_iff hp).1 h).1 ∣ a := pow_multiplicity_dvd _\n  have hdivb : p ^ get (multiplicity p b) ((finite_mul_iff hp).1 h).2 ∣ b := pow_multiplicity_dvd _\n  have hpoweq :\n    p ^ (get (multiplicity p a) ((finite_mul_iff hp).1 h).1 + get (multiplicity p b) ((finite_mul_iff hp).1 h).2) =\n      p ^ get (multiplicity p a) ((finite_mul_iff hp).1 h).1 * p ^ get (multiplicity p b) ((finite_mul_iff hp).1 h).2 :=\n    by simp [pow_add]\n  have hdiv :\n    p ^ (get (multiplicity p a) ((finite_mul_iff hp).1 h).1 + get (multiplicity p b) ((finite_mul_iff hp).1 h).2) ∣\n      a * b :=\n    by rw [hpoweq] <;> apply mul_dvd_mul <;> assumption\n  have hsucc :\n    ¬p ^ (get (multiplicity p a) ((finite_mul_iff hp).1 h).1 + get (multiplicity p b) ((finite_mul_iff hp).1 h).2 + 1) ∣\n        a * b :=\n    fun h =>\n    not_or_of_not (is_greatest' _ (lt_succ_self _)) (is_greatest' _ (lt_succ_self _))\n      (_root_.succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul hp hdiva hdivb h)\n  rw [← part_enat.coe_inj, part_enat.coe_get, eq_coe_iff] <;> exact ⟨hdiv, hsucc⟩\n#align mul' mul'\n\n",
 "mul":
 "protected theorem mul {p a b : α} (hp : Prime p) : multiplicity p (a * b) = multiplicity p a + multiplicity p b :=\n  if h : finite p a ∧ finite p b then by\n    rw [← part_enat.coe_get (finite_iff_dom.1 h.1), ← part_enat.coe_get (finite_iff_dom.1 h.2), ←\n        part_enat.coe_get (finite_iff_dom.1 (finite_mul hp h.1 h.2)), ← Nat.cast_add, part_enat.coe_inj,\n        multiplicity.mul' hp] <;>\n      rfl\n  else by\n    rw [eq_top_iff_not_finite.2 (mt (finite_mul_iff hp).1 h)]\n    cases' not_and_or.1 h with h h <;> simp [eq_top_iff_not_finite.2 h]\n#align mul mul\n\n",
 "min_le_multiplicity_add":
 "theorem min_le_multiplicity_add {p a b : α} : min (multiplicity p a) (multiplicity p b) ≤ multiplicity p (a + b) :=\n  (le_total (multiplicity p a) (multiplicity p b)).elim\n    (fun h => by\n      rw [min_eq_left h, multiplicity_le_multiplicity_iff] <;>\n        exact fun n hn => dvd_add hn (multiplicity_le_multiplicity_iff.1 h n hn))\n    fun h => by\n    rw [min_eq_right h, multiplicity_le_multiplicity_iff] <;>\n      exact fun n hn => dvd_add (multiplicity_le_multiplicity_iff.1 h n hn) hn\n#align min_le_multiplicity_add min_le_multiplicity_add\n\n",
 "lt_top_iff_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem lt_top_iff_finite {a b : α} : multiplicity a b < «expr⊤» ↔ finite a b := by\n  rw [lt_top_iff_ne_top, ne_top_iff_finite]\n#align lt_top_iff_finite lt_top_iff_finite\n\n",
 "le_multiplicity_of_pow_dvd":
 "theorem le_multiplicity_of_pow_dvd {a b : α} {k : ℕ} (hk : a ^ k ∣ b) : (k : part_enat) ≤ multiplicity a b :=\n  le_of_not_gt fun hk' => is_greatest hk' hk\n#align le_multiplicity_of_pow_dvd le_multiplicity_of_pow_dvd\n\n",
 "is_unit_right":
 "theorem is_unit_right {a b : α} (ha : ¬is_unit a) (hb : is_unit b) : multiplicity a b = 0 :=\n  eq_coe_iff.2\n    ⟨show a ^ 0 ∣ b by simp only [pow_zero, one_dvd], by\n      rw [pow_one]\n      exact fun h => mt (isUnit_of_dvd_unit h) ha hb⟩\n#align is_unit_right is_unit_right\n\n",
 "is_unit_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem is_unit_left {a : α} (b : α) (ha : is_unit a) : multiplicity a b = «expr⊤» :=\n  eq_top_iff.2 fun _ => is_unit.dvd (ha.pow _)\n#align is_unit_left is_unit_left\n\n",
 "is_greatest'":
 "theorem is_greatest' {a b : α} {m : ℕ} (h : finite a b) (hm : get (multiplicity a b) h < m) : ¬a ^ m ∣ b :=\n  is_greatest (by rwa [← part_enat.coe_lt_coe, part_enat.coe_get] at hm)\n#align is_greatest' is_greatest'\n\n",
 "get_one_right":
 "@[simp]\ntheorem get_one_right {a : α} (ha : finite a 1) : get (multiplicity a 1) ha = 0 :=\n  by\n  rw [part_enat.get_eq_iff_eq_coe, eq_coe_iff, pow_zero]\n  simp [not_dvd_one_of_finite_one_right ha]\n#align get_one_right get_one_right\n\n",
 "get_multiplicity_self":
 "@[simp]\ntheorem get_multiplicity_self {a : α} (ha : finite a a) : get (multiplicity a a) ha = 1 :=\n  part_enat.get_eq_iff_eq_coe.2\n    (eq_coe_iff.2\n      ⟨by simp, fun ⟨b, hb⟩ => by\n        rw [← mul_one a, pow_add, pow_one, mul_assoc, mul_assoc, mul_right_inj' (ne_zero_of_finite ha)] at hb <;>\n          exact mt isUnit_iff_dvd_one.2 (not_unit_of_finite ha) ⟨b, by clear _fun_match <;> simp_all⟩⟩)\n#align get_multiplicity_self get_multiplicity_self\n\n",
 "finite_pow":
 "theorem finite_pow {p a : α} (hp : Prime p) : ∀ {k : ℕ} (ha : finite p a), finite p (a ^ k)\n  | 0, ha => ⟨0, by simp [mt isUnit_iff_dvd_one.2 hp.2.1]⟩\n  | k + 1, ha => by rw [pow_succ] <;> exact finite_mul hp ha (finite_pow ha)\n#align finite_pow finite_pow\n\n",
 "finite_of_finite_mul_right":
 "theorem finite_of_finite_mul_right {a b c : α} : finite a (b * c) → finite a b := fun ⟨n, hn⟩ =>\n  ⟨n, fun h => hn (h.trans (dvd_mul_right _ _))⟩\n#align finite_of_finite_mul_right finite_of_finite_mul_right\n\n",
 "finite_of_finite_mul_left":
 "theorem finite_of_finite_mul_left {a b c : α} : finite a (b * c) → finite a c := by\n  rw [mul_comm] <;> exact finite_of_finite_mul_right\n#align finite_of_finite_mul_left finite_of_finite_mul_left\n\n",
 "finite_nat_iff":
 "theorem finite_nat_iff {a b : ℕ} : finite a b ↔ a ≠ 1 ∧ 0 < b :=\n  by\n  rw [← not_iff_not, not_finite_iff_forall, not_and_or, ne.def, not_not, not_lt, le_zero_iff]\n  exact\n    ⟨fun h =>\n      or_iff_not_imp_right.2 fun hb =>\n        have ha : a ≠ 0 := fun ha => by simpa [ha] using h 1\n        by_contradiction fun ha1 : a ≠ 1 =>\n          have ha_gt_one : 1 < a :=\n            lt_of_not_ge fun ha' => by\n              clear h\n              revert ha ha1\n              decide!\n          not_lt_of_ge (le_of_dvd (nat.pos_of_ne_zero hb) (h b)) (lt_pow_self ha_gt_one b),\n      fun h => by cases h <;> simp [*]⟩\n#align finite_nat_iff finite_nat_iff\n\n",
 "finite_mul_iff":
 "theorem finite_mul_iff {p a b : α} (hp : Prime p) : finite p (a * b) ↔ finite p a ∧ finite p b :=\n  ⟨fun h => ⟨finite_of_finite_mul_right h, finite_of_finite_mul_left h⟩, fun h => finite_mul hp h.1 h.2⟩\n#align finite_mul_iff finite_mul_iff\n\n",
 "finite_mul_aux":
 "theorem finite_mul_aux {p : α} (hp : Prime p) :\n    ∀ {n m : ℕ} {a b : α}, ¬p ^ (n + 1) ∣ a → ¬p ^ (m + 1) ∣ b → ¬p ^ (n + m + 1) ∣ a * b\n  | n, m => fun a b ha hb ⟨s, hs⟩ =>\n    have : p ∣ a * b := ⟨p ^ (n + m) * s, by simp [hs, pow_add, mul_comm, mul_assoc, mul_left_comm]⟩\n    (hp.2.2 a b this).elim\n      (fun ⟨x, hx⟩ =>\n        have hn0 : 0 < n := nat.pos_of_ne_zero fun hn0 => by clear _fun_match _fun_match <;> simpa [hx, hn0] using ha\n        have wf : n - 1 < n := tsub_lt_self hn0 (by decide)\n        have hpx : ¬p ^ (n - 1 + 1) ∣ x := fun ⟨y, hy⟩ =>\n          ha\n            (hx.symm ▸\n              ⟨y,\n                mul_right_cancel₀ hp.1 <| by\n                  rw [tsub_add_cancel_of_le (succ_le_of_lt hn0)] at hy <;>\n                    simp [hy, pow_add, mul_comm, mul_assoc, mul_left_comm]⟩)\n        have : 1 ≤ n + m := le_trans hn0 (nat.le_add_right n m)\n        finite_mul_aux hpx hb\n          ⟨s,\n            mul_right_cancel₀ hp.1\n              (by\n                rw [tsub_add_eq_add_tsub (succ_le_of_lt hn0), tsub_add_cancel_of_le this]\n                clear _fun_match _fun_match finite_mul_aux\n                simp_all [mul_comm, mul_assoc, mul_left_comm, pow_add])⟩)\n      fun ⟨x, hx⟩ =>\n      have hm0 : 0 < m := nat.pos_of_ne_zero fun hm0 => by clear _fun_match _fun_match <;> simpa [hx, hm0] using hb\n      have wf : m - 1 < m := tsub_lt_self hm0 (by decide)\n      have hpx : ¬p ^ (m - 1 + 1) ∣ x := fun ⟨y, hy⟩ =>\n        hb\n          (hx.symm ▸\n            ⟨y,\n              mul_right_cancel₀ hp.1 <| by\n                rw [tsub_add_cancel_of_le (succ_le_of_lt hm0)] at hy <;>\n                  simp [hy, pow_add, mul_comm, mul_assoc, mul_left_comm]⟩)\n      finite_mul_aux ha hpx\n        ⟨s,\n          mul_right_cancel₀ hp.1\n            (by\n              rw [add_assoc, tsub_add_cancel_of_le (succ_le_of_lt hm0)]\n              clear _fun_match _fun_match finite_mul_aux\n              simp_all [mul_comm, mul_assoc, mul_left_comm, pow_add])⟩\n#align finite_mul_aux finite_mul_aux\n\n",
 "finite_mul":
 "theorem finite_mul {p a b : α} (hp : Prime p) : finite p a → finite p b → finite p (a * b) := fun ⟨n, hn⟩ ⟨m, hm⟩ =>\n  ⟨n + m, finite_mul_aux hp hn hm⟩\n#align finite_mul finite_mul\n\n",
 "finite_iff_dom":
 "/-\nCopyright (c) 2018 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Chris Hughes\n-/\ntheorem finite_iff_dom [decidable_rel ((· ∣ ·) : α → α → Prop)] {a b : α} : finite a b ↔ (multiplicity a b).dom :=\n  iff.rfl\n#align finite_iff_dom finite_iff_dom\n\n",
 "finite_def":
 "theorem finite_def {a b : α} : finite a b ↔ ∃ n : ℕ, ¬a ^ (n + 1) ∣ b :=\n  iff.rfl\n#align finite_def finite_def\n\n",
 "exists_eq_pow_mul_and_not_dvd":
 "theorem exists_eq_pow_mul_and_not_dvd {a b : α} (hfin : finite a b) :\n    ∃ c : α, b = a ^ (multiplicity a b).get hfin * c ∧ ¬a ∣ c :=\n  by\n  obtain ⟨c, hc⟩ := multiplicity.pow_multiplicity_dvd hfin\n  refine' ⟨c, hc, _⟩\n  rintro ⟨k, hk⟩\n  rw [hk, ← mul_assoc, ← pow_succ'] at hc\n  have h₁ : a ^ ((multiplicity a b).get hfin + 1) ∣ b := ⟨k, hc⟩\n  exact (multiplicity.eq_coe_iff.1 (by simp)).2 h₁\n#align exists_eq_pow_mul_and_not_dvd exists_eq_pow_mul_and_not_dvd\n\n",
 "eq_top_iff_not_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_top_iff_not_finite {a b : α} : multiplicity a b = «expr⊤» ↔ ¬finite a b :=\n  Part.eq_none_iff'\n#align eq_top_iff_not_finite eq_top_iff_not_finite\n\n",
 "eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print eq_top_iff /-\ntheorem eq_top_iff {a b : α} : multiplicity a b = «expr⊤» ↔ ∀ n : ℕ, a ^ n ∣ b :=\n  (part_enat.find_eq_top_iff _).trans <| by\n    simp only [not_not]\n    exact\n      ⟨fun h n =>\n        nat.cases_on n\n          (by\n            rw [pow_zero]\n            exact one_dvd _)\n          fun n => h _,\n        fun h n => h _⟩\n#align eq_top_iff eq_top_iff\n-/\n\n",
 "eq_of_associated_right":
 "theorem eq_of_associated_right {a b c : α} (h : Associated b c) : multiplicity a b = multiplicity a c :=\n  le_antisymm (multiplicity_le_multiplicity_of_dvd_right h.dvd) (multiplicity_le_multiplicity_of_dvd_right h.symm.dvd)\n#align eq_of_associated_right eq_of_associated_right\n\n",
 "eq_of_associated_left":
 "theorem eq_of_associated_left {a b c : α} (h : Associated a b) : multiplicity b c = multiplicity a c :=\n  le_antisymm (multiplicity_le_multiplicity_of_dvd_left h.dvd) (multiplicity_le_multiplicity_of_dvd_left h.symm.dvd)\n#align eq_of_associated_left eq_of_associated_left\n\n",
 "eq_coe_iff":
 "theorem eq_coe_iff {a b : α} {n : ℕ} : multiplicity a b = (n : part_enat) ↔ a ^ n ∣ b ∧ ¬a ^ (n + 1) ∣ b :=\n  by\n  rw [← part_enat.some_eq_coe]\n  exact\n    ⟨fun h =>\n      let ⟨h₁, h₂⟩ := eq_some_iff.1 h\n      h₂ ▸\n        ⟨pow_multiplicity_dvd _,\n          IsGreatest\n            (by\n              rw [part_enat.lt_coe_iff]\n              exact ⟨h₁, lt_succ_self _⟩)⟩,\n      fun h => eq_some_iff.2 ⟨⟨n, h.2⟩, eq.symm <| unique' h.1 h.2⟩⟩\n#align eq_coe_iff eq_coe_iff\n\n",
 "dvd_of_multiplicity_pos":
 "theorem dvd_of_multiplicity_pos {a b : α} (h : (0 : part_enat) < multiplicity a b) : a ∣ b :=\n  by\n  rw [← pow_one a]\n  apply pow_dvd_of_le_multiplicity\n  simpa only [Nat.cast_one, part_enat.pos_iff_one_le] using h\n#align dvd_of_multiplicity_pos dvd_of_multiplicity_pos\n\n",
 "dvd_iff_multiplicity_pos":
 "theorem dvd_iff_multiplicity_pos {a b : α} : (0 : part_enat) < multiplicity a b ↔ a ∣ b :=\n  ⟨dvd_of_multiplicity_pos, fun hdvd =>\n    lt_of_le_of_ne (zero_le _) fun heq =>\n      is_greatest\n        (show multiplicity a b < ↑1 by simpa only [HEq, Nat.cast_zero] using part_enat.coe_lt_coe.mpr zero_lt_one)\n        (by rwa [pow_one a])⟩\n#align dvd_iff_multiplicity_pos dvd_iff_multiplicity_pos\n\n",
 "coe_nat_multiplicity":
 "@[norm_cast]\ntheorem int.coe_nat_multiplicity (a b : ℕ) : multiplicity (a : ℤ) (b : ℤ) = multiplicity a b :=\n  by\n  apply Part.ext'\n  · repeat' rw [← finite_iff_dom, finite_def]\n    norm_cast\n  · intro h1 h2\n    apply _root_.le_antisymm <;>\n      · apply Nat.find_mono\n        norm_cast\n        simp\n#align int.coe_nat_multiplicity int.coe_nat_multiplicity\n\n",
 "add_valuation_apply":
 "@[simp]\ntheorem add_valuation_apply {hp : Prime p} {r : R} : add_valuation hp r = multiplicity p r :=\n  rfl\n#align add_valuation_apply add_valuation_apply\n\n",
 "IsGreatest":
 "#print IsGreatest /-\ntheorem IsGreatest {a b : α} {m : ℕ} (hm : multiplicity a b < m) : ¬a ^ m ∣ b := fun h => by\n  rw [part_enat.lt_coe_iff] at hm <;> exact nat.find_spec hm.fst ((pow_dvd_pow _ hm.snd).trans h)\n#align is_greatest IsGreatest\n-/\n\n"}