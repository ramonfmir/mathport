{"symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product.infer -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem algebra.is_pushout.symm (h : algebra.is_pushout R S R' S') : algebra.is_pushout R R' S S' :=\n  by\n  letI := (algebra.tensor_product.include_right : «expr →ₐ[ ] » R' R (tensor_product.infer S R')).to_ring_hom.to_algebra\n  let e : «expr ≃ₗ[ ] » (tensor_product R' R S) R' S' :=\n    by\n    refine' { (tensor_product.comm R R' S).trans <| h.1.equiv.restrict_scalars R with map_smul' := _ }\n    intro r x\n    change\n      h.1.equiv (tensor_product.comm R R' S («expr • » r x)) = «expr • » r (h.1.equiv (tensor_product.comm R R' S x))\n    apply tensor_product.induction_on x\n    · simp only [smul_zero, map_zero]\n    · intro x y\n      simp [smul_tmul', algebra.smul_def, ring_hom.algebra_map_to_algebra, h.1.equiv_tmul]\n      ring\n    · intro x y hx hy\n      simp only [map_add, smul_add, hx, hy]\n  have : (to_alg_hom R S S').to_linear_map = (e.to_linear_map.restrict_scalars R).comp (tensor_product.mk R R' S 1) :=\n    by\n    ext\n    simp [e, h.1.equiv_tmul, algebra.smul_def]\n  constructor\n  rw [this]\n  exact (tensor_product.is_base_change R S R').comp (is_base_change.of_equiv e)\n#align algebra.is_pushout.symm algebra.is_pushout.symm\n\n",
 "pushout_desc_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem algebra.pushout_desc_right [H : algebra.is_pushout R S R' S'] {A : Type _} [Semiring A] [algebra R A]\n    (f : «expr →ₐ[ ] » S R A) (g : «expr →ₐ[ ] » R' R A) (H) (x : R') :\n    algebra.pushout_desc S' f g H (algebra_map R' S' x) = g x := by\n  apply (config := { instances := false }) @is_base_change.lift_eq\n#align algebra.pushout_desc_right algebra.pushout_desc_right\n\n",
 "pushout_desc_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem algebra.pushout_desc_left [H : algebra.is_pushout R S R' S'] {A : Type _} [Semiring A] [algebra R A]\n    (f : «expr →ₐ[ ] » S R A) (g : «expr →ₐ[ ] » R' R A) (H) (x : S) :\n    algebra.pushout_desc S' f g H (algebra_map S S' x) = f x :=\n  by\n  rw [algebra.pushout_desc_apply, algebra.algebra_map_eq_smul_one, linear_map.map_smul, ←\n    algebra.pushout_desc_apply S' f g H, _root_.map_one]\n  exact mul_one (f x)\n#align algebra.pushout_desc_left algebra.pushout_desc_left\n\n",
 "of_lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_base_change.of_lift_unique\n    (h :\n      ∀ (Q : Type max v₁ v₂ v₃) [add_comm_monoid Q],\n        ∀ [Module R Q] [Module S Q],\n          ∀ [IsScalarTower R S Q],\n            ∀ g : «expr →ₗ[ ] » M R Q, ∃! g' : «expr →ₗ[ ] » N S Q, (g'.restrict_scalars R).comp f = g) :\n    is_base_change S f :=\n  by\n  obtain ⟨g, hg, -⟩ :=\n    h (ULift.{v₂} <| tensor_product S R M) (ulift.module_equiv.symm.to_linear_map.comp <| tensor_product.mk R S M 1)\n  let f' : «expr →ₗ[ ] » (tensor_product S R M) R N := _\n  change function.bijective f'\n  let f'' : «expr →ₗ[ ] » (tensor_product S R M) S N :=\n    by\n    refine'\n      { f' with\n        to_fun := f'\n        map_smul' := fun s x => tensor_product.induction_on x _ (fun s' y => smul_assoc s s' _) fun x y hx hy => _ }\n    · rw [map_zero, smul_zero, map_zero, smul_zero]\n    · rw [smul_add, map_add, map_add, smul_add, hx, hy]\n  simp_rw [fun_like.ext_iff, linear_map.comp_apply, linear_map.restrict_scalars_apply] at hg\n  let fe : «expr ≃ₗ[ ] » (tensor_product S R M) S N :=\n    linear_equiv.of_linear f'' (ulift.module_equiv.to_linear_map.comp g) _ _\n  · exact fe.bijective\n  · rw [← linear_map.cancel_left (ulift.module_equiv : «expr ≃ₗ[ ] » (ULift.{max v₁ v₃} N) S N).symm.injective]\n    refine' (h (ULift.{max v₁ v₃} N) <| ulift.module_equiv.symm.to_linear_map.comp f).unique _ rfl\n    · infer_instance\n    ext x\n    simp only [linear_map.comp_apply, linear_map.restrict_scalars_apply, hg]\n    apply one_smul\n  · ext x\n    change (g <| «expr • » (1 : S) (f x)).down = _\n    rw [one_smul, hg]\n    rfl\n#align is_base_change.of_lift_unique is_base_change.of_lift_unique\n\n",
 "of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem is_base_change.of_equiv (e : «expr ≃ₗ[ ] » M R N) : is_base_change R e.to_linear_map :=\n  by\n  apply is_base_change.of_lift_unique\n  intro Q I₁ I₂ I₃ I₄ g\n  have : I₂ = I₃ := by\n    ext (r q)\n    rw [← one_smul R q, smul_smul, ← smul_assoc, smul_eq_mul, mul_one]\n  cases this\n  refine'\n    ⟨g.comp e.symm.to_linear_map, by\n      ext\n      simp, _⟩\n  rintro y (rfl : _ = _)\n  ext\n  simp\n#align is_base_change.of_equiv is_base_change.of_equiv\n\n",
 "map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_tensor_product.map_eq (hf : is_tensor_product f) (hg : is_tensor_product g) (i₁ : «expr →ₗ[ ] » M₁ R N₁)\n    (i₂ : «expr →ₗ[ ] » M₂ R N₂) (x₁ : M₁) (x₂ : M₂) : hf.map hg i₁ i₂ (f x₁ x₂) = g (i₁ x₁) (i₂ x₂) :=\n  by\n  delta is_tensor_product.map\n  simp\n#align is_tensor_product.map_eq is_tensor_product.map_eq\n\n",
 "lift_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_base_change.lift_eq (g : «expr →ₗ[ ] » M R Q) (x : M) : h.lift g (f x) = g x :=\n  by\n  have hF : ∀ (s : S) (m : M), h.lift g («expr • » s (f m)) = «expr • » s (g m) := h.lift_eq _\n  convert hF 1 x <;> rw [one_smul]\n#align is_base_change.lift_eq is_base_change.lift_eq\n\n",
 "lift_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_base_change.lift_comp (g : «expr →ₗ[ ] » M R Q) : ((h.lift g).restrict_scalars R).comp f = g :=\n  linear_map.ext (h.lift_eq g)\n#align is_base_change.lift_comp is_base_change.lift_comp\n\n",
 "lift_alg_hom_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem algebra.lift_alg_hom_comp_right [H : algebra.is_pushout R S R' S'] {A : Type _} [Semiring A] [algebra R A]\n    (f : «expr →ₐ[ ] » S R A) (g : «expr →ₐ[ ] » R' R A) (H) :\n    (algebra.pushout_desc S' f g H).comp (to_alg_hom R R' S') = g :=\n  alg_hom.ext fun x => (algebra.pushout_desc_right S' f g H x : _)\n#align algebra.lift_alg_hom_comp_right algebra.lift_alg_hom_comp_right\n\n",
 "lift_alg_hom_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem algebra.lift_alg_hom_comp_left [H : algebra.is_pushout R S R' S'] {A : Type _} [Semiring A] [algebra R A]\n    (f : «expr →ₐ[ ] » S R A) (g : «expr →ₐ[ ] » R' R A) (H) :\n    (algebra.pushout_desc S' f g H).comp (to_alg_hom R S S') = f :=\n  alg_hom.ext fun x => (algebra.pushout_desc_left S' f g H x : _)\n#align algebra.lift_alg_hom_comp_left algebra.lift_alg_hom_comp_left\n\n",
 "is_tensor_product":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem tensor_product.is_tensor_product : is_tensor_product (tensor_product.mk R M N) :=\n  by\n  delta is_tensor_product\n  convert_to function.bijective linear_map.id using 2\n  · apply tensor_product.ext'\n    simp\n  · exact function.bijective_id\n#align tensor_product.is_tensor_product tensor_product.is_tensor_product\n\n",
 "is_base_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\ntheorem tensor_product.is_base_change : is_base_change S (tensor_product.mk R S M 1) :=\n  by\n  delta is_base_change\n  convert tensor_product.is_tensor_product R S M using 1\n  ext (s x)\n  change «expr • » s («expr ⊗ₜ » 1 x) = «expr ⊗ₜ » s x\n  rw [tensor_product.smul_tmul']\n  congr 1\n  exact mul_one _\n#align tensor_product.is_base_change tensor_product.is_base_change\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[elab_as_elim]\ntheorem is_base_change.induction_on (x : N) (P : N → Prop) (h₁ : P 0) (h₂ : ∀ m : M, P (f m))\n    (h₃ : ∀ (s : S) (n), P n → P («expr • » s n)) (h₄ : ∀ n₁ n₂, P n₁ → P n₂ → P (n₁ + n₂)) : P x :=\n  h.induction_on x h₁ (fun s y => h₃ _ _ (h₂ _)) h₄\n#align is_base_change.induction_on is_base_change.induction_on\n\n",
 "iff_lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_base_change.iff_lift_unique :\n    is_base_change S f ↔\n      ∀ (Q : Type max v₁ v₂ v₃) [add_comm_monoid Q],\n        ∀ [Module R Q] [Module S Q],\n          ∀ [IsScalarTower R S Q],\n            ∀ g : «expr →ₗ[ ] » M R Q, ∃! g' : «expr →ₗ[ ] » N S Q, (g'.restrict_scalars R).comp f = g :=\n  ⟨fun h => by\n    intros\n    exact ⟨h.lift g, h.lift_comp g, fun g' e => h.alg_hom_ext' _ _ (e.trans (h.lift_comp g).symm)⟩,\n    is_base_change.of_lift_unique f⟩\n#align is_base_change.iff_lift_unique is_base_change.iff_lift_unique\n\n",
 "equiv_to_linear_map":
 "@[simp]\ntheorem is_tensor_product.equiv_to_linear_map (h : is_tensor_product f) :\n    h.equiv.to_linear_map = tensor_product.lift f :=\n  rfl\n#align is_tensor_product.equiv_to_linear_map is_tensor_product.equiv_to_linear_map\n\n",
 "equiv_tmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_base_change.equiv_tmul (s : S) (m : M) : h.equiv («expr ⊗ₜ » s m) = «expr • » s (f m) :=\n  tensor_product.lift.tmul s m\n#align is_base_change.equiv_tmul is_base_change.equiv_tmul\n\n",
 "equiv_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\ntheorem is_base_change.equiv_symm_apply (m : M) : h.equiv.symm (f m) = «expr ⊗ₜ » 1 m := by\n  rw [h.equiv.symm_apply_eq, h.equiv_tmul, one_smul]\n#align is_base_change.equiv_symm_apply is_base_change.equiv_symm_apply\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_base_change.comp {f : «expr →ₗ[ ] » M R N} (hf : is_base_change S f) {g : «expr →ₗ[ ] » N S O}\n    (hg : is_base_change T g) : is_base_change T ((g.restrict_scalars R).comp f) :=\n  by\n  apply is_base_change.of_lift_unique\n  intro Q _ _ _ _ i\n  letI := Module.compHom Q (algebra_map S T)\n  haveI : IsScalarTower S T Q :=\n    ⟨fun x y z => by\n      rw [algebra.smul_def, mul_smul]\n      rfl⟩\n  have : IsScalarTower R S Q := by\n    refine' ⟨fun x y z => _⟩\n    change\n      «expr • » ((is_scalar_tower.to_alg_hom R S T) («expr • » x y)) z = «expr • » x («expr • » (algebra_map S T y) z)\n    rw [alg_hom.map_smul, smul_assoc]\n    rfl\n  refine'\n    ⟨hg.lift (hf.lift i), by\n      ext\n      simp [is_base_change.lift_eq], _⟩\n  rintro g' (e : _ = _)\n  refine' hg.alg_hom_ext' _ _ (hf.alg_hom_ext' _ _ _)\n  rw [is_base_change.lift_comp, is_base_change.lift_comp, ← e]\n  ext\n  rfl\n#align is_base_change.comp is_base_change.comp\n\n",
 "comm":
 "theorem algebra.is_pushout.comm : algebra.is_pushout R S R' S' ↔ algebra.is_pushout R R' S S' :=\n  ⟨algebra.is_pushout.symm, algebra.is_pushout.symm⟩\n#align algebra.is_pushout.comm algebra.is_pushout.comm\n\n",
 "alg_hom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_base_change.alg_hom_ext' [Module R Q] [IsScalarTower R S Q] (g₁ g₂ : «expr →ₗ[ ] » N S Q)\n    (e : (g₁.restrict_scalars R).comp f = (g₂.restrict_scalars R).comp f) : g₁ = g₂ :=\n  h.alg_hom_ext g₁ g₂ (linear_map.congr_fun e)\n#align is_base_change.alg_hom_ext' is_base_change.alg_hom_ext'\n\n",
 "alg_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[ext]\ntheorem algebra.is_pushout.alg_hom_ext [H : algebra.is_pushout R S R' S'] {A : Type _} [Semiring A] [algebra R A]\n    {f g : «expr →ₐ[ ] » S' R A} (h₁ : f.comp (to_alg_hom R R' S') = g.comp (to_alg_hom R R' S'))\n    (h₂ : f.comp (to_alg_hom R S S') = g.comp (to_alg_hom R S S')) : f = g :=\n  by\n  ext x\n  apply H.1.induction_on x\n  · simp only [map_zero]\n  · exact alg_hom.congr_fun h₁\n  · intro s s' e\n    rw [algebra.smul_def, f.map_mul, g.map_mul, e]\n    congr 1\n    exact (alg_hom.congr_fun h₂ s : _)\n  · intro s₁ s₂ e₁ e₂\n    rw [map_add, map_add, e₁, e₂]\n#align algebra.is_pushout.alg_hom_ext algebra.is_pushout.alg_hom_ext\n\n"}