{"radical_eq":
 "theorem ideal.is_homogeneous.radical_eq {I : ideal A} (hI : I.is_homogeneous 𝒜) :\n    I.radical = infₛ { J | J.is_homogeneous 𝒜 ∧ I ≤ J ∧ J.is_prime } :=\n  by\n  rw [ideal.radical_eq_Inf]\n  apply le_antisymm\n  · exact infₛ_le_infₛ fun J => And.right\n  · refine' infₛ_le_infₛ_of_forall_exists_le _\n    rintro J ⟨HJ₁, HJ₂⟩\n    refine' ⟨(J.homogeneous_core 𝒜).to_ideal, _, J.to_ideal_homogeneous_core_le _⟩\n    refine' ⟨homogeneous_ideal.is_homogeneous _, _, HJ₂.homogeneous_core⟩\n    refine' hI.to_ideal_homogeneous_core_eq_self.symm.trans_le (ideal.homogeneous_core_mono _ HJ₁)\n#align ideal.is_homogeneous.radical_eq ideal.is_homogeneous.radical_eq\n\n",
 "radical":
 "theorem ideal.is_homogeneous.radical {I : ideal A} (h : I.is_homogeneous 𝒜) : I.radical.is_homogeneous 𝒜 :=\n  by\n  rw [h.radical_eq]\n  exact ideal.is_homogeneous.Inf fun _ => And.left\n#align ideal.is_homogeneous.radical ideal.is_homogeneous.radical\n\n",
 "is_prime_of_homogeneous_mem_or_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Eric Wieser\n-/\ntheorem ideal.is_homogeneous.is_prime_of_homogeneous_mem_or_mem {I : ideal A} (hI : I.is_homogeneous 𝒜)\n    (I_ne_top : I ≠ «expr⊤»)\n    (homogeneous_mem_or_mem : ∀ {x y : A}, is_homogeneous 𝒜 x → is_homogeneous 𝒜 y → x * y ∈ I → x ∈ I ∨ y ∈ I) :\n    ideal.is_prime I :=\n  ⟨I_ne_top, by\n    intro x y hxy\n    by_contra rid\n    obtain ⟨rid₁, rid₂⟩ := not_or_distrib.mp rid\n    classical\n      /-\n        The idea of the proof is the following :\n        since `x * y ∈ I` and `I` homogeneous, then `proj i (x * y) ∈ I` for any `i : ι`.\n        Then consider two sets `{i ∈ x.support | xᵢ ∉ I}` and `{j ∈ y.support | yⱼ ∉ J}`;\n        let `max₁, max₂` be the maximum of the two sets, then `proj (max₁ + max₂) (x * y) ∈ I`.\n        Then, `proj max₁ x ∉ I` and `proj max₂ j ∉ I`\n        but `proj i x ∈ I` for all `max₁ < i` and `proj j y ∈ I` for all `max₂ < j`.\n        `  proj (max₁ + max₂) (x * y)`\n        `= ∑ {(i, j) ∈ supports | i + j = max₁ + max₂}, xᵢ * yⱼ`\n        `= proj max₁ x * proj max₂ y`\n        `  + ∑ {(i, j) ∈ supports \\ {(max₁, max₂)} | i + j = max₁ + max₂}, xᵢ * yⱼ`.\n        This is a contradiction, because both `proj (max₁ + max₂) (x * y) ∈ I` and the sum on the\n        right hand side is in `I` however `proj max₁ x * proj max₂ y` is not in `I`.\n        -/\n      set set₁ := (decompose 𝒜 x).support.filter fun i => proj 𝒜 i x ∉ I with set₁_eq\n      set set₂ := (decompose 𝒜 y).support.filter fun i => proj 𝒜 i y ∉ I with set₂_eq\n      have nonempty : ∀ x : A, x ∉ I → ((decompose 𝒜 x).support.filter fun i => proj 𝒜 i x ∉ I).nonempty :=\n        by\n        intro x hx\n        rw [filter_nonempty_iff]\n        contrapose! hx\n        simp_rw [proj_apply] at hx\n        rw [← sum_support_decompose 𝒜 x]\n        exact ideal.sum_mem _ hx\n      set max₁ := set₁.max' (nonempty x rid₁) with max₁_eq\n      set max₂ := set₂.max' (nonempty y rid₂) with max₂_eq\n      have mem_max₁ : max₁ ∈ set₁ := max'_mem set₁ (nonempty x rid₁)\n      have mem_max₂ : max₂ ∈ set₂ := max'_mem set₂ (nonempty y rid₂)\n      replace hxy : proj 𝒜 (max₁ + max₂) (x * y) ∈ I := hI _ hxy\n      have mem_I : proj 𝒜 max₁ x * proj 𝒜 max₂ y ∈ I :=\n        by\n        set antidiag :=\n          (finset.product (decompose 𝒜 x).support (decompose 𝒜 y).support).filter fun z : ι × ι =>\n            z.1 + z.2 = max₁ + max₂ with\n          ha\n        have mem_antidiag : (max₁, max₂) ∈ antidiag :=\n          by\n          simp only [add_sum_erase, mem_filter, mem_product]\n          exact ⟨⟨mem_of_mem_filter _ mem_max₁, mem_of_mem_filter _ mem_max₂⟩, rfl⟩\n        have eq_add_sum :=\n          calc\n            proj 𝒜 (max₁ + max₂) (x * y) =\n                finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" antidiag\n                  (proj 𝒜 ij.1 x * proj 𝒜 ij.2 y) :=\n              by simp_rw [ha, proj_apply, direct_sum.decompose_mul, direct_sum.coe_mul_apply 𝒜]\n            _ =\n                proj 𝒜 max₁ x * proj 𝒜 max₂ y +\n                  finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                    (antidiag.erase (max₁, max₂)) (proj 𝒜 ij.1 x * proj 𝒜 ij.2 y) :=\n              (add_sum_erase _ _ mem_antidiag).symm\n            \n        rw [eq_sub_of_add_eq eq_add_sum.symm]\n        refine' ideal.sub_mem _ hxy (ideal.sum_mem _ fun z H => _)\n        rcases z with ⟨i, j⟩\n        simp only [mem_erase, prod.mk.inj_iff, ne.def, mem_filter, mem_product] at H\n        rcases H with ⟨H₁, ⟨H₂, H₃⟩, H₄⟩\n        have max_lt : max₁ < i ∨ max₂ < j :=\n          by\n          rcases lt_trichotomy max₁ i with (h | rfl | h)\n          · exact or.inl h\n          · refine' false.elim (H₁ ⟨rfl, add_left_cancel H₄⟩)\n          · apply or.inr\n            have := add_lt_add_right h j\n            rw [H₄] at this\n            exact lt_of_add_lt_add_left this\n        cases max_lt\n        · -- in this case `max₁ < i`, then `xᵢ ∈ I`; for otherwise `i ∈ set₁` then `i ≤ max₁`.\n          have not_mem : i ∉ set₁ := fun h => lt_irrefl _ ((max'_lt_iff set₁ (nonempty x rid₁)).mp max_lt i h)\n          rw [set₁_eq] at not_mem\n          simp only [not_and, not_not, ne.def, mem_filter] at not_mem\n          exact ideal.mul_mem_right _ I (not_mem H₂)\n        · -- in this case  `max₂ < j`, then `yⱼ ∈ I`; for otherwise `j ∈ set₂`, then `j ≤ max₂`.\n          have not_mem : j ∉ set₂ := fun h => lt_irrefl _ ((max'_lt_iff set₂ (nonempty y rid₂)).mp max_lt j h)\n          rw [set₂_eq] at not_mem\n          simp only [not_and, not_not, ne.def, mem_filter] at not_mem\n          exact ideal.mul_mem_left I _ (not_mem H₃)\n      have not_mem_I : proj 𝒜 max₁ x * proj 𝒜 max₂ y ∉ I :=\n        by\n        have neither_mem : proj 𝒜 max₁ x ∉ I ∧ proj 𝒜 max₂ y ∉ I :=\n          by\n          rw [mem_filter] at mem_max₁ mem_max₂\n          exact ⟨mem_max₁.2, mem_max₂.2⟩\n        intro rid\n        cases homogeneous_mem_or_mem ⟨max₁, SetLike.coe_mem _⟩ ⟨max₂, SetLike.coe_mem _⟩ mem_I\n        · apply neither_mem.1 h\n        · apply neither_mem.2 h\n      exact not_mem_I mem_I⟩\n#align ideal.is_homogeneous.is_prime_of_homogeneous_mem_or_mem ideal.is_homogeneous.is_prime_of_homogeneous_mem_or_mem\n\n",
 "is_prime_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ideal.is_homogeneous.is_prime_iff {I : ideal A} (h : I.is_homogeneous 𝒜) :\n    I.is_prime ↔\n      I ≠ «expr⊤» ∧\n        ∀ {x y : A}, set_like.is_homogeneous 𝒜 x → set_like.is_homogeneous 𝒜 y → x * y ∈ I → x ∈ I ∨ y ∈ I :=\n  ⟨fun HI => ⟨ne_of_apply_ne _ HI.ne_top, fun x y hx hy hxy => ideal.is_prime.mem_or_mem HI hxy⟩,\n    fun ⟨I_ne_top, homogeneous_mem_or_mem⟩ => h.is_prime_of_homogeneous_mem_or_mem I_ne_top @homogeneous_mem_or_mem⟩\n#align ideal.is_homogeneous.is_prime_iff ideal.is_homogeneous.is_prime_iff\n\n",
 "homogeneous_core":
 "theorem ideal.is_prime.homogeneous_core {I : ideal A} (h : I.is_prime) : (I.homogeneous_core 𝒜).to_ideal.is_prime :=\n  by\n  apply (ideal.homogeneous_core 𝒜 I).is_homogeneous.is_prime_of_homogeneous_mem_or_mem\n  · exact ne_top_of_le_ne_top h.ne_top (ideal.to_ideal_homogeneous_core_le 𝒜 I)\n  rintro x y hx hy hxy\n  have H := h.mem_or_mem (ideal.to_ideal_homogeneous_core_le 𝒜 I hxy)\n  refine' H.imp _ _\n  · exact ideal.mem_homogeneous_core_of_is_homogeneous_of_mem hx\n  · exact ideal.mem_homogeneous_core_of_is_homogeneous_of_mem hy\n#align ideal.is_prime.homogeneous_core ideal.is_prime.homogeneous_core\n\n",
 "coe_radical":
 "@[simp]\ntheorem homogeneous_ideal.coe_radical (I : homogeneous_ideal 𝒜) : I.radical.to_ideal = I.to_ideal.radical :=\n  rfl\n#align homogeneous_ideal.coe_radical homogeneous_ideal.coe_radical\n\n"}