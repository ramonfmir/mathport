{"radical_eq":
 "theorem ideal.is_homogeneous.radical_eq {I : ideal A} (hI : I.is_homogeneous ğ’œ) :\n    I.radical = infâ‚› { J | J.is_homogeneous ğ’œ âˆ§ I â‰¤ J âˆ§ J.is_prime } :=\n  by\n  rw [ideal.radical_eq_Inf]\n  apply le_antisymm\n  Â· exact infâ‚›_le_infâ‚› fun J => And.right\n  Â· refine' infâ‚›_le_infâ‚›_of_forall_exists_le _\n    rintro J âŸ¨HJâ‚, HJâ‚‚âŸ©\n    refine' âŸ¨(J.homogeneous_core ğ’œ).to_ideal, _, J.to_ideal_homogeneous_core_le _âŸ©\n    refine' âŸ¨homogeneous_ideal.is_homogeneous _, _, HJâ‚‚.homogeneous_coreâŸ©\n    refine' hI.to_ideal_homogeneous_core_eq_self.symm.trans_le (ideal.homogeneous_core_mono _ HJâ‚)\n#align ideal.is_homogeneous.radical_eq ideal.is_homogeneous.radical_eq\n\n",
 "radical":
 "theorem ideal.is_homogeneous.radical {I : ideal A} (h : I.is_homogeneous ğ’œ) : I.radical.is_homogeneous ğ’œ :=\n  by\n  rw [h.radical_eq]\n  exact ideal.is_homogeneous.Inf fun _ => And.left\n#align ideal.is_homogeneous.radical ideal.is_homogeneous.radical\n\n",
 "is_prime_of_homogeneous_mem_or_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Eric Wieser\n-/\ntheorem ideal.is_homogeneous.is_prime_of_homogeneous_mem_or_mem {I : ideal A} (hI : I.is_homogeneous ğ’œ)\n    (I_ne_top : I â‰  Â«exprâŠ¤Â»)\n    (homogeneous_mem_or_mem : âˆ€ {x y : A}, is_homogeneous ğ’œ x â†’ is_homogeneous ğ’œ y â†’ x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I) :\n    ideal.is_prime I :=\n  âŸ¨I_ne_top, by\n    intro x y hxy\n    by_contra rid\n    obtain âŸ¨ridâ‚, ridâ‚‚âŸ© := not_or_distrib.mp rid\n    classical\n      /-\n        The idea of the proof is the following :\n        since `x * y âˆˆ I` and `I` homogeneous, then `proj i (x * y) âˆˆ I` for any `i : Î¹`.\n        Then consider two sets `{i âˆˆ x.support | xáµ¢ âˆ‰ I}` and `{j âˆˆ y.support | yâ±¼ âˆ‰ J}`;\n        let `maxâ‚, maxâ‚‚` be the maximum of the two sets, then `proj (maxâ‚ + maxâ‚‚) (x * y) âˆˆ I`.\n        Then, `proj maxâ‚ x âˆ‰ I` and `proj maxâ‚‚ j âˆ‰ I`\n        but `proj i x âˆˆ I` for all `maxâ‚ < i` and `proj j y âˆˆ I` for all `maxâ‚‚ < j`.\n        `  proj (maxâ‚ + maxâ‚‚) (x * y)`\n        `= âˆ‘ {(i, j) âˆˆ supports | i + j = maxâ‚ + maxâ‚‚}, xáµ¢ * yâ±¼`\n        `= proj maxâ‚ x * proj maxâ‚‚ y`\n        `  + âˆ‘ {(i, j) âˆˆ supports \\ {(maxâ‚, maxâ‚‚)} | i + j = maxâ‚ + maxâ‚‚}, xáµ¢ * yâ±¼`.\n        This is a contradiction, because both `proj (maxâ‚ + maxâ‚‚) (x * y) âˆˆ I` and the sum on the\n        right hand side is in `I` however `proj maxâ‚ x * proj maxâ‚‚ y` is not in `I`.\n        -/\n      set setâ‚ := (decompose ğ’œ x).support.filter fun i => proj ğ’œ i x âˆ‰ I with setâ‚_eq\n      set setâ‚‚ := (decompose ğ’œ y).support.filter fun i => proj ğ’œ i y âˆ‰ I with setâ‚‚_eq\n      have nonempty : âˆ€ x : A, x âˆ‰ I â†’ ((decompose ğ’œ x).support.filter fun i => proj ğ’œ i x âˆ‰ I).nonempty :=\n        by\n        intro x hx\n        rw [filter_nonempty_iff]\n        contrapose! hx\n        simp_rw [proj_apply] at hx\n        rw [â† sum_support_decompose ğ’œ x]\n        exact ideal.sum_mem _ hx\n      set maxâ‚ := setâ‚.max' (nonempty x ridâ‚) with maxâ‚_eq\n      set maxâ‚‚ := setâ‚‚.max' (nonempty y ridâ‚‚) with maxâ‚‚_eq\n      have mem_maxâ‚ : maxâ‚ âˆˆ setâ‚ := max'_mem setâ‚ (nonempty x ridâ‚)\n      have mem_maxâ‚‚ : maxâ‚‚ âˆˆ setâ‚‚ := max'_mem setâ‚‚ (nonempty y ridâ‚‚)\n      replace hxy : proj ğ’œ (maxâ‚ + maxâ‚‚) (x * y) âˆˆ I := hI _ hxy\n      have mem_I : proj ğ’œ maxâ‚ x * proj ğ’œ maxâ‚‚ y âˆˆ I :=\n        by\n        set antidiag :=\n          (finset.product (decompose ğ’œ x).support (decompose ğ’œ y).support).filter fun z : Î¹ Ã— Î¹ =>\n            z.1 + z.2 = maxâ‚ + maxâ‚‚ with\n          ha\n        have mem_antidiag : (maxâ‚, maxâ‚‚) âˆˆ antidiag :=\n          by\n          simp only [add_sum_erase, mem_filter, mem_product]\n          exact âŸ¨âŸ¨mem_of_mem_filter _ mem_maxâ‚, mem_of_mem_filter _ mem_maxâ‚‚âŸ©, rflâŸ©\n        have eq_add_sum :=\n          calc\n            proj ğ’œ (maxâ‚ + maxâ‚‚) (x * y) =\n                finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" antidiag\n                  (proj ğ’œ ij.1 x * proj ğ’œ ij.2 y) :=\n              by simp_rw [ha, proj_apply, direct_sum.decompose_mul, direct_sum.coe_mul_apply ğ’œ]\n            _ =\n                proj ğ’œ maxâ‚ x * proj ğ’œ maxâ‚‚ y +\n                  finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                    (antidiag.erase (maxâ‚, maxâ‚‚)) (proj ğ’œ ij.1 x * proj ğ’œ ij.2 y) :=\n              (add_sum_erase _ _ mem_antidiag).symm\n            \n        rw [eq_sub_of_add_eq eq_add_sum.symm]\n        refine' ideal.sub_mem _ hxy (ideal.sum_mem _ fun z H => _)\n        rcases z with âŸ¨i, jâŸ©\n        simp only [mem_erase, prod.mk.inj_iff, ne.def, mem_filter, mem_product] at H\n        rcases H with âŸ¨Hâ‚, âŸ¨Hâ‚‚, Hâ‚ƒâŸ©, Hâ‚„âŸ©\n        have max_lt : maxâ‚ < i âˆ¨ maxâ‚‚ < j :=\n          by\n          rcases lt_trichotomy maxâ‚ i with (h | rfl | h)\n          Â· exact or.inl h\n          Â· refine' false.elim (Hâ‚ âŸ¨rfl, add_left_cancel Hâ‚„âŸ©)\n          Â· apply or.inr\n            have := add_lt_add_right h j\n            rw [Hâ‚„] at this\n            exact lt_of_add_lt_add_left this\n        cases max_lt\n        Â· -- in this case `maxâ‚ < i`, then `xáµ¢ âˆˆ I`; for otherwise `i âˆˆ setâ‚` then `i â‰¤ maxâ‚`.\n          have not_mem : i âˆ‰ setâ‚ := fun h => lt_irrefl _ ((max'_lt_iff setâ‚ (nonempty x ridâ‚)).mp max_lt i h)\n          rw [setâ‚_eq] at not_mem\n          simp only [not_and, not_not, ne.def, mem_filter] at not_mem\n          exact ideal.mul_mem_right _ I (not_mem Hâ‚‚)\n        Â· -- in this case  `maxâ‚‚ < j`, then `yâ±¼ âˆˆ I`; for otherwise `j âˆˆ setâ‚‚`, then `j â‰¤ maxâ‚‚`.\n          have not_mem : j âˆ‰ setâ‚‚ := fun h => lt_irrefl _ ((max'_lt_iff setâ‚‚ (nonempty y ridâ‚‚)).mp max_lt j h)\n          rw [setâ‚‚_eq] at not_mem\n          simp only [not_and, not_not, ne.def, mem_filter] at not_mem\n          exact ideal.mul_mem_left I _ (not_mem Hâ‚ƒ)\n      have not_mem_I : proj ğ’œ maxâ‚ x * proj ğ’œ maxâ‚‚ y âˆ‰ I :=\n        by\n        have neither_mem : proj ğ’œ maxâ‚ x âˆ‰ I âˆ§ proj ğ’œ maxâ‚‚ y âˆ‰ I :=\n          by\n          rw [mem_filter] at mem_maxâ‚ mem_maxâ‚‚\n          exact âŸ¨mem_maxâ‚.2, mem_maxâ‚‚.2âŸ©\n        intro rid\n        cases homogeneous_mem_or_mem âŸ¨maxâ‚, SetLike.coe_mem _âŸ© âŸ¨maxâ‚‚, SetLike.coe_mem _âŸ© mem_I\n        Â· apply neither_mem.1 h\n        Â· apply neither_mem.2 h\n      exact not_mem_I mem_IâŸ©\n#align ideal.is_homogeneous.is_prime_of_homogeneous_mem_or_mem ideal.is_homogeneous.is_prime_of_homogeneous_mem_or_mem\n\n",
 "is_prime_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem ideal.is_homogeneous.is_prime_iff {I : ideal A} (h : I.is_homogeneous ğ’œ) :\n    I.is_prime â†”\n      I â‰  Â«exprâŠ¤Â» âˆ§\n        âˆ€ {x y : A}, set_like.is_homogeneous ğ’œ x â†’ set_like.is_homogeneous ğ’œ y â†’ x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n  âŸ¨fun HI => âŸ¨ne_of_apply_ne _ HI.ne_top, fun x y hx hy hxy => ideal.is_prime.mem_or_mem HI hxyâŸ©,\n    fun âŸ¨I_ne_top, homogeneous_mem_or_memâŸ© => h.is_prime_of_homogeneous_mem_or_mem I_ne_top @homogeneous_mem_or_memâŸ©\n#align ideal.is_homogeneous.is_prime_iff ideal.is_homogeneous.is_prime_iff\n\n",
 "homogeneous_core":
 "theorem ideal.is_prime.homogeneous_core {I : ideal A} (h : I.is_prime) : (I.homogeneous_core ğ’œ).to_ideal.is_prime :=\n  by\n  apply (ideal.homogeneous_core ğ’œ I).is_homogeneous.is_prime_of_homogeneous_mem_or_mem\n  Â· exact ne_top_of_le_ne_top h.ne_top (ideal.to_ideal_homogeneous_core_le ğ’œ I)\n  rintro x y hx hy hxy\n  have H := h.mem_or_mem (ideal.to_ideal_homogeneous_core_le ğ’œ I hxy)\n  refine' H.imp _ _\n  Â· exact ideal.mem_homogeneous_core_of_is_homogeneous_of_mem hx\n  Â· exact ideal.mem_homogeneous_core_of_is_homogeneous_of_mem hy\n#align ideal.is_prime.homogeneous_core ideal.is_prime.homogeneous_core\n\n",
 "coe_radical":
 "@[simp]\ntheorem homogeneous_ideal.coe_radical (I : homogeneous_ideal ğ’œ) : I.radical.to_ideal = I.to_ideal.radical :=\n  rfl\n#align homogeneous_ideal.coe_radical homogeneous_ideal.coe_radical\n\n"}