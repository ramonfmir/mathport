{"proj_recompose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem graded_algebra.proj_recompose\n    (a : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (ğ’œ i))\n    (i : Î¹) : graded_algebra.proj ğ’œ i ((decompose ğ’œ).symm a) = (decompose ğ’œ).symm (of _ i (a i)) := by\n  rw [graded_algebra.proj_apply, decompose_symm_of, Equiv.apply_symm_apply]\n#align graded_algebra.proj_recompose graded_algebra.proj_recompose\n\n",
 "proj_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n@[simp]\ntheorem graded_algebra.proj_apply (i : Î¹) (r : A) :\n    graded_algebra.proj ğ’œ i r =\n      (decompose ğ’œ r :\n          direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (ğ’œ i))\n        i :=\n  rfl\n#align graded_algebra.proj_apply graded_algebra.proj_apply\n\n",
 "mem_support_iff":
 "theorem graded_algebra.mem_support_iff [DecidableEq A] (r : A) (i : Î¹) :\n    i âˆˆ (decompose ğ’œ r).support â†” graded_algebra.proj ğ’œ i r â‰  0 :=\n  Dfinsupp.mem_support_iff.trans Submodule.coe_eq_zero.not.symm\n#align graded_algebra.mem_support_iff graded_algebra.mem_support_iff\n\n",
 "decompose_symm_one":
 "@[simp]\ntheorem decompose_symm_one : (decompose ğ’œ).symm 1 = (1 : A) :=\n  map_one (decompose_ring_equiv ğ’œ).symm\n#align decompose_symm_one decompose_symm_one\n\n",
 "decompose_symm_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n@[simp]\ntheorem decompose_symm_mul\n    (x y : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (ğ’œ i)) :\n    (decompose ğ’œ).symm (x * y) = (decompose ğ’œ).symm x * (decompose ğ’œ).symm y :=\n  map_mul (decompose_ring_equiv ğ’œ).symm x y\n#align decompose_symm_mul decompose_symm_mul\n\n",
 "decompose_one":
 "/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser, Kevin Buzzard, Jujian Zhang\n-/\n@[simp]\ntheorem decompose_one : decompose ğ’œ (1 : A) = 1 :=\n  map_one (decompose_ring_equiv ğ’œ)\n#align decompose_one decompose_one\n\n",
 "decompose_mul_add_right":
 "theorem decompose_mul_add_right [AddRightCancelMonoid Î¹] [graded_ring ğ’œ] {a : A} (b : ğ’œ j) :\n    decompose ğ’œ (a * â†‘b) (i + j) = @graded_monoid.ghas_mul.mul Î¹ (fun i => ğ’œ i) _ _ _ _ (decompose ğ’œ a i) b :=\n  Subtype.ext <| coe_decompose_mul_add_of_right_mem ğ’œ b.2\n#align decompose_mul_add_right decompose_mul_add_right\n\n",
 "decompose_mul_add_left":
 "theorem decompose_mul_add_left [AddLeftCancelMonoid Î¹] [graded_ring ğ’œ] (a : ğ’œ i) {b : A} :\n    decompose ğ’œ (â†‘a * b) (i + j) = @graded_monoid.ghas_mul.mul Î¹ (fun i => ğ’œ i) _ _ _ _ a (decompose ğ’œ b j) :=\n  Subtype.ext <| coe_decompose_mul_add_of_left_mem ğ’œ a.2\n#align decompose_mul_add_left decompose_mul_add_left\n\n",
 "decompose_mul":
 "@[simp]\ntheorem decompose_mul (x y : A) : decompose ğ’œ (x * y) = decompose ğ’œ x * decompose ğ’œ y :=\n  map_mul (decompose_ring_equiv ğ’œ) x y\n#align decompose_mul decompose_mul\n\n",
 "coe_decompose_mul_of_right_mem_of_not_le":
 "theorem coe_decompose_mul_of_right_mem_of_not_le (b_mem : b âˆˆ ğ’œ i) (h : Â¬i â‰¤ n) : (decompose ğ’œ (a * b) n : A) = 0 :=\n  by\n  lift b to ğ’œ i using b_mem\n  rwa [decompose_mul, decompose_coe, coe_mul_of_apply_of_not_le]\n#align coe_decompose_mul_of_right_mem_of_not_le coe_decompose_mul_of_right_mem_of_not_le\n\n",
 "coe_decompose_mul_of_right_mem_of_le":
 "theorem coe_decompose_mul_of_right_mem_of_le (b_mem : b âˆˆ ğ’œ i) (h : i â‰¤ n) :\n    (decompose ğ’œ (a * b) n : A) = decompose ğ’œ a (n - i) * b :=\n  by\n  lift b to ğ’œ i using b_mem\n  rwa [decompose_mul, decompose_coe, coe_mul_of_apply_of_le]\n#align coe_decompose_mul_of_right_mem_of_le coe_decompose_mul_of_right_mem_of_le\n\n",
 "coe_decompose_mul_of_right_mem":
 "theorem coe_decompose_mul_of_right_mem (n) [Decidable (i â‰¤ n)] (b_mem : b âˆˆ ğ’œ i) :\n    (decompose ğ’œ (a * b) n : A) = if i â‰¤ n then decompose ğ’œ a (n - i) * b else 0 :=\n  by\n  lift b to ğ’œ i using b_mem\n  rwa [decompose_mul, decompose_coe, coe_mul_of_apply]\n#align coe_decompose_mul_of_right_mem coe_decompose_mul_of_right_mem\n\n",
 "coe_decompose_mul_of_left_mem_of_not_le":
 "theorem coe_decompose_mul_of_left_mem_of_not_le (a_mem : a âˆˆ ğ’œ i) (h : Â¬i â‰¤ n) : (decompose ğ’œ (a * b) n : A) = 0 :=\n  by\n  lift a to ğ’œ i using a_mem\n  rwa [decompose_mul, decompose_coe, coe_of_mul_apply_of_not_le]\n#align coe_decompose_mul_of_left_mem_of_not_le coe_decompose_mul_of_left_mem_of_not_le\n\n",
 "coe_decompose_mul_of_left_mem_of_le":
 "theorem coe_decompose_mul_of_left_mem_of_le (a_mem : a âˆˆ ğ’œ i) (h : i â‰¤ n) :\n    (decompose ğ’œ (a * b) n : A) = a * decompose ğ’œ b (n - i) :=\n  by\n  lift a to ğ’œ i using a_mem\n  rwa [decompose_mul, decompose_coe, coe_of_mul_apply_of_le]\n#align coe_decompose_mul_of_left_mem_of_le coe_decompose_mul_of_left_mem_of_le\n\n",
 "coe_decompose_mul_of_left_mem":
 "theorem coe_decompose_mul_of_left_mem (n) [Decidable (i â‰¤ n)] (a_mem : a âˆˆ ğ’œ i) :\n    (decompose ğ’œ (a * b) n : A) = if i â‰¤ n then a * decompose ğ’œ b (n - i) else 0 :=\n  by\n  lift a to ğ’œ i using a_mem\n  rwa [decompose_mul, decompose_coe, coe_of_mul_apply]\n#align coe_decompose_mul_of_left_mem coe_decompose_mul_of_left_mem\n\n",
 "coe_decompose_mul_add_of_right_mem":
 "theorem coe_decompose_mul_add_of_right_mem [AddRightCancelMonoid Î¹] [graded_ring ğ’œ] {a b : A} (b_mem : b âˆˆ ğ’œ j) :\n    (decompose ğ’œ (a * b) (i + j) : A) = decompose ğ’œ a i * b :=\n  by\n  lift b to ğ’œ j using b_mem\n  rw [decompose_mul, decompose_coe, coe_mul_of_apply_add]\n#align coe_decompose_mul_add_of_right_mem coe_decompose_mul_add_of_right_mem\n\n",
 "coe_decompose_mul_add_of_left_mem":
 "theorem coe_decompose_mul_add_of_left_mem [AddLeftCancelMonoid Î¹] [graded_ring ğ’œ] {a b : A} (a_mem : a âˆˆ ğ’œ i) :\n    (decompose ğ’œ (a * b) (i + j) : A) = a * decompose ğ’œ b j :=\n  by\n  lift a to ğ’œ i using a_mem\n  rw [decompose_mul, decompose_coe, coe_of_mul_apply_add]\n#align coe_decompose_mul_add_of_left_mem coe_decompose_mul_add_of_left_mem\n\n"}