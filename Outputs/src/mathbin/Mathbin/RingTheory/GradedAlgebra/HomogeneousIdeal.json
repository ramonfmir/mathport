{"top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem top : ideal.is_homogeneous 𝒜 («expr⊤») := fun i r hr => by simp only [submodule.mem_top]\n#align top top\n\n",
 "to_ideal_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem to_ideal_top : («expr⊤» : homogeneous_ideal 𝒜).to_ideal = («expr⊤» : ideal A) :=\n  rfl\n#align to_ideal_top to_ideal_top\n\n",
 "to_ideal_supr₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem to_ideal_supr₂ {κ : Sort _} {κ' : κ → Sort _} (s : ∀ i, κ' i → homogeneous_ideal 𝒜) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s i j)).to_ideal =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (s i j).to_ideal :=\n  by simp_rw [to_ideal_supr]\n#align to_ideal_supr₂ to_ideal_supr₂\n\n",
 "to_ideal_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem to_ideal_supr {κ : Sort _} (s : κ → homogeneous_ideal 𝒜) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s i)).to_ideal =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s i).to_ideal :=\n  by rw [supᵢ, to_ideal_Sup, supᵢ_range]\n#align to_ideal_supr to_ideal_supr\n\n",
 "to_ideal_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem to_ideal_sup (I J : homogeneous_ideal 𝒜) : («expr ⊔ » I J).to_ideal = «expr ⊔ » I.to_ideal J.to_ideal :=\n  rfl\n#align to_ideal_sup to_ideal_sup\n\n",
 "to_ideal_mul":
 "@[simp]\ntheorem homogeneous_ideal.to_ideal_mul (I J : homogeneous_ideal 𝒜) : (I * J).to_ideal = I.to_ideal * J.to_ideal :=\n  rfl\n#align homogeneous_ideal.to_ideal_mul homogeneous_ideal.to_ideal_mul\n\n",
 "to_ideal_irrelevant":
 "@[simp]\ntheorem homogeneous_ideal.to_ideal_irrelevant :\n    (homogeneous_ideal.irrelevant 𝒜).to_ideal = (graded_ring.proj_zero_ring_hom 𝒜).ker :=\n  rfl\n#align homogeneous_ideal.to_ideal_irrelevant homogeneous_ideal.to_ideal_irrelevant\n\n",
 "to_ideal_injective":
 "theorem homogeneous_ideal.to_ideal_injective :\n    function.injective (homogeneous_ideal.to_ideal : homogeneous_ideal 𝒜 → ideal A) :=\n  fun ⟨x, hx⟩ ⟨y, hy⟩ (h : x = y) => by simp [h]\n#align homogeneous_ideal.to_ideal_injective homogeneous_ideal.to_ideal_injective\n\n",
 "to_ideal_infi₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem to_ideal_infi₂ {κ : Sort _} {κ' : κ → Sort _} (s : ∀ i, κ' i → homogeneous_ideal 𝒜) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s i j)).to_ideal =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (s i j).to_ideal :=\n  by simp_rw [to_ideal_infi]\n#align to_ideal_infi₂ to_ideal_infi₂\n\n",
 "to_ideal_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem to_ideal_infi {κ : Sort _} (s : κ → homogeneous_ideal 𝒜) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s i)).to_ideal =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s i).to_ideal :=\n  by rw [infᵢ, to_ideal_Inf, infᵢ_range]\n#align to_ideal_infi to_ideal_infi\n\n",
 "to_ideal_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem to_ideal_inf (I J : homogeneous_ideal 𝒜) : («expr ⊓ » I J).to_ideal = «expr ⊓ » I.to_ideal J.to_ideal :=\n  rfl\n#align to_ideal_inf to_ideal_inf\n\n",
 "to_ideal_homogeneous_hull_eq_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem ideal.to_ideal_homogeneous_hull_eq_supr :\n    (I.homogeneous_hull 𝒜).to_ideal =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (ideal.span («expr '' » (graded_ring.proj 𝒜 i) I)) :=\n  by\n  rw [← ideal.span_Union]\n  apply congr_arg ideal.span _\n  ext1\n  simp only [Set.mem_unionᵢ, Set.mem_image, mem_set_of_eq, graded_ring.proj_apply, SetLike.exists, exists_prop,\n    subtype.coe_mk, SetLike.mem_coe]\n#align ideal.to_ideal_homogeneous_hull_eq_supr ideal.to_ideal_homogeneous_hull_eq_supr\n\n",
 "to_ideal_homogeneous_hull_eq_self":
 "theorem ideal.is_homogeneous.to_ideal_homogeneous_hull_eq_self (h : I.is_homogeneous 𝒜) :\n    (ideal.homogeneous_hull 𝒜 I).to_ideal = I :=\n  by\n  apply le_antisymm _ (ideal.le_to_ideal_homogeneous_hull _ _)\n  apply ideal.span_le.2\n  rintro _ ⟨i, x, rfl⟩\n  exact h _ x.prop\n#align ideal.is_homogeneous.to_ideal_homogeneous_hull_eq_self ideal.is_homogeneous.to_ideal_homogeneous_hull_eq_self\n\n",
 "to_ideal_homogeneous_core_le":
 "theorem ideal.to_ideal_homogeneous_core_le : (I.homogeneous_core 𝒜).to_ideal ≤ I :=\n  ideal.homogeneous_core'_le 𝒜 I\n#align ideal.to_ideal_homogeneous_core_le ideal.to_ideal_homogeneous_core_le\n\n",
 "to_ideal_homogeneous_core_eq_self":
 "@[simp]\ntheorem homogeneous_ideal.to_ideal_homogeneous_core_eq_self (I : homogeneous_ideal 𝒜) :\n    I.to_ideal.homogeneous_core 𝒜 = I := by\n  ext1 <;> convert ideal.is_homogeneous.to_ideal_homogeneous_core_eq_self I.is_homogeneous\n#align homogeneous_ideal.to_ideal_homogeneous_core_eq_self homogeneous_ideal.to_ideal_homogeneous_core_eq_self\n\n",
 "to_ideal_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem to_ideal_bot : («expr⊥» : homogeneous_ideal 𝒜).to_ideal = («expr⊥» : ideal A) :=\n  rfl\n#align to_ideal_bot to_ideal_bot\n\n",
 "to_ideal_add":
 "@[simp]\ntheorem to_ideal_add (I J : homogeneous_ideal 𝒜) : (I + J).to_ideal = I.to_ideal + J.to_ideal :=\n  rfl\n#align to_ideal_add to_ideal_add\n\n",
 "to_ideal_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem to_ideal_Sup (ℐ : set (homogeneous_ideal 𝒜)) :\n    (supₛ ℐ).to_ideal =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (to_ideal s) :=\n  rfl\n#align to_ideal_Sup to_ideal_Sup\n\n",
 "to_ideal_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem to_ideal_Inf (ℐ : set (homogeneous_ideal 𝒜)) :\n    (infₛ ℐ).to_ideal =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (to_ideal s) :=\n  rfl\n#align to_ideal_Inf to_ideal_Inf\n\n",
 "supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print supᵢ /-\nprotected theorem supᵢ {κ : Sort _} {f : κ → ideal A} (h : ∀ i, (f i).is_homogeneous 𝒜) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (f i)).is_homogeneous\n      𝒜 :=\n  by\n  simp_rw [iff_exists] at h⊢\n  choose s hs using h\n  refine' ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i), _⟩\n  simp_rw [Set.image_unionᵢ, ideal.span_Union]\n  congr\n  exact funext hs\n#align supr supᵢ\n-/\n\n",
 "supr₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr₂ {κ : Sort _} {κ' : κ → Sort _} {f : ∀ i, κ' i → ideal A} (h : ∀ i j, (f i j).is_homogeneous 𝒜) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (f i j)).is_homogeneous\n      𝒜 :=\n  is_homogeneous.supr fun i => is_homogeneous.supr <| h i\n#align supr₂ supr₂\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup {I J : ideal A} (HI : I.is_homogeneous 𝒜) (HJ : J.is_homogeneous 𝒜) : («expr ⊔ » I J).is_homogeneous 𝒜 :=\n  by\n  rw [iff_exists] at HI HJ⊢\n  obtain ⟨⟨s₁, rfl⟩, ⟨s₂, rfl⟩⟩ := HI, HJ\n  refine' ⟨s₁ ∪ s₂, _⟩\n  rw [Set.image_union]\n  exact (submodule.span_union _ _).symm\n#align sup sup\n\n",
 "mul_homogeneous_element_mem_of_mem":
 "theorem ideal.mul_homogeneous_element_mem_of_mem {I : ideal A} (r x : A) (hx₁ : is_homogeneous 𝒜 x) (hx₂ : x ∈ I)\n    (j : ι) : graded_ring.proj 𝒜 j (r * x) ∈ I := by\n  classical\n    rw [← direct_sum.sum_support_decompose 𝒜 r, finset.sum_mul, map_sum]\n    apply ideal.sum_mem\n    intro k hk\n    obtain ⟨i, hi⟩ := hx₁\n    have mem₁ : (direct_sum.decompose 𝒜 r k : A) * x ∈ 𝒜 (k + i) := graded_monoid.mul_mem (SetLike.coe_mem _) hi\n    erw [graded_ring.proj_apply, direct_sum.decompose_of_mem 𝒜 mem₁, coe_of_apply, [anonymous]]\n    split_ifs\n    · exact I.mul_mem_left _ hx₂\n    · exact I.zero_mem\n#align ideal.mul_homogeneous_element_mem_of_mem ideal.mul_homogeneous_element_mem_of_mem\n\n",
 "mul":
 "theorem ideal.is_homogeneous.mul {I J : ideal A} (HI : I.is_homogeneous 𝒜) (HJ : J.is_homogeneous 𝒜) :\n    (I * J).is_homogeneous 𝒜 := by\n  rw [ideal.is_homogeneous.iff_exists] at HI HJ⊢\n  obtain ⟨⟨s₁, rfl⟩, ⟨s₂, rfl⟩⟩ := HI, HJ\n  rw [ideal.span_mul_span']\n  exact ⟨s₁ * s₂, congr_arg _ <| (Set.image_mul (homogeneous_submonoid 𝒜).subtype).symm⟩\n#align ideal.is_homogeneous.mul ideal.is_homogeneous.mul\n\n",
 "mem_irrelevant_iff":
 "@[simp]\ntheorem homogeneous_ideal.mem_irrelevant_iff (a : A) : a ∈ homogeneous_ideal.irrelevant 𝒜 ↔ proj 𝒜 0 a = 0 :=\n  iff.rfl\n#align homogeneous_ideal.mem_irrelevant_iff homogeneous_ideal.mem_irrelevant_iff\n\n",
 "mem_iff":
 "@[simp]\ntheorem homogeneous_ideal.mem_iff {I : homogeneous_ideal 𝒜} {x : A} : x ∈ I.to_ideal ↔ x ∈ I :=\n  iff.rfl\n#align homogeneous_ideal.mem_iff homogeneous_ideal.mem_iff\n\n",
 "mem_homogeneous_core_of_is_homogeneous_of_mem":
 "theorem ideal.mem_homogeneous_core_of_is_homogeneous_of_mem {x : A} (h : set_like.is_homogeneous 𝒜 x) (hmem : x ∈ I) :\n    x ∈ I.homogeneous_core 𝒜 :=\n  ideal.subset_span ⟨⟨x, h⟩, hmem, rfl⟩\n#align ideal.mem_homogeneous_core_of_is_homogeneous_of_mem ideal.mem_homogeneous_core_of_is_homogeneous_of_mem\n\n",
 "le_to_ideal_homogeneous_hull":
 "theorem ideal.le_to_ideal_homogeneous_hull : I ≤ (ideal.homogeneous_hull 𝒜 I).to_ideal :=\n  by\n  intro r hr\n  classical\n    rw [← direct_sum.sum_support_decompose 𝒜 r]\n    refine' ideal.sum_mem _ _\n    intro j hj\n    apply ideal.subset_span\n    use j\n    use ⟨r, hr⟩\n    rfl\n#align ideal.le_to_ideal_homogeneous_hull ideal.le_to_ideal_homogeneous_hull\n\n",
 "is_homogeneous_span":
 "theorem ideal.is_homogeneous_span (s : set A) (h : ∀ x ∈ s, is_homogeneous 𝒜 x) : (ideal.span s).is_homogeneous 𝒜 :=\n  by\n  rintro i r hr\n  rw [ideal.span, finsupp.span_eq_range_total] at hr\n  rw [linear_map.mem_range] at hr\n  obtain ⟨s, rfl⟩ := hr\n  rw [finsupp.total_apply, finsupp.sum, decompose_sum, dfinsupp.finset_sum_apply, add_submonoid_class.coe_finset_sum]\n  refine' ideal.sum_mem _ _\n  rintro z hz1\n  rw [smul_eq_mul]\n  refine' ideal.mul_homogeneous_element_mem_of_mem 𝒜 (s z) z _ _ i\n  · rcases z with ⟨z, hz2⟩\n    apply h _ hz2\n  · exact ideal.subset_span z.2\n#align ideal.is_homogeneous_span ideal.is_homogeneous_span\n\n",
 "is_homogeneous_iff_subset_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem ideal.is_homogeneous_iff_subset_Inter :\n    I.is_homogeneous 𝒜 ↔\n      (I : set A) ⊆\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          («expr ⁻¹' » (graded_ring.proj 𝒜 i) ↑I) :=\n  subset_interᵢ_iff.symm\n#align ideal.is_homogeneous_iff_subset_Inter ideal.is_homogeneous_iff_subset_Inter\n\n",
 "is_homogeneous_iff_forall_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem ideal.is_homogeneous_iff_forall_subset :\n    I.is_homogeneous 𝒜 ↔ ∀ i, (I : set A) ⊆ «expr ⁻¹' » (graded_ring.proj 𝒜 i) I :=\n  iff.rfl\n#align ideal.is_homogeneous_iff_forall_subset ideal.is_homogeneous_iff_forall_subset\n\n",
 "is_homogeneous":
 "/-\nCopyright (c) 2021 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Eric Wieser\n-/\ntheorem homogeneous_ideal.is_homogeneous (I : homogeneous_ideal 𝒜) : I.to_ideal.is_homogeneous 𝒜 :=\n  I.is_homogeneous'\n#align homogeneous_ideal.is_homogeneous homogeneous_ideal.is_homogeneous\n\n",
 "infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print infᵢ /-\nprotected theorem infᵢ {κ : Sort _} {f : κ → ideal A} (h : ∀ i, (f i).is_homogeneous 𝒜) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (f i)).is_homogeneous\n      𝒜 :=\n  by\n  intro i x hx\n  simp only [ideal.mem_infi] at hx⊢\n  exact fun j => h _ _ (hx j)\n#align infi infᵢ\n-/\n\n",
 "infi₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi₂ {κ : Sort _} {κ' : κ → Sort _} {f : ∀ i, κ' i → ideal A} (h : ∀ i j, (f i j).is_homogeneous 𝒜) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (f i j)).is_homogeneous\n      𝒜 :=\n  is_homogeneous.infi fun i => is_homogeneous.infi <| h i\n#align infi₂ infi₂\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf {I J : ideal A} (HI : I.is_homogeneous 𝒜) (HJ : J.is_homogeneous 𝒜) : («expr ⊓ » I J).is_homogeneous 𝒜 :=\n  fun i r hr => ⟨HI _ hr.1, HJ _ hr.2⟩\n#align inf inf\n\n",
 "iff_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem ideal.is_homogeneous.iff_exists :\n    I.is_homogeneous 𝒜 ↔ ∃ S : set (homogeneous_submonoid 𝒜), I = ideal.span («expr '' » coe S) :=\n  by\n  rw [ideal.is_homogeneous.iff_eq, eq_comm]\n  exact ((set.image_preimage.compose (submodule.gi _ _).gc).exists_eq_l _).symm\n#align ideal.is_homogeneous.iff_exists ideal.is_homogeneous.iff_exists\n\n",
 "iff_eq":
 "theorem ideal.is_homogeneous.iff_eq : I.is_homogeneous 𝒜 ↔ (I.homogeneous_core 𝒜).to_ideal = I :=\n  ⟨fun hI => hI.to_ideal_homogeneous_core_eq_self, fun hI => hI ▸ (ideal.homogeneous_core 𝒜 I).2⟩\n#align ideal.is_homogeneous.iff_eq ideal.is_homogeneous.iff_eq\n\n",
 "homogeneous_hull_to_ideal_eq_self":
 "@[simp]\ntheorem homogeneous_ideal.homogeneous_hull_to_ideal_eq_self (I : homogeneous_ideal 𝒜) :\n    I.to_ideal.homogeneous_hull 𝒜 = I :=\n  homogeneous_ideal.to_ideal_injective <| I.is_homogeneous.to_ideal_homogeneous_hull_eq_self\n#align homogeneous_ideal.homogeneous_hull_to_ideal_eq_self homogeneous_ideal.homogeneous_hull_to_ideal_eq_self\n\n",
 "homogeneous_hull_mono":
 "theorem ideal.homogeneous_hull_mono : monotone (ideal.homogeneous_hull 𝒜) := fun I J I_le_J =>\n  by\n  apply ideal.span_mono\n  rintro r ⟨hr1, ⟨x, hx⟩, rfl⟩\n  refine' ⟨hr1, ⟨⟨x, I_le_J hx⟩, rfl⟩⟩\n#align ideal.homogeneous_hull_mono ideal.homogeneous_hull_mono\n\n",
 "homogeneous_hull_eq_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem ideal.homogeneous_hull_eq_supr :\n    I.homogeneous_hull 𝒜 =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        ⟨ideal.span («expr '' » (graded_ring.proj 𝒜 i) I),\n          ideal.is_homogeneous_span 𝒜 _\n            (by\n              rintro _ ⟨x, -, rfl⟩\n              apply set_like.is_homogeneous_coe)⟩ :=\n  by\n  ext1\n  rw [ideal.to_ideal_homogeneous_hull_eq_supr, to_ideal_supr]\n  rfl\n#align ideal.homogeneous_hull_eq_supr ideal.homogeneous_hull_eq_supr\n\n",
 "homogeneous_hull_eq_Inf":
 "theorem ideal.homogeneous_hull_eq_Inf (I : ideal A) :\n    ideal.homogeneous_hull 𝒜 I = infₛ { J : homogeneous_ideal 𝒜 | I ≤ J.to_ideal } :=\n  eq.symm <| IsGLB.infₛ_eq <| (ideal.homogeneous_hull.gc 𝒜).is_least_l.is_glb\n#align ideal.homogeneous_hull_eq_Inf ideal.homogeneous_hull_eq_Inf\n\n",
 "homogeneous_core_mono":
 "theorem ideal.homogeneous_core_mono : monotone (ideal.homogeneous_core 𝒜) :=\n  ideal.homogeneous_core'_mono 𝒜\n#align ideal.homogeneous_core_mono ideal.homogeneous_core_mono\n\n",
 "homogeneous_core_eq_Sup":
 "theorem ideal.homogeneous_core_eq_Sup : I.homogeneous_core 𝒜 = supₛ { J : homogeneous_ideal 𝒜 | J.to_ideal ≤ I } :=\n  eq.symm <| IsLUB.supₛ_eq <| (ideal.homogeneous_core.gc 𝒜).is_greatest_u.is_lub\n#align ideal.homogeneous_core_eq_Sup ideal.homogeneous_core_eq_Sup\n\n",
 "homogeneous_core'_mono":
 "theorem ideal.homogeneous_core'_mono : monotone (ideal.homogeneous_core' 𝒜) := fun I J I_le_J =>\n  ideal.span_mono <| Set.image_subset _ fun x => @I_le_J _\n#align ideal.homogeneous_core'_mono ideal.homogeneous_core'_mono\n\n",
 "homogeneous_core'_le":
 "theorem ideal.homogeneous_core'_le : I.homogeneous_core' 𝒜 ≤ I :=\n  ideal.span_le.2 <| image_preimage_subset _ _\n#align ideal.homogeneous_core'_le ideal.homogeneous_core'_le\n\n",
 "homogeneous_core'_eq_Sup":
 "theorem ideal.homogeneous_core'_eq_Sup : I.homogeneous_core' 𝒜 = supₛ { J : ideal A | J.is_homogeneous 𝒜 ∧ J ≤ I } :=\n  by\n  refine' (IsLUB.supₛ_eq _).symm\n  apply IsGreatest.isLUB\n  have coe_mono : monotone (to_ideal : homogeneous_ideal 𝒜 → ideal A) := fun x y => id\n  convert coe_mono.map_is_greatest (ideal.homogeneous_core.gc 𝒜).is_greatest_u using 1\n  ext\n  rw [mem_image, mem_set_of_eq]\n  refine' ⟨fun hI => ⟨⟨x, hI.1⟩, ⟨hI.2, rfl⟩⟩, by rintro ⟨x, ⟨hx, rfl⟩⟩ <;> exact ⟨x.is_homogeneous, hx⟩⟩\n#align ideal.homogeneous_core'_eq_Sup ideal.homogeneous_core'_eq_Sup\n\n",
 "gc":
 "theorem ideal.homogeneous_hull.gc : GaloisConnection (ideal.homogeneous_hull 𝒜) to_ideal := fun I J =>\n  ⟨le_trans (ideal.le_to_ideal_homogeneous_hull _ _), fun H =>\n    J.homogeneous_hull_to_ideal_eq_self ▸ ideal.homogeneous_hull_mono 𝒜 H⟩\n#align ideal.homogeneous_hull.gc ideal.homogeneous_hull.gc\n\n",
 "ext":
 "@[ext]\ntheorem homogeneous_ideal.ext {I J : homogeneous_ideal 𝒜} (h : I.to_ideal = J.to_ideal) : I = J :=\n  homogeneous_ideal.to_ideal_injective h\n#align homogeneous_ideal.ext homogeneous_ideal.ext\n\n",
 "eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print eq_top_iff /-\n@[simp]\ntheorem eq_top_iff (I : homogeneous_ideal 𝒜) : I = «expr⊤» ↔ I.to_ideal = «expr⊤» :=\n  to_ideal_injective.eq_iff.symm\n#align eq_top_iff eq_top_iff\n-/\n\n",
 "eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print eq_bot_iff /-\n@[simp]\ntheorem eq_bot_iff (I : homogeneous_ideal 𝒜) : I = «expr⊥» ↔ I.to_ideal = «expr⊥» :=\n  to_ideal_injective.eq_iff.symm\n#align eq_bot_iff eq_bot_iff\n-/\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : ((«expr⊤» : homogeneous_ideal 𝒜) : set A) = univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem coe_sup (I J : homogeneous_ideal 𝒜) : ↑(«expr ⊔ » I J) = (I + J : set A) :=\n  submodule.coe_sup _ _\n#align coe_sup coe_sup\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem coe_inf (I J : homogeneous_ideal 𝒜) : (↑(«expr ⊓ » I J) : set A) = I ∩ J :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_bot : ((«expr⊥» : homogeneous_ideal 𝒜) : set A) = 0 :=\n  rfl\n#align coe_bot coe_bot\n\n",
 "bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem bot : ideal.is_homogeneous 𝒜 («expr⊥») := fun i r hr =>\n  by\n  simp only [ideal.mem_bot] at hr\n  rw [hr, decompose_zero, zero_apply]\n  apply ideal.zero_mem\n#align bot bot\n\n",
 "Sup":
 "theorem Sup {ℐ : set (ideal A)} (h : ∀ I ∈ ℐ, ideal.is_homogeneous 𝒜 I) : (supₛ ℐ).is_homogeneous 𝒜 :=\n  by\n  rw [supₛ_eq_supᵢ]\n  exact supr₂ h\n#align Sup Sup\n\n",
 "Inf":
 "theorem Inf {ℐ : set (ideal A)} (h : ∀ I ∈ ℐ, ideal.is_homogeneous 𝒜 I) : (infₛ ℐ).is_homogeneous 𝒜 :=\n  by\n  rw [infₛ_eq_infᵢ]\n  exact infi₂ h\n#align Inf Inf\n\n"}