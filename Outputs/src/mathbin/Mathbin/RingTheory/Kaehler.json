{"total_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\ntheorem kaehler_differential.total_surjective :\n    function.surjective (Finsupp.total S («exprΩ[ ⁄ ]» S R) S (kaehler_differential.D R S)) := by\n  rw [← LinearMap.range_eq_top, Finsupp.range_total, kaehler_differential.span_range_derivation]\n#align kaehler_differential.total_surjective kaehler_differential.total_surjective\n\n",
 "tensor_product_to_tmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem derivation.tensor_product_to_tmul (D : derivation R S M) (s t : S) :\n    D.tensor_product_to («expr ⊗ₜ » s t) = «expr • » s (D t) :=\n  rfl\n#align derivation.tensor_product_to_tmul derivation.tensor_product_to_tmul\n\n",
 "tensor_product_to_surjective":
 "theorem kaehler_differential.tensor_product_to_surjective :\n    function.surjective (kaehler_differential.D R S).tensor_product_to :=\n  by\n  intro x; obtain ⟨x, rfl⟩ := (kaehler_differential.ideal R S).to_cotangent_surjective x\n  exact ⟨x, kaehler_differential.D_tensor_product_to x⟩\n#align kaehler_differential.tensor_product_to_surjective kaehler_differential.tensor_product_to_surjective\n\n",
 "tensor_product_to_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem derivation.tensor_product_to_mul (D : derivation R S M) (x y : tensor_product S R S) :\n    D.tensor_product_to (x * y) =\n      «expr • » (tensor_product.lmul' R x) (D.tensor_product_to y) +\n        «expr • » (tensor_product.lmul' R y) (D.tensor_product_to x) :=\n  by\n  apply TensorProduct.induction_on x\n  · rw [MulZeroClass.zero_mul, map_zero, map_zero, zero_smul, smul_zero, add_zero]\n  swap;\n  · rintro\n    simp only [add_mul, map_add, add_smul, *, smul_add]\n    rw [add_add_add_comm]\n  intro x₁ x₂\n  apply TensorProduct.induction_on y\n  · rw [MulZeroClass.mul_zero, map_zero, map_zero, zero_smul, smul_zero, add_zero]\n  swap;\n  · rintro\n    simp only [mul_add, map_add, add_smul, *, smul_add]\n    rw [add_add_add_comm]\n  intro x y\n  simp only [tensor_product.tmul_mul_tmul, derivation.tensor_product_to,\n    tensor_product.algebra_tensor_module.lift_apply, TensorProduct.lift.tmul', tensor_product.lmul'_apply_tmul]\n  dsimp\n  rw [D.leibniz]\n  simp only [smul_smul, smul_add, mul_comm (x * y) x₁, mul_right_comm x₁ x₂, ← mul_assoc]\n#align derivation.tensor_product_to_mul derivation.tensor_product_to_mul\n\n",
 "submodule_span_range_eq_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/-- The kernel of `S ⊗[R] S →ₐ[R] S` is generated by `1 ⊗ s - s ⊗ 1` as a `S`-module. -/\ntheorem kaehler_differential.submodule_span_range_eq_ideal :\n    Submodule.span S (Set.range fun s : S => «expr ⊗ₜ[ ] » (1 : S) R s - «expr ⊗ₜ[ ] » s R (1 : S)) =\n      (kaehler_differential.ideal R S).restrict_scalars S :=\n  by\n  apply le_antisymm\n  · rw [Submodule.span_le]\n    rintro _ ⟨s, rfl⟩\n    exact kaehler_differential.one_smul_sub_smul_one_mem_ideal _ _\n  · rintro x (hx : _ = _)\n    have : x - «expr ⊗ₜ[ ] » (tensor_product.lmul' R x) R (1 : S) = x := by rw [hx, TensorProduct.zero_tmul, sub_zero]\n    rw [← this]\n    clear this hx\n    apply TensorProduct.induction_on x <;> clear x\n    · rw [map_zero, TensorProduct.zero_tmul, sub_zero]\n      exact zero_mem _\n    · intro x y\n      convert_to«expr • » x («expr ⊗ₜ » 1 y - «expr ⊗ₜ » y 1) ∈ _\n      ·\n        rw [tensor_product.lmul'_apply_tmul, smul_sub, TensorProduct.smul_tmul', TensorProduct.smul_tmul', smul_eq_mul,\n          smul_eq_mul, mul_one]\n      · refine' Submodule.smul_mem _ x _\n        apply Submodule.subset_span\n        exact Set.mem_range_self y\n    · intro x y hx hy\n      rw [map_add, TensorProduct.add_tmul, ← sub_add_sub_comm]\n      exact add_mem hx hy\n#align kaehler_differential.submodule_span_range_eq_ideal kaehler_differential.submodule_span_range_eq_ideal\n\n",
 "span_range_eq_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\ntheorem kaehler_differential.span_range_eq_ideal :\n    Ideal.span (Set.range fun s : S => «expr ⊗ₜ[ ] » (1 : S) R s - «expr ⊗ₜ[ ] » s R (1 : S)) =\n      kaehler_differential.ideal R S :=\n  by\n  apply le_antisymm\n  · rw [Ideal.span_le]\n    rintro _ ⟨s, rfl⟩\n    exact kaehler_differential.one_smul_sub_smul_one_mem_ideal _ _\n  · change (kaehler_differential.ideal R S).restrict_scalars S ≤ (Ideal.span _).restrict_scalars S\n    rw [← kaehler_differential.submodule_span_range_eq_ideal, Ideal.span]\n    conv_rhs => rw [← Submodule.span_span_of_tower S]\n    exact Submodule.subset_span\n#align kaehler_differential.span_range_eq_ideal kaehler_differential.span_range_eq_ideal\n\n",
 "span_range_derivation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem kaehler_differential.span_range_derivation :\n    Submodule.span S (Set.range <| kaehler_differential.D R S) = «expr⊤» :=\n  by\n  rw [_root_.eq_top_iff]\n  rintro x -\n  obtain ⟨⟨x, hx⟩, rfl⟩ := ideal.to_cotangent_surjective _ x\n  have : x ∈ (kaehler_differential.ideal R S).restrict_scalars S := hx\n  rw [← kaehler_differential.submodule_span_range_eq_ideal] at this\n  suffices\n    ∃ hx,\n      (kaehler_differential.ideal R S).to_cotangent ⟨x, hx⟩ ∈ Submodule.span S (Set.range <| kaehler_differential.D R S)\n    by exact this.some_spec\n  apply Submodule.span_induction this\n  · rintro _ ⟨x, rfl⟩\n    refine' ⟨kaehler_differential.one_smul_sub_smul_one_mem_ideal R x, _⟩\n    apply Submodule.subset_span\n    exact ⟨x, kaehler_differential.D_linear_map_apply R S x⟩\n  · exact ⟨zero_mem _, Submodule.zero_mem _⟩\n  · rintro x y ⟨hx₁, hx₂⟩ ⟨hy₁, hy₂⟩\n    exact ⟨add_mem hx₁ hy₁, Submodule.add_mem _ hx₂ hy₂⟩\n  · rintro r x ⟨hx₁, hx₂⟩\n    exact ⟨((kaehler_differential.ideal R S).restrict_scalars S).smul_mem r hx₁, Submodule.smul_mem _ r hx₂⟩\n#align kaehler_differential.span_range_derivation kaehler_differential.span_range_derivation\n\n",
 "quot_ker_total_equiv_symm_comp_D":
 "theorem kaehler_differential.quot_ker_total_equiv_symm_comp_D :\n    (kaehler_differential.quot_ker_total_equiv R S).symm.to_linear_map.comp_der (kaehler_differential.D R S) =\n      kaehler_differential.derivation_quot_ker_total R S :=\n  by convert(kaehler_differential.derivation_quot_ker_total R S).lift_kaehler_differential_comp using 0\n#align kaehler_differential.quot_ker_total_equiv_symm_comp_D kaehler_differential.quot_ker_total_equiv_symm_comp_D\n\n",
 "one_smul_sub_smul_one_mem_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/-\nCopyright © 2020 Nicolò Cavalleri. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Nicolò Cavalleri, Andrew Yang\n-/\ntheorem kaehler_differential.one_smul_sub_smul_one_mem_ideal (a : S) :\n    «expr ⊗ₜ[ ] » (1 : S) R a - «expr ⊗ₜ[ ] » a R (1 : S) ∈ kaehler_differential.ideal R S := by simp [RingHom.mem_ker]\n#align kaehler_differential.one_smul_sub_smul_one_mem_ideal kaehler_differential.one_smul_sub_smul_one_mem_ideal\n\n",
 "map_surjective_of_surjective":
 "theorem kaehler_differential.map_surjective_of_surjective (h : function.surjective (algebraMap A B)) :\n    function.surjective (kaehler_differential.map R S A B) :=\n  by\n  rw [← LinearMap.range_eq_top, _root_.eq_top_iff, ← @Submodule.restrictScalars_top B A, ←\n    kaehler_differential.span_range_derivation, Submodule.restrictScalars_span _ _ h, Submodule.span_le]\n  rintro _ ⟨x, rfl⟩\n  obtain ⟨y, rfl⟩ := h x\n  rw [← kaehler_differential.map_D R S A B]\n  exact ⟨_, rfl⟩\n#align kaehler_differential.map_surjective_of_surjective kaehler_differential.map_surjective_of_surjective\n\n",
 "map_comp_der":
 "/- We have the commutative diagram\nA --→ B\n↑     ↑\n|     |\nR --→ S -/\ntheorem kaehler_differential.map_comp_der :\n    (kaehler_differential.map R S A B).comp_der (kaehler_differential.D R A) =\n      ((kaehler_differential.D S B).restrict_scalars R).comp_algebra_map A :=\n  derivation.lift_kaehler_differential_comp _\n#align kaehler_differential.map_comp_der kaehler_differential.map_comp_der\n\n",
 "map_base_change_tmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem kaehler_differential.map_base_change_tmul (x : B) (y : «exprΩ[ ⁄ ]» A R) :\n    kaehler_differential.map_base_change R A B («expr ⊗ₜ » x y) = «expr • » x (kaehler_differential.map R R A B y) :=\n  by\n  conv_lhs => rw [← mul_one x, ← smul_eq_mul, ← TensorProduct.smul_tmul', LinearMap.map_smul]\n  congr 1\n  exact is_base_change.lift_eq _ _ _\n#align kaehler_differential.map_base_change_tmul kaehler_differential.map_base_change_tmul\n\n",
 "map_D":
 "theorem kaehler_differential.map_D (x : A) :\n    kaehler_differential.map R S A B (kaehler_differential.D R A x) = kaehler_differential.D S B (algebraMap A B x) :=\n  derivation.congr_fun (kaehler_differential.map_comp_der R S A B) x\n#align kaehler_differential.map_D kaehler_differential.map_D\n\n",
 "lift_kaehler_differential_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\n@[ext]\ntheorem derivation.lift_kaehler_differential_unique (f f' : «expr →ₗ[ ] » («exprΩ[ ⁄ ]» S R) S M)\n    (hf : f.comp_der (kaehler_differential.D R S) = f'.comp_der (kaehler_differential.D R S)) : f = f' :=\n  by\n  apply LinearMap.ext\n  intro x\n  have : x ∈ Submodule.span S (Set.range <| kaehler_differential.D R S) :=\n    by\n    rw [kaehler_differential.span_range_derivation]\n    trivial\n  apply Submodule.span_induction this\n  · rintro _ ⟨x, rfl⟩\n    exact congr_arg (fun D : derivation R S M => D x) hf\n  · rw [map_zero, map_zero]\n  · intro x y hx hy\n    rw [map_add, map_add, hx, hy]\n  · intro a x e\n    rw [map_smul, map_smul, e]\n#align derivation.lift_kaehler_differential_unique derivation.lift_kaehler_differential_unique\n\n",
 "lift_kaehler_differential_comp_D":
 "@[simp]\ntheorem derivation.lift_kaehler_differential_comp_D (D' : derivation R S M) (x : S) :\n    D'.lift_kaehler_differential (kaehler_differential.D R S x) = D' x :=\n  derivation.congr_fun D'.lift_kaehler_differential_comp x\n#align derivation.lift_kaehler_differential_comp_D derivation.lift_kaehler_differential_comp_D\n\n",
 "lift_kaehler_differential_comp":
 "theorem derivation.lift_kaehler_differential_comp (D : derivation R S M) :\n    D.lift_kaehler_differential.comp_der (kaehler_differential.D R S) = D :=\n  by\n  ext a\n  dsimp [kaehler_differential.D_apply]\n  refine' (D.lift_kaehler_differential_apply _).trans _\n  rw [Subtype.coe_mk, map_sub, derivation.tensor_product_to_tmul, derivation.tensor_product_to_tmul, one_smul,\n    D.map_one_eq_zero, smul_zero, sub_zero]\n#align derivation.lift_kaehler_differential_comp derivation.lift_kaehler_differential_comp\n\n",
 "lift_kaehler_differential_apply":
 "theorem derivation.lift_kaehler_differential_apply (D : derivation R S M) (x) :\n    D.lift_kaehler_differential ((kaehler_differential.ideal R S).to_cotangent x) = D.tensor_product_to x :=\n  rfl\n#align derivation.lift_kaehler_differential_apply derivation.lift_kaehler_differential_apply\n\n",
 "lift_kaehler_differential_D":
 "theorem derivation.lift_kaehler_differential_D :\n    (kaehler_differential.D R S).lift_kaehler_differential = LinearMap.id :=\n  derivation.lift_kaehler_differential_unique _ _ (kaehler_differential.D R S).lift_kaehler_differential_comp\n#align derivation.lift_kaehler_differential_D derivation.lift_kaehler_differential_D\n\n",
 "ker_total_mkq_single_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\ntheorem kaehler_differential.ker_total_mkq_single_smul (r : R) (x y) :\n    «expr 𝖣 » y («expr • » r x) = «expr • » r («expr 𝖣 » y x) := by\n  rw [Algebra.smul_def, kaehler_differential.ker_total_mkq_single_mul,\n    kaehler_differential.ker_total_mkq_single_algebra_map, add_zero, ← LinearMap.map_smul_of_tower, Finsupp.smul_single,\n    mul_comm, Algebra.smul_def]\n#align kaehler_differential.ker_total_mkq_single_smul kaehler_differential.ker_total_mkq_single_smul\n\n",
 "ker_total_mkq_single_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\ntheorem kaehler_differential.ker_total_mkq_single_mul (x y z) :\n    «expr 𝖣 » z (x * y) = «expr 𝖣 » (z * x) y + «expr 𝖣 » (z * y) x :=\n  by\n  rw [← map_add, eq_comm, ← sub_eq_zero, ← map_sub, Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]\n  simp_rw [← Finsupp.smul_single_one _ z, ← @smul_eq_mul _ _ z, ← Finsupp.smul_single, ← smul_add, ← smul_sub]\n  exact Submodule.smul_mem _ _ (Submodule.subset_span (or.inl <| or.inr <| ⟨⟨_, _⟩, rfl⟩))\n#align kaehler_differential.ker_total_mkq_single_mul kaehler_differential.ker_total_mkq_single_mul\n\n",
 "ker_total_mkq_single_algebra_map_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\ntheorem kaehler_differential.ker_total_mkq_single_algebra_map_one (x) : «expr 𝖣 » x 1 = 0 := by\n  rw [← (algebraMap R S).map_one, kaehler_differential.ker_total_mkq_single_algebra_map]\n#align kaehler_differential.ker_total_mkq_single_algebra_map_one kaehler_differential.ker_total_mkq_single_algebra_map_one\n\n",
 "ker_total_mkq_single_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\ntheorem kaehler_differential.ker_total_mkq_single_algebra_map (x y) : «expr 𝖣 » y (algebraMap R S x) = 0 :=\n  by\n  rw [Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero, ← Finsupp.smul_single_one _ y]\n  exact Submodule.smul_mem _ _ (Submodule.subset_span (or.inr <| ⟨_, rfl⟩))\n#align kaehler_differential.ker_total_mkq_single_algebra_map kaehler_differential.ker_total_mkq_single_algebra_map\n\n",
 "ker_total_mkq_single_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n-- This has type\n-- `derivation R S Ω[S⁄R] ≃ₗ[R] derivation R S (kaehler_differential.ideal R S).cotangent_ideal`\n-- But lean times-out if this is given explicitly.\ntheorem kaehler_differential.ker_total_mkq_single_add (x y z) : «expr 𝖣 » z (x + y) = «expr 𝖣 » z x + «expr 𝖣 » z y :=\n  by\n  rw [← map_add, eq_comm, ← sub_eq_zero, ← map_sub, Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]\n  simp_rw [← Finsupp.smul_single_one _ z, ← smul_add, ← smul_sub]\n  exact Submodule.smul_mem _ _ (Submodule.subset_span (or.inl <| or.inl <| ⟨⟨_, _⟩, rfl⟩))\n#align kaehler_differential.ker_total_mkq_single_add kaehler_differential.ker_total_mkq_single_add\n\n",
 "ker_total_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprfinsupp_map -/\n-- The map `(A →₀ A) →ₗ[A] (B →₀ B)`\ntheorem kaehler_differential.ker_total_map (h : function.surjective (algebraMap A B)) :\n    «expr ⊔ » ((kaehler_differential.ker_total R A).map (exprfinsupp_map))\n        (Submodule.span A (Set.range fun x : S => single (algebraMap S B x) (1 : B))) =\n      (kaehler_differential.ker_total S B).restrict_scalars _ :=\n  by\n  rw [kaehler_differential.ker_total, Submodule.map_span, kaehler_differential.ker_total,\n    Submodule.restrictScalars_span _ _ h]\n  simp_rw [Set.image_union, Submodule.span_union, ← Set.image_univ, Set.image_image, Set.image_univ, map_sub, map_add]\n  simp only [LinearMap.comp_apply, Finsupp.mapRange.linearMap_apply, Finsupp.mapRange_single, Finsupp.lmapDomain_apply,\n    Finsupp.mapDomain_single, AlgHom.toLinearMap_apply, Algebra.ofId_apply, ← IsScalarTower.algebraMap_apply, map_one,\n    map_add, map_mul]\n  simp_rw [sup_assoc, ← (h.prod_map h).range_comp]\n  congr 3\n  rw [sup_eq_right]\n  apply Submodule.span_mono\n  simp_rw [IsScalarTower.algebraMap_apply R S B]\n  exact Set.range_comp_subset_range (algebraMap R S) fun x => single (algebraMap S B x) (1 : B)\n#align kaehler_differential.ker_total_map kaehler_differential.ker_total_map\n\n",
 "ker_total_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\ntheorem kaehler_differential.ker_total_eq :\n    (Finsupp.total S («exprΩ[ ⁄ ]» S R) S (kaehler_differential.D R S)).ker = kaehler_differential.ker_total R S :=\n  by\n  apply le_antisymm\n  · conv_rhs => rw [← (kaehler_differential.ker_total R S).ker_mkq]\n    rw [← kaehler_differential.derivation_quot_ker_total_lift_comp_total]\n    exact LinearMap.ker_le_ker_comp _ _\n  · rw [kaehler_differential.ker_total, Submodule.span_le]\n    rintro _ ((⟨⟨x, y⟩, rfl⟩ | ⟨⟨x, y⟩, rfl⟩) | ⟨x, rfl⟩) <;> dsimp <;> simp [LinearMap.mem_ker]\n#align kaehler_differential.ker_total_eq kaehler_differential.ker_total_eq\n\n",
 "derivation_quot_ker_total_lift_comp_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\ntheorem kaehler_differential.derivation_quot_ker_total_lift_comp_total :\n    (kaehler_differential.derivation_quot_ker_total R S).lift_kaehler_differential.comp\n        (Finsupp.total S («exprΩ[ ⁄ ]» S R) S (kaehler_differential.D R S)) =\n      Submodule.mkQ _ :=\n  by\n  apply Finsupp.lhom_ext\n  intro a b\n  conv_rhs => rw [← Finsupp.smul_single_one a b, LinearMap.map_smul]\n  simp [kaehler_differential.derivation_quot_ker_total_apply]\n#align kaehler_differential.derivation_quot_ker_total_lift_comp_total kaehler_differential.derivation_quot_ker_total_lift_comp_total\n\n",
 "derivation_quot_ker_total_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\ntheorem kaehler_differential.derivation_quot_ker_total_apply (x) :\n    kaehler_differential.derivation_quot_ker_total R S x = «expr 𝖣 » 1 x :=\n  rfl\n#align kaehler_differential.derivation_quot_ker_total_apply kaehler_differential.derivation_quot_ker_total_apply\n\n",
 "End_equiv_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product.infer -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\ntheorem kaehler_differential.End_equiv_aux\n    (f : «expr →ₐ[ ] » S R («expr ⧸ » (tensor_product.infer S S) (kaehler_differential.ideal R S ^ 2))) :\n    (Ideal.Quotient.mkₐ R (kaehler_differential.ideal R S).cotangent_ideal).comp f = IsScalarTower.toAlgHom R S _ ↔\n      (tensor_product.lmul' R : «expr →ₐ[ ] » (tensor_product S R S) R S).ker_square_lift.comp f = AlgHom.id R S :=\n  by\n  rw [AlgHom.ext_iff, AlgHom.ext_iff]\n  apply forall_congr'\n  intro x\n  have e₁ :\n    (tensor_product.lmul' R : «expr →ₐ[ ] » (tensor_product S R S) R S).ker_square_lift (f x) =\n      kaehler_differential.quotient_cotangent_ideal_ring_equiv R S\n        (Ideal.Quotient.mk (kaehler_differential.ideal R S).cotangent_ideal <| f x) :=\n    by\n    generalize f x = y\n    obtain ⟨y, rfl⟩ := Ideal.Quotient.mk_surjective y\n    rfl\n  have e₂ : x = kaehler_differential.quotient_cotangent_ideal_ring_equiv R S (IsScalarTower.toAlgHom R S _ x) :=\n    (mul_one x).symm\n  constructor\n  · intro e\n    exact\n      (e₁.trans\n            (@RingEquiv.congr_arg _ _ _ _ _ _ (kaehler_differential.quotient_cotangent_ideal_ring_equiv R S) _ _\n              e)).trans\n        e₂.symm\n  · intro e\n    apply (kaehler_differential.quotient_cotangent_ideal_ring_equiv R S).injective\n    exact e₁.symm.trans (e.trans e₂)\n#align kaehler_differential.End_equiv_aux kaehler_differential.End_equiv_aux\n\n",
 "D_tensor_product_to":
 "theorem kaehler_differential.D_tensor_product_to (x : kaehler_differential.ideal R S) :\n    (kaehler_differential.D R S).tensor_product_to x = (kaehler_differential.ideal R S).to_cotangent x :=\n  by\n  rw [← derivation.lift_kaehler_differential_apply, derivation.lift_kaehler_differential_D]\n  rfl\n#align kaehler_differential.D_tensor_product_to kaehler_differential.D_tensor_product_to\n\n",
 "D_linear_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\ntheorem kaehler_differential.D_linear_map_apply (s : S) :\n    kaehler_differential.D_linear_map R S s =\n      (kaehler_differential.ideal R S).to_cotangent\n        ⟨«expr ⊗ₜ » 1 s - «expr ⊗ₜ » s 1, kaehler_differential.one_smul_sub_smul_one_mem_ideal R s⟩ :=\n  rfl\n#align kaehler_differential.D_linear_map_apply kaehler_differential.D_linear_map_apply\n\n",
 "D_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\ntheorem kaehler_differential.D_apply (s : S) :\n    kaehler_differential.D R S s =\n      (kaehler_differential.ideal R S).to_cotangent\n        ⟨«expr ⊗ₜ » 1 s - «expr ⊗ₜ » s 1, kaehler_differential.one_smul_sub_smul_one_mem_ideal R s⟩ :=\n  rfl\n#align kaehler_differential.D_apply kaehler_differential.D_apply\n\n"}