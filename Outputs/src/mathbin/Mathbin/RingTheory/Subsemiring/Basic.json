{"zero_mem":
 "/-- A subsemiring contains the semiring's 0. -/\nprotected theorem zero_mem : (0 : R) ∈ s :=\n  zero_mem s\n#align zero_mem zero_mem\n\n",
 "top_prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_prod_top : («expr⊤» : Subsemiring R).prod («expr⊤» : Subsemiring S) = «expr⊤» :=\n  (top_prod _).trans <| comap_top _\n#align top_prod_top top_prod_top\n\n",
 "top_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem top_prod (s : Subsemiring S) : («expr⊤» : Subsemiring R).prod s = s.comap (RingHom.snd R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n#align top_prod top_prod\n\n",
 "to_submonoid_strict_mono":
 "@[mono]\ntheorem to_submonoid_strict_mono : StrictMono (to_submonoid : Subsemiring R → Submonoid R) := fun _ _ => id\n#align to_submonoid_strict_mono to_submonoid_strict_mono\n\n",
 "to_submonoid_mono":
 "@[mono]\ntheorem to_submonoid_mono : Monotone (to_submonoid : Subsemiring R → Submonoid R) :=\n  toSubmonoid_strictMono.monotone\n#align to_submonoid_mono to_submonoid_mono\n\n",
 "to_submonoid_injective":
 "theorem to_submonoid_injective : function.injective (to_submonoid : Subsemiring R → Submonoid R)\n  | r, s, h => ext (SetLike.ext_iff.mp h : _)\n#align to_submonoid_injective to_submonoid_injective\n\n",
 "to_add_submonoid_strict_mono":
 "@[mono]\ntheorem to_add_submonoid_strict_mono : StrictMono (to_add_submonoid : Subsemiring R → AddSubmonoid R) := fun _ _ => id\n#align to_add_submonoid_strict_mono to_add_submonoid_strict_mono\n\n",
 "to_add_submonoid_mono":
 "@[mono]\ntheorem to_add_submonoid_mono : Monotone (to_add_submonoid : Subsemiring R → AddSubmonoid R) :=\n  toAddSubmonoid_strictMono.monotone\n#align to_add_submonoid_mono to_add_submonoid_mono\n\n",
 "to_add_submonoid_injective":
 "theorem to_add_submonoid_injective : function.injective (to_add_submonoid : Subsemiring R → AddSubmonoid R)\n  | r, s, h => ext (SetLike.ext_iff.mp h : _)\n#align to_add_submonoid_injective to_add_submonoid_injective\n\n",
 "sum_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print sum_mem /-\n/-- Sum of elements in an `subsemiring` of an `semiring` indexed by a `finset`\nis in the `add_subsemiring`. -/\nprotected theorem sum_mem (s : Subsemiring R) {ι : Type _} {t : Finset ι} {f : ι → R} (h : ∀ c ∈ t, f c ∈ s) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f i) ∈ s :=\n  sum_mem h\n#align sum_mem sum_mem\n-/\n\n",
 "subset_closure":
 "#print subset_closure /-\n/-- The subsemiring generated by a set includes the set. -/\n@[simp]\ntheorem subset_closure {s : Set R} : s ⊆ closure s := fun x hx => mem_closure.2 fun S hS => hS hx\n#align subset_closure subset_closure\n-/\n\n",
 "subsemiring_closure_to_add_submonoid":
 "theorem subsemiring_closure_to_add_submonoid :\n    M.subsemiring_closure.to_add_submonoid = AddSubmonoid.closure (M : Set R) :=\n  rfl\n#align subsemiring_closure_to_add_submonoid subsemiring_closure_to_add_submonoid\n\n",
 "subsemiring_closure_eq_closure":
 "/-- The `subsemiring` generated by a multiplicative submonoid coincides with the\n`subsemiring.closure` of the submonoid itself . -/\ntheorem subsemiring_closure_eq_closure : M.subsemiring_closure = Subsemiring.closure (M : Set R) :=\n  by\n  ext\n  refine' ⟨fun hx => _, fun hx => (subsemiring.mem_closure.mp hx) M.subsemiring_closure fun s sM => _⟩ <;>\n      rintro - ⟨H1, rfl⟩ <;>\n    rintro - ⟨H2, rfl⟩\n  · exact add_submonoid.mem_closure.mp hx H1.to_add_submonoid H2\n  · exact H2 sM\n#align subsemiring_closure_eq_closure subsemiring_closure_eq_closure\n\n",
 "subsemiring_closure_coe":
 "theorem subsemiring_closure_coe : (M.subsemiring_closure : Set R) = AddSubmonoid.closure (M : Set R) :=\n  rfl\n#align subsemiring_closure_coe subsemiring_closure_coe\n\n",
 "srange_top_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The range of a surjective ring homomorphism is the whole of the codomain. -/\ntheorem srange_top_of_surjective (f : «expr →+* » R S) (hf : function.surjective f) :\n    f.srange = («expr⊤» : Subsemiring S) :=\n  rangeS_top_iff_surjective.2 hf\n#align srange_top_of_surjective srange_top_of_surjective\n\n",
 "srange_top_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem srange_top_iff_surjective {f : «expr →+* » R S} :\n    f.srange = («expr⊤» : Subsemiring S) ↔ function.surjective f :=\n  SetLike.ext'_iff.trans <| iff.trans (by rw [coe_srange, coe_top]) Set.range_iff_surjective\n#align srange_top_iff_surjective srange_top_iff_surjective\n\n",
 "srange_subtype":
 "@[simp]\ntheorem srange_subtype (s : Subsemiring R) : s.subtype.srange = s :=\n  SetLike.coe_injective <| (coe_rangeS _).trans Subtype.range_coe\n#align srange_subtype srange_subtype\n\n",
 "srange_restrict_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem srange_restrict_surjective (f : «expr →+* » R S) : function.surjective f.srange_restrict := fun ⟨y, hy⟩ =>\n  let ⟨x, hx⟩ := mem_rangeS.mp hy\n  ⟨x, Subtype.ext hx⟩\n#align srange_restrict_surjective srange_restrict_surjective\n\n",
 "srange_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem srange_eq_map (f : «expr →+* » R S) : f.srange = («expr⊤» : Subsemiring R).map f :=\n  by\n  ext\n  simp\n#align srange_eq_map srange_eq_map\n\n",
 "sof_left_inverse_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem sof_left_inverse_symm_apply {g : S → R} {f : «expr →+* » R S} (h : function.left_inverse g f) (x : f.srange) :\n    (ofLeftInverseS h).symm x = g x :=\n  rfl\n#align sof_left_inverse_symm_apply sof_left_inverse_symm_apply\n\n",
 "sof_left_inverse_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem sof_left_inverse_apply {g : S → R} {f : «expr →+* » R S} (h : function.left_inverse g f) (x : R) :\n    ↑(ofLeftInverseS h x) = f x :=\n  rfl\n#align sof_left_inverse_apply sof_left_inverse_apply\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_def [SMul R' α] {S : Subsemiring R'} (g : S) (m : α) : «expr • » g m = «expr • » (g : R') m :=\n  rfl\n#align smul_def smul_def\n\n",
 "sclosure_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem sclosure_preimage_le (f : «expr →+* » R S) (s : Set S) : closure («expr ⁻¹' » f s) ≤ (closure s).comap f :=\n  closure_le.2 fun x hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n#align sclosure_preimage_le sclosure_preimage_le\n\n",
 "restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem restrict_apply (f : «expr →+* » R S) {s : σR} (x : s) : f.dom_restrict s x = f x :=\n  rfl\n#align restrict_apply restrict_apply\n\n",
 "range_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_snd : (snd R S).srange = «expr⊤» :=\n  (snd R S).srange_top_of_surjective <| Prod.snd_surjective\n#align range_snd range_snd\n\n",
 "range_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_fst : (fst R S).srange = «expr⊤» :=\n  (fst R S).srange_top_of_surjective <| Prod.fst_surjective\n#align range_fst range_fst\n\n",
 "prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem prod_top (s : Subsemiring R) : s.prod («expr⊤» : Subsemiring S) = s.comap (RingHom.fst R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n#align prod_top prod_top\n\n",
 "prod_mono_right":
 "theorem prod_mono_right (s : Subsemiring R) : Monotone fun t : Subsemiring S => s.prod t :=\n  prod_mono (le_refl s)\n#align prod_mono_right prod_mono_right\n\n",
 "prod_mono_left":
 "theorem prod_mono_left (t : Subsemiring S) : Monotone fun s : Subsemiring R => s.prod t := fun s₁ s₂ hs =>\n  prod_mono hs (le_refl t)\n#align prod_mono_left prod_mono_left\n\n",
 "prod_mono":
 "@[mono]\ntheorem prod_mono ⦃s₁ s₂ : Subsemiring R⦄ (hs : s₁ ≤ s₂) ⦃t₁ t₂ : Subsemiring S⦄ (ht : t₁ ≤ t₂) :\n    s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n#align prod_mono prod_mono\n\n",
 "prod_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print prod_mem /-\n/-- Product of elements of a subsemiring of a `comm_semiring` indexed by a `finset` is in the\n    subsemiring. -/\nprotected theorem prod_mem {R : Type _} [CommSemiring R] (s : Subsemiring R) {ι : Type _} {t : Finset ι} {f : ι → R}\n    (h : ∀ c ∈ t, f c ∈ s) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i) ∈ s :=\n  prod_mem h\n#align prod_mem prod_mem\n-/\n\n",
 "prod_bot_sup_bot_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem prod_bot_sup_bot_prod (s : Subsemiring R) (t : Subsemiring S) :\n    «expr ⊔ » (s.prod («expr⊥»)) (prod («expr⊥») t) = s.prod t :=\n  le_antisymm (sup_le (prod_mono_right s bot_le) (prod_mono_left t bot_le)) fun p hp =>\n    Prod.fst_mul_snd p ▸\n      mul_mem\n        ((le_sup_left : s.prod («expr⊥») ≤ «expr ⊔ » (s.prod («expr⊥»)) (prod («expr⊥») t))\n          ⟨hp.1, SetLike.mem_coe.2 <| one_mem («expr⊥»)⟩)\n        ((le_sup_right : prod («expr⊥») t ≤ «expr ⊔ » (s.prod («expr⊥»)) (prod («expr⊥») t))\n          ⟨SetLike.mem_coe.2 <| one_mem («expr⊥»), hp.2⟩)\n#align prod_bot_sup_bot_prod prod_bot_sup_bot_prod\n\n",
 "pow_mem":
 "#print pow_mem /-\nprotected theorem pow_mem {R : Type _} [Semiring R] (s : Subsemiring R) {x : R} (hx : x ∈ s) (n : ℕ) : x ^ n ∈ s :=\n  pow_mem hx n\n#align pow_mem pow_mem\n-/\n\n",
 "one_mem":
 "/-- A subsemiring contains the semiring's 1. -/\nprotected theorem one_mem : (1 : R) ∈ s :=\n  one_mem s\n#align one_mem one_mem\n\n",
 "nsmul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print nsmul_mem /-\nprotected theorem nsmul_mem {x : R} (hx : x ∈ s) (n : ℕ) : «expr • » n x ∈ s :=\n  nsmul_mem hx n\n#align nsmul_mem nsmul_mem\n-/\n\n",
 "not_mem_of_not_mem_closure":
 "#print not_mem_of_not_mem_closure /-\ntheorem not_mem_of_not_mem_closure {s : Set R} {P : R} (hP : P ∉ closure s) : P ∉ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n-/\n\n",
 "natCast_mem":
 "#print natCast_mem /-\n/-\nCopyright (c) 2020 Yury Kudryashov All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem natCast_mem [AddSubmonoidWithOneClass S R] (n : ℕ) : (n : R) ∈ s := by\n  induction n <;> simp [zero_mem, add_mem, one_mem, *]\n#align nat_cast_mem natCast_mem\n-/\n\n",
 "multiset_sum_mem":
 "#print multiset_sum_mem /-\n/-- Sum of a multiset of elements in a `subsemiring` of a `semiring` is\nin the `add_subsemiring`. -/\nprotected theorem multiset_sum_mem (m : Multiset R) : (∀ a ∈ m, a ∈ s) → m.sum ∈ s :=\n  multiset_sum_mem m\n#align multiset_sum_mem multiset_sum_mem\n-/\n\n",
 "multiset_prod_mem":
 "#print multiset_prod_mem /-\n/-- Product of a multiset of elements in a `subsemiring` of a `comm_semiring`\n    is in the `subsemiring`. -/\nprotected theorem multiset_prod_mem {R} [CommSemiring R] (s : Subsemiring R) (m : Multiset R) :\n    (∀ a ∈ m, a ∈ s) → m.prod ∈ s :=\n  multiset_prod_mem m\n#align multiset_prod_mem multiset_prod_mem\n-/\n\n",
 "mul_mem":
 "/-- A subsemiring is closed under multiplication. -/\nprotected theorem mul_mem {x y : R} : x ∈ s → y ∈ s → x * y ∈ s :=\n  mul_mem\n#align mul_mem mul_mem\n\n",
 "mk'_to_submonoid":
 "@[simp]\ntheorem mk'_to_submonoid {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubmonoid R} (ha : ↑sa = s) :\n    (Subsemiring.mk' s sm hm sa ha).to_submonoid = sm :=\n  SetLike.coe_injective hm.symm\n#align mk'_to_submonoid mk'_to_submonoid\n\n",
 "mk'_to_add_submonoid":
 "@[simp]\ntheorem mk'_to_add_submonoid {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubmonoid R} (ha : ↑sa = s) :\n    (Subsemiring.mk' s sm hm sa ha).to_add_submonoid = sa :=\n  SetLike.coe_injective ha.symm\n#align mk'_to_add_submonoid mk'_to_add_submonoid\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top (x : R) : x ∈ («expr⊤» : Subsemiring R) :=\n  Set.mem_univ x\n#align mem_top mem_top\n\n",
 "mem_to_submonoid":
 "@[simp]\ntheorem mem_to_submonoid {s : Subsemiring R} {x : R} : x ∈ s.to_submonoid ↔ x ∈ s :=\n  iff.rfl\n#align mem_to_submonoid mem_to_submonoid\n\n",
 "mem_to_add_submonoid":
 "@[simp]\ntheorem mem_to_add_submonoid {s : Subsemiring R} {x : R} : x ∈ s.to_add_submonoid ↔ x ∈ s :=\n  iff.rfl\n#align mem_to_add_submonoid mem_to_add_submonoid\n\n",
 "mem_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem mem_supr_of_directed {ι} [hι : Nonempty ι] {S : ι → Subsemiring R} (hS : Directed (· ≤ ·) S) {x : R} :\n    x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) ↔\n      ∃ i, x ∈ S i :=\n  by\n  refine' ⟨_, fun ⟨i, hi⟩ => (SetLike.le_def.1 <| le_supᵢ S i) hi⟩\n  let U : Subsemiring R :=\n    Subsemiring.mk'\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i : Set R))\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (S i).to_submonoid)\n      (Submonoid.coe_supᵢ_of_directed <| hS.mono_comp _ fun _ _ => id)\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (S i).to_add_submonoid)\n      (AddSubmonoid.coe_supᵢ_of_directed <| hS.mono_comp _ fun _ _ => id)\n  suffices «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) ≤ U by\n    simpa using @this x\n  exact supᵢ_le fun i x hx => Set.mem_unionᵢ.2 ⟨i, hx⟩\n#align mem_supr_of_directed mem_supr_of_directed\n\n",
 "mem_srange_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem mem_srange_self (f : «expr →+* » R S) (x : R) : f x ∈ f.srange :=\n  mem_rangeS.mpr ⟨x, rfl⟩\n#align mem_srange_self mem_srange_self\n\n",
 "mem_srange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem mem_srange {f : «expr →+* » R S} {y : S} : y ∈ f.srange ↔ ∃ x, f x = y :=\n  iff.rfl\n#align mem_srange mem_srange\n\n",
 "mem_prod":
 "theorem mem_prod {s : Subsemiring R} {t : Subsemiring S} {p : R × S} : p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  iff.rfl\n#align mem_prod mem_prod\n\n",
 "mem_posSubmonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n#print mem_posSubmonoid /-\n-- While this definition is not about `subsemiring`s, this is the earliest we have\n-- both `strict_ordered_semiring` and `submonoid` available.\n@[simp]\ntheorem mem_posSubmonoid {R : Type _} [StrictOrderedSemiring R] (u : «expr ˣ» R) : ↑u ∈ posSubmonoid R ↔ (0 : R) < u :=\n  iff.rfl\n#align mem_pos_monoid mem_posSubmonoid\n-/\n\n",
 "mem_mk'":
 "@[simp]\ntheorem mem_mk' {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubmonoid R} (ha : ↑sa = s) {x : R} :\n    x ∈ Subsemiring.mk' s sm hm sa ha ↔ x ∈ s :=\n  iff.rfl\n#align mem_mk' mem_mk'\n\n",
 "mem_map_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem mem_map_equiv {f : «expr ≃+* » R S} {K : Subsemiring R} {x : S} :\n    x ∈ K.map (f : «expr →+* » R S) ↔ f.symm x ∈ K :=\n  @Set.mem_image_equiv _ _ (↑K) f.to_equiv x\n#align mem_map_equiv mem_map_equiv\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem mem_map {f : «expr →+* » R S} {s : Subsemiring R} {y : S} : y ∈ s.map f ↔ ∃ x ∈ s, f x = y :=\n  Set.mem_image_iff_bex\n#align mem_map mem_map\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem mem_inf {p p' : Subsemiring R} {x : R} : x ∈ «expr ⊓ » p p' ↔ x ∈ p ∧ x ∈ p' :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem mem_comap {s : Subsemiring S} {f : «expr →+* » R S} {x : R} : x ∈ s.comap f ↔ f x ∈ s :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_closure_iff_exists_list":
 "theorem mem_closure_iff_exists_list {R} [Semiring R] {s : Set R} {x} :\n    x ∈ closure s ↔ ∃ L : List (List R), (∀ t ∈ L, ∀ y ∈ t, y ∈ s) ∧ (L.map List.prod).sum = x :=\n  ⟨fun hx =>\n    AddSubmonoid.closure_induction (mem_closure_iff.1 hx)\n      (fun x hx =>\n        suffices ∃ t : List R, (∀ y ∈ t, y ∈ s) ∧ t.prod = x from\n          let ⟨t, ht1, ht2⟩ := this\n          ⟨[t], List.forall_mem_singleton.2 ht1, by rw [list.map_singleton, List.sum_singleton, ht2]⟩\n        Submonoid.closure_induction hx (fun x hx => ⟨[x], List.forall_mem_singleton.2 hx, one_mul x⟩)\n          ⟨[], List.forall_mem_nil _, rfl⟩ fun x y ⟨t, ht1, ht2⟩ ⟨u, hu1, hu2⟩ =>\n          ⟨t ++ u, List.forall_mem_append.2 ⟨ht1, hu1⟩, by rw [List.prod_append, ht2, hu2]⟩)\n      ⟨[], List.forall_mem_nil _, rfl⟩ fun x y ⟨L, HL1, HL2⟩ ⟨M, HM1, HM2⟩ =>\n      ⟨L ++ M, List.forall_mem_append.2 ⟨HL1, HM1⟩, by rw [list.map_append, List.sum_append, HL2, HM2]⟩,\n    fun ⟨L, HL1, HL2⟩ =>\n    HL2 ▸\n      list_sum_mem fun r hr =>\n        let ⟨t, ht1, ht2⟩ := List.mem_map.1 hr\n        ht2 ▸ list_prod_mem _ fun y hy => subset_closure <| HL1 t ht1 y hy⟩\n#align mem_closure_iff_exists_list mem_closure_iff_exists_list\n\n",
 "mem_closure_iff":
 "#print mem_closure_iff /-\ntheorem mem_closure_iff {s : Set R} {x} : x ∈ closure s ↔ x ∈ AddSubmonoid.closure (Submonoid.closure s : Set R) :=\n  Set.ext_iff.mp (coe_closure_eq s) x\n#align mem_closure_iff mem_closure_iff\n-/\n\n",
 "mem_closure":
 "theorem mem_closure {x : R} {s : Set R} : x ∈ closure s ↔ ∀ S : Subsemiring R, s ⊆ S → x ∈ S :=\n  mem_infₛ\n#align mem_closure mem_closure\n\n",
 "mem_centralizer_iff":
 "theorem mem_centralizer_iff {R} [Semiring R] {s : Set R} {z : R} : z ∈ centralizer s ↔ ∀ g ∈ s, g * z = z * g :=\n  iff.rfl\n#align mem_centralizer_iff mem_centralizer_iff\n\n",
 "mem_center_iff":
 "theorem mem_center_iff {R} [Semiring R] {z : R} : z ∈ center R ↔ ∀ g, g * z = z * g :=\n  iff.rfl\n#align mem_center_iff mem_center_iff\n\n",
 "mem_carrier":
 "@[simp]\ntheorem mem_carrier {s : Subsemiring R} {x : R} : x ∈ s.carrier ↔ x ∈ s :=\n  iff.rfl\n#align mem_carrier mem_carrier\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_bot {x : R} : x ∈ («expr⊥» : Subsemiring R) ↔ ∃ n : ℕ, ↑n = x :=\n  RingHom.mem_rangeS\n#align mem_bot mem_bot\n\n",
 "mem_Sup_of_directed_on":
 "theorem mem_Sup_of_directed_on {S : Set (Subsemiring R)} (Sne : S.nonempty) (hS : DirectedOn (· ≤ ·) S) {x : R} :\n    x ∈ supₛ S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : Nonempty S := Sne.to_subtype\n  simp only [supₛ_eq_supᵢ', mem_supr_of_directed hS.directed_coe, SetCoe.exists, Subtype.coe_mk]\n#align mem_Sup_of_directed_on mem_Sup_of_directed_on\n\n",
 "mem_Inf":
 "theorem mem_Inf {S : Set (Subsemiring R)} {x : R} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_interᵢ₂\n#align mem_Inf mem_Inf\n\n",
 "map_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print map_supᵢ /-\ntheorem map_supᵢ {ι : Sort _} (f : «expr →+* » R S) (s : ι → Subsemiring R) :\n    (supᵢ s).map f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((s i).map f) :=\n  (gc_map_comap f).l_supr\n#align map_supr map_supᵢ\n-/\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup (s t : Subsemiring R) (f : «expr →+* » R S) : («expr ⊔ » s t).map f = «expr ⊔ » (s.map f) (t.map f) :=\n  (gc_map_comap f).l_sup\n#align map_sup map_sup\n\n",
 "map_srange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem map_srange : f.srange.map g = (g.comp f).srange := by\n  simpa only [srange_eq_map] using («expr⊤» : Subsemiring R).map_map g f\n#align map_srange map_srange\n\n",
 "map_sclosure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image under a ring homomorphism of the subsemiring generated by a set equals\nthe subsemiring generated by the image of the set. -/\ntheorem map_sclosure (f : «expr →+* » R S) (s : Set R) : (closure s).map f = closure («expr '' » f s) :=\n  le_antisymm\n    (map_le_iff_le_comap.2 <| le_trans (closure_mono <| Set.subset_preimage_image _ _) (sclosure_preimage_le _ _))\n    (closure_le.2 <| Set.image_subset _ subset_closure)\n#align map_sclosure map_sclosure\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_map (g : «expr →+* » S T) (f : «expr →+* » R S) : (s.map f).map g = s.map (g.comp f) :=\n  SetLike.coe_injective <| Set.image_image _ _ _\n#align map_map map_map\n\n",
 "map_le_iff_le_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_le_iff_le_comap {f : «expr →+* » R S} {s : Subsemiring R} {t : Subsemiring S} :\n    s.map f ≤ t ↔ s ≤ t.comap f :=\n  Set.image_subset_iff\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : s.map (RingHom.id R) = s :=\n  SetLike.coe_injective <| Set.image_id _\n#align map_id map_id\n\n",
 "map_equiv_eq_comap_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_equiv_eq_comap_symm (f : «expr ≃+* » R S) (K : Subsemiring R) :\n    K.map (f : «expr →+* » R S) = K.comap f.symm :=\n  SetLike.coe_injective (f.to_equiv.image_eq_preimage K)\n#align map_equiv_eq_comap_symm map_equiv_eq_comap_symm\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot (f : «expr →+* » R S) : («expr⊥» : Subsemiring R).map f = «expr⊥» :=\n  (gc_map_comap f).l_bot\n#align map_bot map_bot\n\n",
 "list_sum_mem":
 "#print list_sum_mem /-\n/-- Sum of a list of elements in a `subsemiring` is in the `subsemiring`. -/\nprotected theorem list_sum_mem {l : List R} : (∀ x ∈ l, x ∈ s) → l.sum ∈ s :=\n  list_sum_mem\n#align list_sum_mem list_sum_mem\n-/\n\n",
 "list_prod_mem":
 "#print list_prod_mem /-\n/-- Product of a list of elements in a `subsemiring` is in the `subsemiring`. -/\ntheorem list_prod_mem {R : Type _} [Semiring R] (s : Subsemiring R) {l : List R} : (∀ x ∈ l, x ∈ s) → l.prod ∈ s :=\n  list_prod_mem\n#align list_prod_mem list_prod_mem\n-/\n\n",
 "gc_map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem gc_map_comap (f : «expr →+* » R S) : GaloisConnection (map f) (comap f) := fun S T => map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "ext":
 "/-- Two subsemirings are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : Subsemiring R} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "eq_top_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_top_iff' (A : Subsemiring R) : A = «expr⊤» ↔ ∀ x : R, x ∈ A :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n#align eq_top_iff' eq_top_iff'\n\n",
 "eq_slocus_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem eq_slocus_same (f : «expr →+* » R S) : f.eq_slocus f = «expr⊤» :=\n  SetLike.ext fun _ => eq_self_iff_true _\n#align eq_slocus_same eq_slocus_same\n\n",
 "eq_on_sclosure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. -/\ntheorem eq_on_sclosure {f g : «expr →+* » R S} {s : Set R} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eq_slocus g from closure_le.2 h\n#align eq_on_sclosure eq_on_sclosure\n\n",
 "eq_of_eq_on_stop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_of_eq_on_stop {f g : «expr →+* » R S} (h : Set.EqOn f g («expr⊤» : Subsemiring R)) : f = g :=\n  ext fun x => h trivial\n#align eq_of_eq_on_stop eq_of_eq_on_stop\n\n",
 "eq_of_eq_on_sdense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eq_of_eq_on_sdense {s : Set R} (hs : closure s = «expr⊤») {f g : «expr →+* » R S} (h : s.eq_on f g) : f = g :=\n  eq_of_eqOn_stop <| hs ▸ eqOn_sclosure h\n#align eq_of_eq_on_sdense eq_of_eq_on_sdense\n\n",
 "copy_eq":
 "theorem copy_eq (S : Subsemiring R) (s : Set R) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n#align copy_eq copy_eq\n\n",
 "comp_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem comp_restrict (f : «expr →+* » R S) (s' : σR) (s : σS) (h : ∀ x ∈ s', f x ∈ s) :\n    (SubsemiringClass.subtype s).comp (f.restrict s' s h) = f.comp (SubsemiringClass.subtype s') :=\n  rfl\n#align comp_restrict comp_restrict\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top (f : «expr →+* » R S) : («expr⊤» : Subsemiring S).comap f = «expr⊤» :=\n  (gc_map_comap f).u_top\n#align comap_top comap_top\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_infi {ι : Sort _} (f : «expr →+* » R S) (s : ι → Subsemiring S) :\n    (infᵢ s).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((s i).comap f) :=\n  (gc_map_comap f).u_infi\n#align comap_infi comap_infi\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_inf (s t : Subsemiring S) (f : «expr →+* » R S) :\n    («expr ⊓ » s t).comap f = «expr ⊓ » (s.comap f) (t.comap f) :=\n  (gc_map_comap f).u_inf\n#align comap_inf comap_inf\n\n",
 "comap_equiv_eq_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_equiv_eq_map_symm (f : «expr ≃+* » R S) (K : Subsemiring S) :\n    K.comap (f : «expr →+* » R S) = K.map f.symm :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n#align comap_equiv_eq_map_symm comap_equiv_eq_map_symm\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_comap (s : Subsemiring T) (g : «expr →+* » S T) (f : «expr →+* » R S) :\n    (s.comap g).comap f = s.comap (g.comp f) :=\n  rfl\n#align comap_comap comap_comap\n\n",
 "coe_zero":
 "@[simp, norm_cast]\ntheorem coe_zero : ((0 : s) : R) = (0 : R) :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : ((«expr⊤» : Subsemiring R) : Set R) = Set.univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_submonoid":
 "@[simp]\ntheorem coe_to_submonoid (s : Subsemiring R) : (s.to_submonoid : Set R) = s :=\n  rfl\n#align coe_to_submonoid coe_to_submonoid\n\n",
 "coe_to_add_submonoid":
 "@[simp]\ntheorem coe_to_add_submonoid (s : Subsemiring R) : (s.to_add_submonoid : Set R) = s :=\n  rfl\n#align coe_to_add_submonoid coe_to_add_submonoid\n\n",
 "coe_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem coe_supr_of_directed {ι} [hι : Nonempty ι] {S : ι → Subsemiring R} (hS : Directed (· ≤ ·) S) :\n    ((«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) :\n          Subsemiring R) :\n        Set R) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑(S i) :=\n  Set.ext fun x => by simp [mem_supr_of_directed hS]\n#align coe_supr_of_directed coe_supr_of_directed\n\n",
 "coe_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_subtype : «expr⇑ » s.subtype = coe :=\n  rfl\n#align coe_subtype coe_subtype\n\n",
 "coe_srange_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem coe_srange_restrict (f : «expr →+* » R S) (x : R) : (f.srange_restrict x : S) = f x :=\n  rfl\n#align coe_srange_restrict coe_srange_restrict\n\n",
 "coe_srange":
 "@[simp]\ntheorem coe_srange : (f.srange : Set S) = Set.range f :=\n  rfl\n#align coe_srange coe_srange\n\n",
 "coe_restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem coe_restrict_apply (f : «expr →+* » R S) (s' : σR) (s : σS) (h : ∀ x ∈ s', f x ∈ s) (x : s') :\n    (f.restrict s' s h x : S) = f x :=\n  rfl\n#align coe_restrict_apply coe_restrict_apply\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[norm_cast]\ntheorem coe_prod (s : Subsemiring R) (t : Subsemiring S) : (s.prod t : Set (R × S)) = finset.product s t :=\n  rfl\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "@[simp, norm_cast]\ntheorem coe_pow {R} [Semiring R] (s : Subsemiring R) (x : s) (n : ℕ) : ((x ^ n : s) : R) = (x ^ n : R) :=\n  by\n  induction' n with n ih\n  · simp\n  · simp [pow_succ, ih]\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "@[simp, norm_cast]\ntheorem coe_one : ((1 : s) : R) = (1 : R) :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_nat_mem":
 "#print coe_nat_mem /-\n-- See note [lower instance priority]\ntheorem coe_nat_mem (n : ℕ) : (n : R) ∈ s := by\n  rw [← nsmul_one]\n  exact nsmul_mem (one_mem _) _\n#align coe_nat_mem coe_nat_mem\n-/\n\n",
 "coe_mul":
 "@[simp, norm_cast]\ntheorem coe_mul (x y : s) : ((x * y : s) : R) = (x * y : R) :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_mk'":
 "@[simp]\ntheorem coe_mk' {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubmonoid R} (ha : ↑sa = s) :\n    (Subsemiring.mk' s sm hm sa ha : Set R) = s :=\n  rfl\n#align coe_mk' coe_mk'\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem coe_map (f : «expr →+* » R S) (s : Subsemiring R) : (s.map f : Set S) = «expr '' » f s :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem coe_inf (p p' : Subsemiring R) : ((«expr ⊓ » p p' : Subsemiring R) : Set R) = p ∩ p' :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_equiv_map_of_injective_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem coe_equiv_map_of_injective_apply (f : «expr →+* » R S) (hf : function.injective f) (x : s) :\n    (equivMapOfInjective s f hf x : S) = f x :=\n  rfl\n#align coe_equiv_map_of_injective_apply coe_equiv_map_of_injective_apply\n\n",
 "coe_copy":
 "@[simp]\ntheorem coe_copy (S : Subsemiring R) (s : Set R) (hs : s = ↑S) : (S.copy s hs : Set R) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem coe_comap (s : Subsemiring S) (f : «expr →+* » R S) : (s.comap f : Set R) = «expr ⁻¹' » f s :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "coe_closure_eq":
 "/-- The elements of the subsemiring closure of `M` are exactly the elements of the additive closure\nof a multiplicative submonoid `M`. -/\ntheorem coe_closure_eq (s : Set R) : (closure s : Set R) = AddSubmonoid.closure (Submonoid.closure s : Set R) := by\n  simp [← Submonoid.subsemiringClosure_toAddSubmonoid, Submonoid.subsemiringClosure_eq_closure]\n#align coe_closure_eq coe_closure_eq\n\n",
 "coe_centralizer":
 "@[simp, norm_cast]\ntheorem coe_centralizer {R} [Semiring R] (s : Set R) : (centralizer s : Set R) = s.centralizer :=\n  rfl\n#align coe_centralizer coe_centralizer\n\n",
 "coe_center":
 "theorem coe_center (R) [Semiring R] : ↑(center R) = Set.center R :=\n  rfl\n#align coe_center coe_center\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem coe_bot : ((«expr⊥» : Subsemiring R) : Set R) = Set.range (coe : ℕ → R) :=\n  (Nat.castRingHom R).coe_srange\n#align coe_bot coe_bot\n\n",
 "coe_add":
 "@[simp, norm_cast]\ntheorem coe_add (x y : s) : ((x + y : s) : R) = (x + y : R) :=\n  rfl\n#align coe_add coe_add\n\n",
 "coe_Sup_of_directed_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem coe_Sup_of_directed_on {S : Set (Subsemiring R)} (Sne : S.nonempty) (hS : DirectedOn (· ≤ ·) S) :\n    (↑(supₛ S) : Set R) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑s :=\n  Set.ext fun x => by simp [mem_Sup_of_directed_on Sne hS]\n#align coe_Sup_of_directed_on coe_Sup_of_directed_on\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_Inf (S : Set (Subsemiring R)) :\n    ((infₛ S : Subsemiring R) : Set R) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s :=\n  rfl\n#align coe_Inf coe_Inf\n\n",
 "closure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print closure_univ /-\n@[simp]\ntheorem closure_univ : closure (Set.univ : Set R) = «expr⊤» :=\n  @coe_top R _ ▸ closure_eq («expr⊤»)\n#align closure_univ closure_univ\n-/\n\n",
 "closure_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print closure_unionᵢ /-\ntheorem closure_unionᵢ {ι} (s : ι → Set R) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure (s i)) :=\n  (Subsemiring.gi R).gc.l_supr\n#align closure_Union closure_unionᵢ\n-/\n\n",
 "closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print closure_union /-\ntheorem closure_union (s t : Set R) : closure (s ∪ t) = «expr ⊔ » (closure s) (closure t) :=\n  (Subsemiring.gi R).gc.l_sup\n#align closure_union closure_union\n-/\n\n",
 "closure_submonoid_closure":
 "@[simp]\ntheorem closure_submonoid_closure (s : Set R) : closure ↑(Submonoid.closure s) = closure s :=\n  le_antisymm (closure_le.mpr fun y hy => (Submonoid.mem_closure.mp hy) (closure s).to_submonoid subset_closure)\n    (closure_mono Submonoid.subset_closure)\n#align closure_submonoid_closure closure_submonoid_closure\n\n",
 "closure_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem closure_sUnion (s : Set (Set R)) :\n    closure (⋃₀ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure t) :=\n  (Subsemiring.gi R).gc.l_Sup\n#align closure_sUnion closure_sUnion\n\n",
 "closure_mono":
 "#print closure_mono /-\n/-- Subsemiring closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\ntheorem closure_mono ⦃s t : Set R⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Set.Subset.trans h subset_closure\n#align closure_mono closure_mono\n-/\n\n",
 "closure_le":
 "/-- A subsemiring `S` includes `closure s` if and only if it includes `s`. -/\n@[simp]\ntheorem closure_le {s : Set R} {t : Subsemiring R} : closure s ≤ t ↔ s ⊆ t :=\n  ⟨Set.Subset.trans subset_closure, fun h => infₛ_le h⟩\n#align closure_le closure_le\n\n",
 "closure_induction₂":
 "/-- An induction principle for closure membership for predicates with two arguments. -/\n@[elab_as_elim]\ntheorem closure_induction₂ {s : Set R} {p : R → R → Prop} {x} {y : R} (hx : x ∈ closure s) (hy : y ∈ closure s)\n    (Hs : ∀ x ∈ s, ∀ y ∈ s, p x y) (H0_left : ∀ x, p 0 x) (H0_right : ∀ x, p x 0) (H1_left : ∀ x, p 1 x)\n    (H1_right : ∀ x, p x 1) (Hadd_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ + x₂) y)\n    (Hadd_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ + y₂)) (Hmul_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ * x₂) y)\n    (Hmul_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ * y₂)) : p x y :=\n  closure_induction hx\n    (fun x₁ x₁s => closure_induction hy (Hs x₁ x₁s) (H0_right x₁) (H1_right x₁) (Hadd_right x₁) (Hmul_right x₁))\n    (H0_left y) (H1_left y) (fun z z' => Hadd_left z z' y) fun z z' => Hmul_left z z' y\n#align closure_induction₂ closure_induction₂\n\n",
 "closure_induction":
 "/-- An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements\nof `s`, and is preserved under addition and multiplication, then `p` holds for all elements\nof the closure of `s`. -/\n@[elab_as_elim]\ntheorem closure_induction {s : Set R} {p : R → Prop} {x} (h : x ∈ closure s) (Hs : ∀ x ∈ s, p x) (H0 : p 0) (H1 : p 1)\n    (Hadd : ∀ x y, p x → p y → p (x + y)) (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=\n  (@closure_le _ _ _ ⟨p, Hmul, H1, Hadd, H0⟩).2 Hs h\n#align closure_induction closure_induction\n\n",
 "closure_eq_of_le":
 "theorem closure_eq_of_le {s : Set R} {t : Subsemiring R} (h₁ : s ⊆ t) (h₂ : t ≤ closure s) : closure s = t :=\n  le_antisymm (closure_le.2 h₁) h₂\n#align closure_eq_of_le closure_eq_of_le\n\n",
 "closure_eq":
 "/-- Closure of a subsemiring `S` equals `S`. -/\ntheorem closure_eq (s : Subsemiring R) : closure (s : Set R) = s :=\n  (Subsemiring.gi R).l_u_eq s\n#align closure_eq closure_eq\n\n",
 "closure_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print closure_empty /-\n@[simp]\ntheorem closure_empty : closure (∅ : Set R) = «expr⊥» :=\n  (Subsemiring.gi R).gc.l_bot\n#align closure_empty closure_empty\n-/\n\n",
 "closure_add_submonoid_closure":
 "@[simp]\ntheorem closure_add_submonoid_closure {s : Set R} : closure ↑(AddSubmonoid.closure s) = closure s :=\n  by\n  ext x\n  refine' ⟨fun hx => _, fun hx => closure_mono AddSubmonoid.subset_closure hx⟩\n  rintro - ⟨H, rfl⟩\n  rintro - ⟨J, rfl⟩\n  refine' (add_submonoid.mem_closure.mp (mem_closure_iff.mp hx)) H.to_add_submonoid fun y hy => _\n  refine' (submonoid.mem_closure.mp hy) H.to_submonoid fun z hz => _\n  exact (add_submonoid.mem_closure.mp hz) H.to_add_submonoid fun w hw => J hw\n#align closure_add_submonoid_closure closure_add_submonoid_closure\n\n",
 "centralizer_univ":
 "@[simp]\ntheorem centralizer_univ {R} [Semiring R] : centralizer Set.univ = center R :=\n  SetLike.ext' (Set.centralizer_univ R)\n#align centralizer_univ centralizer_univ\n\n",
 "centralizer_to_submonoid":
 "theorem centralizer_to_submonoid {R} [Semiring R] (s : Set R) :\n    (centralizer s).to_submonoid = Submonoid.centralizer s :=\n  rfl\n#align centralizer_to_submonoid centralizer_to_submonoid\n\n",
 "centralizer_le":
 "theorem centralizer_le {R} [Semiring R] (s t : Set R) (h : s ⊆ t) : centralizer t ≤ centralizer s :=\n  Set.centralizer_subset h\n#align centralizer_le centralizer_le\n\n",
 "center_to_submonoid":
 "@[simp]\ntheorem center_to_submonoid (R) [Semiring R] : (center R).to_submonoid = Submonoid.center R :=\n  rfl\n#align center_to_submonoid center_to_submonoid\n\n",
 "center_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem center_eq_top (R) [CommSemiring R] : center R = «expr⊤» :=\n  SetLike.coe_injective (Set.center_eq_univ R)\n#align center_eq_top center_eq_top\n\n",
 "add_mem":
 "/-- A subsemiring is closed under addition. -/\nprotected theorem add_mem {x y : R} : x ∈ s → y ∈ s → x + y ∈ s :=\n  add_mem\n#align add_mem add_mem\n\n",
 "Inf_to_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem Inf_to_submonoid (s : Set (Subsemiring R)) :\n    (infₛ s).to_submonoid =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (subsemiring.to_submonoid t) :=\n  mk'_toSubmonoid _ _\n#align Inf_to_submonoid Inf_to_submonoid\n\n",
 "Inf_to_add_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem Inf_to_add_submonoid (s : Set (Subsemiring R)) :\n    (infₛ s).to_add_submonoid =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (subsemiring.to_add_submonoid t) :=\n  mk'_toAddSubmonoid _ _\n#align Inf_to_add_submonoid Inf_to_add_submonoid\n\n"}