{"zero_apply":
 "theorem zero_apply (a : A) : (0 : derivation R A M) a = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "total_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\ntheorem kaehler_differential.total_surjective :\n    function.surjective (finsupp.total S («exprΩ[ ⁄ ]» S R) S (kaehler_differential.D R S)) := by\n  rw [← linear_map.range_eq_top, finsupp.range_total, kaehler_differential.span_range_derivation]\n#align kaehler_differential.total_surjective kaehler_differential.total_surjective\n\n",
 "to_linear_map_eq_coe":
 "@[simp]\ntheorem to_linear_map_eq_coe : D.to_linear_map = D :=\n  rfl\n#align to_linear_map_eq_coe to_linear_map_eq_coe\n\n",
 "to_fun_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-\nCopyright © 2020 Nicolò Cavalleri. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Nicolò Cavalleri, Andrew Yang\n-/\n-- Not a simp lemma because it can be proved via `coe_fn_coe` + `to_linear_map_eq_coe`\ntheorem to_fun_eq_coe : D.to_fun = «expr⇑ » D :=\n  rfl\n#align to_fun_eq_coe to_fun_eq_coe\n\n",
 "tensor_product_to_tmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem derivation.tensor_product_to_tmul (D : derivation R S M) (s t : S) :\n    D.tensor_product_to («expr ⊗ₜ » s t) = «expr • » s (D t) :=\n  rfl\n#align derivation.tensor_product_to_tmul derivation.tensor_product_to_tmul\n\n",
 "tensor_product_to_surjective":
 "theorem kaehler_differential.tensor_product_to_surjective :\n    function.surjective (kaehler_differential.D R S).tensor_product_to :=\n  by\n  intro x; obtain ⟨x, rfl⟩ := (kaehler_differential.ideal R S).to_cotangent_surjective x\n  exact ⟨x, kaehler_differential.D_tensor_product_to x⟩\n#align kaehler_differential.tensor_product_to_surjective kaehler_differential.tensor_product_to_surjective\n\n",
 "tensor_product_to_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem derivation.tensor_product_to_mul (D : derivation R S M) (x y : tensor_product S R S) :\n    D.tensor_product_to (x * y) =\n      «expr • » (tensor_product.lmul' R x) (D.tensor_product_to y) +\n        «expr • » (tensor_product.lmul' R y) (D.tensor_product_to x) :=\n  by\n  apply tensor_product.induction_on x\n  · rw [zero_mul, map_zero, map_zero, zero_smul, smul_zero, add_zero]\n  swap;\n  · rintro\n    simp only [add_mul, map_add, add_smul, *, smul_add]\n    rw [add_add_add_comm]\n  intro x₁ x₂\n  apply tensor_product.induction_on y\n  · rw [mul_zero, map_zero, map_zero, zero_smul, smul_zero, add_zero]\n  swap;\n  · rintro\n    simp only [mul_add, map_add, add_smul, *, smul_add]\n    rw [add_add_add_comm]\n  intro x y\n  simp only [tensor_product.tmul_mul_tmul, derivation.tensor_product_to,\n    tensor_product.algebra_tensor_module.lift_apply, tensor_product.lift.tmul', tensor_product.lmul'_apply_tmul]\n  dsimp\n  rw [D.leibniz]\n  simp only [smul_smul, smul_add, mul_comm (x * y) x₁, mul_right_comm x₁ x₂, ← mul_assoc]\n#align derivation.tensor_product_to_mul derivation.tensor_product_to_mul\n\n",
 "submodule_span_range_eq_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/-- The kernel of `S ⊗[R] S →ₐ[R] S` is generated by `1 ⊗ s - s ⊗ 1` as a `S`-module. -/\ntheorem kaehler_differential.submodule_span_range_eq_ideal :\n    submodule.span S (Set.range fun s : S => «expr ⊗ₜ[ ] » (1 : S) R s - «expr ⊗ₜ[ ] » s R (1 : S)) =\n      (kaehler_differential.ideal R S).restrict_scalars S :=\n  by\n  apply le_antisymm\n  · rw [submodule.span_le]\n    rintro _ ⟨s, rfl⟩\n    exact kaehler_differential.one_smul_sub_smul_one_mem_ideal _ _\n  · rintro x (hx : _ = _)\n    have : x - «expr ⊗ₜ[ ] » (tensor_product.lmul' R x) R (1 : S) = x := by rw [hx, tensor_product.zero_tmul, sub_zero]\n    rw [← this]\n    clear this hx\n    apply tensor_product.induction_on x <;> clear x\n    · rw [map_zero, tensor_product.zero_tmul, sub_zero]\n      exact zero_mem _\n    · intro x y\n      convert_to «expr • » x («expr ⊗ₜ » 1 y - «expr ⊗ₜ » y 1) ∈ _\n      ·\n        rw [tensor_product.lmul'_apply_tmul, smul_sub, tensor_product.smul_tmul', tensor_product.smul_tmul',\n          smul_eq_mul, smul_eq_mul, mul_one]\n      · refine' submodule.smul_mem _ x _\n        apply submodule.subset_span\n        exact Set.mem_range_self y\n    · intro x y hx hy\n      rw [map_add, tensor_product.add_tmul, ← sub_add_sub_comm]\n      exact add_mem hx hy\n#align kaehler_differential.submodule_span_range_eq_ideal kaehler_differential.submodule_span_range_eq_ideal\n\n",
 "sub_apply":
 "theorem sub_apply : (D1 - D2) a = D1 a - D2 a :=\n  rfl\n#align sub_apply sub_apply\n\n",
 "span_range_eq_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\ntheorem kaehler_differential.span_range_eq_ideal :\n    ideal.span (Set.range fun s : S => «expr ⊗ₜ[ ] » (1 : S) R s - «expr ⊗ₜ[ ] » s R (1 : S)) =\n      kaehler_differential.ideal R S :=\n  by\n  apply le_antisymm\n  · rw [ideal.span_le]\n    rintro _ ⟨s, rfl⟩\n    exact kaehler_differential.one_smul_sub_smul_one_mem_ideal _ _\n  · change (kaehler_differential.ideal R S).restrict_scalars S ≤ (ideal.span _).restrict_scalars S\n    rw [← kaehler_differential.submodule_span_range_eq_ideal, ideal.span]\n    conv_rhs => rw [← submodule.span_span_of_tower S]\n    exact submodule.subset_span\n#align kaehler_differential.span_range_eq_ideal kaehler_differential.span_range_eq_ideal\n\n",
 "span_range_derivation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem kaehler_differential.span_range_derivation :\n    submodule.span S (Set.range <| kaehler_differential.D R S) = «expr⊤» :=\n  by\n  rw [_root_.eq_top_iff]\n  rintro x -\n  obtain ⟨⟨x, hx⟩, rfl⟩ := ideal.to_cotangent_surjective _ x\n  have : x ∈ (kaehler_differential.ideal R S).restrict_scalars S := hx\n  rw [← kaehler_differential.submodule_span_range_eq_ideal] at this\n  suffices\n    ∃ hx,\n      (kaehler_differential.ideal R S).to_cotangent ⟨x, hx⟩ ∈ submodule.span S (Set.range <| kaehler_differential.D R S)\n    by exact this.some_spec\n  apply submodule.span_induction this\n  · rintro _ ⟨x, rfl⟩\n    refine' ⟨kaehler_differential.one_smul_sub_smul_one_mem_ideal R x, _⟩\n    apply submodule.subset_span\n    exact ⟨x, kaehler_differential.D_linear_map_apply R S x⟩\n  · exact ⟨zero_mem _, zero_mem _⟩\n  · rintro x y ⟨hx₁, hx₂⟩ ⟨hy₁, hy₂⟩\n    exact ⟨add_mem hx₁ hy₁, add_mem hx₂ hy₂⟩\n  · rintro r x ⟨hx₁, hx₂⟩\n    exact ⟨((kaehler_differential.ideal R S).restrict_scalars S).smul_mem r hx₁, submodule.smul_mem _ r hx₂⟩\n#align kaehler_differential.span_range_derivation kaehler_differential.span_range_derivation\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_apply (r : S) (D : derivation R A M) : («expr • » r D) a = «expr • » r (D a) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "quot_ker_total_equiv_symm_comp_D":
 "theorem kaehler_differential.quot_ker_total_equiv_symm_comp_D :\n    (kaehler_differential.quot_ker_total_equiv R S).symm.to_linear_map.comp_der (kaehler_differential.D R S) =\n      kaehler_differential.derivation_quot_ker_total R S :=\n  by convert (kaehler_differential.derivation_quot_ker_total R S).lift_kaehler_differential_comp using 0\n#align kaehler_differential.quot_ker_total_equiv_symm_comp_D kaehler_differential.quot_ker_total_equiv_symm_comp_D\n\n",
 "one_smul_sub_smul_one_mem_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\ntheorem kaehler_differential.one_smul_sub_smul_one_mem_ideal (a : S) :\n    «expr ⊗ₜ[ ] » (1 : S) R a - «expr ⊗ₜ[ ] » a R (1 : S) ∈ kaehler_differential.ideal R S := by simp [ring_hom.mem_ker]\n#align kaehler_differential.one_smul_sub_smul_one_mem_ideal kaehler_differential.one_smul_sub_smul_one_mem_ideal\n\n",
 "neg_apply":
 "theorem neg_apply : (-D) a = -D a :=\n  rfl\n#align neg_apply neg_apply\n\n",
 "mk_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem mk_coe (f : «expr →ₗ[ ] » A R M) (h₁ h₂) : ((⟨f, h₁, h₂⟩ : derivation R A M) : A → M) = f :=\n  rfl\n#align mk_coe mk_coe\n\n",
 "map_zero":
 "#print map_zero /-\nprotected theorem map_zero : D 0 = 0 :=\n  map_zero D\n#align map_zero map_zero\n-/\n\n",
 "map_surjective_of_surjective":
 "theorem kaehler_differential.map_surjective_of_surjective (h : function.surjective (algebra_map A B)) :\n    function.surjective (kaehler_differential.map R S A B) :=\n  by\n  rw [← linear_map.range_eq_top, _root_.eq_top_iff, ← @submodule.restrict_scalars_top B A, ←\n    kaehler_differential.span_range_derivation, ← submodule.span_eq_restrict_scalars _ _ _ _ h, submodule.span_le]\n  rintro _ ⟨x, rfl⟩\n  obtain ⟨y, rfl⟩ := h x\n  rw [← kaehler_differential.map_D R S A B]\n  exact ⟨_, rfl⟩\n#align kaehler_differential.map_surjective_of_surjective kaehler_differential.map_surjective_of_surjective\n\n",
 "map_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem map_sum {ι : Type _} (s : Finset ι) (f : ι → A) :\n    D (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (D (f i)) :=\n  D.to_linear_map.map_sum\n#align map_sum map_sum\n\n",
 "map_sub":
 "#print map_sub /-\nprotected theorem map_sub : D (a - b) = D a - D b :=\n  map_sub D a b\n#align map_sub map_sub\n-/\n\n",
 "map_smul_of_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem map_smul_of_tower {S : Type _} [SMul S A] [SMul S M] [linear_map.compatible_smul A M S R] (D : derivation R A M)\n    (r : S) (a : A) : D («expr • » r a) = «expr • » r (D a) :=\n  D.to_linear_map.map_smul_of_tower r a\n#align map_smul_of_tower map_smul_of_tower\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem map_smul : D («expr • » r a) = «expr • » r (D a) :=\n  D.to_linear_map.map_smul r a\n#align map_smul map_smul\n\n",
 "map_one_eq_zero":
 "@[simp]\ntheorem map_one_eq_zero : D 1 = 0 :=\n  D.map_one_eq_zero'\n#align map_one_eq_zero map_one_eq_zero\n\n",
 "map_neg":
 "#print map_neg /-\nprotected theorem map_neg : D (-a) = -D a :=\n  map_neg D a\n#align map_neg map_neg\n-/\n\n",
 "map_comp_der":
 "/- We have the commutative diagram\nA --→ B\n↑     ↑\n|     |\nR --→ S -/\ntheorem kaehler_differential.map_comp_der :\n    (kaehler_differential.map R S A B).comp_der (kaehler_differential.D R A) =\n      ((kaehler_differential.D S B).restrict_scalars R).comp_algebra_map A :=\n  derivation.lift_kaehler_differential_comp _\n#align kaehler_differential.map_comp_der kaehler_differential.map_comp_der\n\n",
 "map_coe_nat":
 "@[simp]\ntheorem map_coe_nat (n : ℕ) : D (n : A) = 0 := by rw [← nsmul_one, D.map_smul_of_tower n, map_one_eq_zero, smul_zero]\n#align map_coe_nat map_coe_nat\n\n",
 "map_coe_int":
 "@[simp]\ntheorem map_coe_int (n : ℤ) : D (n : A) = 0 := by rw [← zsmul_one, D.map_smul_of_tower n, map_one_eq_zero, smul_zero]\n#align map_coe_int map_coe_int\n\n",
 "map_base_change_tmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem kaehler_differential.map_base_change_tmul (x : B) (y : «exprΩ[ ⁄ ]» A R) :\n    kaehler_differential.map_base_change R A B («expr ⊗ₜ » x y) = «expr • » x (kaehler_differential.map R R A B y) :=\n  by\n  conv_lhs => rw [← mul_one x, ← smul_eq_mul, ← tensor_product.smul_tmul', linear_map.map_smul]\n  congr 1\n  exact is_base_change.lift_eq _ _ _\n#align kaehler_differential.map_base_change_tmul kaehler_differential.map_base_change_tmul\n\n",
 "map_algebra_map":
 "@[simp]\ntheorem map_algebra_map : D (algebra_map R A r) = 0 := by\n  rw [← mul_one r, RingHom.map_mul, RingHom.map_one, ← smul_def, map_smul, map_one_eq_zero, smul_zero]\n#align map_algebra_map map_algebra_map\n\n",
 "map_add":
 "#print map_add /-\nprotected theorem map_add : D (a + b) = D a + D b :=\n  map_add D a b\n#align map_add map_add\n-/\n\n",
 "map_D":
 "theorem kaehler_differential.map_D (x : A) :\n    kaehler_differential.map R S A B (kaehler_differential.D R A x) = kaehler_differential.D S B (algebra_map A B x) :=\n  derivation.congr_fun (kaehler_differential.map_comp_der R S A B) x\n#align kaehler_differential.map_D kaehler_differential.map_D\n\n",
 "lift_of_derivation_to_square_zero_mk_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp]\ntheorem lift_of_derivation_to_square_zero_mk_apply (d : derivation R A I) (x : A) :\n    ideal.quotient.mk I (lift_of_derivation_to_square_zero I hI d x) = algebra_map A («expr ⧸ » B I) x :=\n  by\n  rw [lift_of_derivation_to_square_zero_apply, map_add, ideal.quotient.eq_zero_iff_mem.mpr (d x).prop, zero_add]\n  rfl\n#align lift_of_derivation_to_square_zero_mk_apply lift_of_derivation_to_square_zero_mk_apply\n\n",
 "lift_of_derivation_to_square_zero_apply":
 "theorem lift_of_derivation_to_square_zero_apply (f : derivation R A I) (x : A) :\n    lift_of_derivation_to_square_zero I hI f x = f x + algebra_map A B x :=\n  rfl\n#align lift_of_derivation_to_square_zero_apply lift_of_derivation_to_square_zero_apply\n\n",
 "lift_kaehler_differential_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\n@[ext]\ntheorem derivation.lift_kaehler_differential_unique (f f' : «expr →ₗ[ ] » («exprΩ[ ⁄ ]» S R) S M)\n    (hf : f.comp_der (kaehler_differential.D R S) = f'.comp_der (kaehler_differential.D R S)) : f = f' :=\n  by\n  apply linear_map.ext\n  intro x\n  have : x ∈ submodule.span S (Set.range <| kaehler_differential.D R S) :=\n    by\n    rw [kaehler_differential.span_range_derivation]\n    trivial\n  apply submodule.span_induction this\n  · rintro _ ⟨x, rfl⟩\n    exact congr_arg (fun D : derivation R S M => D x) hf\n  · rw [map_zero, map_zero]\n  · intro x y hx hy\n    rw [map_add, map_add, hx, hy]\n  · intro a x e\n    rw [map_smul, map_smul, e]\n#align derivation.lift_kaehler_differential_unique derivation.lift_kaehler_differential_unique\n\n",
 "lift_kaehler_differential_comp_D":
 "@[simp]\ntheorem derivation.lift_kaehler_differential_comp_D (D' : derivation R S M) (x : S) :\n    D'.lift_kaehler_differential (kaehler_differential.D R S x) = D' x :=\n  derivation.congr_fun D'.lift_kaehler_differential_comp x\n#align derivation.lift_kaehler_differential_comp_D derivation.lift_kaehler_differential_comp_D\n\n",
 "lift_kaehler_differential_comp":
 "theorem derivation.lift_kaehler_differential_comp (D : derivation R S M) :\n    D.lift_kaehler_differential.comp_der (kaehler_differential.D R S) = D :=\n  by\n  ext a\n  dsimp [kaehler_differential.D_apply]\n  refine' (D.lift_kaehler_differential_apply _).trans _\n  rw [subtype.coe_mk, map_sub, derivation.tensor_product_to_tmul, derivation.tensor_product_to_tmul, one_smul,\n    D.map_one_eq_zero, smul_zero, sub_zero]\n#align derivation.lift_kaehler_differential_comp derivation.lift_kaehler_differential_comp\n\n",
 "lift_kaehler_differential_apply":
 "theorem derivation.lift_kaehler_differential_apply (D : derivation R S M) (x) :\n    D.lift_kaehler_differential ((kaehler_differential.ideal R S).to_cotangent x) = D.tensor_product_to x :=\n  rfl\n#align derivation.lift_kaehler_differential_apply derivation.lift_kaehler_differential_apply\n\n",
 "lift_kaehler_differential_D":
 "theorem derivation.lift_kaehler_differential_D :\n    (kaehler_differential.D R S).lift_kaehler_differential = linear_map.id :=\n  derivation.lift_kaehler_differential_unique _ _ (kaehler_differential.D R S).lift_kaehler_differential_comp\n#align derivation.lift_kaehler_differential_D derivation.lift_kaehler_differential_D\n\n",
 "leibniz_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem leibniz_pow (n : ℕ) : D (a ^ n) = «expr • » n («expr • » (a ^ (n - 1)) (D a)) :=\n  by\n  induction' n with n ihn\n  · rw [pow_zero, map_one_eq_zero, zero_smul]\n  · rcases(zero_le n).eq_or_lt with (rfl | hpos)\n    · rw [pow_one, one_smul, pow_zero, one_smul]\n    · have : a * a ^ (n - 1) = a ^ n := by rw [← pow_succ, nat.sub_add_cancel hpos]\n      simp only [pow_succ, leibniz, ihn, smul_comm a n, smul_smul a, add_smul, this, nat.succ_eq_add_one,\n        Nat.add_succ_sub_one, add_zero, one_nsmul]\n#align leibniz_pow leibniz_pow\n\n",
 "leibniz_of_mul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem leibniz_of_mul_eq_one {a b : A} (h : a * b = 1) : D a = «expr • » (-a ^ 2) (D b) :=\n  by\n  rw [neg_smul]\n  refine' eq_neg_of_add_eq_zero_left _\n  calc\n    D a + «expr • » (a ^ 2) (D b) = «expr • » a («expr • » b (D a)) + «expr • » a («expr • » a (D b)) := by\n      simp only [smul_smul, h, one_smul, sq]\n    _ = «expr • » a (D (a * b)) := by rw [leibniz, smul_add, add_comm]\n    _ = 0 := by rw [h, map_one_eq_zero, smul_zero]\n    \n#align leibniz_of_mul_eq_one leibniz_of_mul_eq_one\n\n",
 "leibniz_inv_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem leibniz_inv_of [Invertible a] : D ((«expr⅟») a) = «expr • » (-(«expr⅟») a ^ 2) (D a) :=\n  D.leibniz_of_mul_eq_one <| invOf_mul_self a\n#align leibniz_inv_of leibniz_inv_of\n\n",
 "leibniz_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem leibniz_inv {K : Type _} [Field K] [Module K M] [algebra R K] (D : derivation R K M) (a : K) :\n    D a⁻¹ = «expr • » (-a⁻¹ ^ 2) (D a) := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp\n  · exact D.leibniz_of_mul_eq_one (inv_mul_cancel ha)\n#align leibniz_inv leibniz_inv\n\n",
 "leibniz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem leibniz : D (a * b) = «expr • » a (D b) + «expr • » b (D a) :=\n  D.leibniz' _ _\n#align leibniz leibniz\n\n",
 "ker_total_mkq_single_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\ntheorem kaehler_differential.ker_total_mkq_single_smul (r : R) (x y) :\n    «expr 𝖣 » y («expr • » r x) = «expr • » r («expr 𝖣 » y x) := by\n  rw [algebra.smul_def, kaehler_differential.ker_total_mkq_single_mul,\n    kaehler_differential.ker_total_mkq_single_algebra_map, add_zero, ← linear_map.map_smul_of_tower,\n    finsupp.smul_single, mul_comm, algebra.smul_def]\n#align kaehler_differential.ker_total_mkq_single_smul kaehler_differential.ker_total_mkq_single_smul\n\n",
 "ker_total_mkq_single_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\ntheorem kaehler_differential.ker_total_mkq_single_mul (x y z) :\n    «expr 𝖣 » z (x * y) = «expr 𝖣 » (z * x) y + «expr 𝖣 » (z * y) x :=\n  by\n  rw [← map_add, eq_comm, ← sub_eq_zero, ← map_sub, submodule.mkq_apply, submodule.quotient.mk_eq_zero]\n  simp_rw [← finsupp.smul_single_one _ z, ← @smul_eq_mul _ _ z, ← finsupp.smul_single, ← smul_add, ← smul_sub]\n  exact submodule.smul_mem _ _ (submodule.subset_span (or.inl <| or.inr <| ⟨⟨_, _⟩, rfl⟩))\n#align kaehler_differential.ker_total_mkq_single_mul kaehler_differential.ker_total_mkq_single_mul\n\n",
 "ker_total_mkq_single_algebra_map_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\ntheorem kaehler_differential.ker_total_mkq_single_algebra_map_one (x) : «expr 𝖣 » x 1 = 0 := by\n  rw [← (algebra_map R S).map_one, kaehler_differential.ker_total_mkq_single_algebra_map]\n#align\n  kaehler_differential.ker_total_mkq_single_algebra_map_one kaehler_differential.ker_total_mkq_single_algebra_map_one\n\n",
 "ker_total_mkq_single_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\ntheorem kaehler_differential.ker_total_mkq_single_algebra_map (x y) : «expr 𝖣 » y (algebra_map R S x) = 0 :=\n  by\n  rw [submodule.mkq_apply, submodule.quotient.mk_eq_zero, ← finsupp.smul_single_one _ y]\n  exact submodule.smul_mem _ _ (submodule.subset_span (or.inr <| ⟨_, rfl⟩))\n#align kaehler_differential.ker_total_mkq_single_algebra_map kaehler_differential.ker_total_mkq_single_algebra_map\n\n",
 "ker_total_mkq_single_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\n-- This has type\n-- `derivation R S Ω[ S / R ] ≃ₗ[R] derivation R S (kaehler_differential.ideal R S).cotangent_ideal`\n-- But lean times-out if this is given explicitly.\ntheorem kaehler_differential.ker_total_mkq_single_add (x y z) : «expr 𝖣 » z (x + y) = «expr 𝖣 » z x + «expr 𝖣 » z y :=\n  by\n  rw [← map_add, eq_comm, ← sub_eq_zero, ← map_sub, submodule.mkq_apply, submodule.quotient.mk_eq_zero]\n  simp_rw [← finsupp.smul_single_one _ z, ← smul_add, ← smul_sub]\n  exact submodule.smul_mem _ _ (submodule.subset_span (or.inl <| or.inl <| ⟨⟨_, _⟩, rfl⟩))\n#align kaehler_differential.ker_total_mkq_single_add kaehler_differential.ker_total_mkq_single_add\n\n",
 "ker_total_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprfinsupp_map -/\n-- The map `(A →₀ A) →ₗ[A] (B →₀ B)`\ntheorem kaehler_differential.ker_total_map (h : function.surjective (algebra_map A B)) :\n    «expr ⊔ » ((kaehler_differential.ker_total R A).map (exprfinsupp_map))\n        (submodule.span A (Set.range fun x : S => single (algebra_map S B x) (1 : B))) =\n      (kaehler_differential.ker_total S B).restrict_scalars _ :=\n  by\n  rw [kaehler_differential.ker_total, submodule.map_span, kaehler_differential.ker_total, ←\n    submodule.span_eq_restrict_scalars _ _ _ _ h]\n  simp_rw [Set.image_union, submodule.span_union, ← Set.image_univ, Set.image_image, Set.image_univ, map_sub, map_add]\n  simp only [linear_map.comp_apply, finsupp.map_range.linear_map_apply, finsupp.map_range_single,\n    finsupp.lmap_domain_apply, finsupp.map_domain_single, alg_hom.to_linear_map_apply, algebra.of_id_apply, ←\n    is_scalar_tower.algebra_map_apply, map_one, map_add, map_mul]\n  simp_rw [sup_assoc, ← (h.prod_map h).range_comp]\n  congr 3\n  rw [sup_eq_right]\n  apply submodule.span_mono\n  simp_rw [is_scalar_tower.algebra_map_apply R S B]\n  exact Set.range_comp_subset_range (algebra_map R S) fun x => single (algebra_map S B x) (1 : B)\n#align kaehler_differential.ker_total_map kaehler_differential.ker_total_map\n\n",
 "ker_total_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\ntheorem kaehler_differential.ker_total_eq :\n    (finsupp.total S («exprΩ[ ⁄ ]» S R) S (kaehler_differential.D R S)).ker = kaehler_differential.ker_total R S :=\n  by\n  apply le_antisymm\n  · conv_rhs => rw [← (kaehler_differential.ker_total R S).ker_mkq]\n    rw [← kaehler_differential.derivation_quot_ker_total_lift_comp_total]\n    exact linear_map.ker_le_ker_comp _ _\n  · rw [kaehler_differential.ker_total, submodule.span_le]\n    rintro _ ((⟨⟨x, y⟩, rfl⟩ | ⟨⟨x, y⟩, rfl⟩) | ⟨x, rfl⟩) <;> dsimp <;> simp [linear_map.mem_ker]\n#align kaehler_differential.ker_total_eq kaehler_differential.ker_total_eq\n\n",
 "ext_of_adjoin_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If adjoin of a set is the whole algebra, then any two derivations equal on this set are equal\non the whole algebra. -/\ntheorem ext_of_adjoin_eq_top (s : set A) (hs : adjoin R s = «expr⊤») (h : Set.EqOn D1 D2 s) : D1 = D2 :=\n  ext fun a => eq_on_adjoin h <| hs.symm ▸ trivial\n#align ext_of_adjoin_eq_top ext_of_adjoin_eq_top\n\n",
 "ext":
 "@[ext]\ntheorem ext (H : ∀ a, D1 a = D2 a) : D1 = D2 :=\n  fun_like.ext _ _ H\n#align ext ext\n\n",
 "eq_on_adjoin":
 "theorem eq_on_adjoin {s : set A} (h : Set.EqOn D1 D2 s) : Set.EqOn D1 D2 (adjoin R s) := fun x hx =>\n  algebra.adjoin_induction hx h (fun r => (D1.map_algebra_map r).trans (D2.map_algebra_map r).symm)\n    (fun x y hx hy => by simp only [map_add, *]) fun x y hx hy => by simp only [leibniz, *]\n#align eq_on_adjoin eq_on_adjoin\n\n",
 "diff_to_ideal_of_quotient_comp_eq_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem diff_to_ideal_of_quotient_comp_eq_apply (f₁ f₂ : «expr →ₐ[ ] » A R B)\n    (e : (ideal.quotient.mkₐ R I).comp f₁ = (ideal.quotient.mkₐ R I).comp f₂) (x : A) :\n    ((diff_to_ideal_of_quotient_comp_eq I f₁ f₂ e) x : B) = f₁ x - f₂ x :=\n  rfl\n#align diff_to_ideal_of_quotient_comp_eq_apply diff_to_ideal_of_quotient_comp_eq_apply\n\n",
 "derivation_to_square_zero_of_lift_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem derivation_to_square_zero_of_lift_apply (f : «expr →ₐ[ ] » A R B)\n    (e : (ideal.quotient.mkₐ R I).comp f = is_scalar_tower.to_alg_hom R A («expr ⧸ » B I)) (x : A) :\n    (derivation_to_square_zero_of_lift I hI f e x : B) = f x - algebra_map A B x :=\n  rfl\n#align derivation_to_square_zero_of_lift_apply derivation_to_square_zero_of_lift_apply\n\n",
 "derivation_quot_ker_total_lift_comp_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΩ[ ⁄ ]» -/\ntheorem kaehler_differential.derivation_quot_ker_total_lift_comp_total :\n    (kaehler_differential.derivation_quot_ker_total R S).lift_kaehler_differential.comp\n        (finsupp.total S («exprΩ[ ⁄ ]» S R) S (kaehler_differential.D R S)) =\n      submodule.mkq _ :=\n  by\n  apply finsupp.lhom_ext\n  intro a b\n  conv_rhs => rw [← finsupp.smul_single_one a b, linear_map.map_smul]\n  simp [kaehler_differential.derivation_quot_ker_total_apply]\n#align\n  kaehler_differential.derivation_quot_ker_total_lift_comp_total kaehler_differential.derivation_quot_ker_total_lift_comp_total\n\n",
 "derivation_quot_ker_total_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr 𝖣 » -/\ntheorem kaehler_differential.derivation_quot_ker_total_apply (x) :\n    kaehler_differential.derivation_quot_ker_total R S x = «expr 𝖣 » 1 x :=\n  rfl\n#align kaehler_differential.derivation_quot_ker_total_apply kaehler_differential.derivation_quot_ker_total_apply\n\n",
 "congr_fun":
 "#print congr_fun /-\ntheorem congr_fun (h : D1 = D2) (a : A) : D1 a = D2 a :=\n  fun_like.congr_fun h a\n#align congr_fun congr_fun\n-/\n\n",
 "commutator_coe_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem commutator_coe_linear_map : ↑(«expr⁅ , ⁆» D1 D2) = «expr⁅ , ⁆» (D1 : module.End R A) (D2 : module.End R A) :=\n  rfl\n#align commutator_coe_linear_map commutator_coe_linear_map\n\n",
 "commutator_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_apply : («expr⁅ , ⁆» D1 D2) a = D1 (D2 a) - D2 (D1 a) :=\n  rfl\n#align commutator_apply commutator_apply\n\n",
 "coe_zero_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_zero_linear_map : ↑(0 : derivation R A M) = (0 : «expr →ₗ[ ] » A R M) :=\n  rfl\n#align coe_zero_linear_map coe_zero_linear_map\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n-- Data typeclasses\n@[simp]\ntheorem coe_zero : «expr⇑ » (0 : derivation R A M) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_to_linear_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_to_linear_map_comp :\n    (f.comp_der D : «expr →ₗ[ ] » A R N) = (f : «expr →ₗ[ ] » M R N).comp (D : «expr →ₗ[ ] » A R M) :=\n  rfl\n#align coe_to_linear_map_comp coe_to_linear_map_comp\n\n",
 "coe_sub_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_sub_linear_map (D1 D2 : derivation R A M) : ↑(D1 - D2) = (D1 - D2 : «expr →ₗ[ ] » A R M) :=\n  rfl\n#align coe_sub_linear_map coe_sub_linear_map\n\n",
 "coe_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_sub (D1 D2 : derivation R A M) : «expr⇑ » (D1 - D2) = D1 - D2 :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_smul_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_smul_linear_map (r : S) (D : derivation R A M) : ↑(«expr • » r D) = («expr • » r D : «expr →ₗ[ ] » A R M) :=\n  rfl\n#align coe_smul_linear_map coe_smul_linear_map\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul (r : S) (D : derivation R A M) : «expr⇑ » («expr • » r D) = «expr • » r D :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_neg_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_neg_linear_map (D : derivation R A M) : ↑(-D) = (-D : «expr →ₗ[ ] » A R M) :=\n  rfl\n#align coe_neg_linear_map coe_neg_linear_map\n\n",
 "coe_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_neg (D : derivation R A M) : «expr⇑ » (-D) = -D :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_mk'_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_mk'_linear_map (D : «expr →ₗ[ ] » A R M) (h) : (mk' D h : «expr →ₗ[ ] » A R M) = D :=\n  rfl\n#align coe_mk'_linear_map coe_mk'_linear_map\n\n",
 "coe_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mk' (D : «expr →ₗ[ ] » A R M) (h) : «expr⇑ » (mk' D h) = D :=\n  rfl\n#align coe_mk' coe_mk'\n\n",
 "coe_injective":
 "theorem coe_injective : @function.injective (derivation R A M) (A → M) coe_fn :=\n  fun_like.coe_injective\n#align coe_injective coe_injective\n\n",
 "coe_fn_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_fn_coe (f : derivation R A M) : «expr⇑ » (f : «expr →ₗ[ ] » A R M) = f :=\n  rfl\n#align coe_fn_coe coe_fn_coe\n\n",
 "coe_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_comp : (f.comp_der D : A → N) = (f : «expr →ₗ[ ] » M R N).comp (D : «expr →ₗ[ ] » A R M) :=\n  rfl\n#align coe_comp coe_comp\n\n",
 "coe_add_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_add_linear_map (D1 D2 : derivation R A M) : ↑(D1 + D2) = (D1 + D2 : «expr →ₗ[ ] » A R M) :=\n  rfl\n#align coe_add_linear_map coe_add_linear_map\n\n",
 "coe_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_add (D1 D2 : derivation R A M) : «expr⇑ » (D1 + D2) = D1 + D2 :=\n  rfl\n#align coe_add coe_add\n\n",
 "add_apply":
 "theorem add_apply : (D1 + D2) a = D1 a + D2 a :=\n  rfl\n#align add_apply add_apply\n\n",
 "End_equiv_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product.infer -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\ntheorem kaehler_differential.End_equiv_aux\n    (f : «expr →ₐ[ ] » S R («expr ⧸ » (tensor_product.infer S S) (kaehler_differential.ideal R S ^ 2))) :\n    (ideal.quotient.mkₐ R (kaehler_differential.ideal R S).cotangent_ideal).comp f = is_scalar_tower.to_alg_hom R S _ ↔\n      (tensor_product.lmul' R : «expr →ₐ[ ] » (tensor_product S R S) R S).ker_square_lift.comp f = alg_hom.id R S :=\n  by\n  rw [alg_hom.ext_iff, alg_hom.ext_iff]\n  apply forall_congr'\n  intro x\n  have e₁ :\n    (tensor_product.lmul' R : «expr →ₐ[ ] » (tensor_product S R S) R S).ker_square_lift (f x) =\n      kaehler_differential.quotient_cotangent_ideal_ring_equiv R S\n        (ideal.quotient.mk (kaehler_differential.ideal R S).cotangent_ideal <| f x) :=\n    by\n    generalize f x = y\n    obtain ⟨y, rfl⟩ := ideal.quotient.mk_surjective y\n    rfl\n  have e₂ : x = kaehler_differential.quotient_cotangent_ideal_ring_equiv R S (is_scalar_tower.to_alg_hom R S _ x) :=\n    (mul_one x).symm\n  constructor\n  · intro e\n    exact\n      (e₁.trans\n            (@RingEquiv.congr_arg _ _ _ _ _ _ (kaehler_differential.quotient_cotangent_ideal_ring_equiv R S) _ _\n              e)).trans\n        e₂.symm\n  · intro e\n    apply (kaehler_differential.quotient_cotangent_ideal_ring_equiv R S).injective\n    exact e₁.symm.trans (e.trans e₂)\n#align kaehler_differential.End_equiv_aux kaehler_differential.End_equiv_aux\n\n",
 "D_tensor_product_to":
 "theorem kaehler_differential.D_tensor_product_to (x : kaehler_differential.ideal R S) :\n    (kaehler_differential.D R S).tensor_product_to x = (kaehler_differential.ideal R S).to_cotangent x :=\n  by\n  rw [← derivation.lift_kaehler_differential_apply, derivation.lift_kaehler_differential_D]\n  rfl\n#align kaehler_differential.D_tensor_product_to kaehler_differential.D_tensor_product_to\n\n",
 "D_linear_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\ntheorem kaehler_differential.D_linear_map_apply (s : S) :\n    kaehler_differential.D_linear_map R S s =\n      (kaehler_differential.ideal R S).to_cotangent\n        ⟨«expr ⊗ₜ » 1 s - «expr ⊗ₜ » s 1, kaehler_differential.one_smul_sub_smul_one_mem_ideal R s⟩ :=\n  rfl\n#align kaehler_differential.D_linear_map_apply kaehler_differential.D_linear_map_apply\n\n",
 "D_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\ntheorem kaehler_differential.D_apply (s : S) :\n    kaehler_differential.D R S s =\n      (kaehler_differential.ideal R S).to_cotangent\n        ⟨«expr ⊗ₜ » 1 s - «expr ⊗ₜ » s 1, kaehler_differential.one_smul_sub_smul_one_mem_ideal R s⟩ :=\n  rfl\n#align kaehler_differential.D_apply kaehler_differential.D_apply\n\n"}