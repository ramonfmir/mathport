{"nat_degree_minpoly_gen":
 "theorem nat_degree_minpoly_gen [Nontrivial A] (pb : power_basis A S) : natDegree (minpoly_gen pb) = pb.dim :=\n  natDegree_eq_of_degree_eq_some pb.degree_minpoly_gen\n#align nat_degree_minpoly_gen nat_degree_minpoly_gen\n\n",
 "nat_degree_minpoly":
 "@[simp]\ntheorem nat_degree_minpoly [Nontrivial A] (pb : power_basis A S) : (minpoly A pb.gen).nat_degree = pb.dim := by\n  rw [← minpoly_gen_eq, nat_degree_minpoly_gen]\n#align nat_degree_minpoly nat_degree_minpoly\n\n",
 "minpoly_gen_monic":
 "theorem minpoly_gen_monic (pb : power_basis A S) : Monic (minpoly_gen pb) :=\n  by\n  nontriviality A\n  apply (monic_X_pow _).sub_of_left _\n  rw [degree_X_pow]\n  exact degree_sum_fin_lt _\n#align minpoly_gen_monic minpoly_gen_monic\n\n",
 "minpoly_gen_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem minpoly_gen_map (pb : power_basis A S) (e : «expr ≃ₐ[ ] » S A S') : (pb.map e).minpoly_gen = pb.minpoly_gen :=\n  by\n  dsimp only [minpoly_gen, map_dim]\n  -- Turn `fin (pb.map e).dim` into `fin pb.dim`\n  simp only [LinearEquiv.trans_apply, map_basis, basis.map_repr, map_gen, AlgEquiv.toLinearEquiv_apply,\n    e.to_linear_equiv_symm, AlgEquiv.map_pow, AlgEquiv.symm_apply_apply, sub_right_inj]\n#align minpoly_gen_map minpoly_gen_map\n\n",
 "minpoly_gen_eq":
 "@[simp]\ntheorem minpoly_gen_eq (pb : power_basis A S) : pb.minpoly_gen = minpoly A pb.gen :=\n  by\n  nontriviality A\n  refine'\n    minpoly.unique' A _ pb.minpoly_gen_monic pb.aeval_minpoly_gen fun q hq => or_iff_not_imp_left.2 fun hn0 h0 => _\n  exact (pb.dim_le_degree_of_root hn0 h0).not_lt (pb.degree_minpoly_gen ▸ hq)\n#align minpoly_gen_eq minpoly_gen_eq\n\n",
 "mem_span_pow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_span_pow' {x y : S} {d : ℕ} :\n    y ∈ Submodule.span R (Set.range fun i : Fin d => x ^ (i : ℕ)) ↔ ∃ f : polynomial R, f.degree < d ∧ y = aeval x f :=\n  by\n  have : (Set.range fun i : Fin d => x ^ (i : ℕ)) = «expr '' » (fun i : ℕ => x ^ i) ↑(Finset.range d) :=\n    by\n    ext n\n    simp_rw [Set.mem_range, Set.mem_image, Finset.mem_coe, Finset.mem_range]\n    exact ⟨fun ⟨⟨i, hi⟩, hy⟩ => ⟨i, hi, hy⟩, fun ⟨i, hi, hy⟩ => ⟨⟨i, hi⟩, hy⟩⟩\n  simp only [this, Finsupp.mem_span_image_iff_total, degree_lt_iff_coeff_zero, exists_iff_exists_finsupp, coeff, aeval,\n    eval₂_ring_hom', eval₂_eq_sum, Polynomial.sum, support, Finsupp.mem_supported', Finsupp.total, Finsupp.sum,\n    Algebra.smul_def, eval₂_zero, exists_prop, LinearMap.id_coe, eval₂_one, id.def, not_lt, Finsupp.coe_lsum,\n    LinearMap.coe_smulRight, Finset.mem_range, AlgHom.coe_mks, Finset.mem_coe]\n  simp_rw [@eq_comm _ y]\n  exact iff.rfl\n#align mem_span_pow' mem_span_pow'\n\n",
 "mem_span_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_integral.mem_span_pow [Nontrivial R] {x y : S} (hx : is_integral R x)\n    (hy : ∃ f : polynomial R, y = aeval x f) :\n    y ∈ Submodule.span R (Set.range fun i : Fin (minpoly R x).nat_degree => x ^ (i : ℕ)) :=\n  by\n  obtain ⟨f, rfl⟩ := hy\n  apply mem_span_pow'.mpr _\n  have := minpoly.monic hx\n  refine' ⟨«expr %ₘ » f (minpoly R x), (degree_mod_by_monic_lt _ this).trans_le degree_le_nat_degree, _⟩\n  conv_lhs => rw [← mod_by_monic_add_div f this]\n  simp only [add_zero, MulZeroClass.zero_mul, minpoly.aeval, aeval_add, AlgHom.map_mul]\n#align is_integral.mem_span_pow is_integral.mem_span_pow\n\n",
 "linear_independent_pow":
 "/-- Useful lemma to show `x` generates a power basis:\nthe powers of `x` less than the degree of `x`'s minimal polynomial are linearly independent. -/\ntheorem linear_independent_pow [Algebra K S] (x : S) :\n    LinearIndependent K fun i : Fin (minpoly K x).nat_degree => x ^ (i : ℕ) :=\n  by\n  by_cases is_integral K x; swap\n  · rw [minpoly.eq_zero h, nat_degree_zero]\n    exact linearIndependent_empty_type\n  refine' Fintype.linearIndependent_iff.2 fun g hg i => _\n  simp only at hg\n  simp_rw [Algebra.smul_def, ← aeval_monomial, ← map_sum] at hg\n  apply (fun hn0 => (minpoly.degree_le_of_ne_zero K x (mt (fun h0 => _) hn0) hg).not_lt).mtr\n  · simp_rw [← C_mul_X_pow_eq_monomial]\n    exact (degree_eq_nat_degree <| minpoly.ne_zero h).symm ▸ degree_sum_fin_lt _\n  · apply_fun lcoeff K i  at h0\n    simp_rw [map_sum, lcoeff_apply, coeff_monomial, Fin.val_eq_val, Finset.sum_ite_eq'] at h0\n    exact (if_pos <| Finset.mem_univ _).symm.trans h0\n#align linear_independent_pow linear_independent_pow\n\n",
 "lift_gen":
 "@[simp]\ntheorem lift_gen (pb : power_basis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) : pb.lift y hy pb.gen = y :=\n  pb.constr_pow_gen hy\n#align lift_gen lift_gen\n\n",
 "lift_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem lift_aeval (pb : power_basis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) (f : polynomial A) :\n    pb.lift y hy (aeval pb.gen f) = aeval y f :=\n  pb.constr_pow_aeval hy f\n#align lift_aeval lift_aeval\n\n",
 "left_mul_matrix":
 "protected theorem left_mul_matrix (pb : power_basis A S) :\n    Algebra.leftMulMatrix pb.basis pb.gen =\n      Matrix.of fun i j => if ↑j + 1 = pb.dim then -pb.minpoly_gen.coeff ↑i else if ↑i = ↑j + 1 then 1 else 0 :=\n  by\n  cases subsingleton_or_nontrivial A; · apply subsingleton.elim\n  rw [Algebra.leftMulMatrix_apply, ← LinearEquiv.eq_symm_apply, LinearMap.toMatrix_symm]\n  refine' pb.basis.ext fun k => _\n  simp_rw [Matrix.toLin_self, Matrix.of_apply, pb.basis_eq_pow]\n  apply (pow_succ _ _).symm.trans\n  split_ifs with h h\n  · simp_rw [h, neg_smul, Finset.sum_neg_distrib, eq_neg_iff_add_eq_zero]\n    convert pb.aeval_minpoly_gen\n    rw [add_comm, aeval_eq_sum_range, Finset.sum_range_succ, ← leading_coeff, pb.minpoly_gen_monic.leading_coeff,\n      one_smul, nat_degree_minpoly_gen, Finset.sum_range]\n  · rw [Fintype.sum_eq_single (⟨↑k + 1, lt_of_le_of_ne k.2 h⟩ : Fin pb.dim), if_pos, one_smul]\n    · rfl\n    · rfl\n    intro x hx\n    rw [if_neg, zero_smul]\n    apply mt Fin.ext hx\n#align left_mul_matrix left_mul_matrix\n\n",
 "is_integral_gen":
 "theorem is_integral_gen (pb : power_basis A S) : is_integral A pb.gen :=\n  ⟨minpoly_gen pb, minpoly_gen_monic pb, aeval_minpoly_gen pb⟩\n#align is_integral_gen is_integral_gen\n\n",
 "finrank":
 "theorem finrank [Algebra K S] (pb : power_basis K S) : FiniteDimensional.finrank K S = pb.dim := by\n  rw [FiniteDimensional.finrank_eq_card_basis pb.basis, Fintype.card_fin]\n#align finrank finrank\n\n",
 "exists_eq_aeval'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_eq_aeval' (pb : power_basis R S) (y : S) : ∃ f : polynomial R, y = aeval pb.gen f :=\n  by\n  nontriviality S\n  obtain ⟨f, _, hf⟩ := exists_eq_aeval pb y\n  exact ⟨f, hf⟩\n#align exists_eq_aeval' exists_eq_aeval'\n\n",
 "exists_eq_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_eq_aeval [Nontrivial S] (pb : power_basis R S) (y : S) :\n    ∃ f : polynomial R, f.nat_degree < pb.dim ∧ y = aeval pb.gen f :=\n  (mem_span_pow pb.dim_ne_zero).mp (by simpa using pb.basis.mem_span y)\n#align exists_eq_aeval exists_eq_aeval\n\n",
 "equiv_of_root_symm":
 "@[simp]\ntheorem equiv_of_root_symm (pb : power_basis A S) (pb' : power_basis A S') (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0)\n    (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0) : (pb.equiv_of_root pb' h₁ h₂).symm = pb'.equiv_of_root pb h₂ h₁ :=\n  rfl\n#align equiv_of_root_symm equiv_of_root_symm\n\n",
 "equiv_of_root_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem equiv_of_root_map (pb : power_basis A S) (e : «expr ≃ₐ[ ] » S A S') (h₁ h₂) :\n    pb.equiv_of_root (pb.map e) h₁ h₂ = e := by\n  ext x\n  obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x\n  simp [aeval_alg_equiv]\n#align equiv_of_root_map equiv_of_root_map\n\n",
 "equiv_of_root_gen":
 "@[simp]\ntheorem equiv_of_root_gen (pb : power_basis A S) (pb' : power_basis A S') (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0)\n    (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0) : pb.equiv_of_root pb' h₁ h₂ pb.gen = pb'.gen :=\n  pb.lift_gen _ h₂\n#align equiv_of_root_gen equiv_of_root_gen\n\n",
 "equiv_of_root_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem equiv_of_root_aeval (pb : power_basis A S) (pb' : power_basis A S') (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0)\n    (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0) (f : polynomial A) :\n    pb.equiv_of_root pb' h₁ h₂ (aeval pb.gen f) = aeval pb'.gen f :=\n  pb.lift_aeval _ h₂ _\n#align equiv_of_root_aeval equiv_of_root_aeval\n\n",
 "equiv_of_minpoly_symm":
 "@[simp]\ntheorem equiv_of_minpoly_symm (pb : power_basis A S) (pb' : power_basis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) : (pb.equiv_of_minpoly pb' h).symm = pb'.equiv_of_minpoly pb h.symm :=\n  rfl\n#align equiv_of_minpoly_symm equiv_of_minpoly_symm\n\n",
 "equiv_of_minpoly_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem equiv_of_minpoly_map (pb : power_basis A S) (e : «expr ≃ₐ[ ] » S A S')\n    (h : minpoly A pb.gen = minpoly A (pb.map e).gen) : pb.equiv_of_minpoly (pb.map e) h = e :=\n  pb.equiv_of_root_map _ _ _\n#align equiv_of_minpoly_map equiv_of_minpoly_map\n\n",
 "equiv_of_minpoly_gen":
 "@[simp]\ntheorem equiv_of_minpoly_gen (pb : power_basis A S) (pb' : power_basis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) : pb.equiv_of_minpoly pb' h pb.gen = pb'.gen :=\n  pb.equiv_of_root_gen pb' _ _\n#align equiv_of_minpoly_gen equiv_of_minpoly_gen\n\n",
 "equiv_of_minpoly_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem equiv_of_minpoly_aeval (pb : power_basis A S) (pb' : power_basis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) (f : polynomial A) :\n    pb.equiv_of_minpoly pb' h (aeval pb.gen f) = aeval pb'.gen f :=\n  pb.equiv_of_root_aeval pb' _ _ _\n#align equiv_of_minpoly_aeval equiv_of_minpoly_aeval\n\n",
 "dim_pos":
 "theorem dim_pos [Nontrivial S] (pb : power_basis R S) : 0 < pb.dim :=\n  nat.pos_of_ne_zero pb.dim_ne_zero\n#align dim_pos dim_pos\n\n",
 "dim_ne_zero":
 "theorem dim_ne_zero [h : Nontrivial S] (pb : power_basis R S) : pb.dim ≠ 0 := fun h =>\n  not_nonempty_iff.mpr (h.symm ▸ fin.is_empty : IsEmpty (Fin pb.dim)) pb.basis.index_nonempty\n#align dim_ne_zero dim_ne_zero\n\n",
 "dim_le_nat_degree_of_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem dim_le_nat_degree_of_root (pb : power_basis A S) {p : polynomial A} (ne_zero : p ≠ 0)\n    (root : aeval pb.gen p = 0) : pb.dim ≤ p.nat_degree :=\n  by\n  refine' le_of_not_lt fun hlt => NeZero _\n  rw [p.as_sum_range' _ hlt, Finset.sum_range]\n  refine' Fintype.sum_eq_zero _ fun i => _\n  simp_rw [aeval_eq_sum_range' hlt, Finset.sum_range, ← pb.basis_eq_pow] at root\n  have := Fintype.linearIndependent_iff.1 pb.basis.linear_independent _ root\n  dsimp only at this\n  rw [this, monomial_zero_right]\n#align dim_le_nat_degree_of_root dim_le_nat_degree_of_root\n\n",
 "dim_le_degree_of_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem dim_le_degree_of_root (h : power_basis A S) {p : polynomial A} (ne_zero : p ≠ 0) (root : aeval h.gen p = 0) :\n    ↑h.dim ≤ p.degree := by\n  rw [degree_eq_nat_degree NeZero, WithBot.coe_le_coe]\n  exact h.dim_le_nat_degree_of_root NeZero root\n#align dim_le_degree_of_root dim_le_degree_of_root\n\n",
 "degree_minpoly_gen":
 "theorem degree_minpoly_gen [Nontrivial A] (pb : power_basis A S) : degree (minpoly_gen pb) = pb.dim :=\n  by\n  unfold minpoly_gen\n  rw [degree_sub_eq_left_of_degree_lt] <;> rw [degree_X_pow]\n  apply degree_sum_fin_lt\n#align degree_minpoly_gen degree_minpoly_gen\n\n",
 "degree_minpoly":
 "@[simp]\ntheorem degree_minpoly [Nontrivial A] (pb : power_basis A S) : degree (minpoly A pb.gen) = pb.dim := by\n  rw [← minpoly_gen_eq, degree_minpoly_gen]\n#align degree_minpoly degree_minpoly\n\n",
 "constr_pow_mul":
 "theorem constr_pow_mul (pb : power_basis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) (x x' : S) :\n    pb.basis.constr A (fun i => y ^ (i : ℕ)) (x * x') =\n      pb.basis.constr A (fun i => y ^ (i : ℕ)) x * pb.basis.constr A (fun i => y ^ (i : ℕ)) x' :=\n  by\n  obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x\n  obtain ⟨g, rfl⟩ := pb.exists_eq_aeval' x'\n  simp only [← aeval_mul, pb.constr_pow_aeval hy]\n#align constr_pow_mul constr_pow_mul\n\n",
 "constr_pow_gen":
 "theorem constr_pow_gen (pb : power_basis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) :\n    pb.basis.constr A (fun i => y ^ (i : ℕ)) pb.gen = y := by convert pb.constr_pow_aeval hy X <;> rw [aeval_X]\n#align constr_pow_gen constr_pow_gen\n\n",
 "constr_pow_algebra_map":
 "theorem constr_pow_algebra_map (pb : power_basis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) (x : A) :\n    pb.basis.constr A (fun i => y ^ (i : ℕ)) (algebraMap A S x) = algebraMap A S' x := by\n  convert pb.constr_pow_aeval hy (C x) <;> rw [aeval_C]\n#align constr_pow_algebra_map constr_pow_algebra_map\n\n",
 "constr_pow_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem constr_pow_aeval (pb : power_basis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) (f : polynomial A) :\n    pb.basis.constr A (fun i => y ^ (i : ℕ)) (aeval pb.gen f) = aeval y f :=\n  by\n  cases subsingleton_or_nontrivial A\n  · rw [(subsingleton.elim _ _ : f = 0), aeval_zero, map_zero, aeval_zero]\n  rw [← aeval_mod_by_monic_eq_self_of_root (minpoly.monic pb.is_integral_gen) (minpoly.aeval _ _), ←\n    @aeval_mod_by_monic_eq_self_of_root _ _ _ _ _ f _ (minpoly.monic pb.is_integral_gen) y hy]\n  by_cases hf : «expr %ₘ » f (minpoly A pb.gen) = 0\n  · simp only [hf, AlgHom.map_zero, LinearMap.map_zero]\n  have : («expr %ₘ » f (minpoly A pb.gen)).nat_degree < pb.dim :=\n    by\n    rw [← pb.nat_degree_minpoly]\n    apply nat_degree_lt_nat_degree hf\n    exact degree_mod_by_monic_lt _ (minpoly.monic pb.is_integral_gen)\n  rw [aeval_eq_sum_range' this, aeval_eq_sum_range' this, LinearMap.map_sum]\n  refine' Finset.sum_congr rfl fun i (hi : i ∈ Finset.range pb.dim) => _\n  rw [Finset.mem_range] at hi\n  rw [LinearMap.map_smul]\n  congr\n  rw [← Fin.val_mk hi, ← pb.basis_eq_pow ⟨i, hi⟩, Basis.constr_basis]\n#align constr_pow_aeval constr_pow_aeval\n\n",
 "coe_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-\nCopyright (c) 2020 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n-- this is usually not needed because of `basis_eq_pow` but can be needed in some cases;\n-- in such circumstances, add it manually using `@[simps dim gen basis]`.\n@[simp]\ntheorem coe_basis (pb : power_basis R S) : «expr⇑ » pb.basis = fun i : Fin pb.dim => pb.gen ^ (i : ℕ) :=\n  funext pb.basis_eq_pow\n#align coe_basis coe_basis\n\n",
 "alg_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem alg_hom_ext {S' : Type _} [Semiring S'] [Algebra R S'] (pb : power_basis R S) ⦃f g : «expr →ₐ[ ] » S R S'⦄\n    (h : f pb.gen = g pb.gen) : f = g := by\n  ext x\n  obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x\n  rw [← Polynomial.aeval_algHom_apply, ← Polynomial.aeval_algHom_apply, h]\n#align alg_hom_ext alg_hom_ext\n\n",
 "aeval_minpoly_gen":
 "theorem aeval_minpoly_gen (pb : power_basis A S) : aeval pb.gen (minpoly_gen pb) = 0 :=\n  by\n  simp_rw [minpoly_gen, AlgHom.map_sub, AlgHom.map_sum, AlgHom.map_mul, AlgHom.map_pow, aeval_C, ← Algebra.smul_def,\n    aeval_X]\n  refine' sub_eq_zero.mpr ((pb.basis.total_repr (pb.gen ^ pb.dim)).symm.trans _)\n  rw [Finsupp.total_apply, Finsupp.sum_fintype] <;> simp only [pb.coe_basis, zero_smul, eq_self_iff_true, imp_true_iff]\n#align aeval_minpoly_gen aeval_minpoly_gen\n\n",
 "adjoin_gen_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem adjoin_gen_eq_top (B : power_basis R S) : adjoin R ({B.gen} : Set S) = «expr⊤» :=\n  by\n  rw [← to_submodule_eq_top, _root_.eq_top_iff, ← B.basis.span_eq, Submodule.span_le]\n  rintro x ⟨i, rfl⟩\n  rw [B.basis_eq_pow i]\n  exact Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _\n#align adjoin_gen_eq_top adjoin_gen_eq_top\n\n",
 "adjoin_eq_top_of_gen_mem_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem adjoin_eq_top_of_gen_mem_adjoin {B : power_basis R S} {x : S} (hx : B.gen ∈ adjoin R ({x} : Set S)) :\n    adjoin R ({x} : Set S) = «expr⊤» :=\n  by\n  rw [_root_.eq_top_iff, ← B.adjoin_gen_eq_top]\n  refine' adjoin_le _\n  simp [hx]\n#align adjoin_eq_top_of_gen_mem_adjoin adjoin_eq_top_of_gen_mem_adjoin\n\n",
 "FiniteDimensional":
 "#print FiniteDimensional /-\n/-- Cannot be an instance because `power_basis` cannot be a class. -/\ntheorem FiniteDimensional [Algebra K S] (pb : power_basis K S) : FiniteDimensional K S :=\n  FiniteDimensional.of_fintype_basis pb.basis\n#align finite_dimensional FiniteDimensional\n-/\n\n"}