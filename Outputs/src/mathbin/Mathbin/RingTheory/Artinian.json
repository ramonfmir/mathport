{"surjective_of_injective_endomorphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem surjective_of_injective_endomorphism (f : «expr →ₗ[ ] » M R M) (s : injective f) : surjective f :=\n  by\n  obtain ⟨n, ne, w⟩ := exists_endomorphism_iterate_ker_sup_range_eq_top f\n  rw [linear_map.ker_eq_bot.mpr (linear_map.iterate_injective s n), bot_sup_eq, linear_map.range_eq_top] at w\n  exact linear_map.surjective_of_iterate_surjective ne w\n#align surjective_of_injective_endomorphism surjective_of_injective_endomorphism\n\n",
 "set_has_minimal_iff_artinian":
 "/-- A module is Artinian iff every nonempty set of submodules has a minimal submodule among them.\n-/\ntheorem set_has_minimal_iff_artinian :\n    (∀ a : set <| submodule R M, a.nonempty → ∃ M' ∈ a, ∀ I ∈ a, I ≤ M' → I = M') ↔ is_artinian R M := by\n  rw [is_artinian_iff_well_founded, WellFounded.wellFounded_iff_has_min']\n#align set_has_minimal_iff_artinian set_has_minimal_iff_artinian\n\n",
 "set_has_minimal":
 "theorem is_artinian.set_has_minimal [is_artinian R M] (a : set <| submodule R M) (ha : a.nonempty) :\n    ∃ M' ∈ a, ∀ I ∈ a, I ≤ M' → I = M' :=\n  set_has_minimal_iff_artinian.mpr ‹_› a ha\n#align is_artinian.set_has_minimal is_artinian.set_has_minimal\n\n",
 "range_smul_pow_stabilizes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem range_smul_pow_stabilizes (r : R) :\n    ∃ n : ℕ,\n      ∀ m,\n        n ≤ m →\n          («expr • » (r ^ n) linear_map.id : «expr →ₗ[ ] » M R M).range =\n            («expr • » (r ^ m) linear_map.id : «expr →ₗ[ ] » M R M).range :=\n  monotone_stabilizes\n    ⟨fun n => («expr • » (r ^ n) linear_map.id : «expr →ₗ[ ] » M R M).range, fun n m h x ⟨y, hy⟩ =>\n      ⟨«expr • » (r ^ (m - n)) y, by\n        dsimp at hy⊢\n        rw [← smul_assoc, smul_eq_mul, ← pow_add, ← hy, add_tsub_cancel_of_le h]⟩⟩\n#align range_smul_pow_stabilizes range_smul_pow_stabilizes\n\n",
 "monotone_stabilizes_iff_artinian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- A module is Artinian iff every decreasing chain of submodules stabilizes. -/\ntheorem monotone_stabilizes_iff_artinian :\n    (∀ f : «expr →o » ℕ («expr ᵒᵈ» (submodule R M)), ∃ n, ∀ m, n ≤ m → f n = f m) ↔ is_artinian R M :=\n  by\n  rw [is_artinian_iff_well_founded]\n  exact well_founded.monotone_chain_condition.symm\n#align monotone_stabilizes_iff_artinian monotone_stabilizes_iff_artinian\n\n",
 "monotone_stabilizes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem monotone_stabilizes (f : «expr →o » ℕ («expr ᵒᵈ» (submodule R M))) : ∃ n, ∀ m, n ≤ m → f n = f m :=\n  monotone_stabilizes_iff_artinian.mpr ‹_› f\n#align monotone_stabilizes monotone_stabilizes\n\n",
 "localization_surjective":
 "/-- Localizing an artinian ring can only reduce the amount of elements. -/\ntheorem localization_surjective : function.surjective (algebra_map R L) :=\n  by\n  intro r'\n  obtain ⟨r₁, s, rfl⟩ := is_localization.mk'_surjective S r'\n  obtain ⟨r₂, h⟩ : ∃ r : R, is_localization.mk' L 1 s = algebra_map R L r\n  swap; · exact ⟨r₁ * r₂, by rw [is_localization.mk'_eq_mul_mk'_one, map_mul, h]⟩\n  obtain ⟨n, r, hr⟩ := is_artinian.exists_pow_succ_smul_dvd (s : R) (1 : R)\n  use r\n  rw [smul_eq_mul, smul_eq_mul, pow_succ', mul_assoc] at hr\n  apply_fun algebra_map R L  at hr\n  simp only [map_mul, ← [anonymous]] at hr\n  rw [← is_localization.mk'_one L, is_localization.mk'_eq_iff_eq, one_mul, Submonoid.coe_one, ←\n    (is_localization.map_units L (s ^ n)).mul_left_cancel hr, map_mul, mul_comm]\n#align localization_surjective localization_surjective\n\n",
 "localization_artinian":
 "theorem localization_artinian : is_artinian_ring L :=\n  (localization_surjective S L).is_artinian_ring\n#align localization_artinian localization_artinian\n\n",
 "is_nilpotent_jacobson_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_nilpotent_jacobson_bot : is_nilpotent (ideal.jacobson («expr⊥» : ideal R)) :=\n  by\n  let Jac := ideal.jacobson («expr⊥» : ideal R)\n  let f : «expr →o » ℕ («expr ᵒᵈ» (ideal R)) := ⟨fun n => Jac ^ n, fun _ _ h => ideal.pow_le_pow h⟩\n  obtain ⟨n, hn⟩ : ∃ n, ∀ m, n ≤ m → Jac ^ n = Jac ^ m := is_artinian.monotone_stabilizes f\n  refine' ⟨n, _⟩\n  let J : ideal R := annihilator (Jac ^ n)\n  suffices J = «expr⊤» by\n    have hJ : «expr • » J (Jac ^ n) = «expr⊥» := annihilator_smul (Jac ^ n)\n    simpa only [this, top_smul, ideal.zero_eq_bot] using hJ\n  by_contra hJ\n  change J ≠ «expr⊤» at hJ\n  rcases is_artinian.set_has_minimal { J' : ideal R | J < J' } ⟨«expr⊤», hJ.lt_top⟩ with\n    ⟨J', hJJ' : J < J', hJ' : ∀ I, J < I → I ≤ J' → I = J'⟩\n  rcases SetLike.exists_of_lt hJJ' with ⟨x, hxJ', hxJ⟩\n  obtain rfl : «expr ⊔ » J (ideal.span {x}) = J' :=\n    by\n    refine' hJ' («expr ⊔ » J (ideal.span {x})) _ _\n    · rw [SetLike.lt_iff_le_and_exists]\n      exact ⟨le_sup_left, ⟨x, mem_sup_right (mem_span_singleton_self x), hxJ⟩⟩\n    · exact sup_le hJJ'.le (span_le.2 (singleton_subset_iff.2 hxJ'))\n  have : «expr ⊔ » J («expr • » Jac (ideal.span {x})) ≤ «expr ⊔ » J (ideal.span {x}) :=\n    sup_le_sup_left (smul_le.2 fun _ _ _ => submodule.smul_mem _ _) _\n  have : Jac * ideal.span {x} ≤ J := by\n    classical\n      --Need version 4 of Nakayamas lemma on Stacks\n      by_contra H\n      refine' H (smul_sup_le_of_le_smul_of_le_jacobson_bot (fg_span_singleton _) le_rfl (hJ' _ _ this).ge)\n      exact lt_of_le_of_ne le_sup_left fun h => H <| h.symm ▸ le_sup_right\n  have : ideal.span {x} * Jac ^ (n + 1) ≤ «expr⊥»\n  calc\n    ideal.span {x} * Jac ^ (n + 1) = ideal.span {x} * Jac * Jac ^ n := by rw [pow_succ, ← mul_assoc]\n    _ ≤ J * Jac ^ n := mul_le_mul (by rwa [mul_comm]) le_rfl\n    _ = «expr⊥» := by simp [J]\n    \n  refine' hxJ (mem_annihilator.2 fun y hy => (mem_bot R).1 _)\n  refine' this (mul_mem_mul (mem_span_singleton_self x) _)\n  rwa [← hn (n + 1) (nat.le_succ _)]\n#align is_nilpotent_jacobson_bot is_nilpotent_jacobson_bot\n\n",
 "is_artinian_span_of_finite":
 "/-- In a module over a artinian ring, the submodule generated by finitely many vectors is\nartinian. -/\ntheorem is_artinian_span_of_finite (R) {M} [Ring R] [add_comm_group M] [Module R M] [is_artinian_ring R] {A : set M}\n    (hA : A.finite) : is_artinian R (submodule.span R A) :=\n  is_artinian_of_fg_of_artinian _ (submodule.fg_def.mpr ⟨A, hA, rfl⟩)\n#align is_artinian_span_of_finite is_artinian_span_of_finite\n\n",
 "is_artinian_ring_iff":
 "-- TODO: Prove this for artinian modules\n-- /--\n-- If `M ⊕ N` embeds into `M`, for `M` noetherian over `R`, then `N` is trivial.\n-- -/\n-- universe w\n-- variables {N : Type w} [add_comm_group N] [module R N]\n-- noncomputable def is_noetherian.equiv_punit_of_prod_injective [is_noetherian R M]\n--   (f : M × N →ₗ[R] M) (i : injective f) : N ≃ₗ[R] punit.{w+1} :=\n-- begin\n--   apply nonempty.some,\n--   obtain ⟨n, w⟩ := is_noetherian.disjoint_partial_sups_eventually_bot (f.tailing i)\n--     (f.tailings_disjoint_tailing i),\n--   specialize w n (le_refl n),\n--   apply nonempty.intro,\n--   refine (f.tailing_linear_equiv i n).symm.trans _,\n--   rw w,\n--   exact submodule.bot_equiv_punit,\n-- end\ntheorem is_artinian_ring_iff {R} [Ring R] : is_artinian_ring R ↔ is_artinian R R :=\n  iff.rfl\n#align is_artinian_ring_iff is_artinian_ring_iff\n\n",
 "is_artinian_ring":
 "theorem function.surjective.is_artinian_ring {R} [Ring R] {S} [Ring S] {F} [RingHomClass F R S] {f : F}\n    (hf : function.surjective f) [H : is_artinian_ring R] : is_artinian_ring S :=\n  by\n  rw [is_artinian_ring_iff, is_artinian_iff_well_founded] at H⊢\n  exact (ideal.order_embedding_of_surjective f hf).well_founded H\n#align function.surjective.is_artinian_ring function.surjective.is_artinian_ring\n\n",
 "is_artinian_of_zero_eq_one":
 "theorem ring.is_artinian_of_zero_eq_one {R} [Ring R] (h01 : (0 : R) = 1) : is_artinian_ring R :=\n  have := subsingleton_of_zero_eq_one h01\n  infer_instance\n#align ring.is_artinian_of_zero_eq_one ring.is_artinian_of_zero_eq_one\n\n",
 "is_artinian_of_tower":
 "/-- If `M / S / R` is a scalar tower, and `M / R` is Artinian, then `M / S` is\nalso Artinian. -/\ntheorem is_artinian_of_tower (R) {S M} [CommRing R] [Ring S] [add_comm_group M] [algebra R S] [Module S M] [Module R M]\n    [IsScalarTower R S M] (h : is_artinian R M) : is_artinian S M :=\n  by\n  rw [is_artinian_iff_well_founded] at h⊢\n  refine' (submodule.restrict_scalars_embedding R S M).well_founded h\n#align is_artinian_of_tower is_artinian_of_tower\n\n",
 "is_artinian_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_artinian_of_surjective (f : «expr →ₗ[ ] » M R P) (hf : function.surjective f) [is_artinian R M] :\n    is_artinian R P :=\n  ⟨subrelation.wf (fun A B hAB => show A.comap f < B.comap f from submodule.comap_strict_mono_of_surjective hf hAB)\n      (inv_image.wf (submodule.comap f) (is_artinian.well_founded_submodule_lt _ _))⟩\n#align is_artinian_of_surjective is_artinian_of_surjective\n\n",
 "is_artinian_of_submodule_of_artinian":
 "theorem is_artinian_of_submodule_of_artinian (R M) [Ring R] [add_comm_group M] [Module R M] (N : submodule R M)\n    (h : is_artinian R M) : is_artinian R N := by infer_instance\n#align is_artinian_of_submodule_of_artinian is_artinian_of_submodule_of_artinian\n\n",
 "is_artinian_of_range_eq_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_artinian_of_range_eq_ker [is_artinian R M] [is_artinian R P] (f : «expr →ₗ[ ] » M R N)\n    (g : «expr →ₗ[ ] » N R P) (hf : function.injective f) (hg : function.surjective g) (h : f.range = g.ker) :\n    is_artinian R N :=\n  ⟨wellFounded_lt_exact_sequence (is_artinian.well_founded_submodule_lt _ _) (is_artinian.well_founded_submodule_lt _ _)\n      f.range (submodule.map f) (submodule.comap f) (submodule.comap g) (submodule.map g) (submodule.gci_map_comap hf)\n      (submodule.gi_map_comap hg) (by simp [submodule.map_comap_eq, inf_comm]) (by simp [submodule.comap_map_eq, h])⟩\n#align is_artinian_of_range_eq_ker is_artinian_of_range_eq_ker\n\n",
 "is_artinian_of_quotient_of_artinian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem is_artinian_of_quotient_of_artinian (R) [Ring R] (M) [add_comm_group M] [Module R M] (N : submodule R M)\n    (h : is_artinian R M) : is_artinian R («expr ⧸ » M N) :=\n  is_artinian_of_surjective M (submodule.mkq N) (submodule.quotient.mk_surjective N)\n#align is_artinian_of_quotient_of_artinian is_artinian_of_quotient_of_artinian\n\n",
 "is_artinian_of_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem is_artinian_of_linear_equiv (f : «expr ≃ₗ[ ] » M R P) [is_artinian R M] : is_artinian R P :=\n  is_artinian_of_surjective _ f.to_linear_map f.to_equiv.surjective\n#align is_artinian_of_linear_equiv is_artinian_of_linear_equiv\n\n",
 "is_artinian_of_le":
 "theorem is_artinian_of_le {s t : submodule R M} [ht : is_artinian R t] (h : s ≤ t) : is_artinian R s :=\n  is_artinian_of_injective (submodule.of_le h) (submodule.of_le_injective h)\n#align is_artinian_of_le is_artinian_of_le\n\n",
 "is_artinian_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2021 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\ntheorem is_artinian_of_injective (f : «expr →ₗ[ ] » M R P) (h : function.injective f) [is_artinian R P] :\n    is_artinian R M :=\n  ⟨subrelation.wf (fun A B hAB => show A.map f < B.map f from submodule.map_strict_mono_of_injective h hAB)\n      (inv_image.wf (submodule.map f) (is_artinian.well_founded_submodule_lt R P))⟩\n#align is_artinian_of_injective is_artinian_of_injective\n\n",
 "is_artinian_of_fg_of_artinian'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_artinian_of_fg_of_artinian' {R M} [Ring R] [add_comm_group M] [Module R M] [is_artinian_ring R]\n    (h : («expr⊤» : submodule R M).fg) : is_artinian R M :=\n  have : is_artinian R («expr⊤» : submodule R M) := is_artinian_of_fg_of_artinian _ h\n  is_artinian_of_linear_equiv (linear_equiv.of_top («expr⊤» : submodule R M) rfl)\n#align is_artinian_of_fg_of_artinian' is_artinian_of_fg_of_artinian'\n\n",
 "is_artinian_of_fg_of_artinian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_artinian_of_fg_of_artinian {R M} [Ring R] [add_comm_group M] [Module R M] (N : submodule R M)\n    [is_artinian_ring R] (hN : N.fg) : is_artinian R N :=\n  by\n  let ⟨s, hs⟩ := hN\n  haveI := classical.dec_eq M\n  haveI := classical.dec_eq R\n  have : ∀ x ∈ s, x ∈ N := fun x hx => hs ▸ submodule.subset_span hx\n  refine' @is_artinian_of_surjective ((↑s : set M) → R) _ _ _ (Pi.module _ _ _) _ _ _ is_artinian_pi\n  · fapply linear_map.mk\n    ·\n      exact fun f =>\n        ⟨finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n            («expr • » (f i) i.1),\n          N.sum_mem fun c _ => N.smul_mem _ <| this _ c.2⟩\n    · intro f g\n      apply subtype.eq\n      change\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n            («expr • » (f i + g i) _) =\n          _\n      simp only [add_smul, finset.sum_add_distrib]\n      rfl\n    · intro c f\n      apply subtype.eq\n      change\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n            («expr • » («expr • » c (f i)) _) =\n          _\n      simp only [smul_eq_mul, mul_smul]\n      exact finset.smul_sum.symm\n  rintro ⟨n, hn⟩\n  change n ∈ N at hn\n  rw [← hs, ← Set.image_id ↑s, finsupp.mem_span_image_iff_total] at hn\n  rcases hn with ⟨l, hl1, hl2⟩\n  refine' ⟨fun x => l x, subtype.ext _⟩\n  change\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n        («expr • » (l i) (i : M)) =\n      n\n  rw [@finset.sum_attach M M s _ fun i => «expr • » (l i) i, ← hl2, finsupp.total_apply, finsupp.sum, eq_comm]\n  refine' finset.sum_subset hl1 fun x _ hx => _\n  rw [finsupp.not_mem_support_iff.1 hx, zero_smul]\n#align is_artinian_of_fg_of_artinian is_artinian_of_fg_of_artinian\n\n",
 "is_artinian_iff_well_founded":
 "theorem is_artinian_iff_well_founded :\n    is_artinian R M ↔ well_founded ((· < ·) : submodule R M → submodule R M → Prop) :=\n  ⟨fun h => h.1, is_artinian.mk⟩\n#align is_artinian_iff_well_founded is_artinian_iff_well_founded\n\n",
 "induction":
 "/-- If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. -/\ntheorem induction {P : submodule R M → Prop} (hgt : ∀ I, (∀ J < I, P J) → P I) (I : submodule R M) : P I :=\n  (well_founded_submodule_lt R M).recursion I hgt\n#align induction induction\n\n",
 "finite_of_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_artinian.finite_of_linear_independent [nontrivial R] [is_artinian R M] {s : set M}\n    (hs : linear_independent R (coe : s → M)) : s.finite :=\n  by\n  refine'\n    by_contradiction fun hf =>\n      (rel_embedding.well_founded_iff_no_descending_seq.1 (well_founded_submodule_lt R M)).elim' _\n  have f : «expr ↪ » ℕ s := set.infinite.nat_embedding s hf\n  have : ∀ n, «expr '' » (coe ∘ f) { m | n ≤ m } ⊆ s :=\n    by\n    rintro n x ⟨y, hy₁, rfl⟩\n    exact (f y).2\n  have : ∀ a b : ℕ, a ≤ b ↔ span R («expr '' » (coe ∘ f) { m | b ≤ m }) ≤ span R («expr '' » (coe ∘ f) { m | a ≤ m }) :=\n    by\n    intro a b\n    rw [span_le_span_iff hs (this b) (this a), Set.image_subset_image_iff (subtype.coe_injective.comp f.injective),\n      Set.subset_def]\n    simp only [Set.mem_setOf_eq]\n    exact ⟨fun hab x => le_trans hab, fun h => h _ le_rfl⟩\n  exact\n    ⟨⟨fun n => span R («expr '' » (coe ∘ f) { m | n ≤ m }), fun x y => by\n        simp (config := { contextual := true }) [le_antisymm_iff, (this _ _).symm]⟩,\n      by\n      intro a b\n      conv_rhs => rw [GT.gt, lt_iff_le_not_le, this, this, ← lt_iff_le_not_le]\n      simp⟩\n#align is_artinian.finite_of_linear_independent is_artinian.finite_of_linear_independent\n\n",
 "exists_pow_succ_smul_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_pow_succ_smul_dvd (r : R) (x : M) : ∃ (n : ℕ)(y : M), «expr • » (r ^ n.succ) y = «expr • » (r ^ n) x :=\n  by\n  obtain ⟨n, hn⟩ := is_artinian.range_smul_pow_stabilizes M r\n  simp_rw [SetLike.ext_iff] at hn\n  exact ⟨n, by simpa using hn n.succ n.le_succ («expr • » (r ^ n) x)⟩\n#align exists_pow_succ_smul_dvd exists_pow_succ_smul_dvd\n\n",
 "exists_endomorphism_iterate_ker_sup_range_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- For any endomorphism of a Artinian module, there is some nontrivial iterate\nwith disjoint kernel and range.\n-/\ntheorem exists_endomorphism_iterate_ker_sup_range_eq_top (f : «expr →ₗ[ ] » M R M) :\n    ∃ n : ℕ, n ≠ 0 ∧ «expr ⊔ » (f ^ n).ker (f ^ n).range = «expr⊤» :=\n  by\n  obtain ⟨n, w⟩ := monotone_stabilizes (f.iterate_range.comp ⟨fun n => n + 1, fun n m w => by linarith⟩)\n  specialize w (n + 1 + n) (by linarith)\n  dsimp at w\n  refine' ⟨n + 1, nat.succ_ne_zero _, _⟩\n  simp_rw [eq_top_iff', mem_sup]\n  intro x\n  have : (f ^ (n + 1)) x ∈ (f ^ (n + 1 + n + 1)).range :=\n    by\n    rw [← w]\n    exact mem_range_self _\n  rcases this with ⟨y, hy⟩\n  use x - (f ^ (n + 1)) y\n  constructor\n  · rw [linear_map.mem_ker, linear_map.map_sub, ← hy, sub_eq_zero, pow_add]\n    simp [iterate_add_apply]\n  · use (f ^ (n + 1)) y\n    simp\n#align exists_endomorphism_iterate_ker_sup_range_eq_top exists_endomorphism_iterate_ker_sup_range_eq_top\n\n",
 "disjoint_partial_infs_eventually_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A sequence `f` of submodules of a artinian module,\nwith the supremum `f (n+1)` and the infinum of `f 0`, ..., `f n` being ⊤,\nis eventually ⊤.\n-/\ntheorem disjoint_partial_infs_eventually_top (f : ℕ → submodule R M)\n    (h : ∀ n, Disjoint (partial_sups (OrderDual.toDual ∘ f) n) (OrderDual.toDual (f (n + 1)))) :\n    ∃ n : ℕ, ∀ m, n ≤ m → f m = «expr⊤» :=\n  by\n  -- A little off-by-one cleanup first:\n  rsuffices ⟨n, w⟩ : ∃ n : ℕ, ∀ m, n ≤ m → OrderDual.toDual f (m + 1) = «expr⊤»\n  · use n + 1\n    rintro (_ | m) p\n    · cases p\n    · apply w\n      exact nat.succ_le_succ_iff.mp p\n  obtain ⟨n, w⟩ := monotone_stabilizes (partial_sups (OrderDual.toDual ∘ f))\n  refine' ⟨n, fun m p => _⟩\n  exact (h m).eq_bot_of_ge (sup_eq_left.1 <| (w (m + 1) <| le_add_right p).symm.trans <| w m p)\n#align disjoint_partial_infs_eventually_top disjoint_partial_infs_eventually_top\n\n",
 "bijective_of_injective_endomorphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Any injective endomorphism of an Artinian module is bijective. -/\ntheorem bijective_of_injective_endomorphism (f : «expr →ₗ[ ] » M R M) (s : injective f) : bijective f :=\n  ⟨s, surjective_of_injective_endomorphism f s⟩\n#align bijective_of_injective_endomorphism bijective_of_injective_endomorphism\n\n"}