{"val_aux_zero":
 "theorem val_aux_zero : val_aux K v O hv p 0 = 0 :=\n  dif_neg fun ⟨n, hn⟩ => hn rfl\n#align val_aux_zero val_aux_zero\n\n",
 "val_aux_one":
 "theorem val_aux_one : val_aux K v O hv p 1 = 1 :=\n  (val_aux_eq <| show coeff (mod_p K v O hv p) p 0 1 ≠ 0 from one_ne_zero).trans <|\n    by\n    rw [pow_zero, pow_one, RingHom.map_one, ← (Ideal.Quotient.mk _).map_one, mod_p.pre_val_mk, RingHom.map_one,\n      v.map_one]\n    change (1 : mod_p K v O hv p) ≠ 0\n    exact one_ne_zero\n#align val_aux_one val_aux_one\n\n",
 "val_aux_mul":
 "theorem val_aux_mul (f g : pre_tilt K v O hv p) :\n    val_aux K v O hv p (f * g) = val_aux K v O hv p f * val_aux K v O hv p g :=\n  by\n  by_cases hf : f = 0\n  · rw [hf, MulZeroClass.zero_mul, val_aux_zero, MulZeroClass.zero_mul]\n  by_cases hg : g = 0\n  · rw [hg, MulZeroClass.mul_zero, val_aux_zero, MulZeroClass.mul_zero]\n  obtain ⟨m, hm⟩ : ∃ n, coeff _ _ n f ≠ 0 := not_forall.1 fun h => hf <| perfection.ext h\n  obtain ⟨n, hn⟩ : ∃ n, coeff _ _ n g ≠ 0 := not_forall.1 fun h => hg <| perfection.ext h\n  replace hm := coeff_ne_zero_of_le hm (le_max_left m n)\n  replace hn := coeff_ne_zero_of_le hn (le_max_right m n)\n  have hfg : coeff _ _ (max m n + 1) (f * g) ≠ 0 :=\n    by\n    rw [RingHom.map_mul]\n    refine' mod_p.mul_ne_zero_of_pow_p_ne_zero _ _\n    · rw [← RingHom.map_pow, coeff_pow_p f]\n      assumption\n    · rw [← RingHom.map_pow, coeff_pow_p g]\n      assumption\n  rw [val_aux_eq (coeff_add_ne_zero hm 1), val_aux_eq (coeff_add_ne_zero hn 1), val_aux_eq hfg]\n  rw [RingHom.map_mul] at hfg⊢\n  rw [mod_p.pre_val_mul hfg, mul_pow]\n#align val_aux_mul val_aux_mul\n\n",
 "val_aux_eq":
 "theorem val_aux_eq {f : pre_tilt K v O hv p} {n : ℕ} (hfn : coeff _ _ n f ≠ 0) :\n    val_aux K v O hv p f = mod_p.pre_val K v O hv p (coeff _ _ n f) ^ p ^ n :=\n  by\n  have h : ∃ n, coeff _ _ n f ≠ 0 := ⟨n, hfn⟩\n  rw [val_aux, dif_pos h]\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le (nat.find_min' h hfn)\n  induction' k with k ih\n  · rfl\n  obtain ⟨x, hx⟩ := Ideal.Quotient.mk_surjective (coeff _ _ (nat.find h + k + 1) f)\n  have h1 : (Ideal.Quotient.mk _ x : mod_p K v O hv p) ≠ 0 := hx.symm ▸ hfn\n  have h2 : (Ideal.Quotient.mk _ (x ^ p) : mod_p K v O hv p) ≠ 0 :=\n    by\n    erw [RingHom.map_pow, hx, ← RingHom.map_pow, coeff_pow_p]\n    exact coeff_nat_find_add_ne_zero k\n  erw [ih (coeff_nat_find_add_ne_zero k), ← hx, ← coeff_pow_p, RingHom.map_pow, ← hx, ← RingHom.map_pow,\n    mod_p.pre_val_mk h1, mod_p.pre_val_mk h2, RingHom.map_pow, v.map_pow, ← pow_mul, pow_succ]\n  rfl\n#align val_aux_eq val_aux_eq\n\n",
 "val_aux_add":
 "theorem val_aux_add (f g : pre_tilt K v O hv p) :\n    val_aux K v O hv p (f + g) ≤ max (val_aux K v O hv p f) (val_aux K v O hv p g) :=\n  by\n  by_cases hf : f = 0;\n  · rw [hf, zero_add, val_aux_zero, max_eq_right]\n    exact zero_le _\n  by_cases hg : g = 0;\n  · rw [hg, add_zero, val_aux_zero, max_eq_left]\n    exact zero_le _\n  by_cases hfg : f + g = 0;\n  · rw [hfg, val_aux_zero]\n    exact zero_le _\n  replace hf : ∃ n, coeff _ _ n f ≠ 0 := not_forall.1 fun h => hf <| perfection.ext h\n  replace hg : ∃ n, coeff _ _ n g ≠ 0 := not_forall.1 fun h => hg <| perfection.ext h\n  replace hfg : ∃ n, coeff _ _ n (f + g) ≠ 0 := not_forall.1 fun h => hfg <| perfection.ext h\n  obtain ⟨m, hm⟩ := hf; obtain ⟨n, hn⟩ := hg; obtain ⟨k, hk⟩ := hfg\n  replace hm := coeff_ne_zero_of_le hm (le_trans (le_max_left m n) (le_max_left _ k))\n  replace hn := coeff_ne_zero_of_le hn (le_trans (le_max_right m n) (le_max_left _ k))\n  replace hk := coeff_ne_zero_of_le hk (le_max_right (max m n) k)\n  rw [val_aux_eq hm, val_aux_eq hn, val_aux_eq hk, RingHom.map_add]\n  cases' le_max_iff.1 (mod_p.pre_val_add (coeff _ _ (max (max m n) k) f) (coeff _ _ (max (max m n) k) g)) with h h\n  · exact le_max_of_le_left (pow_le_pow_of_le_left' h _)\n  · exact le_max_of_le_right (pow_le_pow_of_le_left' h _)\n#align val_aux_add val_aux_add\n\n",
 "v_p_lt_val":
 "theorem v_p_lt_val {x : O} : v p < v (algebraMap O K x) ↔ (Ideal.Quotient.mk _ x : mod_p K v O hv p) ≠ 0 := by\n  rw [lt_iff_not_le, not_iff_not, ← map_natCast (algebraMap O K) p, hv.le_iff_dvd, Ideal.Quotient.eq_zero_iff_mem,\n    Ideal.mem_span_singleton]\n#align v_p_lt_val v_p_lt_val\n\n",
 "v_p_lt_pre_val":
 "theorem v_p_lt_pre_val {x : mod_p K v O hv p} : v p < pre_val K v O hv p x ↔ x ≠ 0 :=\n  by\n  refine'\n    ⟨fun h hx => by\n      rw [hx, pre_val_zero] at h\n      exact not_lt_zero' h, fun h => lt_of_not_le fun hp => h _⟩\n  obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective x\n  rw [pre_val_mk h, ← map_natCast (algebraMap O K) p, hv.le_iff_dvd] at hp\n  rw [Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_span_singleton]; exact hp\n#align v_p_lt_pre_val v_p_lt_pre_val\n\n",
 "pthRoot_frobenius":
 "#print pthRoot_frobenius /-\ntheorem pthRoot_frobenius : (pth_root R p).comp (frobenius _ p) = RingHom.id _ :=\n  RingHom.ext fun x => ext fun n => by rw [RingHom.comp_apply, RingHom.id_apply, coeff_pth_root, coeff_frobenius]\n#align pth_root_frobenius pthRoot_frobenius\n-/\n\n",
 "pre_val_zero":
 "theorem pre_val_zero : pre_val K v O hv p 0 = 0 :=\n  if_pos rfl\n#align pre_val_zero pre_val_zero\n\n",
 "pre_val_mul":
 "theorem pre_val_mul {x y : mod_p K v O hv p} (hxy0 : x * y ≠ 0) :\n    pre_val K v O hv p (x * y) = pre_val K v O hv p x * pre_val K v O hv p y :=\n  by\n  have hx0 : x ≠ 0 :=\n    mt\n      (by\n        rintro rfl\n        rw [MulZeroClass.zero_mul])\n      hxy0\n  have hy0 : y ≠ 0 :=\n    mt\n      (by\n        rintro rfl\n        rw [MulZeroClass.mul_zero])\n      hxy0\n  obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective x\n  obtain ⟨s, rfl⟩ := Ideal.Quotient.mk_surjective y\n  rw [← RingHom.map_mul] at hxy0⊢\n  rw [pre_val_mk hx0, pre_val_mk hy0, pre_val_mk hxy0, RingHom.map_mul, v.map_mul]\n#align pre_val_mul pre_val_mul\n\n",
 "pre_val_mk":
 "theorem pre_val_mk {x : O} (hx : (Ideal.Quotient.mk _ x : mod_p K v O hv p) ≠ 0) :\n    pre_val K v O hv p (Ideal.Quotient.mk _ x) = v (algebraMap O K x) :=\n  by\n  obtain ⟨r, hr⟩ :=\n    Ideal.mem_span_singleton'.1\n      (Ideal.Quotient.eq.1 <| Quotient.sound' <| @Quotient.mk_out' O (Ideal.span {p} : Ideal O).quotient_rel x)\n  refine' (if_neg hx).trans (v.map_eq_of_sub_lt <| lt_of_not_le _)\n  erw [← RingHom.map_sub, ← hr, hv.le_iff_dvd]\n  exact fun hprx => hx (Ideal.Quotient.eq_zero_iff_mem.2 <| Ideal.mem_span_singleton.2 <| dvd_of_mul_left_dvd hprx)\n#align pre_val_mk pre_val_mk\n\n",
 "pre_val_eq_zero":
 "theorem pre_val_eq_zero {x : mod_p K v O hv p} : pre_val K v O hv p x = 0 ↔ x = 0 :=\n  ⟨fun hvx =>\n    by_contradiction fun hx0 : x ≠ 0 => by\n      rw [← v_p_lt_pre_val, hvx] at hx0\n      exact not_lt_zero' hx0,\n    fun hx => hx.symm ▸ pre_val_zero⟩\n#align pre_val_eq_zero pre_val_eq_zero\n\n",
 "pre_val_add":
 "theorem pre_val_add (x y : mod_p K v O hv p) :\n    pre_val K v O hv p (x + y) ≤ max (pre_val K v O hv p x) (pre_val K v O hv p y) :=\n  by\n  by_cases hx0 : x = 0;\n  · rw [hx0, zero_add]\n    exact le_max_right _ _\n  by_cases hy0 : y = 0;\n  · rw [hy0, add_zero]\n    exact le_max_left _ _\n  by_cases hxy0 : x + y = 0;\n  · rw [hxy0, pre_val_zero]\n    exact zero_le _\n  obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective x\n  obtain ⟨s, rfl⟩ := Ideal.Quotient.mk_surjective y\n  rw [← RingHom.map_add] at hxy0⊢\n  rw [pre_val_mk hx0, pre_val_mk hy0, pre_val_mk hxy0, RingHom.map_add]; exact v.map_add _ _\n#align pre_val_add pre_val_add\n\n",
 "of":
 "/-- The canonical perfection map from the perfection of a ring. -/\ntheorem of : perfection_map p (perfection.coeff R p 0) :=\n  mk' (RingEquiv.refl _) <| (Equiv.apply_eq_iff_eq_symm_apply _).2 rfl\n#align of of\n\n",
 "mul_ne_zero_of_pow_p_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mul_ne_zero_of_pow_p_ne_zero {x y : mod_p K v O hv p} (hx : x ^ p ≠ 0) (hy : y ^ p ≠ 0) : x * y ≠ 0 :=\n  by\n  obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective x\n  obtain ⟨s, rfl⟩ := Ideal.Quotient.mk_surjective y\n  have h1p : (0 : exprℝ) < 1 / p := one_div_pos.2 (Nat.cast_pos.2 hp.1.pos)\n  rw [← RingHom.map_mul]; rw [← RingHom.map_pow] at hx hy\n  rw [← v_p_lt_val hv] at hx hy⊢\n  rw [RingHom.map_pow, v.map_pow, ← rpow_lt_rpow_iff h1p, ← rpow_nat_cast, ← rpow_mul,\n    mul_one_div_cancel (Nat.cast_ne_zero.2 hp.1.ne_zero : (p : exprℝ) ≠ 0), rpow_one] at hx hy\n  rw [RingHom.map_mul, v.map_mul]; refine' lt_of_le_of_lt _ (mul_lt_mul₀ hx hy)\n  by_cases hvp : v p = 0;\n  · rw [hvp]\n    exact zero_le _; replace hvp := zero_lt_iff.2 hvp\n  conv_lhs => rw [← rpow_one (v p)]; rw [← rpow_add (ne_of_gt hvp)]\n  refine' rpow_le_rpow_of_exponent_ge hvp (map_natCast (algebraMap O K) p ▸ hv.2 _) _\n  rw [← add_div, div_le_one (Nat.cast_pos.2 hp.1.pos : 0 < (p : exprℝ))]; exact_mod_cast hp.1.two_le\n#align mul_ne_zero_of_pow_p_ne_zero mul_ne_zero_of_pow_p_ne_zero\n\n",
 "mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/-- Create a `perfection_map` from an isomorphism to the perfection. -/\n@[simps]\ntheorem mk' {f : «expr →+* » P R} (g : «expr ≃+* » P (ring.perfection R p)) (hfg : perfection.lift p P R f = g) :\n    perfection_map p f :=\n  { injective := fun x y hxy =>\n      g.injective <|\n        (RingHom.ext_iff.1 hfg x).symm.trans <|\n          Eq.symm <| (RingHom.ext_iff.1 hfg y).symm.trans <| perfection.ext fun n => (hxy n).symm\n    surjective := fun y hy =>\n      let ⟨x, hx⟩ := g.surjective ⟨y, hy⟩\n      ⟨x, fun n =>\n        show perfection.coeff R p n (perfection.lift p P R f x) = perfection.coeff R p n ⟨y, hy⟩ by\n          rw [hfg, ← coe_fn_coe_base, hx]⟩ }\n#align mk' mk'\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_map {π : «expr →+* » P R} (m : perfection_map p π) {σ : «expr →+* » Q S} (n : perfection_map p σ)\n    (φ : «expr →+* » R S) (x : P) : σ (map p m n φ x) = φ (π x) :=\n  RingHom.ext_iff.1 (comp_map p m n φ) x\n#align map_map map_map\n\n",
 "map_eq_zero":
 "#print map_eq_zero /-\ntheorem map_eq_zero {f : pre_tilt K v O hv p} : val K v O hv p f = 0 ↔ f = 0 :=\n  by\n  by_cases hf0 : f = 0;\n  · rw [hf0]\n    exact iff_of_true (Valuation.map_zero _) rfl\n  obtain ⟨n, hn⟩ : ∃ n, coeff _ _ n f ≠ 0 := not_forall.1 fun h => hf0 <| perfection.ext h\n  show val_aux K v O hv p f = 0 ↔ f = 0; refine' iff_of_false (fun hvf => hn _) hf0\n  rw [val_aux_eq hn] at hvf; replace hvf := pow_eq_zero hvf; rwa [mod_p.pre_val_eq_zero] at hvf\n#align map_eq_zero map_eq_zero\n-/\n\n",
 "map_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n-- Why is this slow?\ntheorem map_eq_map (φ : «expr →+* » R S) :\n    @map p _ R _ _ _ _ _ _ S _ _ _ _ _ _ _ (of p R) _ (of p S) φ = perfection.map p φ :=\n  hom_ext _ (of p S) fun f => by rw [map_map, perfection.coeff_map]\n#align map_eq_map map_eq_map\n\n",
 "id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print id /-\n/-- For a perfect ring, it itself is the perfection. -/\ntheorem id [PerfectRing R p] : perfection_map p (RingHom.id R) :=\n  { injective := fun x y hxy => hxy 0\n    surjective := fun f hf =>\n      ⟨f 0, fun n =>\n        show («expr ^[ ]» (pthRoot R p) n) (f 0) = f n from\n          nat.rec_on n rfl fun n ih =>\n            injective_pow_p p <| by rw [Function.iterate_succ_apply', pthRoot_pow_p _, ih, hf]⟩ }\n#align id id\n-/\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem hom_ext [PerfectRing R p] {S : Type u₂} [CommSemiring S] [CharP S p] {P : Type u₃} [CommSemiring P] [CharP P p]\n    [PerfectRing P p] (π : «expr →+* » P S) (m : perfection_map p π) {f g : «expr →+* » R P}\n    (hfg : ∀ x, π (f x) = π (g x)) : f = g :=\n  (lift p R S P π m).symm.injective <| RingHom.ext hfg\n#align hom_ext hom_ext\n\n",
 "frobenius_pthRoot":
 "#print frobenius_pthRoot /-\ntheorem frobenius_pthRoot : (frobenius _ p).comp (pth_root R p) = RingHom.id _ :=\n  RingHom.ext fun x =>\n    ext fun n => by\n      rw [RingHom.comp_apply, RingHom.id_apply, RingHom.map_frobenius, coeff_pth_root, ← RingHom.map_frobenius,\n        coeff_frobenius]\n#align frobenius_pth_root frobenius_pthRoot\n-/\n\n",
 "ext":
 "/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n@[ext]\ntheorem ext {f g : ring.perfection R p} (h : ∀ n, coeff R p n f = coeff R p n g) : f = g :=\n  Subtype.eq <| funext h\n#align ext ext\n\n",
 "equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem equiv_apply {π : «expr →+* » P R} (m : perfection_map p π) (x : P) : m.equiv x = perfection.lift p P R π x :=\n  rfl\n#align equiv_apply equiv_apply\n\n",
 "comp_symm_equiv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comp_symm_equiv' {π : «expr →+* » P R} (m : perfection_map p π) :\n    π.comp ↑m.equiv.symm = perfection.coeff R p 0 :=\n  RingHom.ext m.comp_symm_equiv\n#align comp_symm_equiv' comp_symm_equiv'\n\n",
 "comp_symm_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comp_symm_equiv {π : «expr →+* » P R} (m : perfection_map p π) (f : ring.perfection R p) :\n    π (m.equiv.symm f) = perfection.coeff R p 0 f :=\n  (m.comp_equiv _).symm.trans <| congr_arg _ <| m.equiv.apply_symm_apply f\n#align comp_symm_equiv comp_symm_equiv\n\n",
 "comp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comp_map {π : «expr →+* » P R} (m : perfection_map p π) {σ : «expr →+* » Q S} (n : perfection_map p σ)\n    (φ : «expr →+* » R S) : σ.comp (map p m n φ) = φ.comp π :=\n  (lift p P S Q σ n).symm_apply_apply _\n#align comp_map comp_map\n\n",
 "comp_equiv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comp_equiv' {π : «expr →+* » P R} (m : perfection_map p π) : (perfection.coeff R p 0).comp ↑m.equiv = π :=\n  RingHom.ext fun x => rfl\n#align comp_equiv' comp_equiv'\n\n",
 "comp_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comp_equiv {π : «expr →+* » P R} (m : perfection_map p π) (x : P) : perfection.coeff R p 0 (m.equiv x) = π x :=\n  rfl\n#align comp_equiv comp_equiv\n\n",
 "coeff_pth_root":
 "theorem coeff_pth_root (f : ring.perfection R p) (n : ℕ) : coeff R p n (pth_root R p f) = coeff R p (n + 1) f :=\n  rfl\n#align coeff_pth_root coeff_pth_root\n\n",
 "coeff_pow_p'":
 "theorem coeff_pow_p' (f : ring.perfection R p) (n : ℕ) : coeff R p (n + 1) f ^ p = coeff R p n f :=\n  f.2 n\n#align coeff_pow_p' coeff_pow_p'\n\n",
 "coeff_pow_p":
 "theorem coeff_pow_p (f : ring.perfection R p) (n : ℕ) : coeff R p (n + 1) (f ^ p) = coeff R p n f :=\n  by\n  rw [RingHom.map_pow]\n  exact f.2 n\n#align coeff_pow_p coeff_pow_p\n\n",
 "coeff_ne_zero_of_le":
 "theorem coeff_ne_zero_of_le {f : ring.perfection R p} {m n : ℕ} (hfm : coeff R p m f ≠ 0) (hmn : m ≤ n) :\n    coeff R p n f ≠ 0 :=\n  let ⟨k, hk⟩ := Nat.exists_eq_add_of_le hmn\n  hk.symm ▸ coeff_add_ne_zero hfm k\n#align coeff_ne_zero_of_le coeff_ne_zero_of_le\n\n",
 "coeff_nat_find_add_ne_zero":
 "theorem coeff_nat_find_add_ne_zero {f : pre_tilt K v O hv p} {h : ∃ n, coeff _ _ n f ≠ 0} (k : ℕ) :\n    coeff _ _ (nat.find h + k) f ≠ 0 :=\n  coeff_add_ne_zero (nat.find_spec h) k\n#align coeff_nat_find_add_ne_zero coeff_nat_find_add_ne_zero\n\n",
 "coeff_mk":
 "@[simp]\ntheorem coeff_mk (f : ℕ → R) (hf) (n : ℕ) : coeff R p n ⟨f, hf⟩ = f n :=\n  rfl\n#align coeff_mk coeff_mk\n\n",
 "coeff_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem coeff_map (φ : «expr →+* » R S) (f : ring.perfection R p) (n : ℕ) :\n    coeff S p n (map p φ f) = φ (coeff R p n f) :=\n  rfl\n#align coeff_map coeff_map\n\n",
 "coeff_iterate_frobenius'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem coeff_iterate_frobenius' (f : ring.perfection R p) (n m : ℕ) (hmn : m ≤ n) :\n    coeff R p n ((«expr ^[ ]» (frobenius _ p) m) f) = coeff R p (n - m) f :=\n  Eq.symm <| (coeff_iterate_frobenius _ _ m).symm.trans <| (tsub_add_cancel_of_le hmn).symm ▸ rfl\n#align coeff_iterate_frobenius' coeff_iterate_frobenius'\n\n",
 "coeff_iterate_frobenius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n-- `coeff_pow_p f n` also works but is slow!\ntheorem coeff_iterate_frobenius (f : ring.perfection R p) (n m : ℕ) :\n    coeff R p (n + m) ((«expr ^[ ]» (frobenius _ p) m) f) = coeff R p n f :=\n  nat.rec_on m rfl fun m ih => by erw [Function.iterate_succ_apply', coeff_frobenius, ih]\n#align coeff_iterate_frobenius coeff_iterate_frobenius\n\n",
 "coeff_frobenius":
 "theorem coeff_frobenius (f : ring.perfection R p) (n : ℕ) : coeff R p (n + 1) (frobenius _ p f) = coeff R p n f := by\n  apply coeff_pow_p f n\n#align coeff_frobenius coeff_frobenius\n\n",
 "coeff_add_ne_zero":
 "theorem coeff_add_ne_zero {f : ring.perfection R p} {n : ℕ} (hfn : coeff R p n f ≠ 0) (k : ℕ) :\n    coeff R p (n + k) f ≠ 0 :=\n  nat.rec_on k hfn fun k ih h => ih <| by erw [← coeff_pow_p, RingHom.map_pow, h, zero_pow hp.1.pos]\n#align coeff_add_ne_zero coeff_add_ne_zero\n\n"}