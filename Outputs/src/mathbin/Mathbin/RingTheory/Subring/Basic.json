{"zsmul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print zsmul_mem /-\nprotected theorem zsmul_mem {x : R} (hx : x ∈ s) (n : ℤ) : «expr • » n x ∈ s :=\n  zsmul_mem hx n\n#align zsmul_mem zsmul_mem\n-/\n\n",
 "zero_mem":
 "/-- A subring contains the ring's 0. -/\nprotected theorem zero_mem : (0 : R) ∈ s :=\n  zero_mem _\n#align zero_mem zero_mem\n\n",
 "top_prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_prod_top : («expr⊤» : Subring R).prod («expr⊤» : Subring S) = «expr⊤» :=\n  (top_prod _).trans <| comap_top _\n#align top_prod_top top_prod_top\n\n",
 "top_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem top_prod (s : Subring S) : («expr⊤» : Subring R).prod s = s.comap (RingHom.snd R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n#align top_prod top_prod\n\n",
 "to_subsemiring_strict_mono":
 "@[mono]\ntheorem to_subsemiring_strict_mono : StrictMono (to_subsemiring : Subring R → Subsemiring R) := fun _ _ => id\n#align to_subsemiring_strict_mono to_subsemiring_strict_mono\n\n",
 "to_subsemiring_mono":
 "@[mono]\ntheorem to_subsemiring_mono : Monotone (to_subsemiring : Subring R → Subsemiring R) :=\n  toSubsemiring_strictMono.monotone\n#align to_subsemiring_mono to_subsemiring_mono\n\n",
 "to_subsemiring_injective":
 "theorem to_subsemiring_injective : function.injective (to_subsemiring : Subring R → Subsemiring R)\n  | r, s, h => ext (SetLike.ext_iff.mp h : _)\n#align to_subsemiring_injective to_subsemiring_injective\n\n",
 "to_submonoid_strict_mono":
 "@[mono]\ntheorem to_submonoid_strict_mono : StrictMono ([anonymous] : Subring R → Submonoid R) := fun _ _ => id\n#align to_submonoid_strict_mono to_submonoid_strict_mono\n\n",
 "to_submonoid_mono":
 "@[mono]\ntheorem to_submonoid_mono : Monotone ([anonymous] : Subring R → Submonoid R) :=\n  toSubmonoid_strictMono.monotone\n#align to_submonoid_mono to_submonoid_mono\n\n",
 "to_submonoid_injective":
 "theorem to_submonoid_injective : function.injective ([anonymous] : Subring R → Submonoid R)\n  | r, s, h => ext (SetLike.ext_iff.mp h : _)\n#align to_submonoid_injective to_submonoid_injective\n\n",
 "to_add_subgroup_strict_mono":
 "@[mono]\ntheorem to_add_subgroup_strict_mono : StrictMono (to_add_subgroup : Subring R → AddSubgroup R) := fun _ _ => id\n#align to_add_subgroup_strict_mono to_add_subgroup_strict_mono\n\n",
 "to_add_subgroup_mono":
 "@[mono]\ntheorem to_add_subgroup_mono : Monotone (to_add_subgroup : Subring R → AddSubgroup R) :=\n  toAddSubgroup_strictMono.monotone\n#align to_add_subgroup_mono to_add_subgroup_mono\n\n",
 "to_add_subgroup_injective":
 "theorem to_add_subgroup_injective : function.injective (to_add_subgroup : Subring R → AddSubgroup R)\n  | r, s, h => ext (SetLike.ext_iff.mp h : _)\n#align to_add_subgroup_injective to_add_subgroup_injective\n\n",
 "sum_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print sum_mem /-\n/-- Sum of elements in a `subring` of a `ring` indexed by a `finset`\nis in the `subring`. -/\nprotected theorem sum_mem {R : Type _} [Ring R] (s : Subring R) {ι : Type _} {t : Finset ι} {f : ι → R}\n    (h : ∀ c ∈ t, f c ∈ s) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f i) ∈ s :=\n  sum_mem h\n#align sum_mem sum_mem\n-/\n\n",
 "subset_closure":
 "#print subset_closure /-\n/-- The subring generated by a set includes the set. -/\n@[simp]\ntheorem subset_closure {s : Set R} : s ⊆ closure s := fun x hx => mem_closure.2 fun S hS => hS hx\n#align subset_closure subset_closure\n-/\n\n",
 "sub_mem":
 "#print sub_mem /-\n/-- A subring is closed under subtraction -/\nprotected theorem sub_mem {x y : R} (hx : x ∈ s) (hy : y ∈ s) : x - y ∈ s :=\n  sub_mem hx hy\n#align sub_mem sub_mem\n-/\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_def [SMul R α] {S : Subring R} (g : S) (m : α) : «expr • » g m = «expr • » (g : R) m :=\n  rfl\n#align smul_def smul_def\n\n",
 "rec_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[elab_as_elim]\nprotected theorem in_closure.rec_on {C : R → Prop} {x : R} (hx : x ∈ closure s) (h1 : C 1) (hneg1 : C (-1))\n    (hs : ∀ z ∈ s, ∀ n, C n → C (z * n)) (ha : ∀ {x y}, C x → C y → C (x + y)) : C x :=\n  by\n  have h0 : C 0 := add_neg_self (1 : R) ▸ ha h1 hneg1\n  rcases exists_list_of_mem_closure hx with ⟨L, HL, rfl⟩\n  clear hx\n  induction' L with hd tl ih\n  · exact h0\n  rw [List.forall_mem_cons] at HL\n  suffices C (List.prod hd) by\n    rw [list.map_cons, List.sum_cons]\n    exact ha this (ih HL.2)\n  replace HL := HL.1\n  clear ih tl\n  rsuffices ⟨L, HL', HP | HP⟩ :\n    ∃ L : List R, (∀ x ∈ L, x ∈ s) ∧ (List.prod hd = List.prod L ∨ List.prod hd = -List.prod L)\n  · rw [HP]\n    clear HP HL hd\n    induction' L with hd tl ih\n    · exact h1\n    rw [List.forall_mem_cons] at HL'\n    rw [List.prod_cons]\n    exact hs _ HL'.1 _ (ih HL'.2)\n  · rw [HP]\n    clear HP HL hd\n    induction' L with hd tl ih\n    · exact hneg1\n    rw [List.prod_cons, neg_mul_eq_mul_neg]\n    rw [List.forall_mem_cons] at HL'\n    exact hs _ HL'.1 _ (ih HL'.2)\n  induction' hd with hd tl ih\n  · exact ⟨[], List.forall_mem_nil _, or.inl rfl⟩\n  rw [List.forall_mem_cons] at HL\n  rcases ih HL.2 with ⟨L, HL', HP | HP⟩ <;> cases' HL.1 with hhd hhd\n  · exact ⟨sym.cons' hd L, List.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inl <| by rw [List.prod_cons, List.prod_cons, HP]⟩\n  · exact ⟨L, HL', or.inr <| by rw [List.prod_cons, hhd, neg_one_mul, HP]⟩\n  ·\n    exact\n      ⟨sym.cons' hd L, List.forall_mem_cons.2 ⟨hhd, HL'⟩,\n        or.inr <| by rw [List.prod_cons, List.prod_cons, HP, neg_mul_eq_mul_neg]⟩\n  · exact ⟨L, HL', or.inl <| by rw [List.prod_cons, hhd, HP, neg_one_mul, neg_neg]⟩\n#align in_closure.rec_on in_closure.rec_on\n\n",
 "range_top_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The range of a surjective ring homomorphism is the whole of the codomain. -/\ntheorem range_top_of_surjective (f : «expr →+* » R S) (hf : function.surjective f) : f.range = («expr⊤» : Subring S) :=\n  range_top_iff_surjective.2 hf\n#align range_top_of_surjective range_top_of_surjective\n\n",
 "range_top_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_top_iff_surjective {f : «expr →+* » R S} : f.range = («expr⊤» : Subring S) ↔ function.surjective f :=\n  SetLike.ext'_iff.trans <| iff.trans (by rw [coe_range, coe_top]) Set.range_iff_surjective\n#align range_top_iff_surjective range_top_iff_surjective\n\n",
 "range_subtype":
 "@[simp]\ntheorem range_subtype (s : Subring R) : s.subtype.range = s :=\n  SetLike.coe_injective <| (coe_rangeS _).trans Subtype.range_coe\n#align range_subtype range_subtype\n\n",
 "range_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_snd : (snd R S).srange = «expr⊤» :=\n  (snd R S).srange_top_of_surjective <| Prod.snd_surjective\n#align range_snd range_snd\n\n",
 "range_restrict_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem range_restrict_surjective (f : «expr →+* » R S) : function.surjective f.range_restrict := fun ⟨y, hy⟩ =>\n  let ⟨x, hx⟩ := mem_range.mp hy\n  ⟨x, Subtype.ext hx⟩\n#align range_restrict_surjective range_restrict_surjective\n\n",
 "range_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_fst : (fst R S).srange = «expr⊤» :=\n  (fst R S).srange_top_of_surjective <| Prod.fst_surjective\n#align range_fst range_fst\n\n",
 "range_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_eq_map (f : «expr →+* » R S) : f.range = Subring.map f («expr⊤») :=\n  by\n  ext\n  simp\n#align range_eq_map range_eq_map\n\n",
 "prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem prod_top (s : Subring R) : s.prod («expr⊤» : Subring S) = s.comap (RingHom.fst R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n#align prod_top prod_top\n\n",
 "prod_mono_right":
 "theorem prod_mono_right (s : Subring R) : Monotone fun t : Subring S => s.prod t :=\n  prod_mono (le_refl s)\n#align prod_mono_right prod_mono_right\n\n",
 "prod_mono_left":
 "theorem prod_mono_left (t : Subring S) : Monotone fun s : Subring R => s.prod t := fun s₁ s₂ hs =>\n  prod_mono hs (le_refl t)\n#align prod_mono_left prod_mono_left\n\n",
 "prod_mono":
 "@[mono]\ntheorem prod_mono ⦃s₁ s₂ : Subring R⦄ (hs : s₁ ≤ s₂) ⦃t₁ t₂ : Subring S⦄ (ht : t₁ ≤ t₂) : s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n#align prod_mono prod_mono\n\n",
 "prod_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print prod_mem /-\n/-- Product of elements of a subring of a `comm_ring` indexed by a `finset` is in the\n    subring. -/\nprotected theorem prod_mem {R : Type _} [CommRing R] (s : Subring R) {ι : Type _} {t : Finset ι} {f : ι → R}\n    (h : ∀ c ∈ t, f c ∈ s) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i) ∈ s :=\n  prod_mem h\n#align prod_mem prod_mem\n-/\n\n",
 "prod_bot_sup_bot_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem prod_bot_sup_bot_prod (s : Subring R) (t : Subring S) :\n    «expr ⊔ » (s.prod («expr⊥»)) (prod («expr⊥») t) = s.prod t :=\n  le_antisymm (sup_le (prod_mono_right s bot_le) (prod_mono_left t bot_le)) fun p hp =>\n    Prod.fst_mul_snd p ▸\n      mul_mem\n        ((le_sup_left : s.prod («expr⊥») ≤ «expr ⊔ » (s.prod («expr⊥»)) (prod («expr⊥») t))\n          ⟨hp.1, SetLike.mem_coe.2 <| one_mem («expr⊥»)⟩)\n        ((le_sup_right : prod («expr⊥») t ≤ «expr ⊔ » (s.prod («expr⊥»)) (prod («expr⊥») t))\n          ⟨SetLike.mem_coe.2 <| one_mem («expr⊥»), hp.2⟩)\n#align prod_bot_sup_bot_prod prod_bot_sup_bot_prod\n\n",
 "pow_mem":
 "#print pow_mem /-\nprotected theorem pow_mem {x : R} (hx : x ∈ s) (n : ℕ) : x ^ n ∈ s :=\n  pow_mem hx n\n#align pow_mem pow_mem\n-/\n\n",
 "one_mem":
 "/-- A subring contains the ring's 1. -/\nprotected theorem one_mem : (1 : R) ∈ s :=\n  one_mem _\n#align one_mem one_mem\n\n",
 "of_left_inverse_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem of_left_inverse_symm_apply {g : S → R} {f : «expr →+* » R S} (h : function.left_inverse g f) (x : f.range) :\n    (ofLeftInverse h).symm x = g x :=\n  rfl\n#align of_left_inverse_symm_apply of_left_inverse_symm_apply\n\n",
 "of_left_inverse_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem of_left_inverse_apply {g : S → R} {f : «expr →+* » R S} (h : function.left_inverse g f) (x : R) :\n    ↑(ofLeftInverse h x) = f x :=\n  rfl\n#align of_left_inverse_apply of_left_inverse_apply\n\n",
 "not_mem_of_not_mem_closure":
 "#print not_mem_of_not_mem_closure /-\ntheorem not_mem_of_not_mem_closure {s : Set R} {P : R} (hP : P ∉ closure s) : P ∉ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n-/\n\n",
 "neg_mem":
 "/-- A subring is closed under negation. -/\nprotected theorem neg_mem {x : R} : x ∈ s → -x ∈ s :=\n  neg_mem\n#align neg_mem neg_mem\n\n",
 "multiset_sum_mem":
 "#print multiset_sum_mem /-\n/-- Sum of a multiset of elements in an `subring` of a `ring` is\nin the `subring`. -/\nprotected theorem multiset_sum_mem {R} [Ring R] (s : Subring R) (m : Multiset R) : (∀ a ∈ m, a ∈ s) → m.sum ∈ s :=\n  multiset_sum_mem _\n#align multiset_sum_mem multiset_sum_mem\n-/\n\n",
 "multiset_prod_mem":
 "#print multiset_prod_mem /-\n/-- Product of a multiset of elements in a subring of a `comm_ring` is in the subring. -/\nprotected theorem multiset_prod_mem {R} [CommRing R] (s : Subring R) (m : Multiset R) : (∀ a ∈ m, a ∈ s) → m.prod ∈ s :=\n  multiset_prod_mem _\n#align multiset_prod_mem multiset_prod_mem\n-/\n\n",
 "mul_mem":
 "/-- A subring is closed under multiplication. -/\nprotected theorem mul_mem {x y : R} : x ∈ s → y ∈ s → x * y ∈ s :=\n  mul_mem\n#align mul_mem mul_mem\n\n",
 "mk_le_mk":
 "@[simp]\ntheorem mk_le_mk {S S' : Set R} (h₁ h₂ h₃ h₄ h₅ h₁' h₂' h₃' h₄' h₅') :\n    (⟨S, h₁, h₂, h₃, h₄, h₅⟩ : Subring R) ≤ (⟨S', h₁', h₂', h₃', h₄', h₅'⟩ : Subring R) ↔ S ⊆ S' :=\n  iff.rfl\n#align mk_le_mk mk_le_mk\n\n",
 "mk'_to_submonoid":
 "@[simp]\ntheorem mk'_to_submonoid {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubgroup R} (ha : ↑sa = s) :\n    (Subring.mk' s sm sa hm ha).to_submonoid = sm :=\n  SetLike.coe_injective hm.symm\n#align mk'_to_submonoid mk'_to_submonoid\n\n",
 "mk'_to_add_subgroup":
 "@[simp]\ntheorem mk'_to_add_subgroup {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubgroup R} (ha : ↑sa = s) :\n    (Subring.mk' s sm sa hm ha).to_add_subgroup = sa :=\n  SetLike.coe_injective ha.symm\n#align mk'_to_add_subgroup mk'_to_add_subgroup\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top (x : R) : x ∈ («expr⊤» : Subring R) :=\n  Set.mem_univ x\n#align mem_top mem_top\n\n",
 "mem_to_submonoid":
 "@[simp]\ntheorem mem_to_submonoid {s : Subring R} {x : R} : x ∈ s.to_submonoid ↔ x ∈ s :=\n  iff.rfl\n#align mem_to_submonoid mem_to_submonoid\n\n",
 "mem_to_add_subgroup":
 "@[simp]\ntheorem mem_to_add_subgroup {s : Subring R} {x : R} : x ∈ s.to_add_subgroup ↔ x ∈ s :=\n  iff.rfl\n#align mem_to_add_subgroup mem_to_add_subgroup\n\n",
 "mem_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- The underlying set of a non-empty directed Sup of subrings is just a union of the subrings.\n  Note that this fails without the directedness assumption (the union of two subrings is\n  typically not a subring) -/\ntheorem mem_supr_of_directed {ι} [hι : Nonempty ι] {S : ι → Subring R} (hS : Directed (· ≤ ·) S) {x : R} :\n    x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) ↔\n      ∃ i, x ∈ S i :=\n  by\n  refine' ⟨_, fun ⟨i, hi⟩ => (SetLike.le_def.1 <| le_supᵢ S i) hi⟩\n  let U : Subring R :=\n    Subring.mk'\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i : Set R))\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (S i).to_submonoid)\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (S i).to_add_subgroup)\n      (Submonoid.coe_supᵢ_of_directed <| hS.mono_comp _ fun _ _ => id)\n      (AddSubgroup.coe_supᵢ_of_directed <| hS.mono_comp _ fun _ _ => id)\n  suffices «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) ≤ U by\n    simpa using @this x\n  exact supᵢ_le fun i x hx => Set.mem_unionᵢ.2 ⟨i, hx⟩\n#align mem_supr_of_directed mem_supr_of_directed\n\n",
 "mem_range_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem mem_range_self (f : «expr →+* » R S) (x : R) : f x ∈ f.range :=\n  mem_range.mpr ⟨x, rfl⟩\n#align mem_range_self mem_range_self\n\n",
 "mem_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem mem_range {f : «expr →+* » R S} {y : S} : y ∈ f.range ↔ ∃ x, f x = y :=\n  iff.rfl\n#align mem_range mem_range\n\n",
 "mem_prod":
 "theorem mem_prod {s : Subring R} {t : Subring S} {p : R × S} : p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  iff.rfl\n#align mem_prod mem_prod\n\n",
 "mem_posSubgroup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n#print Units.mem_posSubgroup /-\n-- while this definition is not about subrings, this is the earliest we have\n-- both ordered ring structures and submonoids available\n@[simp]\ntheorem Units.mem_posSubgroup {R : Type _} [LinearOrderedSemiring R] (u : «expr ˣ» R) :\n    u ∈ Units.posSubgroup R ↔ (0 : R) < u :=\n  iff.rfl\n#align units.mem_pos_subgroup Units.mem_posSubgroup\n-/\n\n",
 "mem_mk'":
 "@[simp]\ntheorem mem_mk' {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubgroup R} (ha : ↑sa = s) {x : R} :\n    x ∈ Subring.mk' s sm sa hm ha ↔ x ∈ s :=\n  iff.rfl\n#align mem_mk' mem_mk'\n\n",
 "mem_mk":
 "@[simp]\ntheorem mem_mk {S : Set R} {x : R} (h₁ h₂ h₃ h₄ h₅) : x ∈ (⟨S, h₁, h₂, h₃, h₄, h₅⟩ : Subring R) ↔ x ∈ S :=\n  iff.rfl\n#align mem_mk mem_mk\n\n",
 "mem_map_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem mem_map_equiv {f : «expr ≃+* » R S} {K : Subring R} {x : S} : x ∈ K.map (f : «expr →+* » R S) ↔ f.symm x ∈ K :=\n  @Set.mem_image_equiv _ _ (↑K) f.to_equiv x\n#align mem_map_equiv mem_map_equiv\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem mem_map {f : «expr →+* » R S} {s : Subring R} {y : S} : y ∈ s.map f ↔ ∃ x ∈ s, f x = y :=\n  Set.mem_image_iff_bex\n#align mem_map mem_map\n\n",
 "mem_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem mem_infi {ι : Sort _} {S : ι → Subring R} {x : R} :\n    x ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i) ↔\n      ∀ i, x ∈ S i :=\n  by simp only [infᵢ, mem_Inf, Set.forall_range_iff]\n#align mem_infi mem_infi\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem mem_inf {p p' : Subring R} {x : R} : x ∈ «expr ⊓ » p p' ↔ x ∈ p ∧ x ∈ p' :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem mem_comap {s : Subring S} {f : «expr →+* » R S} {x : R} : x ∈ s.comap f ↔ f x ∈ s :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_closure_iff":
 "#print mem_closure_iff /-\ntheorem mem_closure_iff {s : Set R} {x} : x ∈ closure s ↔ x ∈ AddSubgroup.closure (Submonoid.closure s : Set R) :=\n  ⟨fun h =>\n    closure_induction h (fun x hx => AddSubgroup.subset_closure <| Submonoid.subset_closure hx) (AddSubgroup.zero_mem _)\n      (AddSubgroup.subset_closure (Submonoid.one_mem (Submonoid.closure s)))\n      (fun x y hx hy => AddSubgroup.add_mem _ hx hy) (fun x hx => AddSubgroup.neg_mem _ hx) fun x y hx hy =>\n      AddSubgroup.closure_induction hy\n        (fun q hq =>\n          AddSubgroup.closure_induction hx\n            (fun p hp => AddSubgroup.subset_closure ((Submonoid.closure s).mul_mem hp hq))\n            (by rw [MulZeroClass.zero_mul q]; apply AddSubgroup.zero_mem _)\n            (fun p₁ p₂ ihp₁ ihp₂ => by rw [add_mul p₁ p₂ q]; apply AddSubgroup.add_mem _ ihp₁ ihp₂) fun x hx =>\n            by\n            have f : -x * q = -(x * q) := by simp\n            rw [f]; apply AddSubgroup.neg_mem _ hx)\n        (by rw [MulZeroClass.mul_zero x]; apply AddSubgroup.zero_mem _)\n        (fun q₁ q₂ ihq₁ ihq₂ => by rw [mul_add x q₁ q₂]; apply AddSubgroup.add_mem _ ihq₁ ihq₂) fun z hz =>\n        by\n        have f : x * -z = -(x * z) := by simp\n        rw [f]; apply AddSubgroup.neg_mem _ hz,\n    fun h =>\n    AddSubgroup.closure_induction h\n      (fun x hx =>\n        Submonoid.closure_induction hx (fun x hx => subset_closure hx) (one_mem _) fun x y hx hy => mul_mem hx hy)\n      (zero_mem _) (fun x y hx hy => add_mem hx hy) fun x hx => neg_mem hx⟩\n#align mem_closure_iff mem_closure_iff\n-/\n\n",
 "mem_closure":
 "theorem mem_closure {x : R} {s : Set R} : x ∈ closure s ↔ ∀ S : Subring R, s ⊆ S → x ∈ S :=\n  mem_infₛ\n#align mem_closure mem_closure\n\n",
 "mem_center_iff":
 "theorem mem_center_iff {z : R} : z ∈ center R ↔ ∀ g, g * z = z * g :=\n  iff.rfl\n#align mem_center_iff mem_center_iff\n\n",
 "mem_carrier":
 "@[simp]\ntheorem mem_carrier {s : Subring R} {x : R} : x ∈ s.carrier ↔ x ∈ s :=\n  iff.rfl\n#align mem_carrier mem_carrier\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_bot {x : R} : x ∈ («expr⊥» : Subring R) ↔ ∃ n : ℤ, ↑n = x :=\n  RingHom.mem_range\n#align mem_bot mem_bot\n\n",
 "mem_Sup_of_directed_on":
 "theorem mem_Sup_of_directed_on {S : Set (Subring R)} (Sne : S.nonempty) (hS : DirectedOn (· ≤ ·) S) {x : R} :\n    x ∈ supₛ S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : Nonempty S := Sne.to_subtype\n  simp only [supₛ_eq_supᵢ', mem_supr_of_directed hS.directed_coe, SetCoe.exists, Subtype.coe_mk]\n#align mem_Sup_of_directed_on mem_Sup_of_directed_on\n\n",
 "mem_Inf":
 "theorem mem_Inf {S : Set (Subring R)} {x : R} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_interᵢ₂\n#align mem_Inf mem_Inf\n\n",
 "map_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print map_supᵢ /-\ntheorem map_supᵢ {ι : Sort _} (f : «expr →+* » R S) (s : ι → Subring R) :\n    (supᵢ s).map f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((s i).map f) :=\n  (gc_map_comap f).l_supr\n#align map_supr map_supᵢ\n-/\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup (s t : Subring R) (f : «expr →+* » R S) : («expr ⊔ » s t).map f = «expr ⊔ » (s.map f) (t.map f) :=\n  (gc_map_comap f).l_sup\n#align map_sup map_sup\n\n",
 "map_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem map_range : f.range.map g = (g.comp f).range := by\n  simpa only [range_eq_map] using («expr⊤» : Subring R).map_map g f\n#align map_range map_range\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_map (g : «expr →+* » S T) (f : «expr →+* » R S) : (s.map f).map g = s.map (g.comp f) :=\n  SetLike.coe_injective <| Set.image_image _ _ _\n#align map_map map_map\n\n",
 "map_le_iff_le_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_le_iff_le_comap {f : «expr →+* » R S} {s : Subring R} {t : Subring S} : s.map f ≤ t ↔ s ≤ t.comap f :=\n  Set.image_subset_iff\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : s.map (RingHom.id R) = s :=\n  SetLike.coe_injective <| Set.image_id _\n#align map_id map_id\n\n",
 "map_equiv_eq_comap_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_equiv_eq_comap_symm (f : «expr ≃+* » R S) (K : Subring R) : K.map (f : «expr →+* » R S) = K.comap f.symm :=\n  SetLike.coe_injective (f.to_equiv.image_eq_preimage K)\n#align map_equiv_eq_comap_symm map_equiv_eq_comap_symm\n\n",
 "map_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image under a ring homomorphism of the subring generated by a set equals\nthe subring generated by the image of the set. -/\ntheorem map_closure (f : «expr →+* » R S) (s : Set R) : (closure s).map f = closure («expr '' » f s) :=\n  le_antisymm\n    (map_le_iff_le_comap.2 <| le_trans (closure_mono <| Set.subset_preimage_image _ _) (closure_preimage_le _ _))\n    (closure_le.2 <| Set.image_subset _ subset_closure)\n#align map_closure map_closure\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot (f : «expr →+* » R S) : («expr⊥» : Subring R).map f = «expr⊥» :=\n  (gc_map_comap f).l_bot\n#align map_bot map_bot\n\n",
 "list_sum_mem":
 "#print list_sum_mem /-\n/-- Sum of a list of elements in a subring is in the subring. -/\nprotected theorem list_sum_mem {l : List R} : (∀ x ∈ l, x ∈ s) → l.sum ∈ s :=\n  list_sum_mem\n#align list_sum_mem list_sum_mem\n-/\n\n",
 "list_prod_mem":
 "#print list_prod_mem /-\n/-- Product of a list of elements in a subring is in the subring. -/\nprotected theorem list_prod_mem {l : List R} : (∀ x ∈ l, x ∈ s) → l.prod ∈ s :=\n  list_prod_mem\n#align list_prod_mem list_prod_mem\n-/\n\n",
 "int_mul_mem":
 "#print AddSubgroup.int_mul_mem /-\ntheorem AddSubgroup.int_mul_mem {G : AddSubgroup R} (k : ℤ) {g : R} (h : g ∈ G) : (k : R) * g ∈ G :=\n  by\n  convert AddSubgroup.zsmul_mem G h k\n  simp\n#align add_subgroup.int_mul_mem AddSubgroup.int_mul_mem\n-/\n\n",
 "gc_map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem gc_map_comap (f : «expr →+* » R S) : GaloisConnection (map f) (comap f) := fun S T => map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "ext":
 "/-- Two subrings are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : Subring R} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "exists_list_of_mem_closure":
 "theorem exists_list_of_mem_closure {s : Set R} {x : R} (h : x ∈ closure s) :\n    ∃ L : List (List R), (∀ t ∈ L, ∀ y ∈ t, y ∈ s ∨ y = (-1 : R)) ∧ (L.map List.prod).sum = x :=\n  AddSubgroup.closure_induction (mem_closure_iff.1 h)\n    (fun x hx =>\n      let ⟨l, hl, h⟩ := Submonoid.exists_list_of_mem_closure hx\n      ⟨[l], by simp [h] <;> clear_aux_decl <;> tauto⟩)\n    ⟨[], by simp⟩\n    (fun x y ⟨l, hl1, hl2⟩ ⟨m, hm1, hm2⟩ =>\n      ⟨l ++ m, fun t ht => (list.mem_append.1 ht).elim (hl1 t) (hm1 t), by simp [hl2, hm2]⟩)\n    fun x ⟨L, hL⟩ =>\n    ⟨L.map (List.cons (-1)), List.forall_mem_map_iff.2 fun j hj => List.forall_mem_cons.2 ⟨or.inr rfl, hL.1 j hj⟩,\n      hL.2 ▸ list.rec_on L (by simp) (by simp (config := { contextual := true }) [list.map_cons, add_comm])⟩\n#align exists_list_of_mem_closure exists_list_of_mem_closure\n\n",
 "eq_top_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_top_iff' (A : Subring R) : A = «expr⊤» ↔ ∀ x : R, x ∈ A :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n#align eq_top_iff' eq_top_iff'\n\n",
 "eq_on_set_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem eq_on_set_closure {f g : «expr →+* » R S} {s : Set R} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eq_locus g from closure_le.2 h\n#align eq_on_set_closure eq_on_set_closure\n\n",
 "eq_of_eq_on_set_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_of_eq_on_set_top {f g : «expr →+* » R S} (h : Set.EqOn f g («expr⊤» : Subring R)) : f = g :=\n  ext fun x => h trivial\n#align eq_of_eq_on_set_top eq_of_eq_on_set_top\n\n",
 "eq_of_eq_on_set_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eq_of_eq_on_set_dense {s : Set R} (hs : closure s = «expr⊤») {f g : «expr →+* » R S} (h : s.eq_on f g) :\n    f = g :=\n  eq_of_eqOn_set_top <| hs ▸ eqOn_set_closure h\n#align eq_of_eq_on_set_dense eq_of_eq_on_set_dense\n\n",
 "eq_locus_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem eq_locus_same (f : «expr →+* » R S) : f.eq_locus f = «expr⊤» :=\n  SetLike.ext fun _ => eq_self_iff_true _\n#align eq_locus_same eq_locus_same\n\n",
 "copy_eq":
 "theorem copy_eq (S : Subring R) (s : Set R) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n#align copy_eq copy_eq\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top (f : «expr →+* » R S) : («expr⊤» : Subring S).comap f = «expr⊤» :=\n  (gc_map_comap f).u_top\n#align comap_top comap_top\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_infi {ι : Sort _} (f : «expr →+* » R S) (s : ι → Subring S) :\n    (infᵢ s).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((s i).comap f) :=\n  (gc_map_comap f).u_infi\n#align comap_infi comap_infi\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_inf (s t : Subring S) (f : «expr →+* » R S) :\n    («expr ⊓ » s t).comap f = «expr ⊓ » (s.comap f) (t.comap f) :=\n  (gc_map_comap f).u_inf\n#align comap_inf comap_inf\n\n",
 "comap_equiv_eq_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_equiv_eq_map_symm (f : «expr ≃+* » R S) (K : Subring S) : K.comap (f : «expr →+* » R S) = K.map f.symm :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n#align comap_equiv_eq_map_symm comap_equiv_eq_map_symm\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_comap (s : Subring T) (g : «expr →+* » S T) (f : «expr →+* » R S) :\n    (s.comap g).comap f = s.comap (g.comp f) :=\n  rfl\n#align comap_comap comap_comap\n\n",
 "coe_zero":
 "@[simp, norm_cast]\ntheorem coe_zero : ((0 : s) : R) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : ((«expr⊤» : Subring R) : Set R) = Set.univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_submonoid":
 "@[simp]\ntheorem coe_to_submonoid (s : Subring R) : (s.to_submonoid : Set R) = s :=\n  rfl\n#align coe_to_submonoid coe_to_submonoid\n\n",
 "coe_to_add_subgroup":
 "@[simp]\ntheorem coe_to_add_subgroup (s : Subring R) : (s.to_add_subgroup : Set R) = s :=\n  rfl\n#align coe_to_add_subgroup coe_to_add_subgroup\n\n",
 "coe_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem coe_supr_of_directed {ι} [hι : Nonempty ι] {S : ι → Subring R} (hS : Directed (· ≤ ·) S) :\n    ((«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) :\n          Subring R) :\n        Set R) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑(S i) :=\n  Set.ext fun x => by simp [mem_supr_of_directed hS]\n#align coe_supr_of_directed coe_supr_of_directed\n\n",
 "coe_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_subtype : «expr⇑ » s.subtype = coe :=\n  rfl\n#align coe_subtype coe_subtype\n\n",
 "coe_set_mk":
 "@[simp]\ntheorem coe_set_mk (S : Set R) (h₁ h₂ h₃ h₄ h₅) : ((⟨S, h₁, h₂, h₃, h₄, h₅⟩ : Subring R) : Set R) = S :=\n  rfl\n#align coe_set_mk coe_set_mk\n\n",
 "coe_range_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem coe_range_restrict (f : «expr →+* » R S) (x : R) : (f.range_restrict x : S) = f x :=\n  rfl\n#align coe_range_restrict coe_range_restrict\n\n",
 "coe_range":
 "@[simp]\ntheorem coe_range : (f.range : Set S) = Set.range f :=\n  rfl\n#align coe_range coe_range\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[norm_cast]\ntheorem coe_prod (s : Subring R) (t : Subring S) : (s.prod t : Set (R × S)) = finset.product s t :=\n  rfl\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "@[simp, norm_cast]\ntheorem coe_pow (x : s) (n : ℕ) : (↑(x ^ n) : R) = x ^ n :=\n  SubmonoidClass.coe_pow x n\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "@[simp, norm_cast]\ntheorem coe_one : ((1 : s) : R) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_neg":
 "@[simp, norm_cast]\ntheorem coe_neg (x : s) : (↑(-x) : R) = -↑x :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_nat_cast":
 "@[simp, norm_cast]\ntheorem coe_nat_cast : ∀ n : ℕ, ((n : s) : R) = n :=\n  map_natCast s.subtype\n#align coe_nat_cast coe_nat_cast\n\n",
 "coe_mul":
 "@[simp, norm_cast]\ntheorem coe_mul (x y : s) : (↑(x * y) : R) = ↑x * ↑y :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_mk'":
 "@[simp]\ntheorem coe_mk' {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubgroup R} (ha : ↑sa = s) :\n    (Subring.mk' s sm sa hm ha : Set R) = s :=\n  rfl\n#align coe_mk' coe_mk'\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem coe_map (f : «expr →+* » R S) (s : Subring R) : (s.map f : Set S) = «expr '' » f s :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_inv":
 "@[simp]\ntheorem center.coe_inv (a : center K) : ((a⁻¹ : center K) : K) = (a : K)⁻¹ :=\n  rfl\n#align center.coe_inv center.coe_inv\n\n",
 "coe_int_mem":
 "#print coe_int_mem /-\n/-\nCopyright (c) 2020 Ashvni Narayanan. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ashvni Narayanan\n-/\n-- See note [lower instance priority]\ntheorem coe_int_mem (n : ℤ) : (n : R) ∈ s := by simp only [← zsmul_one, zsmul_mem, one_mem]\n#align coe_int_mem coe_int_mem\n-/\n\n",
 "coe_int_cast":
 "@[simp, norm_cast]\ntheorem coe_int_cast : ∀ n : ℤ, ((n : s) : R) = n :=\n  map_intCast s.subtype\n#align coe_int_cast coe_int_cast\n\n",
 "coe_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_infi {ι : Sort _} {S : ι → Subring R} :\n    (↑(«expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i)) : Set R) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (S i) :=\n  by simp only [infᵢ, coe_Inf, Set.binterᵢ_range]\n#align coe_infi coe_infi\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem coe_inf (p p' : Subring R) : ((«expr ⊓ » p p' : Subring R) : Set R) = p ∩ p' :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_equiv_map_of_injective_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem coe_equiv_map_of_injective_apply (f : «expr →+* » R S) (hf : function.injective f) (x : s) :\n    (equivMapOfInjective s f hf x : S) = f x :=\n  rfl\n#align coe_equiv_map_of_injective_apply coe_equiv_map_of_injective_apply\n\n",
 "coe_eq_zero_iff":
 "-- TODO: can be generalized to `add_submonoid_class`\n@[simp]\ntheorem coe_eq_zero_iff {x : s} : (x : R) = 0 ↔ x = 0 :=\n  ⟨fun h => Subtype.ext (trans h s.coe_zero.symm), fun h => h.symm ▸ s.coe_zero⟩\n#align coe_eq_zero_iff coe_eq_zero_iff\n\n",
 "coe_div":
 "@[simp]\ntheorem center.coe_div (a b : center K) : ((a / b : center K) : K) = (a : K) / (b : K) :=\n  rfl\n#align center.coe_div center.coe_div\n\n",
 "coe_copy":
 "@[simp]\ntheorem coe_copy (S : Subring R) (s : Set R) (hs : s = ↑S) : (S.copy s hs : Set R) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem coe_comap (s : Subring S) (f : «expr →+* » R S) : (s.comap f : Set R) = «expr ⁻¹' » f s :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "coe_center":
 "theorem coe_center : ↑(center R) = Set.center R :=\n  rfl\n#align coe_center coe_center\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem coe_bot : ((«expr⊥» : Subring R) : Set R) = Set.range (coe : ℤ → R) :=\n  RingHom.coe_range (Int.castRingHom R)\n#align coe_bot coe_bot\n\n",
 "coe_add":
 "@[simp, norm_cast]\ntheorem coe_add (x y : s) : (↑(x + y) : R) = ↑x + ↑y :=\n  rfl\n#align coe_add coe_add\n\n",
 "coe_Sup_of_directed_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem coe_Sup_of_directed_on {S : Set (Subring R)} (Sne : S.nonempty) (hS : DirectedOn (· ≤ ·) S) :\n    (↑(supₛ S) : Set R) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑s :=\n  Set.ext fun x => by simp [mem_Sup_of_directed_on Sne hS]\n#align coe_Sup_of_directed_on coe_Sup_of_directed_on\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_Inf (S : Set (Subring R)) :\n    ((infₛ S : Subring R) : Set R) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s :=\n  rfl\n#align coe_Inf coe_Inf\n\n",
 "closure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print closure_univ /-\n@[simp]\ntheorem closure_univ : closure (Set.univ : Set R) = «expr⊤» :=\n  @coe_top R _ ▸ closure_eq («expr⊤»)\n#align closure_univ closure_univ\n-/\n\n",
 "closure_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print closure_unionᵢ /-\ntheorem closure_unionᵢ {ι} (s : ι → Set R) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure (s i)) :=\n  (Subring.gi R).gc.l_supr\n#align closure_Union closure_unionᵢ\n-/\n\n",
 "closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print closure_union /-\ntheorem closure_union (s t : Set R) : closure (s ∪ t) = «expr ⊔ » (closure s) (closure t) :=\n  (Subring.gi R).gc.l_sup\n#align closure_union closure_union\n-/\n\n",
 "closure_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem closure_sUnion (s : Set (Set R)) :\n    closure (⋃₀ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure t) :=\n  (Subring.gi R).gc.l_Sup\n#align closure_sUnion closure_sUnion\n\n",
 "closure_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem closure_preimage_le (f : «expr →+* » R S) (s : Set S) : closure («expr ⁻¹' » f s) ≤ (closure s).comap f :=\n  closure_le.2 fun x hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n#align closure_preimage_le closure_preimage_le\n\n",
 "closure_mono":
 "#print closure_mono /-\n/-- Subring closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\ntheorem closure_mono ⦃s t : Set R⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Set.Subset.trans h subset_closure\n#align closure_mono closure_mono\n-/\n\n",
 "closure_le":
 "/-- A subring `t` includes `closure s` if and only if it includes `s`. -/\n@[simp]\ntheorem closure_le {s : Set R} {t : Subring R} : closure s ≤ t ↔ s ⊆ t :=\n  ⟨Set.Subset.trans subset_closure, fun h => infₛ_le h⟩\n#align closure_le closure_le\n\n",
 "closure_induction₂":
 "/-- An induction principle for closure membership, for predicates with two arguments. -/\n@[elab_as_elim]\ntheorem closure_induction₂ {s : Set R} {p : R → R → Prop} {a b : R} (ha : a ∈ closure s) (hb : b ∈ closure s)\n    (Hs : ∀ x ∈ s, ∀ y ∈ s, p x y) (H0_left : ∀ x, p 0 x) (H0_right : ∀ x, p x 0) (H1_left : ∀ x, p 1 x)\n    (H1_right : ∀ x, p x 1) (Hneg_left : ∀ x y, p x y → p (-x) y) (Hneg_right : ∀ x y, p x y → p x (-y))\n    (Hadd_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ + x₂) y) (Hadd_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ + y₂))\n    (Hmul_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ * x₂) y) (Hmul_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ * y₂)) :\n    p a b :=\n  by\n  refine' closure_induction hb _ (H0_right _) (H1_right _) (Hadd_right a) (Hneg_right a) (Hmul_right a)\n  refine' closure_induction ha Hs (fun x _ => H0_left x) (fun x _ => H1_left x) _ _ _\n  · exact fun x y H₁ H₂ z zs => Hadd_left x y z (H₁ z zs) (H₂ z zs)\n  · exact fun x hx z zs => Hneg_left x z (hx z zs)\n  · exact fun x y H₁ H₂ z zs => Hmul_left x y z (H₁ z zs) (H₂ z zs)\n#align closure_induction₂ closure_induction₂\n\n",
 "closure_induction":
 "/-- An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements\nof `s`, and is preserved under addition, negation, and multiplication, then `p` holds for all\nelements of the closure of `s`. -/\n@[elab_as_elim]\ntheorem closure_induction {s : Set R} {p : R → Prop} {x} (h : x ∈ closure s) (Hs : ∀ x ∈ s, p x) (H0 : p 0) (H1 : p 1)\n    (Hadd : ∀ x y, p x → p y → p (x + y)) (Hneg : ∀ x : R, p x → p (-x)) (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=\n  (@closure_le _ _ _ ⟨p, Hmul, H1, Hadd, H0, Hneg⟩).2 Hs h\n#align closure_induction closure_induction\n\n",
 "closure_eq_of_le":
 "theorem closure_eq_of_le {s : Set R} {t : Subring R} (h₁ : s ⊆ t) (h₂ : t ≤ closure s) : closure s = t :=\n  le_antisymm (closure_le.2 h₁) h₂\n#align closure_eq_of_le closure_eq_of_le\n\n",
 "closure_eq":
 "/-- Closure of a subring `S` equals `S`. -/\ntheorem closure_eq (s : Subring R) : closure (s : Set R) = s :=\n  (Subring.gi R).l_u_eq s\n#align closure_eq closure_eq\n\n",
 "closure_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print closure_empty /-\n@[simp]\ntheorem closure_empty : closure (∅ : Set R) = «expr⊥» :=\n  (Subring.gi R).gc.l_bot\n#align closure_empty closure_empty\n-/\n\n",
 "center_to_subsemiring":
 "@[simp]\ntheorem center_to_subsemiring : (center R).to_subsemiring = Subsemiring.center R :=\n  rfl\n#align center_to_subsemiring center_to_subsemiring\n\n",
 "center_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem center_eq_top (R) [CommRing R] : center R = «expr⊤» :=\n  SetLike.coe_injective (Set.center_eq_univ R)\n#align center_eq_top center_eq_top\n\n",
 "add_mem":
 "/-- A subring is closed under addition. -/\nprotected theorem add_mem {x y : R} : x ∈ s → y ∈ s → x + y ∈ s :=\n  add_mem\n#align add_mem add_mem\n\n",
 "Inf_to_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem Inf_to_submonoid (s : Set (Subring R)) :\n    (infₛ s).to_submonoid =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ([anonymous] t) :=\n  mk'_toSubmonoid _ _\n#align Inf_to_submonoid Inf_to_submonoid\n\n",
 "Inf_to_add_subgroup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem Inf_to_add_subgroup (s : Set (Subring R)) :\n    (infₛ s).to_add_subgroup =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (subring.to_add_subgroup t) :=\n  mk'_toAddSubgroup _ _\n#align Inf_to_add_subgroup Inf_to_add_subgroup\n\n"}