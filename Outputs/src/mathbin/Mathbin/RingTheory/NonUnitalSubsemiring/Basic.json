{"top_prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_prod_top : («expr⊤» : NonUnitalSubsemiring R).prod («expr⊤» : NonUnitalSubsemiring S) = «expr⊤» :=\n  (top_prod _).trans <| comap_top _\n#align top_prod_top top_prod_top\n\n",
 "top_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem top_prod (s : NonUnitalSubsemiring S) :\n    («expr⊤» : NonUnitalSubsemiring R).prod s = s.comap (NonUnitalRingHom.snd R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n#align top_prod top_prod\n\n",
 "to_subsemigroup_strict_mono":
 "@[mono]\ntheorem to_subsemigroup_strict_mono : StrictMono (to_subsemigroup : NonUnitalSubsemiring R → Subsemigroup R) :=\n  fun _ _ => id\n#align to_subsemigroup_strict_mono to_subsemigroup_strict_mono\n\n",
 "to_subsemigroup_mono":
 "@[mono]\ntheorem to_subsemigroup_mono : Monotone (to_subsemigroup : NonUnitalSubsemiring R → Subsemigroup R) :=\n  toSubsemigroup_strictMono.monotone\n#align to_subsemigroup_mono to_subsemigroup_mono\n\n",
 "to_subsemigroup_injective":
 "theorem to_subsemigroup_injective : function.injective (to_subsemigroup : NonUnitalSubsemiring R → Subsemigroup R)\n  | r, s, h => ext (SetLike.ext_iff.mp h : _)\n#align to_subsemigroup_injective to_subsemigroup_injective\n\n",
 "to_add_submonoid_strict_mono":
 "@[mono]\ntheorem to_add_submonoid_strict_mono : StrictMono (to_add_submonoid : NonUnitalSubsemiring R → AddSubmonoid R) :=\n  fun _ _ => id\n#align to_add_submonoid_strict_mono to_add_submonoid_strict_mono\n\n",
 "to_add_submonoid_mono":
 "@[mono]\ntheorem to_add_submonoid_mono : Monotone (to_add_submonoid : NonUnitalSubsemiring R → AddSubmonoid R) :=\n  toAddSubmonoid_strictMono.monotone\n#align to_add_submonoid_mono to_add_submonoid_mono\n\n",
 "to_add_submonoid_injective":
 "theorem to_add_submonoid_injective : function.injective (to_add_submonoid : NonUnitalSubsemiring R → AddSubmonoid R)\n  | r, s, h => ext (SetLike.ext_iff.mp h : _)\n#align to_add_submonoid_injective to_add_submonoid_injective\n\n",
 "subset_closure":
 "#print subset_closure /-\n/-- The non-unital subsemiring generated by a set includes the set. -/\n@[simp]\ntheorem subset_closure {s : Set R} : s ⊆ closure s := fun x hx => mem_closure.2 fun S hS => hS hx\n#align subset_closure subset_closure\n-/\n\n",
 "srange_top_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The range of a surjective non-unital ring homomorphism is the whole of the codomain. -/\ntheorem srange_top_of_surjective (f : F) (hf : function.surjective (f : R → S)) :\n    srange f = («expr⊤» : NonUnitalSubsemiring S) :=\n  srange_top_iff_surjective.2 hf\n#align srange_top_of_surjective srange_top_of_surjective\n\n",
 "srange_top_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem srange_top_iff_surjective {f : F} :\n    srange f = («expr⊤» : NonUnitalSubsemiring S) ↔ function.surjective (f : R → S) :=\n  SetLike.ext'_iff.trans <| iff.trans (by rw [coe_srange, coe_top]) Set.range_iff_surjective\n#align srange_top_iff_surjective srange_top_iff_surjective\n\n",
 "srange_subtype":
 "@[simp]\ntheorem srange_subtype (s : NonUnitalSubsemiring R) : (Subtype s).srange = s :=\n  SetLike.coe_injective <| (coe_srange _).trans Subtype.range_coe\n#align srange_subtype srange_subtype\n\n",
 "srange_restrict_surjective":
 "theorem srange_restrict_surjective (f : F) :\n    function.surjective (srangeRestrict f : R → (srange f : NonUnitalSubsemiring S)) := fun ⟨y, hy⟩ =>\n  let ⟨x, hx⟩ := mem_srange.mp hy\n  ⟨x, Subtype.ext hx⟩\n#align srange_restrict_surjective srange_restrict_surjective\n\n",
 "srange_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem srange_eq_map : @srange R S _ _ _ _ f = («expr⊤» : NonUnitalSubsemiring R).map f :=\n  by\n  ext\n  simp\n#align srange_eq_map srange_eq_map\n\n",
 "sof_left_inverse'_symm_apply":
 "@[simp]\ntheorem sof_left_inverse'_symm_apply {g : S → R} {f : F} (h : function.left_inverse g f) (x : srange f) :\n    (sofLeftInverse' h).symm x = g x :=\n  rfl\n#align sof_left_inverse'_symm_apply sof_left_inverse'_symm_apply\n\n",
 "sof_left_inverse'_apply":
 "@[simp]\ntheorem sof_left_inverse'_apply {g : S → R} {f : F} (h : function.left_inverse g f) (x : R) :\n    ↑(sofLeftInverse' h x) = f x :=\n  rfl\n#align sof_left_inverse'_apply sof_left_inverse'_apply\n\n",
 "sclosure_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem sclosure_preimage_le (f : F) (s : Set S) : closure («expr ⁻¹' » (f : R → S) s) ≤ (closure s).comap f :=\n  closure_le.2 fun x hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n#align sclosure_preimage_le sclosure_preimage_le\n\n",
 "range_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_snd : (snd R S).srange = «expr⊤» :=\n  NonUnitalRingHom.srange_top_of_surjective (snd R S) <| Prod.snd_surjective\n#align range_snd range_snd\n\n",
 "range_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_fst : (fst R S).srange = «expr⊤» :=\n  NonUnitalRingHom.srange_top_of_surjective (fst R S) Prod.fst_surjective\n#align range_fst range_fst\n\n",
 "prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem prod_top (s : NonUnitalSubsemiring R) :\n    s.prod («expr⊤» : NonUnitalSubsemiring S) = s.comap (NonUnitalRingHom.fst R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n#align prod_top prod_top\n\n",
 "prod_mono_right":
 "theorem prod_mono_right (s : NonUnitalSubsemiring R) : Monotone fun t : NonUnitalSubsemiring S => s.prod t :=\n  prod_mono (le_refl s)\n#align prod_mono_right prod_mono_right\n\n",
 "prod_mono_left":
 "theorem prod_mono_left (t : NonUnitalSubsemiring S) : Monotone fun s : NonUnitalSubsemiring R => s.prod t :=\n  fun s₁ s₂ hs => prod_mono hs (le_refl t)\n#align prod_mono_left prod_mono_left\n\n",
 "prod_mono":
 "@[mono]\ntheorem prod_mono ⦃s₁ s₂ : NonUnitalSubsemiring R⦄ (hs : s₁ ≤ s₂) ⦃t₁ t₂ : NonUnitalSubsemiring S⦄ (ht : t₁ ≤ t₂) :\n    s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n#align prod_mono prod_mono\n\n",
 "not_mem_of_not_mem_closure":
 "#print not_mem_of_not_mem_closure /-\ntheorem not_mem_of_not_mem_closure {s : Set R} {P : R} (hP : P ∉ closure s) : P ∉ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n-/\n\n",
 "non_unital_subsemiring_closure_to_add_submonoid":
 "theorem non_unital_subsemiring_closure_to_add_submonoid :\n    M.non_unital_subsemiring_closure.to_add_submonoid = AddSubmonoid.closure (M : Set R) :=\n  rfl\n#align non_unital_subsemiring_closure_to_add_submonoid non_unital_subsemiring_closure_to_add_submonoid\n\n",
 "non_unital_subsemiring_closure_eq_closure":
 "/-- The `non_unital_subsemiring` generated by a multiplicative subsemigroup coincides with the\n`non_unital_subsemiring.closure` of the subsemigroup itself . -/\ntheorem non_unital_subsemiring_closure_eq_closure :\n    M.non_unital_subsemiring_closure = NonUnitalSubsemiring.closure (M : Set R) :=\n  by\n  ext\n  refine'\n        ⟨fun hx => _, fun hx =>\n          (non_unital_subsemiring.mem_closure.mp hx) M.non_unital_subsemiring_closure fun s sM => _⟩ <;>\n      rintro - ⟨H1, rfl⟩ <;>\n    rintro - ⟨H2, rfl⟩\n  · exact add_submonoid.mem_closure.mp hx H1.to_add_submonoid H2\n  · exact H2 sM\n#align non_unital_subsemiring_closure_eq_closure non_unital_subsemiring_closure_eq_closure\n\n",
 "non_unital_subsemiring_closure_coe":
 "theorem non_unital_subsemiring_closure_coe :\n    (M.non_unital_subsemiring_closure : Set R) = AddSubmonoid.closure (M : Set R) :=\n  rfl\n#align non_unital_subsemiring_closure_coe non_unital_subsemiring_closure_coe\n\n",
 "mk'_to_subsemigroup":
 "@[simp]\ntheorem mk'_to_subsemigroup {s : Set R} {sg : Subsemigroup R} (hg : ↑sg = s) {sa : AddSubmonoid R} (ha : ↑sa = s) :\n    (NonUnitalSubsemiring.mk' s sg hg sa ha).to_subsemigroup = sg :=\n  SetLike.coe_injective hg.symm\n#align mk'_to_subsemigroup mk'_to_subsemigroup\n\n",
 "mk'_to_add_submonoid":
 "@[simp]\ntheorem mk'_to_add_submonoid {s : Set R} {sg : Subsemigroup R} (hg : ↑sg = s) {sa : AddSubmonoid R} (ha : ↑sa = s) :\n    (NonUnitalSubsemiring.mk' s sg hg sa ha).to_add_submonoid = sa :=\n  SetLike.coe_injective ha.symm\n#align mk'_to_add_submonoid mk'_to_add_submonoid\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top (x : R) : x ∈ («expr⊤» : NonUnitalSubsemiring R) :=\n  Set.mem_univ x\n#align mem_top mem_top\n\n",
 "mem_to_subsemigroup":
 "@[simp]\ntheorem mem_to_subsemigroup {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.to_subsemigroup ↔ x ∈ s :=\n  iff.rfl\n#align mem_to_subsemigroup mem_to_subsemigroup\n\n",
 "mem_to_add_submonoid":
 "@[simp]\ntheorem mem_to_add_submonoid {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.to_add_submonoid ↔ x ∈ s :=\n  iff.rfl\n#align mem_to_add_submonoid mem_to_add_submonoid\n\n",
 "mem_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem mem_supr_of_directed {ι} [hι : Nonempty ι] {S : ι → NonUnitalSubsemiring R} (hS : Directed (· ≤ ·) S) {x : R} :\n    x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) ↔\n      ∃ i, x ∈ S i :=\n  by\n  refine' ⟨_, fun ⟨i, hi⟩ => (SetLike.le_def.1 <| le_supᵢ S i) hi⟩\n  let U : NonUnitalSubsemiring R :=\n    NonUnitalSubsemiring.mk'\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i : Set R))\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (S i).to_subsemigroup)\n      (Subsemigroup.coe_supᵢ_of_directed <| hS.mono_comp _ fun _ _ => id)\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (S i).to_add_submonoid)\n      (AddSubmonoid.coe_supᵢ_of_directed <| hS.mono_comp _ fun _ _ => id)\n  suffices «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) ≤ U by\n    simpa using @this x\n  exact supᵢ_le fun i x hx => Set.mem_unionᵢ.2 ⟨i, hx⟩\n#align mem_supr_of_directed mem_supr_of_directed\n\n",
 "mem_srange_self":
 "theorem mem_srange_self (f : F) (x : R) : f x ∈ @srange R S _ _ _ _ f :=\n  mem_srange.mpr ⟨x, rfl⟩\n#align mem_srange_self mem_srange_self\n\n",
 "mem_srange":
 "@[simp]\ntheorem mem_srange {f : F} {y : S} : y ∈ @srange R S _ _ _ _ f ↔ ∃ x, f x = y :=\n  iff.rfl\n#align mem_srange mem_srange\n\n",
 "mem_prod":
 "theorem mem_prod {s : NonUnitalSubsemiring R} {t : NonUnitalSubsemiring S} {p : R × S} :\n    p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  iff.rfl\n#align mem_prod mem_prod\n\n",
 "mem_mk'":
 "@[simp]\ntheorem mem_mk' {s : Set R} {sg : Subsemigroup R} (hg : ↑sg = s) {sa : AddSubmonoid R} (ha : ↑sa = s) {x : R} :\n    x ∈ NonUnitalSubsemiring.mk' s sg hg sa ha ↔ x ∈ s :=\n  iff.rfl\n#align mem_mk' mem_mk'\n\n",
 "mem_map_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\ntheorem mem_map_equiv {f : «expr ≃+* » R S} {K : NonUnitalSubsemiring R} {x : S} :\n    x ∈ K.map (f : «expr →ₙ+* » R S) ↔ f.symm x ∈ K :=\n  @Set.mem_image_equiv _ _ (↑K) f.to_equiv x\n#align mem_map_equiv mem_map_equiv\n\n",
 "mem_map":
 "@[simp]\ntheorem mem_map {f : F} {s : NonUnitalSubsemiring R} {y : S} : y ∈ s.map f ↔ ∃ x ∈ s, f x = y :=\n  Set.mem_image_iff_bex\n#align mem_map mem_map\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem mem_inf {p p' : NonUnitalSubsemiring R} {x : R} : x ∈ «expr ⊓ » p p' ↔ x ∈ p ∧ x ∈ p' :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_comap":
 "@[simp]\ntheorem mem_comap {s : NonUnitalSubsemiring S} {f : F} {x : R} : x ∈ s.comap f ↔ f x ∈ s :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_closure_iff":
 "#print mem_closure_iff /-\ntheorem mem_closure_iff {s : Set R} {x} : x ∈ closure s ↔ x ∈ AddSubmonoid.closure (Subsemigroup.closure s : Set R) :=\n  Set.ext_iff.mp (coe_closure_eq s) x\n#align mem_closure_iff mem_closure_iff\n-/\n\n",
 "mem_closure":
 "theorem mem_closure {x : R} {s : Set R} : x ∈ closure s ↔ ∀ S : NonUnitalSubsemiring R, s ⊆ S → x ∈ S :=\n  mem_infₛ\n#align mem_closure mem_closure\n\n",
 "mem_centralizer_iff":
 "theorem mem_centralizer_iff {R} [NonUnitalSemiring R] {s : Set R} {z : R} :\n    z ∈ centralizer s ↔ ∀ g ∈ s, g * z = z * g :=\n  iff.rfl\n#align mem_centralizer_iff mem_centralizer_iff\n\n",
 "mem_center_iff":
 "theorem mem_center_iff {R} [NonUnitalSemiring R] {z : R} : z ∈ center R ↔ ∀ g, g * z = z * g :=\n  iff.rfl\n#align mem_center_iff mem_center_iff\n\n",
 "mem_carrier":
 "@[simp]\ntheorem mem_carrier {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.carrier ↔ x ∈ s :=\n  iff.rfl\n#align mem_carrier mem_carrier\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_bot {x : R} : x ∈ («expr⊥» : NonUnitalSubsemiring R) ↔ x = 0 :=\n  Set.mem_singleton_iff\n#align mem_bot mem_bot\n\n",
 "mem_Sup_of_directed_on":
 "theorem mem_Sup_of_directed_on {S : Set (NonUnitalSubsemiring R)} (Sne : S.nonempty) (hS : DirectedOn (· ≤ ·) S)\n    {x : R} : x ∈ supₛ S ↔ ∃ s ∈ S, x ∈ s :=\n  by\n  haveI : Nonempty S := Sne.to_subtype\n  simp only [supₛ_eq_supᵢ', mem_supr_of_directed hS.directed_coe, SetCoe.exists, Subtype.coe_mk]\n#align mem_Sup_of_directed_on mem_Sup_of_directed_on\n\n",
 "mem_Inf":
 "theorem mem_Inf {S : Set (NonUnitalSubsemiring R)} {x : R} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_interᵢ₂\n#align mem_Inf mem_Inf\n\n",
 "map_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print map_supᵢ /-\ntheorem map_supᵢ {ι : Sort _} (f : F) (s : ι → NonUnitalSubsemiring R) :\n    (map f (supᵢ s) : NonUnitalSubsemiring S) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (map f (s i)) :=\n  @GaloisConnection.l_supᵢ _ _ _ _ _ _ _ (gc_map_comap f) s\n#align map_supr map_supᵢ\n-/\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup (s t : NonUnitalSubsemiring R) (f : F) :\n    (map f («expr ⊔ » s t) : NonUnitalSubsemiring S) = «expr ⊔ » (map f s) (map f t) :=\n  @GaloisConnection.l_sup _ _ s t _ _ _ _ (gc_map_comap f)\n#align map_sup map_sup\n\n",
 "map_srange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\ntheorem map_srange (g : «expr →ₙ+* » S T) (f : «expr →ₙ+* » R S) : map g (srange f) = srange (g.comp f) := by\n  simpa only [srange_eq_map] using («expr⊤» : NonUnitalSubsemiring R).map_map g f\n#align map_srange map_srange\n\n",
 "map_sclosure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image under a ring homomorphism of the subsemiring generated by a set equals\nthe subsemiring generated by the image of the set. -/\ntheorem map_sclosure (f : F) (s : Set R) : (closure s).map f = closure («expr '' » (f : R → S) s) :=\n  le_antisymm\n    (map_le_iff_le_comap.2 <| le_trans (closure_mono <| Set.subset_preimage_image _ _) (sclosure_preimage_le _ _))\n    (closure_le.2 <| Set.image_subset _ subset_closure)\n#align map_sclosure map_sclosure\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\n-- unavoidable coercions?\ntheorem map_map (g : G) (f : F) :\n    (s.map (f : «expr →ₙ+* » R S)).map (g : «expr →ₙ+* » S T) =\n      s.map ((g : «expr →ₙ+* » S T).comp (f : «expr →ₙ+* » R S)) :=\n  SetLike.coe_injective <| Set.image_image _ _ _\n#align map_map map_map\n\n",
 "map_le_iff_le_comap":
 "theorem map_le_iff_le_comap {f : F} {s : NonUnitalSubsemiring R} {t : NonUnitalSubsemiring S} :\n    s.map f ≤ t ↔ s ≤ t.comap f :=\n  Set.image_subset_iff\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : s.map (NonUnitalRingHom.id R) = s :=\n  SetLike.coe_injective <| Set.image_id _\n#align map_id map_id\n\n",
 "map_equiv_eq_comap_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\ntheorem map_equiv_eq_comap_symm (f : «expr ≃+* » R S) (K : NonUnitalSubsemiring R) :\n    K.map (f : «expr →ₙ+* » R S) = K.comap f.symm :=\n  SetLike.coe_injective (f.to_equiv.image_eq_preimage K)\n#align map_equiv_eq_comap_symm map_equiv_eq_comap_symm\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot (f : F) : map f («expr⊥» : NonUnitalSubsemiring R) = («expr⊥» : NonUnitalSubsemiring S) :=\n  (gc_map_comap f).l_bot\n#align map_bot map_bot\n\n",
 "gc_map_comap":
 "theorem gc_map_comap (f : F) :\n    @GaloisConnection (NonUnitalSubsemiring R) (NonUnitalSubsemiring S) _ _ (map f) (comap f) := fun S T =>\n  map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "ext":
 "/-- Two non-unital subsemirings are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : NonUnitalSubsemiring R} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "eq_top_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_top_iff' (A : NonUnitalSubsemiring R) : A = «expr⊤» ↔ ∀ x : R, x ∈ A :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n#align eq_top_iff' eq_top_iff'\n\n",
 "eq_on_sclosure":
 "/-- If two non-unital ring homomorphisms are equal on a set, then they are equal on its\nnon-unital subsemiring closure. -/\ntheorem eq_on_sclosure {f g : F} {s : Set R} (h : Set.EqOn (f : R → S) (g : R → S) s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ eqSlocus f g from closure_le.2 h\n#align eq_on_sclosure eq_on_sclosure\n\n",
 "eq_of_eq_on_stop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_of_eq_on_stop {f g : F} (h : Set.EqOn (f : R → S) (g : R → S) («expr⊤» : NonUnitalSubsemiring R)) : f = g :=\n  FunLike.ext _ _ fun x => h trivial\n#align eq_of_eq_on_stop eq_of_eq_on_stop\n\n",
 "eq_of_eq_on_sdense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_of_eq_on_sdense {s : Set R} (hs : closure s = «expr⊤») {f g : F} (h : s.eq_on (f : R → S) (g : R → S)) :\n    f = g :=\n  eq_of_eqOn_stop <| hs ▸ eqOn_sclosure h\n#align eq_of_eq_on_sdense eq_of_eq_on_sdense\n\n",
 "copy_eq":
 "theorem copy_eq (S : NonUnitalSubsemiring R) (s : Set R) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n#align copy_eq copy_eq\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top (f : F) : comap f («expr⊤» : NonUnitalSubsemiring S) = («expr⊤» : NonUnitalSubsemiring R) :=\n  (gc_map_comap f).u_top\n#align comap_top comap_top\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_infi {ι : Sort _} (f : F) (s : ι → NonUnitalSubsemiring S) :\n    (comap f (infᵢ s) : NonUnitalSubsemiring R) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (comap f (s i)) :=\n  @GaloisConnection.u_infᵢ _ _ _ _ _ _ _ (gc_map_comap f) s\n#align comap_infi comap_infi\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_inf (s t : NonUnitalSubsemiring S) (f : F) :\n    (comap f («expr ⊓ » s t) : NonUnitalSubsemiring R) = «expr ⊓ » (comap f s) (comap f t) :=\n  @GaloisConnection.u_inf _ _ s t _ _ _ _ (gc_map_comap f)\n#align comap_inf comap_inf\n\n",
 "comap_equiv_eq_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\ntheorem comap_equiv_eq_map_symm (f : «expr ≃+* » R S) (K : NonUnitalSubsemiring S) :\n    K.comap (f : «expr →ₙ+* » R S) = K.map f.symm :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n#align comap_equiv_eq_map_symm comap_equiv_eq_map_symm\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ+* » -/\n-- this has some nasty coercions, how to deal with it?\ntheorem comap_comap (s : NonUnitalSubsemiring T) (g : G) (f : F) :\n    ((s.comap g : NonUnitalSubsemiring S).comap f : NonUnitalSubsemiring R) =\n      s.comap ((g : «expr →ₙ+* » S T).comp (f : «expr →ₙ+* » R S)) :=\n  rfl\n#align comap_comap comap_comap\n\n",
 "coe_zero":
 "@[simp, norm_cast]\ntheorem coe_zero : ((0 : s) : R) = (0 : R) :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : ((«expr⊤» : NonUnitalSubsemiring R) : Set R) = Set.univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_subsemigroup":
 "@[simp]\ntheorem coe_to_subsemigroup (s : NonUnitalSubsemiring R) : (s.to_subsemigroup : Set R) = s :=\n  rfl\n#align coe_to_subsemigroup coe_to_subsemigroup\n\n",
 "coe_to_add_submonoid":
 "@[simp]\ntheorem coe_to_add_submonoid (s : NonUnitalSubsemiring R) : (s.to_add_submonoid : Set R) = s :=\n  rfl\n#align coe_to_add_submonoid coe_to_add_submonoid\n\n",
 "coe_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem coe_supr_of_directed {ι} [hι : Nonempty ι] {S : ι → NonUnitalSubsemiring R} (hS : Directed (· ≤ ·) S) :\n    ((«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) :\n          NonUnitalSubsemiring R) :\n        Set R) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑(S i) :=\n  Set.ext fun x => by simp [mem_supr_of_directed hS]\n#align coe_supr_of_directed coe_supr_of_directed\n\n",
 "coe_subtype":
 "/-\nCopyright (c) 2022 Jireh Loreaux All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\n-- See note [lower instance priority]\n/- Prefer subclasses of `non_unital_non_assoc_semiring` over subclasses of\n`non_unital_subsemiring_class`. -/\n@[simp]\ntheorem coe_subtype : (subtype s : s → R) = coe :=\n  rfl\n#align coe_subtype coe_subtype\n\n",
 "coe_srange_restrict":
 "@[simp]\ntheorem coe_srange_restrict (f : F) (x : R) : (srangeRestrict f x : S) = f x :=\n  rfl\n#align coe_srange_restrict coe_srange_restrict\n\n",
 "coe_srange":
 "@[simp]\ntheorem coe_srange : (@srange R S _ _ _ _ f : Set S) = Set.range f :=\n  rfl\n#align coe_srange coe_srange\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[norm_cast]\ntheorem coe_prod (s : NonUnitalSubsemiring R) (t : NonUnitalSubsemiring S) :\n    (s.prod t : Set (R × S)) = finset.product (s : Set R) (t : Set S) :=\n  rfl\n#align coe_prod coe_prod\n\n",
 "coe_mul":
 "@[simp, norm_cast]\ntheorem coe_mul (x y : s) : ((x * y : s) : R) = (x * y : R) :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_mk'":
 "@[simp]\ntheorem coe_mk' {s : Set R} {sg : Subsemigroup R} (hg : ↑sg = s) {sa : AddSubmonoid R} (ha : ↑sa = s) :\n    (NonUnitalSubsemiring.mk' s sg hg sa ha : Set R) = s :=\n  rfl\n#align coe_mk' coe_mk'\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem coe_map (f : F) (s : NonUnitalSubsemiring R) : (s.map f : Set S) = «expr '' » f s :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem coe_inf (p p' : NonUnitalSubsemiring R) : ((«expr ⊓ » p p' : NonUnitalSubsemiring R) : Set R) = p ∩ p' :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_equiv_map_of_injective_apply":
 "@[simp]\ntheorem coe_equiv_map_of_injective_apply (f : F) (hf : function.injective f) (x : s) :\n    (equivMapOfInjective s f hf x : S) = f x :=\n  rfl\n#align coe_equiv_map_of_injective_apply coe_equiv_map_of_injective_apply\n\n",
 "coe_copy":
 "@[simp]\ntheorem coe_copy (S : NonUnitalSubsemiring R) (s : Set R) (hs : s = ↑S) : (S.copy s hs : Set R) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem coe_comap (s : NonUnitalSubsemiring S) (f : F) : (s.comap f : Set R) = «expr ⁻¹' » f s :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "coe_closure_eq":
 "/-- The elements of the non-unital subsemiring closure of `M` are exactly the elements of the\nadditive closure of a multiplicative subsemigroup `M`. -/\ntheorem coe_closure_eq (s : Set R) : (closure s : Set R) = AddSubmonoid.closure (Subsemigroup.closure s : Set R) := by\n  simp [← Subsemigroup.nonUnitalSubsemiringClosure_toAddSubmonoid, Subsemigroup.nonUnitalSubsemiringClosure_eq_closure]\n#align coe_closure_eq coe_closure_eq\n\n",
 "coe_centralizer":
 "@[simp, norm_cast]\ntheorem coe_centralizer {R} [NonUnitalSemiring R] (s : Set R) : (centralizer s : Set R) = s.centralizer :=\n  rfl\n#align coe_centralizer coe_centralizer\n\n",
 "coe_center":
 "theorem coe_center (R) [NonUnitalSemiring R] : ↑(center R) = Set.center R :=\n  rfl\n#align coe_center coe_center\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- should we define this as the range of the zero homomorphism?\ntheorem coe_bot : ((«expr⊥» : NonUnitalSubsemiring R) : Set R) = {0} :=\n  rfl\n#align coe_bot coe_bot\n\n",
 "coe_add":
 "@[simp, norm_cast]\ntheorem coe_add (x y : s) : ((x + y : s) : R) = (x + y : R) :=\n  rfl\n#align coe_add coe_add\n\n",
 "coe_Sup_of_directed_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem coe_Sup_of_directed_on {S : Set (NonUnitalSubsemiring R)} (Sne : S.nonempty) (hS : DirectedOn (· ≤ ·) S) :\n    (↑(supₛ S) : Set R) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑s :=\n  Set.ext fun x => by simp [mem_Sup_of_directed_on Sne hS]\n#align coe_Sup_of_directed_on coe_Sup_of_directed_on\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_Inf (S : Set (NonUnitalSubsemiring R)) :\n    ((infₛ S : NonUnitalSubsemiring R) : Set R) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s :=\n  rfl\n#align coe_Inf coe_Inf\n\n",
 "closure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print closure_univ /-\n@[simp]\ntheorem closure_univ : closure (Set.univ : Set R) = «expr⊤» :=\n  @coe_top R _ ▸ closure_eq («expr⊤»)\n#align closure_univ closure_univ\n-/\n\n",
 "closure_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print closure_unionᵢ /-\ntheorem closure_unionᵢ {ι} (s : ι → Set R) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure (s i)) :=\n  (NonUnitalSubsemiring.gi R).gc.l_supr\n#align closure_Union closure_unionᵢ\n-/\n\n",
 "closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print closure_union /-\ntheorem closure_union (s t : Set R) : closure (s ∪ t) = «expr ⊔ » (closure s) (closure t) :=\n  (NonUnitalSubsemiring.gi R).gc.l_sup\n#align closure_union closure_union\n-/\n\n",
 "closure_subsemigroup_closure":
 "@[simp]\ntheorem closure_subsemigroup_closure (s : Set R) : closure ↑(Subsemigroup.closure s) = closure s :=\n  le_antisymm (closure_le.mpr fun y hy => (Subsemigroup.mem_closure.mp hy) (closure s).to_subsemigroup subset_closure)\n    (closure_mono Subsemigroup.subset_closure)\n#align closure_subsemigroup_closure closure_subsemigroup_closure\n\n",
 "closure_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem closure_sUnion (s : Set (Set R)) :\n    closure (⋃₀ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure t) :=\n  (NonUnitalSubsemiring.gi R).gc.l_Sup\n#align closure_sUnion closure_sUnion\n\n",
 "closure_mono":
 "#print closure_mono /-\n/-- Subsemiring closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\ntheorem closure_mono ⦃s t : Set R⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Set.Subset.trans h subset_closure\n#align closure_mono closure_mono\n-/\n\n",
 "closure_le":
 "/-- A non-unital subsemiring `S` includes `closure s` if and only if it includes `s`. -/\n@[simp]\ntheorem closure_le {s : Set R} {t : NonUnitalSubsemiring R} : closure s ≤ t ↔ s ⊆ t :=\n  ⟨Set.Subset.trans subset_closure, fun h => infₛ_le h⟩\n#align closure_le closure_le\n\n",
 "closure_induction₂":
 "/-- An induction principle for closure membership for predicates with two arguments. -/\n@[elab_as_elim]\ntheorem closure_induction₂ {s : Set R} {p : R → R → Prop} {x} {y : R} (hx : x ∈ closure s) (hy : y ∈ closure s)\n    (Hs : ∀ x ∈ s, ∀ y ∈ s, p x y) (H0_left : ∀ x, p 0 x) (H0_right : ∀ x, p x 0)\n    (Hadd_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ + x₂) y) (Hadd_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ + y₂))\n    (Hmul_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ * x₂) y) (Hmul_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ * y₂)) :\n    p x y :=\n  closure_induction hx (fun x₁ x₁s => closure_induction hy (Hs x₁ x₁s) (H0_right x₁) (Hadd_right x₁) (Hmul_right x₁))\n    (H0_left y) (fun z z' => Hadd_left z z' y) fun z z' => Hmul_left z z' y\n#align closure_induction₂ closure_induction₂\n\n",
 "closure_induction":
 "/-- An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements\nof `s`, and is preserved under addition and multiplication, then `p` holds for all elements\nof the closure of `s`. -/\n@[elab_as_elim]\ntheorem closure_induction {s : Set R} {p : R → Prop} {x} (h : x ∈ closure s) (Hs : ∀ x ∈ s, p x) (H0 : p 0)\n    (Hadd : ∀ x y, p x → p y → p (x + y)) (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=\n  (@closure_le _ _ _ ⟨p, Hadd, H0, Hmul⟩).2 Hs h\n#align closure_induction closure_induction\n\n",
 "closure_eq_of_le":
 "theorem closure_eq_of_le {s : Set R} {t : NonUnitalSubsemiring R} (h₁ : s ⊆ t) (h₂ : t ≤ closure s) : closure s = t :=\n  le_antisymm (closure_le.2 h₁) h₂\n#align closure_eq_of_le closure_eq_of_le\n\n",
 "closure_eq":
 "/-- Closure of a non-unital subsemiring `S` equals `S`. -/\ntheorem closure_eq (s : NonUnitalSubsemiring R) : closure (s : Set R) = s :=\n  (NonUnitalSubsemiring.gi R).l_u_eq s\n#align closure_eq closure_eq\n\n",
 "closure_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print closure_empty /-\n@[simp]\ntheorem closure_empty : closure (∅ : Set R) = «expr⊥» :=\n  (NonUnitalSubsemiring.gi R).gc.l_bot\n#align closure_empty closure_empty\n-/\n\n",
 "closure_add_submonoid_closure":
 "@[simp]\ntheorem closure_add_submonoid_closure {s : Set R} : closure ↑(AddSubmonoid.closure s) = closure s :=\n  by\n  ext x\n  refine' ⟨fun hx => _, fun hx => closure_mono AddSubmonoid.subset_closure hx⟩\n  rintro - ⟨H, rfl⟩\n  rintro - ⟨J, rfl⟩\n  refine' (add_submonoid.mem_closure.mp (mem_closure_iff.mp hx)) H.to_add_submonoid fun y hy => _\n  refine' (subsemigroup.mem_closure.mp hy) H.to_subsemigroup fun z hz => _\n  exact (add_submonoid.mem_closure.mp hz) H.to_add_submonoid fun w hw => J hw\n#align closure_add_submonoid_closure closure_add_submonoid_closure\n\n",
 "centralizer_univ":
 "@[simp]\ntheorem centralizer_univ {R} [NonUnitalSemiring R] : centralizer Set.univ = center R :=\n  SetLike.ext' (Set.centralizer_univ R)\n#align centralizer_univ centralizer_univ\n\n",
 "centralizer_to_subsemigroup":
 "theorem centralizer_to_subsemigroup {R} [NonUnitalSemiring R] (s : Set R) :\n    (centralizer s).to_subsemigroup = Subsemigroup.centralizer s :=\n  rfl\n#align centralizer_to_subsemigroup centralizer_to_subsemigroup\n\n",
 "centralizer_le":
 "theorem centralizer_le {R} [NonUnitalSemiring R] (s t : Set R) (h : s ⊆ t) : centralizer t ≤ centralizer s :=\n  Set.centralizer_subset h\n#align centralizer_le centralizer_le\n\n",
 "center_to_subsemigroup":
 "@[simp]\ntheorem center_to_subsemigroup (R) [NonUnitalSemiring R] : (center R).to_subsemigroup = Subsemigroup.center R :=\n  rfl\n#align center_to_subsemigroup center_to_subsemigroup\n\n",
 "center_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem center_eq_top (R) [NonUnitalCommSemiring R] : center R = «expr⊤» :=\n  SetLike.coe_injective (Set.center_eq_univ R)\n#align center_eq_top center_eq_top\n\n",
 "Inf_to_subsemigroup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem Inf_to_subsemigroup (s : Set (NonUnitalSubsemiring R)) :\n    (infₛ s).to_subsemigroup =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (non_unital_subsemiring.to_subsemigroup t) :=\n  mk'_toSubsemigroup _ _\n#align Inf_to_subsemigroup Inf_to_subsemigroup\n\n",
 "Inf_to_add_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem Inf_to_add_submonoid (s : Set (NonUnitalSubsemiring R)) :\n    (infₛ s).to_add_submonoid =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (non_unital_subsemiring.to_add_submonoid t) :=\n  mk'_toAddSubmonoid _ _\n#align Inf_to_add_submonoid Inf_to_add_submonoid\n\n"}