{"surjective_or_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem surjective_or_eq_zero [IsSimpleModule R N] (f : «expr →ₗ[ ] » M R N) : function.surjective f ∨ f = 0 :=\n  by\n  rw [← range_eq_top, ← range_eq_bot, or_comm']\n  apply eq_bot_or_eq_top\n#align surjective_or_eq_zero surjective_or_eq_zero\n\n",
 "surjective_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem surjective_of_ne_zero [IsSimpleModule R N] {f : «expr →ₗ[ ] » M R N} (h : f ≠ 0) : function.surjective f :=\n  f.surjective_or_eq_zero.resolve_right h\n#align surjective_of_ne_zero surjective_of_ne_zero\n\n",
 "nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print IsSimpleModule.nontrivial /-\n/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n-- Making this an instance causes the linter to complain of \"dangerous instances\"\ntheorem IsSimpleModule.nontrivial [IsSimpleModule R M] : Nontrivial M :=\n  ⟨⟨0, by\n      have h : («expr⊥» : Submodule R M) ≠ «expr⊤» := bot_ne_top\n      contrapose! h\n      ext\n      simp [Submodule.mem_bot, Submodule.mem_top, h x]⟩⟩\n#align is_simple_module.nontrivial IsSimpleModule.nontrivial\n-/\n\n",
 "is_semisimple_of_supₛ_simples_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print is_semisimple_of_supₛ_simples_eq_top /-\ntheorem is_semisimple_of_supₛ_simples_eq_top (h : supₛ { m : Submodule R M | IsSimpleModule R m } = «expr⊤») :\n    IsSemisimpleModule R M :=\n  complementedLattice_of_supₛ_atoms_eq_top (by simp_rw [← h, isSimpleModule_iff_isAtom])\n#align is_semisimple_of_Sup_simples_eq_top is_semisimple_of_supₛ_simples_eq_top\n-/\n\n",
 "is_semisimple_iff_top_eq_supₛ_simples":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print is_semisimple_iff_top_eq_supₛ_simples /-\ntheorem is_semisimple_iff_top_eq_supₛ_simples :\n    supₛ { m : Submodule R M | IsSimpleModule R m } = «expr⊤» ↔ IsSemisimpleModule R M :=\n  ⟨is_semisimple_of_supₛ_simples_eq_top, by\n    intro\n    exact IsSemisimpleModule.supₛ_simples_eq_top⟩\n#align is_semisimple_iff_top_eq_Sup_simples is_semisimple_iff_top_eq_supₛ_simples\n-/\n\n",
 "is_coatom_ker_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_coatom_ker_of_surjective [IsSimpleModule R N] {f : «expr →ₗ[ ] » M R N} (hf : function.surjective f) :\n    IsCoatom f.ker := by\n  rw [← isSimpleModule_iff_isCoatom]\n  exact IsSimpleModule.congr (f.quot_ker_equiv_of_surjective hf)\n#align is_coatom_ker_of_surjective is_coatom_ker_of_surjective\n\n",
 "isSimpleModule_iff_isCoatom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print isSimpleModule_iff_isCoatom /-\ntheorem isSimpleModule_iff_isCoatom : IsSimpleModule R («expr ⧸ » M m) ↔ IsCoatom m :=\n  by\n  rw [← Set.isSimpleOrder_Ici_iff_isCoatom]\n  apply OrderIso.isSimpleOrder_iff\n  exact Submodule.comapMkQRelIso m\n#align is_simple_module_iff_is_coatom isSimpleModule_iff_isCoatom\n-/\n\n",
 "isSimpleModule_iff_isAtom":
 "#print isSimpleModule_iff_isAtom /-\ntheorem isSimpleModule_iff_isAtom : IsSimpleModule R m ↔ IsAtom m :=\n  by\n  rw [← Set.isSimpleOrder_Iic_iff_isAtom]\n  apply OrderIso.isSimpleOrder_iff\n  exact Submodule.MapSubtype.relIso m\n#align is_simple_module_iff_is_atom isSimpleModule_iff_isAtom\n-/\n\n",
 "injective_or_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem injective_or_eq_zero [IsSimpleModule R M] (f : «expr →ₗ[ ] » M R N) : function.injective f ∨ f = 0 :=\n  by\n  rw [← ker_eq_bot, ← ker_eq_top]\n  apply eq_bot_or_eq_top\n#align injective_or_eq_zero injective_or_eq_zero\n\n",
 "injective_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem injective_of_ne_zero [IsSimpleModule R M] {f : «expr →ₗ[ ] » M R N} (h : f ≠ 0) : function.injective f :=\n  f.injective_or_eq_zero.resolve_right h\n#align injective_of_ne_zero injective_of_ne_zero\n\n",
 "covby_iff_quot_is_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋖ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print covby_iff_quot_is_simple /-\ntheorem covby_iff_quot_is_simple {A B : Submodule R M} (hAB : A ≤ B) :\n    «expr ⋖ » A B ↔ IsSimpleModule R («expr ⧸ » B (Submodule.comap B.subtype A)) :=\n  by\n  set f : «expr ≃o » (Submodule R B) (Set.Iic B) := Submodule.MapSubtype.relIso B with hf\n  rw [covby_iff_coatom_Iic hAB, isSimpleModule_iff_isCoatom, ← OrderIso.isCoatom_iff f, hf]\n  simp [-OrderIso.isCoatom_iff, Submodule.MapSubtype.relIso, Submodule.map_comap_subtype, inf_eq_right.2 hAB]\n#align covby_iff_quot_is_simple covby_iff_quot_is_simple\n-/\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print IsSimpleModule.congr /-\ntheorem IsSimpleModule.congr (l : «expr ≃ₗ[ ] » M R N) [IsSimpleModule R N] : IsSimpleModule R M :=\n  (Submodule.orderIsoMapComap l).is_simple_order\n#align is_simple_module.congr IsSimpleModule.congr\n-/\n\n",
 "bijective_or_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- **Schur's Lemma** for linear maps between (possibly distinct) simple modules -/\ntheorem bijective_or_eq_zero [IsSimpleModule R M] [IsSimpleModule R N] (f : «expr →ₗ[ ] » M R N) :\n    function.bijective f ∨ f = 0 := by\n  by_cases h : f = 0\n  · right\n    exact h\n  exact or.intro_left _ ⟨injective_of_ne_zero h, surjective_of_ne_zero h⟩\n#align bijective_or_eq_zero bijective_or_eq_zero\n\n",
 "bijective_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem bijective_of_ne_zero [IsSimpleModule R M] [IsSimpleModule R N] {f : «expr →ₗ[ ] » M R N} (h : f ≠ 0) :\n    function.bijective f :=\n  f.bijective_or_eq_zero.resolve_right h\n#align bijective_of_ne_zero bijective_of_ne_zero\n\n",
 "Sup_simples_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem Sup_simples_eq_top : supₛ { m : Submodule R M | IsSimpleModule R m } = «expr⊤» :=\n  by\n  simp_rw [isSimpleModule_iff_isAtom]\n  exact supₛ_atoms_eq_top\n#align Sup_simples_eq_top Sup_simples_eq_top\n\n",
 "IsAtom":
 "#print IsAtom /-\n@[simp]\ntheorem IsAtom : IsAtom m :=\n  isSimpleModule_iff_isAtom.1 hm\n#align is_atom IsAtom\n-/\n\n"}