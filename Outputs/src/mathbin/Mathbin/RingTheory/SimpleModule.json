{"surjective_or_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem surjective_or_eq_zero [is_simple_module R N] (f : «expr →ₗ[ ] » M R N) : function.surjective f ∨ f = 0 :=\n  by\n  rw [← range_eq_top, ← range_eq_bot, or_comm']\n  apply eq_bot_or_eq_top\n#align surjective_or_eq_zero surjective_or_eq_zero\n\n",
 "surjective_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem surjective_of_ne_zero [is_simple_module R N] {f : «expr →ₗ[ ] » M R N} (h : f ≠ 0) : function.surjective f :=\n  f.surjective_or_eq_zero.resolve_right h\n#align surjective_of_ne_zero surjective_of_ne_zero\n\n",
 "nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n-- Making this an instance causes the linter to complain of \"dangerous instances\"\ntheorem is_simple_module.nontrivial [is_simple_module R M] : nontrivial M :=\n  ⟨⟨0, by\n      have h : («expr⊥» : submodule R M) ≠ «expr⊤» := bot_ne_top\n      contrapose! h\n      ext\n      simp [submodule.mem_bot, submodule.mem_top, h x]⟩⟩\n#align is_simple_module.nontrivial is_simple_module.nontrivial\n\n",
 "is_simple_module_iff_is_coatom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem is_simple_module_iff_is_coatom : is_simple_module R («expr ⧸ » M m) ↔ IsCoatom m :=\n  by\n  rw [← Set.isSimpleOrder_Ici_iff_isCoatom]\n  apply OrderIso.isSimpleOrder_iff\n  exact submodule.comap_mkq.rel_iso m\n#align is_simple_module_iff_is_coatom is_simple_module_iff_is_coatom\n\n",
 "is_simple_module_iff_is_atom":
 "theorem is_simple_module_iff_is_atom : is_simple_module R m ↔ IsAtom m :=\n  by\n  rw [← Set.isSimpleOrder_Iic_iff_isAtom]\n  apply OrderIso.isSimpleOrder_iff\n  exact submodule.map_subtype.rel_iso m\n#align is_simple_module_iff_is_atom is_simple_module_iff_is_atom\n\n",
 "is_semisimple_of_Sup_simples_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_semisimple_of_Sup_simples_eq_top (h : supₛ { m : submodule R M | is_simple_module R m } = «expr⊤») :\n    is_semisimple_module R M :=\n  complemented_lattice_of_Sup_atoms_eq_top (by simp_rw [← h, is_simple_module_iff_is_atom])\n#align is_semisimple_of_Sup_simples_eq_top is_semisimple_of_Sup_simples_eq_top\n\n",
 "is_semisimple_iff_top_eq_Sup_simples":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_semisimple_iff_top_eq_Sup_simples :\n    supₛ { m : submodule R M | is_simple_module R m } = «expr⊤» ↔ is_semisimple_module R M :=\n  ⟨is_semisimple_of_Sup_simples_eq_top, by\n    intro\n    exact is_semisimple_module.Sup_simples_eq_top⟩\n#align is_semisimple_iff_top_eq_Sup_simples is_semisimple_iff_top_eq_Sup_simples\n\n",
 "is_coatom_ker_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_coatom_ker_of_surjective [is_simple_module R N] {f : «expr →ₗ[ ] » M R N} (hf : function.surjective f) :\n    IsCoatom f.ker := by\n  rw [← is_simple_module_iff_is_coatom]\n  exact is_simple_module.congr (f.quot_ker_equiv_of_surjective hf)\n#align is_coatom_ker_of_surjective is_coatom_ker_of_surjective\n\n",
 "injective_or_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem injective_or_eq_zero [is_simple_module R M] (f : «expr →ₗ[ ] » M R N) : function.injective f ∨ f = 0 :=\n  by\n  rw [← ker_eq_bot, ← ker_eq_top]\n  apply eq_bot_or_eq_top\n#align injective_or_eq_zero injective_or_eq_zero\n\n",
 "injective_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem injective_of_ne_zero [is_simple_module R M] {f : «expr →ₗ[ ] » M R N} (h : f ≠ 0) : function.injective f :=\n  f.injective_or_eq_zero.resolve_right h\n#align injective_of_ne_zero injective_of_ne_zero\n\n",
 "covby_iff_quot_is_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋖ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem covby_iff_quot_is_simple {A B : submodule R M} (hAB : A ≤ B) :\n    «expr ⋖ » A B ↔ is_simple_module R («expr ⧸ » B (submodule.comap B.subtype A)) :=\n  by\n  set f : «expr ≃o » (submodule R B) (Set.Iic B) := submodule.map_subtype.rel_iso B with hf\n  rw [covby_iff_coatom_Iic hAB, is_simple_module_iff_is_coatom, ← OrderIso.isCoatom_iff f, hf]\n  simp [-OrderIso.isCoatom_iff, submodule.map_subtype.rel_iso, submodule.map_comap_subtype, inf_eq_right.2 hAB]\n#align covby_iff_quot_is_simple covby_iff_quot_is_simple\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem is_simple_module.congr (l : «expr ≃ₗ[ ] » M R N) [is_simple_module R N] : is_simple_module R M :=\n  (submodule.order_iso_map_comap l).is_simple_order\n#align is_simple_module.congr is_simple_module.congr\n\n",
 "bijective_or_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- **Schur's Lemma** for linear maps between (possibly distinct) simple modules -/\ntheorem bijective_or_eq_zero [is_simple_module R M] [is_simple_module R N] (f : «expr →ₗ[ ] » M R N) :\n    function.bijective f ∨ f = 0 := by\n  by_cases h : f = 0\n  · right\n    exact h\n  exact or.intro_left _ ⟨injective_of_ne_zero h, surjective_of_ne_zero h⟩\n#align bijective_or_eq_zero bijective_or_eq_zero\n\n",
 "bijective_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem bijective_of_ne_zero [is_simple_module R M] [is_simple_module R N] {f : «expr →ₗ[ ] » M R N} (h : f ≠ 0) :\n    function.bijective f :=\n  f.bijective_or_eq_zero.resolve_right h\n#align bijective_of_ne_zero bijective_of_ne_zero\n\n",
 "Sup_simples_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem Sup_simples_eq_top : supₛ { m : submodule R M | is_simple_module R m } = «expr⊤» :=\n  by\n  simp_rw [is_simple_module_iff_is_atom]\n  exact supₛ_atoms_eq_top\n#align Sup_simples_eq_top Sup_simples_eq_top\n\n",
 "IsAtom":
 "#print IsAtom /-\n@[simp]\ntheorem IsAtom : IsAtom m :=\n  is_simple_module_iff_is_atom.1 hm\n#align is_atom IsAtom\n-/\n\n"}