{"skip_left_wf":
 "theorem skip_left_wf (α : Type u) {β : Type v} {s : β → β → Prop} (hb : well_founded s) :\n    well_founded (skip_left α s) :=\n  rev_lex_wf empty_wf hb\n#align skip_left_wf skip_left_wf\n\n",
 "rev_lex_wf":
 "theorem rev_lex_wf (ha : well_founded r) (hb : well_founded s) : well_founded (rev_lex r s) :=\n  well_founded.intro fun ⟨a, b⟩ => rev_lex_accessible (apply hb b) (well_founded.apply ha) a\n#align rev_lex_wf rev_lex_wf\n\n",
 "rev_lex_accessible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n-- Reverse lexicographical order based on r and s\ntheorem rev_lex_accessible {b} (acb : acc s b) (aca : ∀ a, acc r a) : ∀ a, acc (rev_lex r s) ⟨a, b⟩ :=\n  acc.rec_on acb fun xb acb (ihb : ∀ y, s y xb → ∀ a, acc (rev_lex r s) ⟨a, y⟩) => fun a =>\n    acc.rec_on (aca a) fun xa aca (iha : ∀ y, r y xa → acc (rev_lex r s) (mk y xb)) =>\n      acc.intro ⟨xa, xb⟩ fun p (lt : «expr ≺ » p ⟨xa, xb⟩) =>\n        have aux : xa = xa → xb = xb → acc (rev_lex r s) p :=\n          @rev_lex.rec_on α β r s (fun p₁ p₂ => fst p₂ = xa → snd p₂ = xb → acc (rev_lex r s) p₁) p ⟨xa, xb⟩ lt\n            (fun a₁ a₂ b (h : r a₁ a₂) (eq₂ : a₂ = xa) (eq₃ : b = xb) =>\n              show acc (rev_lex r s) ⟨a₁, b⟩ from\n                have r₁ : r a₁ xa := eq.rec_on eq₂ h\n                have aux : acc (rev_lex r s) ⟨a₁, xb⟩ := iha a₁ r₁\n                eq.rec_on (Eq.symm eq₃) aux)\n            fun a₁ b₁ a₂ b₂ (h : s b₁ b₂) (eq₂ : a₂ = xa) (eq₃ : b₂ = xb) =>\n            show acc (rev_lex r s) (mk a₁ b₁) from\n              have s₁ : s b₁ xb := eq.rec_on eq₃ h\n              ihb b₁ s₁ a₁\n        aux rfl rfl\n#align rev_lex_accessible rev_lex_accessible\n\n",
 "mk_skip_left":
 "theorem mk_skip_left {α : Type u} {β : Type v} {b₁ b₂ : β} {s : β → β → Prop} (a₁ a₂ : α) (h : s b₁ b₂) :\n    skip_left α s ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ :=\n  rev_lex.right _ _ h\n#align mk_skip_left mk_skip_left\n\n",
 "lex_wf":
 "-- The lexicographical order of well founded relations is well-founded\ntheorem lex_wf (ha : well_founded r) (hb : ∀ x, well_founded (s x)) : well_founded (lex r s) :=\n  well_founded.intro fun ⟨a, b⟩ => lex_accessible (well_founded.apply ha a) hb b\n#align lex_wf lex_wf\n\n",
 "lex_ndep_wf":
 "theorem lex_ndep_wf {r : α → α → Prop} {s : β → β → Prop} (ha : well_founded r) (hb : well_founded s) :\n    well_founded (lex_ndep r s) :=\n  well_founded.intro fun ⟨a, b⟩ => lex_accessible (well_founded.apply ha a) (fun x => hb) b\n#align lex_ndep_wf lex_ndep_wf\n\n",
 "lex_accessible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/-\nCopyright (c) 2016 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthor: Leonardo de Moura\n-/\n-- Lexicographical order based on r and s\ntheorem lex_accessible {a} (aca : acc r a) (acb : ∀ a, well_founded (s a)) : ∀ b : β a, acc (lex r s) ⟨a, b⟩ :=\n  acc.rec_on aca fun xa aca (iha : ∀ y, r y xa → ∀ b : β y, acc (lex r s) ⟨y, b⟩) => fun b : β xa =>\n    acc.rec_on (well_founded.apply (acb xa) b) fun xb acb (ihb : ∀ y : β xa, s xa y xb → acc (lex r s) ⟨xa, y⟩) =>\n      acc.intro ⟨xa, xb⟩ fun p (lt : «expr ≺ » p ⟨xa, xb⟩) =>\n        have aux : xa = xa → HEq xb xb → acc (lex r s) p :=\n          @psigma.lex.rec_on α β r s (fun p₁ p₂ => p₂.1 = xa → HEq p₂.2 xb → acc (lex r s) p₁) p ⟨xa, xb⟩ lt\n            (fun (a₁ : α) (b₁ : β a₁) (a₂ : α) (b₂ : β a₂) (h : r a₁ a₂) (eq₂ : a₂ = xa) (eq₃ : HEq b₂ xb) => by\n              subst eq₂; exact iha a₁ h b₁)\n            fun (a : α) (b₁ b₂ : β a) (h : s a b₁ b₂) (eq₂ : a = xa) (eq₃ : HEq b₂ xb) =>\n            by\n            subst eq₂\n            have new_eq₃ := eq_of_heq eq₃\n            subst new_eq₃\n            exact ihb b₁ h\n        aux rfl (heq.refl xb)\n#align lex_accessible lex_accessible\n\n"}