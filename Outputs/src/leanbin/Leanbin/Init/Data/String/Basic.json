{"str_ne_str_right_aux":
 "private theorem str_ne_str_right_aux : ∀ (c₁ c₂ : char) {l₁ l₂ : list char}, l₁ ≠ l₂ → l₁ ++ [c₁] ≠ l₂ ++ [c₂]\n  | c₁, c₂, [], [], h₁, h₂ => absurd rfl h₁\n  | c₁, c₂, d₁ :: l₁, [], h₁, h₂ =>\n    have : d₁ :: (l₁ ++ [c₁]) = [c₂] := h₂\n    have : l₁ ++ [c₁] = [] := list.no_confusion this fun _ h => h\n    absurd this.symm (nil_ne_append_singleton _ _)\n  | c₁, c₂, [], d₂ :: l₂, h₁, h₂ =>\n    have : [c₁] = d₂ :: (l₂ ++ [c₂]) := h₂\n    have : [] = l₂ ++ [c₂] := list.no_confusion this fun _ h => h\n    absurd this (nil_ne_append_singleton _ _)\n  | c₁, c₂, d₁ :: l₁, d₂ :: l₂, h₁, h₂ =>\n    have aux₁ : d₁ :: (l₁ ++ [c₁]) = d₂ :: (l₂ ++ [c₂]) := h₂\n    have : d₁ = d₂ := list.no_confusion aux₁ fun h _ => h\n    have aux₂ : l₁ ≠ l₂ := fun h =>\n      have : d₁ :: l₁ = d₂ :: l₂ := eq.subst h (eq.subst this rfl)\n      absurd this h₁\n    have : l₁ ++ [c₁] = l₂ ++ [c₂] := list.no_confusion aux₁ fun _ h => h\n    absurd this (str_ne_str_right_aux c₁ c₂ aux₂)\n#align str_ne_str_right_aux str_ne_str_right_aux\n\n",
 "str_ne_str_right":
 "theorem str_ne_str_right : ∀ (c₁ c₂ : char) {s₁ s₂ : string}, s₁ ≠ s₂ → str s₁ c₁ ≠ str s₂ c₂\n  | c₁, c₂, string_imp.mk l₁, string_imp.mk l₂, h₁, h₂ =>\n    have aux : l₁ ≠ l₂ := fun h =>\n      have : string_imp.mk l₁ = string_imp.mk l₂ := eq.subst h rfl\n      absurd this h₁\n    have : l₁ ++ [c₁] = l₂ ++ [c₂] := string_imp.no_confusion h₂ id\n    absurd this (str_ne_str_right_aux c₁ c₂ aux)\n#align str_ne_str_right str_ne_str_right\n\n",
 "str_ne_str_left_aux":
 "private theorem str_ne_str_left_aux : ∀ {c₁ c₂ : char} (l₁ l₂ : list char), c₁ ≠ c₂ → l₁ ++ [c₁] ≠ l₂ ++ [c₂]\n  | c₁, c₂, [], [], h₁, h₂ => list.no_confusion h₂ fun h _ => absurd h h₁\n  | c₁, c₂, d₁ :: l₁, [], h₁, h₂ =>\n    have : d₁ :: (l₁ ++ [c₁]) = [c₂] := h₂\n    have : l₁ ++ [c₁] = [] := list.no_confusion this fun _ h => h\n    absurd this.symm (nil_ne_append_singleton _ _)\n  | c₁, c₂, [], d₂ :: l₂, h₁, h₂ =>\n    have : [c₁] = d₂ :: (l₂ ++ [c₂]) := h₂\n    have : [] = l₂ ++ [c₂] := list.no_confusion this fun _ h => h\n    absurd this (nil_ne_append_singleton _ _)\n  | c₁, c₂, d₁ :: l₁, d₂ :: l₂, h₁, h₂ =>\n    have : d₁ :: (l₁ ++ [c₁]) = d₂ :: (l₂ ++ [c₂]) := h₂\n    have : l₁ ++ [c₁] = l₂ ++ [c₂] := list.no_confusion this fun _ h => h\n    absurd this (str_ne_str_left_aux l₁ l₂ h₁)\n#align str_ne_str_left_aux str_ne_str_left_aux\n\n",
 "str_ne_str_left":
 "theorem str_ne_str_left : ∀ {c₁ c₂ : char} (s₁ s₂ : string), c₁ ≠ c₂ → str s₁ c₁ ≠ str s₂ c₂\n  | c₁, c₂, string_imp.mk l₁, string_imp.mk l₂, h₁, h₂ =>\n    have : l₁ ++ [c₁] = l₂ ++ [c₂] := string_imp.no_confusion h₂ id\n    absurd this (str_ne_str_left_aux l₁ l₂ h₁)\n#align str_ne_str_left str_ne_str_left\n\n",
 "str_ne_empty":
 "theorem str_ne_empty (c : char) (s : string) : str s c ≠ empty :=\n  (empty_ne_str c s).symm\n#align str_ne_empty str_ne_empty\n\n",
 "nil_ne_append_singleton":
 "/-\nCopyright (c) 2016 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthor: Leonardo de Moura\n-/\nprivate theorem nil_ne_append_singleton : ∀ (c : char) (l : list char), [] ≠ l ++ [c]\n  | c, [] => fun h => list.no_confusion h\n  | c, d :: l => fun h => list.no_confusion h\n#align nil_ne_append_singleton nil_ne_append_singleton\n\n",
 "empty_ne_str":
 "theorem empty_ne_str : ∀ (c : char) (s : string), empty ≠ str s c\n  | c, ⟨l⟩ => fun h : string_imp.mk [] = string_imp.mk (l ++ [c]) =>\n    string_imp.no_confusion h fun h => nil_ne_append_singleton _ _ h\n#align empty_ne_str empty_ne_str\n\n"}